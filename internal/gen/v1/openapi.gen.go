// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package v1

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Api_keyScopes              = "api_key.Scopes"
	Basic_authenticationScopes = "basic_authentication.Scopes"
	Oauth2Scopes               = "oauth2.Scopes"
)

// Defines values for AddActivityTypeJSONBodyIconKey.
const (
	AddActivityTypeJSONBodyIconKeyAddressbook  AddActivityTypeJSONBodyIconKey = "addressbook"
	AddActivityTypeJSONBodyIconKeyBell         AddActivityTypeJSONBodyIconKey = "bell"
	AddActivityTypeJSONBodyIconKeyBrush        AddActivityTypeJSONBodyIconKey = "brush"
	AddActivityTypeJSONBodyIconKeyBubble       AddActivityTypeJSONBodyIconKey = "bubble"
	AddActivityTypeJSONBodyIconKeyBulb         AddActivityTypeJSONBodyIconKey = "bulb"
	AddActivityTypeJSONBodyIconKeyCalendar     AddActivityTypeJSONBodyIconKey = "calendar"
	AddActivityTypeJSONBodyIconKeyCall         AddActivityTypeJSONBodyIconKey = "call"
	AddActivityTypeJSONBodyIconKeyCamera       AddActivityTypeJSONBodyIconKey = "camera"
	AddActivityTypeJSONBodyIconKeyCar          AddActivityTypeJSONBodyIconKey = "car"
	AddActivityTypeJSONBodyIconKeyCart         AddActivityTypeJSONBodyIconKey = "cart"
	AddActivityTypeJSONBodyIconKeyCheckbox     AddActivityTypeJSONBodyIconKey = "checkbox"
	AddActivityTypeJSONBodyIconKeyClip         AddActivityTypeJSONBodyIconKey = "clip"
	AddActivityTypeJSONBodyIconKeyCogs         AddActivityTypeJSONBodyIconKey = "cogs"
	AddActivityTypeJSONBodyIconKeyDeadline     AddActivityTypeJSONBodyIconKey = "deadline"
	AddActivityTypeJSONBodyIconKeyDocument     AddActivityTypeJSONBodyIconKey = "document"
	AddActivityTypeJSONBodyIconKeyDownarrow    AddActivityTypeJSONBodyIconKey = "downarrow"
	AddActivityTypeJSONBodyIconKeyEmail        AddActivityTypeJSONBodyIconKey = "email"
	AddActivityTypeJSONBodyIconKeyFinish       AddActivityTypeJSONBodyIconKey = "finish"
	AddActivityTypeJSONBodyIconKeyKey          AddActivityTypeJSONBodyIconKey = "key"
	AddActivityTypeJSONBodyIconKeyLinegraph    AddActivityTypeJSONBodyIconKey = "linegraph"
	AddActivityTypeJSONBodyIconKeyLoop         AddActivityTypeJSONBodyIconKey = "loop"
	AddActivityTypeJSONBodyIconKeyLunch        AddActivityTypeJSONBodyIconKey = "lunch"
	AddActivityTypeJSONBodyIconKeyMeeting      AddActivityTypeJSONBodyIconKey = "meeting"
	AddActivityTypeJSONBodyIconKeyPadlock      AddActivityTypeJSONBodyIconKey = "padlock"
	AddActivityTypeJSONBodyIconKeyPicture      AddActivityTypeJSONBodyIconKey = "picture"
	AddActivityTypeJSONBodyIconKeyPlane        AddActivityTypeJSONBodyIconKey = "plane"
	AddActivityTypeJSONBodyIconKeyPresentation AddActivityTypeJSONBodyIconKey = "presentation"
	AddActivityTypeJSONBodyIconKeyPricetag     AddActivityTypeJSONBodyIconKey = "pricetag"
	AddActivityTypeJSONBodyIconKeyScissors     AddActivityTypeJSONBodyIconKey = "scissors"
	AddActivityTypeJSONBodyIconKeySearch       AddActivityTypeJSONBodyIconKey = "search"
	AddActivityTypeJSONBodyIconKeyShuffle      AddActivityTypeJSONBodyIconKey = "shuffle"
	AddActivityTypeJSONBodyIconKeySignpost     AddActivityTypeJSONBodyIconKey = "signpost"
	AddActivityTypeJSONBodyIconKeySmartphone   AddActivityTypeJSONBodyIconKey = "smartphone"
	AddActivityTypeJSONBodyIconKeySound        AddActivityTypeJSONBodyIconKey = "sound"
	AddActivityTypeJSONBodyIconKeySuitcase     AddActivityTypeJSONBodyIconKey = "suitcase"
	AddActivityTypeJSONBodyIconKeyTask         AddActivityTypeJSONBodyIconKey = "task"
	AddActivityTypeJSONBodyIconKeyTruck        AddActivityTypeJSONBodyIconKey = "truck"
	AddActivityTypeJSONBodyIconKeyUparrow      AddActivityTypeJSONBodyIconKey = "uparrow"
	AddActivityTypeJSONBodyIconKeyWifi         AddActivityTypeJSONBodyIconKey = "wifi"
	AddActivityTypeJSONBodyIconKeyWorld        AddActivityTypeJSONBodyIconKey = "world"
)

// Defines values for UpdateActivityTypeJSONBodyIconKey.
const (
	UpdateActivityTypeJSONBodyIconKeyAddressbook  UpdateActivityTypeJSONBodyIconKey = "addressbook"
	UpdateActivityTypeJSONBodyIconKeyBell         UpdateActivityTypeJSONBodyIconKey = "bell"
	UpdateActivityTypeJSONBodyIconKeyBrush        UpdateActivityTypeJSONBodyIconKey = "brush"
	UpdateActivityTypeJSONBodyIconKeyBubble       UpdateActivityTypeJSONBodyIconKey = "bubble"
	UpdateActivityTypeJSONBodyIconKeyBulb         UpdateActivityTypeJSONBodyIconKey = "bulb"
	UpdateActivityTypeJSONBodyIconKeyCalendar     UpdateActivityTypeJSONBodyIconKey = "calendar"
	UpdateActivityTypeJSONBodyIconKeyCall         UpdateActivityTypeJSONBodyIconKey = "call"
	UpdateActivityTypeJSONBodyIconKeyCamera       UpdateActivityTypeJSONBodyIconKey = "camera"
	UpdateActivityTypeJSONBodyIconKeyCar          UpdateActivityTypeJSONBodyIconKey = "car"
	UpdateActivityTypeJSONBodyIconKeyCart         UpdateActivityTypeJSONBodyIconKey = "cart"
	UpdateActivityTypeJSONBodyIconKeyCheckbox     UpdateActivityTypeJSONBodyIconKey = "checkbox"
	UpdateActivityTypeJSONBodyIconKeyClip         UpdateActivityTypeJSONBodyIconKey = "clip"
	UpdateActivityTypeJSONBodyIconKeyCogs         UpdateActivityTypeJSONBodyIconKey = "cogs"
	UpdateActivityTypeJSONBodyIconKeyDeadline     UpdateActivityTypeJSONBodyIconKey = "deadline"
	UpdateActivityTypeJSONBodyIconKeyDocument     UpdateActivityTypeJSONBodyIconKey = "document"
	UpdateActivityTypeJSONBodyIconKeyDownarrow    UpdateActivityTypeJSONBodyIconKey = "downarrow"
	UpdateActivityTypeJSONBodyIconKeyEmail        UpdateActivityTypeJSONBodyIconKey = "email"
	UpdateActivityTypeJSONBodyIconKeyFinish       UpdateActivityTypeJSONBodyIconKey = "finish"
	UpdateActivityTypeJSONBodyIconKeyKey          UpdateActivityTypeJSONBodyIconKey = "key"
	UpdateActivityTypeJSONBodyIconKeyLinegraph    UpdateActivityTypeJSONBodyIconKey = "linegraph"
	UpdateActivityTypeJSONBodyIconKeyLoop         UpdateActivityTypeJSONBodyIconKey = "loop"
	UpdateActivityTypeJSONBodyIconKeyLunch        UpdateActivityTypeJSONBodyIconKey = "lunch"
	UpdateActivityTypeJSONBodyIconKeyMeeting      UpdateActivityTypeJSONBodyIconKey = "meeting"
	UpdateActivityTypeJSONBodyIconKeyPadlock      UpdateActivityTypeJSONBodyIconKey = "padlock"
	UpdateActivityTypeJSONBodyIconKeyPicture      UpdateActivityTypeJSONBodyIconKey = "picture"
	UpdateActivityTypeJSONBodyIconKeyPlane        UpdateActivityTypeJSONBodyIconKey = "plane"
	UpdateActivityTypeJSONBodyIconKeyPresentation UpdateActivityTypeJSONBodyIconKey = "presentation"
	UpdateActivityTypeJSONBodyIconKeyPricetag     UpdateActivityTypeJSONBodyIconKey = "pricetag"
	UpdateActivityTypeJSONBodyIconKeyScissors     UpdateActivityTypeJSONBodyIconKey = "scissors"
	UpdateActivityTypeJSONBodyIconKeySearch       UpdateActivityTypeJSONBodyIconKey = "search"
	UpdateActivityTypeJSONBodyIconKeyShuffle      UpdateActivityTypeJSONBodyIconKey = "shuffle"
	UpdateActivityTypeJSONBodyIconKeySignpost     UpdateActivityTypeJSONBodyIconKey = "signpost"
	UpdateActivityTypeJSONBodyIconKeySmartphone   UpdateActivityTypeJSONBodyIconKey = "smartphone"
	UpdateActivityTypeJSONBodyIconKeySound        UpdateActivityTypeJSONBodyIconKey = "sound"
	UpdateActivityTypeJSONBodyIconKeySuitcase     UpdateActivityTypeJSONBodyIconKey = "suitcase"
	UpdateActivityTypeJSONBodyIconKeyTask         UpdateActivityTypeJSONBodyIconKey = "task"
	UpdateActivityTypeJSONBodyIconKeyTruck        UpdateActivityTypeJSONBodyIconKey = "truck"
	UpdateActivityTypeJSONBodyIconKeyUparrow      UpdateActivityTypeJSONBodyIconKey = "uparrow"
	UpdateActivityTypeJSONBodyIconKeyWifi         UpdateActivityTypeJSONBodyIconKey = "wifi"
	UpdateActivityTypeJSONBodyIconKeyWorld        UpdateActivityTypeJSONBodyIconKey = "world"
)

// Defines values for AddCallLogJSONBodyOutcome.
const (
	Busy          AddCallLogJSONBodyOutcome = "busy"
	Connected     AddCallLogJSONBodyOutcome = "connected"
	LeftMessage   AddCallLogJSONBodyOutcome = "left_message"
	LeftVoicemail AddCallLogJSONBodyOutcome = "left_voicemail"
	NoAnswer      AddCallLogJSONBodyOutcome = "no_answer"
	WrongNumber   AddCallLogJSONBodyOutcome = "wrong_number"
)

// Defines values for AddChannelJSONBodyProviderType.
const (
	Facebook AddChannelJSONBodyProviderType = "facebook"
	Other    AddChannelJSONBodyProviderType = "other"
	Whatsapp AddChannelJSONBodyProviderType = "whatsapp"
)

// Defines values for ReceiveMessageJSONBodyStatus.
const (
	ReceiveMessageJSONBodyStatusDelivered ReceiveMessageJSONBodyStatus = "delivered"
	ReceiveMessageJSONBodyStatusFailed    ReceiveMessageJSONBodyStatus = "failed"
	ReceiveMessageJSONBodyStatusRead      ReceiveMessageJSONBodyStatus = "read"
	ReceiveMessageJSONBodyStatusSent      ReceiveMessageJSONBodyStatus = "sent"
)

// Defines values for GetDealsCollectionParamsStatus.
const (
	GetDealsCollectionParamsStatusDeleted GetDealsCollectionParamsStatus = "deleted"
	GetDealsCollectionParamsStatusLost    GetDealsCollectionParamsStatus = "lost"
	GetDealsCollectionParamsStatusOpen    GetDealsCollectionParamsStatus = "open"
	GetDealsCollectionParamsStatusWon     GetDealsCollectionParamsStatus = "won"
)

// Defines values for GetDealsSummaryParamsStatus.
const (
	GetDealsSummaryParamsStatusLost GetDealsSummaryParamsStatus = "lost"
	GetDealsSummaryParamsStatusOpen GetDealsSummaryParamsStatus = "open"
	GetDealsSummaryParamsStatusWon  GetDealsSummaryParamsStatus = "won"
)

// Defines values for GetArchivedDealsSummaryParamsStatus.
const (
	GetArchivedDealsSummaryParamsStatusLost GetArchivedDealsSummaryParamsStatus = "lost"
	GetArchivedDealsSummaryParamsStatusOpen GetArchivedDealsSummaryParamsStatus = "open"
	GetArchivedDealsSummaryParamsStatusWon  GetArchivedDealsSummaryParamsStatus = "won"
)

// Defines values for GetDealsTimelineParamsInterval.
const (
	GetDealsTimelineParamsIntervalDay     GetDealsTimelineParamsInterval = "day"
	GetDealsTimelineParamsIntervalMonth   GetDealsTimelineParamsInterval = "month"
	GetDealsTimelineParamsIntervalQuarter GetDealsTimelineParamsInterval = "quarter"
	GetDealsTimelineParamsIntervalWeek    GetDealsTimelineParamsInterval = "week"
)

// Defines values for GetDealsTimelineParamsExcludeDeals.
const (
	GetDealsTimelineParamsExcludeDealsN0 GetDealsTimelineParamsExcludeDeals = 0
	GetDealsTimelineParamsExcludeDealsN1 GetDealsTimelineParamsExcludeDeals = 1
)

// Defines values for GetArchivedDealsTimelineParamsInterval.
const (
	GetArchivedDealsTimelineParamsIntervalDay     GetArchivedDealsTimelineParamsInterval = "day"
	GetArchivedDealsTimelineParamsIntervalMonth   GetArchivedDealsTimelineParamsInterval = "month"
	GetArchivedDealsTimelineParamsIntervalQuarter GetArchivedDealsTimelineParamsInterval = "quarter"
	GetArchivedDealsTimelineParamsIntervalWeek    GetArchivedDealsTimelineParamsInterval = "week"
)

// Defines values for GetArchivedDealsTimelineParamsExcludeDeals.
const (
	GetArchivedDealsTimelineParamsExcludeDealsN0 GetArchivedDealsTimelineParamsExcludeDeals = 0
	GetArchivedDealsTimelineParamsExcludeDealsN1 GetArchivedDealsTimelineParamsExcludeDeals = 1
)

// Defines values for GetDealActivitiesParamsDone.
const (
	GetDealActivitiesParamsDoneN0 GetDealActivitiesParamsDone = 0
	GetDealActivitiesParamsDoneN1 GetDealActivitiesParamsDone = 1
)

// Defines values for AddFileAndLinkItFormdataBodyFileType.
const (
	Gdoc    AddFileAndLinkItFormdataBodyFileType = "gdoc"
	Gdraw   AddFileAndLinkItFormdataBodyFileType = "gdraw"
	Gform   AddFileAndLinkItFormdataBodyFileType = "gform"
	Gsheet  AddFileAndLinkItFormdataBodyFileType = "gsheet"
	Gslides AddFileAndLinkItFormdataBodyFileType = "gslides"
)

// Defines values for AddFileAndLinkItFormdataBodyItemType.
const (
	AddFileAndLinkItFormdataBodyItemTypeDeal         AddFileAndLinkItFormdataBodyItemType = "deal"
	AddFileAndLinkItFormdataBodyItemTypeOrganization AddFileAndLinkItFormdataBodyItemType = "organization"
	AddFileAndLinkItFormdataBodyItemTypePerson       AddFileAndLinkItFormdataBodyItemType = "person"
)

// Defines values for AddFileAndLinkItFormdataBodyRemoteLocation.
const (
	AddFileAndLinkItFormdataBodyRemoteLocationGoogledrive AddFileAndLinkItFormdataBodyRemoteLocation = "googledrive"
)

// Defines values for LinkFileToItemFormdataBodyItemType.
const (
	LinkFileToItemFormdataBodyItemTypeDeal         LinkFileToItemFormdataBodyItemType = "deal"
	LinkFileToItemFormdataBodyItemTypeOrganization LinkFileToItemFormdataBodyItemType = "organization"
	LinkFileToItemFormdataBodyItemTypePerson       LinkFileToItemFormdataBodyItemType = "person"
)

// Defines values for LinkFileToItemFormdataBodyRemoteLocation.
const (
	LinkFileToItemFormdataBodyRemoteLocationGoogledrive LinkFileToItemFormdataBodyRemoteLocation = "googledrive"
)

// Defines values for GetFiltersParamsType.
const (
	GetFiltersParamsTypeActivity GetFiltersParamsType = "activity"
	GetFiltersParamsTypeDeals    GetFiltersParamsType = "deals"
	GetFiltersParamsTypeLeads    GetFiltersParamsType = "leads"
	GetFiltersParamsTypeOrg      GetFiltersParamsType = "org"
	GetFiltersParamsTypePeople   GetFiltersParamsType = "people"
	GetFiltersParamsTypeProducts GetFiltersParamsType = "products"
	GetFiltersParamsTypeProjects GetFiltersParamsType = "projects"
)

// Defines values for AddFilterJSONBodyType.
const (
	AddFilterJSONBodyTypeActivity AddFilterJSONBodyType = "activity"
	AddFilterJSONBodyTypeDeals    AddFilterJSONBodyType = "deals"
	AddFilterJSONBodyTypeLeads    AddFilterJSONBodyType = "leads"
	AddFilterJSONBodyTypeOrg      AddFilterJSONBodyType = "org"
	AddFilterJSONBodyTypePeople   AddFilterJSONBodyType = "people"
	AddFilterJSONBodyTypeProducts AddFilterJSONBodyType = "products"
	AddFilterJSONBodyTypeProjects AddFilterJSONBodyType = "projects"
)

// Defines values for AddGoalJSONBodyInterval.
const (
	AddGoalJSONBodyIntervalMonthly   AddGoalJSONBodyInterval = "monthly"
	AddGoalJSONBodyIntervalQuarterly AddGoalJSONBodyInterval = "quarterly"
	AddGoalJSONBodyIntervalWeekly    AddGoalJSONBodyInterval = "weekly"
	AddGoalJSONBodyIntervalYearly    AddGoalJSONBodyInterval = "yearly"
)

// Defines values for GetGoalsParamsTypeName.
const (
	ActivitiesAdded     GetGoalsParamsTypeName = "activities_added"
	ActivitiesCompleted GetGoalsParamsTypeName = "activities_completed"
	DealsProgressed     GetGoalsParamsTypeName = "deals_progressed"
	DealsStarted        GetGoalsParamsTypeName = "deals_started"
	DealsWon            GetGoalsParamsTypeName = "deals_won"
)

// Defines values for GetGoalsParamsAssigneeType.
const (
	GetGoalsParamsAssigneeTypeCompany GetGoalsParamsAssigneeType = "company"
	GetGoalsParamsAssigneeTypePerson  GetGoalsParamsAssigneeType = "person"
	GetGoalsParamsAssigneeTypeTeam    GetGoalsParamsAssigneeType = "team"
)

// Defines values for GetGoalsParamsExpectedOutcomeTrackingMetric.
const (
	Quantity GetGoalsParamsExpectedOutcomeTrackingMetric = "quantity"
	Sum      GetGoalsParamsExpectedOutcomeTrackingMetric = "sum"
)

// Defines values for UpdateGoalJSONBodyInterval.
const (
	UpdateGoalJSONBodyIntervalMonthly   UpdateGoalJSONBodyInterval = "monthly"
	UpdateGoalJSONBodyIntervalQuarterly UpdateGoalJSONBodyInterval = "quarterly"
	UpdateGoalJSONBodyIntervalWeekly    UpdateGoalJSONBodyInterval = "weekly"
	UpdateGoalJSONBodyIntervalYearly    UpdateGoalJSONBodyInterval = "yearly"
)

// Defines values for AddLeadLabelJSONBodyColor.
const (
	AddLeadLabelJSONBodyColorBlue     AddLeadLabelJSONBodyColor = "blue"
	AddLeadLabelJSONBodyColorBrown    AddLeadLabelJSONBodyColor = "brown"
	AddLeadLabelJSONBodyColorDarkGray AddLeadLabelJSONBodyColor = "dark-gray"
	AddLeadLabelJSONBodyColorGray     AddLeadLabelJSONBodyColor = "gray"
	AddLeadLabelJSONBodyColorGreen    AddLeadLabelJSONBodyColor = "green"
	AddLeadLabelJSONBodyColorOrange   AddLeadLabelJSONBodyColor = "orange"
	AddLeadLabelJSONBodyColorPink     AddLeadLabelJSONBodyColor = "pink"
	AddLeadLabelJSONBodyColorPurple   AddLeadLabelJSONBodyColor = "purple"
	AddLeadLabelJSONBodyColorRed      AddLeadLabelJSONBodyColor = "red"
	AddLeadLabelJSONBodyColorYellow   AddLeadLabelJSONBodyColor = "yellow"
)

// Defines values for UpdateLeadLabelJSONBodyColor.
const (
	UpdateLeadLabelJSONBodyColorBlue     UpdateLeadLabelJSONBodyColor = "blue"
	UpdateLeadLabelJSONBodyColorBrown    UpdateLeadLabelJSONBodyColor = "brown"
	UpdateLeadLabelJSONBodyColorDarkGray UpdateLeadLabelJSONBodyColor = "dark-gray"
	UpdateLeadLabelJSONBodyColorGray     UpdateLeadLabelJSONBodyColor = "gray"
	UpdateLeadLabelJSONBodyColorGreen    UpdateLeadLabelJSONBodyColor = "green"
	UpdateLeadLabelJSONBodyColorOrange   UpdateLeadLabelJSONBodyColor = "orange"
	UpdateLeadLabelJSONBodyColorPink     UpdateLeadLabelJSONBodyColor = "pink"
	UpdateLeadLabelJSONBodyColorPurple   UpdateLeadLabelJSONBodyColor = "purple"
	UpdateLeadLabelJSONBodyColorRed      UpdateLeadLabelJSONBodyColor = "red"
	UpdateLeadLabelJSONBodyColorYellow   UpdateLeadLabelJSONBodyColor = "yellow"
)

// Defines values for GetLeadsParamsSort.
const (
	GetLeadsParamsSortAddTime           GetLeadsParamsSort = "add_time"
	GetLeadsParamsSortCreatorId         GetLeadsParamsSort = "creator_id"
	GetLeadsParamsSortExpectedCloseDate GetLeadsParamsSort = "expected_close_date"
	GetLeadsParamsSortId                GetLeadsParamsSort = "id"
	GetLeadsParamsSortNextActivityId    GetLeadsParamsSort = "next_activity_id"
	GetLeadsParamsSortOwnerId           GetLeadsParamsSort = "owner_id"
	GetLeadsParamsSortTitle             GetLeadsParamsSort = "title"
	GetLeadsParamsSortUpdateTime        GetLeadsParamsSort = "update_time"
	GetLeadsParamsSortWasSeen           GetLeadsParamsSort = "was_seen"
)

// Defines values for AddLeadJSONBodyVisibleTo.
const (
	AddLeadJSONBodyVisibleToN1 AddLeadJSONBodyVisibleTo = "1"
	AddLeadJSONBodyVisibleToN3 AddLeadJSONBodyVisibleTo = "3"
	AddLeadJSONBodyVisibleToN5 AddLeadJSONBodyVisibleTo = "5"
	AddLeadJSONBodyVisibleToN7 AddLeadJSONBodyVisibleTo = "7"
)

// Defines values for GetArchivedLeadsParamsSort.
const (
	GetArchivedLeadsParamsSortAddTime           GetArchivedLeadsParamsSort = "add_time"
	GetArchivedLeadsParamsSortCreatorId         GetArchivedLeadsParamsSort = "creator_id"
	GetArchivedLeadsParamsSortExpectedCloseDate GetArchivedLeadsParamsSort = "expected_close_date"
	GetArchivedLeadsParamsSortId                GetArchivedLeadsParamsSort = "id"
	GetArchivedLeadsParamsSortNextActivityId    GetArchivedLeadsParamsSort = "next_activity_id"
	GetArchivedLeadsParamsSortOwnerId           GetArchivedLeadsParamsSort = "owner_id"
	GetArchivedLeadsParamsSortTitle             GetArchivedLeadsParamsSort = "title"
	GetArchivedLeadsParamsSortUpdateTime        GetArchivedLeadsParamsSort = "update_time"
	GetArchivedLeadsParamsSortWasSeen           GetArchivedLeadsParamsSort = "was_seen"
)

// Defines values for UpdateLeadJSONBodyVisibleTo.
const (
	UpdateLeadJSONBodyVisibleToN1 UpdateLeadJSONBodyVisibleTo = "1"
	UpdateLeadJSONBodyVisibleToN3 UpdateLeadJSONBodyVisibleTo = "3"
	UpdateLeadJSONBodyVisibleToN5 UpdateLeadJSONBodyVisibleTo = "5"
	UpdateLeadJSONBodyVisibleToN7 UpdateLeadJSONBodyVisibleTo = "7"
)

// Defines values for GetTeamsParamsOrderBy.
const (
	GetTeamsParamsOrderByActiveFlag GetTeamsParamsOrderBy = "active_flag"
	GetTeamsParamsOrderById         GetTeamsParamsOrderBy = "id"
	GetTeamsParamsOrderByManagerId  GetTeamsParamsOrderBy = "manager_id"
	GetTeamsParamsOrderByName       GetTeamsParamsOrderBy = "name"
)

// Defines values for GetTeamsParamsSkipUsers.
const (
	GetTeamsParamsSkipUsersN0 GetTeamsParamsSkipUsers = 0
	GetTeamsParamsSkipUsersN1 GetTeamsParamsSkipUsers = 1
)

// Defines values for GetUserTeamsParamsOrderBy.
const (
	GetUserTeamsParamsOrderByActiveFlag GetUserTeamsParamsOrderBy = "active_flag"
	GetUserTeamsParamsOrderById         GetUserTeamsParamsOrderBy = "id"
	GetUserTeamsParamsOrderByManagerId  GetUserTeamsParamsOrderBy = "manager_id"
	GetUserTeamsParamsOrderByName       GetUserTeamsParamsOrderBy = "name"
)

// Defines values for GetUserTeamsParamsSkipUsers.
const (
	GetUserTeamsParamsSkipUsersN0 GetUserTeamsParamsSkipUsers = 0
	GetUserTeamsParamsSkipUsersN1 GetUserTeamsParamsSkipUsers = 1
)

// Defines values for GetTeamParamsSkipUsers.
const (
	GetTeamParamsSkipUsersN0 GetTeamParamsSkipUsers = 0
	GetTeamParamsSkipUsersN1 GetTeamParamsSkipUsers = 1
)

// Defines values for UpdateTeamJSONBodyActiveFlag.
const (
	UpdateTeamJSONBodyActiveFlagN0 UpdateTeamJSONBodyActiveFlag = 0
	UpdateTeamJSONBodyActiveFlagN1 UpdateTeamJSONBodyActiveFlag = 1
)

// Defines values for UpdateTeamJSONBodyDeletedFlag.
const (
	UpdateTeamJSONBodyDeletedFlagN0 UpdateTeamJSONBodyDeletedFlag = 0
	UpdateTeamJSONBodyDeletedFlagN1 UpdateTeamJSONBodyDeletedFlag = 1
)

// Defines values for GetMailMessageParamsIncludeBody.
const (
	GetMailMessageParamsIncludeBodyN0 GetMailMessageParamsIncludeBody = 0
	GetMailMessageParamsIncludeBodyN1 GetMailMessageParamsIncludeBody = 1
)

// Defines values for GetMailThreadsParamsFolder.
const (
	GetMailThreadsParamsFolderArchive GetMailThreadsParamsFolder = "archive"
	GetMailThreadsParamsFolderDrafts  GetMailThreadsParamsFolder = "drafts"
	GetMailThreadsParamsFolderInbox   GetMailThreadsParamsFolder = "inbox"
	GetMailThreadsParamsFolderSent    GetMailThreadsParamsFolder = "sent"
)

// Defines values for UpdateMailThreadDetailsFormdataBodyArchivedFlag.
const (
	UpdateMailThreadDetailsFormdataBodyArchivedFlagN0 UpdateMailThreadDetailsFormdataBodyArchivedFlag = 0
	UpdateMailThreadDetailsFormdataBodyArchivedFlagN1 UpdateMailThreadDetailsFormdataBodyArchivedFlag = 1
)

// Defines values for UpdateMailThreadDetailsFormdataBodyReadFlag.
const (
	UpdateMailThreadDetailsFormdataBodyReadFlagN0 UpdateMailThreadDetailsFormdataBodyReadFlag = 0
	UpdateMailThreadDetailsFormdataBodyReadFlagN1 UpdateMailThreadDetailsFormdataBodyReadFlag = 1
)

// Defines values for UpdateMailThreadDetailsFormdataBodySharedFlag.
const (
	UpdateMailThreadDetailsFormdataBodySharedFlagN0 UpdateMailThreadDetailsFormdataBodySharedFlag = 0
	UpdateMailThreadDetailsFormdataBodySharedFlagN1 UpdateMailThreadDetailsFormdataBodySharedFlag = 1
)

// Defines values for GetNotesParamsPinnedToLeadFlag.
const (
	GetNotesParamsPinnedToLeadFlagN0 GetNotesParamsPinnedToLeadFlag = 0
	GetNotesParamsPinnedToLeadFlagN1 GetNotesParamsPinnedToLeadFlag = 1
)

// Defines values for GetNotesParamsPinnedToDealFlag.
const (
	GetNotesParamsPinnedToDealFlagN0 GetNotesParamsPinnedToDealFlag = 0
	GetNotesParamsPinnedToDealFlagN1 GetNotesParamsPinnedToDealFlag = 1
)

// Defines values for GetNotesParamsPinnedToOrganizationFlag.
const (
	GetNotesParamsPinnedToOrganizationFlagN0 GetNotesParamsPinnedToOrganizationFlag = 0
	GetNotesParamsPinnedToOrganizationFlagN1 GetNotesParamsPinnedToOrganizationFlag = 1
)

// Defines values for GetNotesParamsPinnedToPersonFlag.
const (
	GetNotesParamsPinnedToPersonFlagN0 GetNotesParamsPinnedToPersonFlag = 0
	GetNotesParamsPinnedToPersonFlagN1 GetNotesParamsPinnedToPersonFlag = 1
)

// Defines values for GetNotesParamsPinnedToProjectFlag.
const (
	GetNotesParamsPinnedToProjectFlagN0 GetNotesParamsPinnedToProjectFlag = 0
	GetNotesParamsPinnedToProjectFlagN1 GetNotesParamsPinnedToProjectFlag = 1
)

// Defines values for AddNoteJSONBodyPinnedToDealFlag.
const (
	AddNoteJSONBodyPinnedToDealFlagN0 AddNoteJSONBodyPinnedToDealFlag = 0
	AddNoteJSONBodyPinnedToDealFlagN1 AddNoteJSONBodyPinnedToDealFlag = 1
)

// Defines values for AddNoteJSONBodyPinnedToLeadFlag.
const (
	AddNoteJSONBodyPinnedToLeadFlagN0 AddNoteJSONBodyPinnedToLeadFlag = 0
	AddNoteJSONBodyPinnedToLeadFlagN1 AddNoteJSONBodyPinnedToLeadFlag = 1
)

// Defines values for AddNoteJSONBodyPinnedToOrganizationFlag.
const (
	AddNoteJSONBodyPinnedToOrganizationFlagN0 AddNoteJSONBodyPinnedToOrganizationFlag = 0
	AddNoteJSONBodyPinnedToOrganizationFlagN1 AddNoteJSONBodyPinnedToOrganizationFlag = 1
)

// Defines values for AddNoteJSONBodyPinnedToPersonFlag.
const (
	AddNoteJSONBodyPinnedToPersonFlagN0 AddNoteJSONBodyPinnedToPersonFlag = 0
	AddNoteJSONBodyPinnedToPersonFlagN1 AddNoteJSONBodyPinnedToPersonFlag = 1
)

// Defines values for AddNoteJSONBodyPinnedToProjectFlag.
const (
	AddNoteJSONBodyPinnedToProjectFlagN0 AddNoteJSONBodyPinnedToProjectFlag = 0
	AddNoteJSONBodyPinnedToProjectFlagN1 AddNoteJSONBodyPinnedToProjectFlag = 1
)

// Defines values for UpdateNoteJSONBodyPinnedToDealFlag.
const (
	UpdateNoteJSONBodyPinnedToDealFlagN0 UpdateNoteJSONBodyPinnedToDealFlag = 0
	UpdateNoteJSONBodyPinnedToDealFlagN1 UpdateNoteJSONBodyPinnedToDealFlag = 1
)

// Defines values for UpdateNoteJSONBodyPinnedToLeadFlag.
const (
	UpdateNoteJSONBodyPinnedToLeadFlagN0 UpdateNoteJSONBodyPinnedToLeadFlag = 0
	UpdateNoteJSONBodyPinnedToLeadFlagN1 UpdateNoteJSONBodyPinnedToLeadFlag = 1
)

// Defines values for UpdateNoteJSONBodyPinnedToOrganizationFlag.
const (
	UpdateNoteJSONBodyPinnedToOrganizationFlagN0 UpdateNoteJSONBodyPinnedToOrganizationFlag = 0
	UpdateNoteJSONBodyPinnedToOrganizationFlagN1 UpdateNoteJSONBodyPinnedToOrganizationFlag = 1
)

// Defines values for UpdateNoteJSONBodyPinnedToPersonFlag.
const (
	UpdateNoteJSONBodyPinnedToPersonFlagN0 UpdateNoteJSONBodyPinnedToPersonFlag = 0
	UpdateNoteJSONBodyPinnedToPersonFlagN1 UpdateNoteJSONBodyPinnedToPersonFlag = 1
)

// Defines values for UpdateNoteJSONBodyPinnedToProjectFlag.
const (
	UpdateNoteJSONBodyPinnedToProjectFlagN0 UpdateNoteJSONBodyPinnedToProjectFlag = 0
	UpdateNoteJSONBodyPinnedToProjectFlagN1 UpdateNoteJSONBodyPinnedToProjectFlag = 1
)

// Defines values for GetTokensFormdataBodyGrantType.
const (
	GetTokensFormdataBodyGrantTypeAuthorizationCode GetTokensFormdataBodyGrantType = "authorization_code"
	GetTokensFormdataBodyGrantTypeRefreshToken      GetTokensFormdataBodyGrantType = "refresh_token"
)

// Defines values for RefreshTokensFormdataBodyGrantType.
const (
	RefreshTokensFormdataBodyGrantTypeAuthorizationCode RefreshTokensFormdataBodyGrantType = "authorization_code"
	RefreshTokensFormdataBodyGrantTypeRefreshToken      RefreshTokensFormdataBodyGrantType = "refresh_token"
)

// Defines values for AddOrganizationRelationshipJSONBodyType.
const (
	AddOrganizationRelationshipJSONBodyTypeParent  AddOrganizationRelationshipJSONBodyType = "parent"
	AddOrganizationRelationshipJSONBodyTypeRelated AddOrganizationRelationshipJSONBodyType = "related"
)

// Defines values for UpdateOrganizationRelationshipJSONBodyType.
const (
	UpdateOrganizationRelationshipJSONBodyTypeParent  UpdateOrganizationRelationshipJSONBodyType = "parent"
	UpdateOrganizationRelationshipJSONBodyTypeRelated UpdateOrganizationRelationshipJSONBodyType = "related"
)

// Defines values for GetOrganizationActivitiesParamsDone.
const (
	GetOrganizationActivitiesParamsDoneN0 GetOrganizationActivitiesParamsDone = 0
	GetOrganizationActivitiesParamsDoneN1 GetOrganizationActivitiesParamsDone = 1
)

// Defines values for GetOrganizationDealsParamsStatus.
const (
	GetOrganizationDealsParamsStatusAllNotDeleted GetOrganizationDealsParamsStatus = "all_not_deleted"
	GetOrganizationDealsParamsStatusDeleted       GetOrganizationDealsParamsStatus = "deleted"
	GetOrganizationDealsParamsStatusLost          GetOrganizationDealsParamsStatus = "lost"
	GetOrganizationDealsParamsStatusOpen          GetOrganizationDealsParamsStatus = "open"
	GetOrganizationDealsParamsStatusWon           GetOrganizationDealsParamsStatus = "won"
)

// Defines values for GetOrganizationDealsParamsOnlyPrimaryAssociation.
const (
	GetOrganizationDealsParamsOnlyPrimaryAssociationN0 GetOrganizationDealsParamsOnlyPrimaryAssociation = 0
	GetOrganizationDealsParamsOnlyPrimaryAssociationN1 GetOrganizationDealsParamsOnlyPrimaryAssociation = 1
)

// Defines values for GetPermissionSetsParamsApp.
const (
	GetPermissionSetsParamsAppAccountSettings GetPermissionSetsParamsApp = "account_settings"
	GetPermissionSetsParamsAppCampaigns       GetPermissionSetsParamsApp = "campaigns"
	GetPermissionSetsParamsAppGlobal          GetPermissionSetsParamsApp = "global"
	GetPermissionSetsParamsAppProjects        GetPermissionSetsParamsApp = "projects"
	GetPermissionSetsParamsAppSales           GetPermissionSetsParamsApp = "sales"
)

// Defines values for GetPersonActivitiesParamsDone.
const (
	GetPersonActivitiesParamsDoneN0 GetPersonActivitiesParamsDone = 0
	GetPersonActivitiesParamsDoneN1 GetPersonActivitiesParamsDone = 1
)

// Defines values for GetPersonDealsParamsStatus.
const (
	GetPersonDealsParamsStatusAllNotDeleted GetPersonDealsParamsStatus = "all_not_deleted"
	GetPersonDealsParamsStatusDeleted       GetPersonDealsParamsStatus = "deleted"
	GetPersonDealsParamsStatusLost          GetPersonDealsParamsStatus = "lost"
	GetPersonDealsParamsStatusOpen          GetPersonDealsParamsStatus = "open"
	GetPersonDealsParamsStatusWon           GetPersonDealsParamsStatus = "won"
)

// Defines values for GetPipelineDealsParamsEveryone.
const (
	GetPipelineDealsParamsEveryoneN0 GetPipelineDealsParamsEveryone = 0
	GetPipelineDealsParamsEveryoneN1 GetPipelineDealsParamsEveryone = 1
)

// Defines values for GetPipelineDealsParamsGetSummary.
const (
	GetPipelineDealsParamsGetSummaryN0 GetPipelineDealsParamsGetSummary = 0
	GetPipelineDealsParamsGetSummaryN1 GetPipelineDealsParamsGetSummary = 1
)

// Defines values for GetProductDealsParamsStatus.
const (
	GetProductDealsParamsStatusAllNotDeleted GetProductDealsParamsStatus = "all_not_deleted"
	GetProductDealsParamsStatusDeleted       GetProductDealsParamsStatus = "deleted"
	GetProductDealsParamsStatusLost          GetProductDealsParamsStatus = "lost"
	GetProductDealsParamsStatusOpen          GetProductDealsParamsStatus = "open"
	GetProductDealsParamsStatusWon           GetProductDealsParamsStatus = "won"
)

// Defines values for GetRecentsParamsItems.
const (
	GetRecentsParamsItemsActivity     GetRecentsParamsItems = "activity"
	GetRecentsParamsItemsActivityType GetRecentsParamsItems = "activityType"
	GetRecentsParamsItemsDeal         GetRecentsParamsItems = "deal"
	GetRecentsParamsItemsFile         GetRecentsParamsItems = "file"
	GetRecentsParamsItemsFilter       GetRecentsParamsItems = "filter"
	GetRecentsParamsItemsNote         GetRecentsParamsItems = "note"
	GetRecentsParamsItemsOrganization GetRecentsParamsItems = "organization"
	GetRecentsParamsItemsPerson       GetRecentsParamsItems = "person"
	GetRecentsParamsItemsPipeline     GetRecentsParamsItems = "pipeline"
	GetRecentsParamsItemsProduct      GetRecentsParamsItems = "product"
	GetRecentsParamsItemsStage        GetRecentsParamsItems = "stage"
	GetRecentsParamsItemsUser         GetRecentsParamsItems = "user"
)

// Defines values for AddOrUpdateRoleSettingJSONBodySettingKey.
const (
	DealDefaultVisibility    AddOrUpdateRoleSettingJSONBodySettingKey = "deal_default_visibility"
	LeadDefaultVisibility    AddOrUpdateRoleSettingJSONBodySettingKey = "lead_default_visibility"
	OrgDefaultVisibility     AddOrUpdateRoleSettingJSONBodySettingKey = "org_default_visibility"
	PersonDefaultVisibility  AddOrUpdateRoleSettingJSONBodySettingKey = "person_default_visibility"
	ProductDefaultVisibility AddOrUpdateRoleSettingJSONBodySettingKey = "product_default_visibility"
)

// Defines values for AddOrUpdateRoleSettingJSONBodyValue.
const (
	AddOrUpdateRoleSettingJSONBodyValueN1 AddOrUpdateRoleSettingJSONBodyValue = 1
	AddOrUpdateRoleSettingJSONBodyValueN3 AddOrUpdateRoleSettingJSONBodyValue = 3
	AddOrUpdateRoleSettingJSONBodyValueN5 AddOrUpdateRoleSettingJSONBodyValue = 5
	AddOrUpdateRoleSettingJSONBodyValueN7 AddOrUpdateRoleSettingJSONBodyValue = 7
)

// Defines values for GetStageDealsParamsEveryone.
const (
	GetStageDealsParamsEveryoneN0 GetStageDealsParamsEveryone = 0
	GetStageDealsParamsEveryoneN1 GetStageDealsParamsEveryone = 1
)

// Defines values for GetTasksParamsDone.
const (
	GetTasksParamsDoneN0 GetTasksParamsDone = 0
	GetTasksParamsDoneN1 GetTasksParamsDone = 1
)

// Defines values for AddTaskJSONBodyDone.
const (
	AddTaskJSONBodyDoneN0 AddTaskJSONBodyDone = 0
	AddTaskJSONBodyDoneN1 AddTaskJSONBodyDone = 1
)

// Defines values for UpdateTaskJSONBodyDone.
const (
	UpdateTaskJSONBodyDoneN0 UpdateTaskJSONBodyDone = 0
	UpdateTaskJSONBodyDoneN1 UpdateTaskJSONBodyDone = 1
)

// Defines values for AddUserJSONBodyAccessApp.
const (
	AddUserJSONBodyAccessAppAccountSettings AddUserJSONBodyAccessApp = "account_settings"
	AddUserJSONBodyAccessAppCampaigns       AddUserJSONBodyAccessApp = "campaigns"
	AddUserJSONBodyAccessAppGlobal          AddUserJSONBodyAccessApp = "global"
	AddUserJSONBodyAccessAppPartnership     AddUserJSONBodyAccessApp = "partnership"
	AddUserJSONBodyAccessAppProjects        AddUserJSONBodyAccessApp = "projects"
	AddUserJSONBodyAccessAppSales           AddUserJSONBodyAccessApp = "sales"
)

// Defines values for FindUsersByNameParamsSearchByEmail.
const (
	FindUsersByNameParamsSearchByEmailN0 FindUsersByNameParamsSearchByEmail = 0
	FindUsersByNameParamsSearchByEmailN1 FindUsersByNameParamsSearchByEmail = 1
)

// Defines values for AddWebhookJSONBodyEventAction.
const (
	AddWebhookJSONBodyEventActionAsterisk AddWebhookJSONBodyEventAction = "*"
	AddWebhookJSONBodyEventActionChange   AddWebhookJSONBodyEventAction = "change"
	AddWebhookJSONBodyEventActionCreate   AddWebhookJSONBodyEventAction = "create"
	AddWebhookJSONBodyEventActionDelete   AddWebhookJSONBodyEventAction = "delete"
)

// Defines values for AddWebhookJSONBodyEventObject.
const (
	AddWebhookJSONBodyEventObjectActivity     AddWebhookJSONBodyEventObject = "activity"
	AddWebhookJSONBodyEventObjectAsterisk     AddWebhookJSONBodyEventObject = "*"
	AddWebhookJSONBodyEventObjectDeal         AddWebhookJSONBodyEventObject = "deal"
	AddWebhookJSONBodyEventObjectLead         AddWebhookJSONBodyEventObject = "lead"
	AddWebhookJSONBodyEventObjectNote         AddWebhookJSONBodyEventObject = "note"
	AddWebhookJSONBodyEventObjectOrganization AddWebhookJSONBodyEventObject = "organization"
	AddWebhookJSONBodyEventObjectPerson       AddWebhookJSONBodyEventObject = "person"
	AddWebhookJSONBodyEventObjectPipeline     AddWebhookJSONBodyEventObject = "pipeline"
	AddWebhookJSONBodyEventObjectProduct      AddWebhookJSONBodyEventObject = "product"
	AddWebhookJSONBodyEventObjectStage        AddWebhookJSONBodyEventObject = "stage"
	AddWebhookJSONBodyEventObjectUser         AddWebhookJSONBodyEventObject = "user"
)

// Defines values for AddWebhookJSONBodyVersion.
const (
	N10 AddWebhookJSONBodyVersion = "1.0"
	N20 AddWebhookJSONBodyVersion = "2.0"
)

// DeleteActivitiesParams defines parameters for DeleteActivities.
type DeleteActivitiesParams struct {
	// Ids The comma-separated IDs of activities that will be deleted
	Ids string `form:"ids" json:"ids"`
}

// GetActivitiesCollectionParams defines parameters for GetActivitiesCollection.
type GetActivitiesCollectionParams struct {
	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Since The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field.
	Since *string `form:"since,omitempty" json:"since,omitempty"`

	// Until The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field.
	Until *string `form:"until,omitempty" json:"until,omitempty"`

	// UserId The ID of the user whose activities will be fetched. If omitted, all activities are returned.
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`

	// Done Whether the activity is done or not. `false` = Not done, `true` = Done. If omitted, returns both done and not done activities.
	Done *bool `form:"done,omitempty" json:"done,omitempty"`

	// Type The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the `key_string` parameter of ActivityTypes.
	Type *string `form:"type,omitempty" json:"type,omitempty"`
}

// DeleteActivityTypesParams defines parameters for DeleteActivityTypes.
type DeleteActivityTypesParams struct {
	// Ids The comma-separated activity type IDs
	Ids string `form:"ids" json:"ids"`
}

// AddActivityTypeJSONBody defines parameters for AddActivityType.
type AddActivityTypeJSONBody struct {
	// Color A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
	Color *string `json:"color,omitempty"`

	// IconKey Icon graphic to use for representing this activity type
	IconKey AddActivityTypeJSONBodyIconKey `json:"icon_key"`

	// Name The name of the activity type
	Name string `json:"name"`
}

// AddActivityTypeJSONBodyIconKey defines parameters for AddActivityType.
type AddActivityTypeJSONBodyIconKey string

// UpdateActivityTypeJSONBody defines parameters for UpdateActivityType.
type UpdateActivityTypeJSONBody struct {
	// Color A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
	Color *string `json:"color,omitempty"`

	// IconKey Icon graphic to use for representing this activity type
	IconKey *UpdateActivityTypeJSONBodyIconKey `json:"icon_key,omitempty"`

	// Name The name of the activity type
	Name *string `json:"name,omitempty"`

	// OrderNr An order number for this activity type. Order numbers should be used to order the types in the activity type selections.
	OrderNr *int `json:"order_nr,omitempty"`
}

// UpdateActivityTypeJSONBodyIconKey defines parameters for UpdateActivityType.
type UpdateActivityTypeJSONBodyIconKey string

// GetUserCallLogsParams defines parameters for GetUserCallLogs.
type GetUserCallLogsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit For pagination, the limit of entries to be returned. The upper limit is 50.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddCallLogJSONBody defines parameters for AddCallLog.
type AddCallLogJSONBody struct {
	// ActivityId If specified, this activity will be converted into a call log, with the information provided. When this field is used, you don't need to specify `deal_id`, `person_id` or `org_id`, as they will be ignored in favor of the values already available in the activity. The `activity_id` must refer to a `call` type activity.
	ActivityId *int `json:"activity_id,omitempty"`

	// DealId The ID of the deal this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
	DealId *int `json:"deal_id,omitempty"`

	// Duration The duration of the call in seconds
	Duration *string `json:"duration,omitempty"`

	// EndTime The date and time of the end of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
	EndTime time.Time `json:"end_time"`

	// FromPhoneNumber The number that made the call
	FromPhoneNumber *string `json:"from_phone_number,omitempty"`

	// LeadId The ID of the lead in the UUID format this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
	LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

	// Note The note for the call log in HTML format
	Note *string `json:"note,omitempty"`

	// OrgId The ID of the organization this call is associated with
	OrgId *int `json:"org_id,omitempty"`

	// Outcome Describes the outcome of the call
	Outcome AddCallLogJSONBodyOutcome `json:"outcome"`

	// PersonId The ID of the person this call is associated with
	PersonId *int `json:"person_id,omitempty"`

	// StartTime The date and time of the start of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
	StartTime time.Time `json:"start_time"`

	// Subject The name of the activity this call is attached to
	Subject *string `json:"subject,omitempty"`

	// ToPhoneNumber The number called
	ToPhoneNumber string `json:"to_phone_number"`

	// UserId The ID of the owner of the call log. Please note that a user without account settings access cannot create call logs for other users.
	UserId *int `json:"user_id,omitempty"`
}

// AddCallLogJSONBodyOutcome defines parameters for AddCallLog.
type AddCallLogJSONBodyOutcome string

// AddCallLogAudioFileMultipartBody defines parameters for AddCallLogAudioFile.
type AddCallLogAudioFileMultipartBody struct {
	// File Audio file supported by the HTML5 specification
	File openapi_types.File `json:"file"`
}

// AddChannelJSONBody defines parameters for AddChannel.
type AddChannelJSONBody struct {
	// AvatarUrl The URL for an icon that represents your channel
	AvatarUrl *string `json:"avatar_url,omitempty"`

	// Name The name of the channel
	Name string `json:"name"`

	// ProviderChannelId The channel ID
	ProviderChannelId string `json:"provider_channel_id"`

	// ProviderType It controls the icons (like the icon next to the conversation)
	ProviderType *AddChannelJSONBodyProviderType `json:"provider_type,omitempty"`

	// TemplateSupport If true, enables templates logic on UI. Requires getTemplates endpoint implemented. Find out more [here](https://pipedrive.readme.io/docs/implementing-messaging-app-extension).
	TemplateSupport *bool `json:"template_support,omitempty"`
}

// AddChannelJSONBodyProviderType defines parameters for AddChannel.
type AddChannelJSONBodyProviderType string

// ReceiveMessageJSONBody defines parameters for ReceiveMessage.
type ReceiveMessageJSONBody struct {
	// Attachments The list of attachments available in the message
	Attachments *[]struct {
		// Id The ID of the attachment
		Id string `json:"id"`

		// LinkExpires If true, it will use the getMessageById endpoint for fetching updated attachment's urls. Find out more [here](https://pipedrive.readme.io/docs/implementing-messaging-app-extension)
		LinkExpires *bool `json:"link_expires,omitempty"`

		// Name The name of the attachment
		Name *string `json:"name,omitempty"`

		// PreviewUrl A URL to a preview picture of the file
		PreviewUrl *string `json:"preview_url,omitempty"`

		// Size The size of the attachment
		Size *float32 `json:"size,omitempty"`

		// Type The mime-type of the attachment
		Type string `json:"type"`

		// Url A URL to the file
		Url string `json:"url"`
	} `json:"attachments,omitempty"`

	// ChannelId The channel ID as in the provider
	ChannelId string `json:"channel_id"`

	// ConversationId The ID of the conversation
	ConversationId string `json:"conversation_id"`

	// ConversationLink A URL that can open the conversation in the provider's side
	ConversationLink *string `json:"conversation_link,omitempty"`

	// CreatedAt The date and time when the message was created in the provider, in UTC. Format: YYYY-MM-DD HH:MM
	CreatedAt time.Time `json:"created_at"`

	// Id The ID of the message
	Id string `json:"id"`

	// Message The body of the message
	Message string `json:"message"`

	// ReplyBy The date and time when the message can no longer receive a reply, in UTC. Format: YYYY-MM-DD HH:MM
	ReplyBy *time.Time `json:"reply_by,omitempty"`

	// SenderId The ID of the provider's user that sent the message
	SenderId string `json:"sender_id"`

	// Status The status of the message
	Status ReceiveMessageJSONBodyStatus `json:"status"`
}

// ReceiveMessageJSONBodyStatus defines parameters for ReceiveMessage.
type ReceiveMessageJSONBodyStatus string

// GetCurrenciesParams defines parameters for GetCurrencies.
type GetCurrenciesParams struct {
	// Term Optional search term that is searched for from currency's name and/or code
	Term *string `form:"term,omitempty" json:"term,omitempty"`
}

// DeleteDealFieldsParams defines parameters for DeleteDealFields.
type DeleteDealFieldsParams struct {
	// Ids The comma-separated field IDs to delete
	Ids string `form:"ids" json:"ids"`
}

// DeleteDealsParams defines parameters for DeleteDeals.
type DeleteDealsParams struct {
	// Ids The comma-separated IDs that will be deleted
	Ids string `form:"ids" json:"ids"`
}

// GetDealsCollectionParams defines parameters for GetDealsCollection.
type GetDealsCollectionParams struct {
	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Since The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field.
	Since *string `form:"since,omitempty" json:"since,omitempty"`

	// Until The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field.
	Until *string `form:"until,omitempty" json:"until,omitempty"`

	// UserId If supplied, only deals matching the given user will be returned
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`

	// StageId If supplied, only deals within the given stage will be returned
	StageId *int `form:"stage_id,omitempty" json:"stage_id,omitempty"`

	// Status Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
	Status *GetDealsCollectionParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetDealsCollectionParamsStatus defines parameters for GetDealsCollection.
type GetDealsCollectionParamsStatus string

// GetDealsSummaryParams defines parameters for GetDealsSummary.
type GetDealsSummaryParams struct {
	// Status Only fetch deals with a specific status. open = Open, won = Won, lost = Lost.
	Status *GetDealsSummaryParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// FilterId <code>user_id</code> will not be considered. Only deals matching the given filter will be returned.
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// UserId Only deals matching the given user will be returned. `user_id` will not be considered if you use `filter_id`.
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`

	// PipelineId Only deals within the given pipeline will be returned
	PipelineId *int `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty"`

	// StageId Only deals within the given stage will be returned
	StageId *int `form:"stage_id,omitempty" json:"stage_id,omitempty"`
}

// GetDealsSummaryParamsStatus defines parameters for GetDealsSummary.
type GetDealsSummaryParamsStatus string

// GetArchivedDealsSummaryParams defines parameters for GetArchivedDealsSummary.
type GetArchivedDealsSummaryParams struct {
	// Status Only fetch deals with a specific status. open = Open, won = Won, lost = Lost.
	Status *GetArchivedDealsSummaryParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// FilterId <code>user_id</code> will not be considered. Only deals matching the given filter will be returned.
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// UserId Only deals matching the given user will be returned. `user_id` will not be considered if you use `filter_id`.
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`

	// PipelineId Only deals within the given pipeline will be returned
	PipelineId *int `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty"`

	// StageId Only deals within the given stage will be returned
	StageId *int `form:"stage_id,omitempty" json:"stage_id,omitempty"`
}

// GetArchivedDealsSummaryParamsStatus defines parameters for GetArchivedDealsSummary.
type GetArchivedDealsSummaryParamsStatus string

// GetDealsTimelineParams defines parameters for GetDealsTimeline.
type GetDealsTimelineParams struct {
	// StartDate The date when the first interval starts. Format: YYYY-MM-DD.
	StartDate openapi_types.Date `form:"start_date" json:"start_date"`

	// Interval The type of the interval<table><tr><th>Value</th><th>Description</th></tr><tr><td>`day`</td><td>Day</td></tr><tr><td>`week`</td><td>A full week (7 days) starting from `start_date`</td></tr><tr><td>`month`</td><td>A full month (depending on the number of days in given month) starting from `start_date`</td></tr><tr><td>`quarter`</td><td>A full quarter (3 months) starting from `start_date`</td></tr></table>
	Interval GetDealsTimelineParamsInterval `form:"interval" json:"interval"`

	// Amount The number of given intervals, starting from `start_date`, to fetch. E.g. 3 (months).
	Amount int `form:"amount" json:"amount"`

	// FieldKey The date field key which deals will be retrieved from
	FieldKey string `form:"field_key" json:"field_key"`

	// UserId If supplied, only deals matching the given user will be returned
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`

	// PipelineId If supplied, only deals matching the given pipeline will be returned
	PipelineId *int `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty"`

	// FilterId If supplied, only deals matching the given filter will be returned
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// ExcludeDeals Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned.
	ExcludeDeals *GetDealsTimelineParamsExcludeDeals `form:"exclude_deals,omitempty" json:"exclude_deals,omitempty"`

	// TotalsConvertCurrency The 3-letter currency code of any of the supported currencies. When supplied, `totals_converted` is returned per each interval which contains the currency-converted total amounts in the given currency. You may also set this parameter to `default_currency` in which case the user's default currency is used.
	TotalsConvertCurrency *string `form:"totals_convert_currency,omitempty" json:"totals_convert_currency,omitempty"`
}

// GetDealsTimelineParamsInterval defines parameters for GetDealsTimeline.
type GetDealsTimelineParamsInterval string

// GetDealsTimelineParamsExcludeDeals defines parameters for GetDealsTimeline.
type GetDealsTimelineParamsExcludeDeals float32

// GetArchivedDealsTimelineParams defines parameters for GetArchivedDealsTimeline.
type GetArchivedDealsTimelineParams struct {
	// StartDate The date when the first interval starts. Format: YYYY-MM-DD.
	StartDate openapi_types.Date `form:"start_date" json:"start_date"`

	// Interval The type of the interval<table><tr><th>Value</th><th>Description</th></tr><tr><td>`day`</td><td>Day</td></tr><tr><td>`week`</td><td>A full week (7 days) starting from `start_date`</td></tr><tr><td>`month`</td><td>A full month (depending on the number of days in given month) starting from `start_date`</td></tr><tr><td>`quarter`</td><td>A full quarter (3 months) starting from `start_date`</td></tr></table>
	Interval GetArchivedDealsTimelineParamsInterval `form:"interval" json:"interval"`

	// Amount The number of given intervals, starting from `start_date`, to fetch. E.g. 3 (months).
	Amount int `form:"amount" json:"amount"`

	// FieldKey The date field key which deals will be retrieved from
	FieldKey string `form:"field_key" json:"field_key"`

	// UserId If supplied, only deals matching the given user will be returned
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`

	// PipelineId If supplied, only deals matching the given pipeline will be returned
	PipelineId *int `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty"`

	// FilterId If supplied, only deals matching the given filter will be returned
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// ExcludeDeals Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned.
	ExcludeDeals *GetArchivedDealsTimelineParamsExcludeDeals `form:"exclude_deals,omitempty" json:"exclude_deals,omitempty"`

	// TotalsConvertCurrency The 3-letter currency code of any of the supported currencies. When supplied, `totals_converted` is returned per each interval which contains the currency-converted total amounts in the given currency. You may also set this parameter to `default_currency` in which case the user's default currency is used.
	TotalsConvertCurrency *string `form:"totals_convert_currency,omitempty" json:"totals_convert_currency,omitempty"`
}

// GetArchivedDealsTimelineParamsInterval defines parameters for GetArchivedDealsTimeline.
type GetArchivedDealsTimelineParamsInterval string

// GetArchivedDealsTimelineParamsExcludeDeals defines parameters for GetArchivedDealsTimeline.
type GetArchivedDealsTimelineParamsExcludeDeals float32

// GetDealActivitiesParams defines parameters for GetDealActivities.
type GetDealActivitiesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Done Whether the activity is done or not. 0 = Not done, 1 = Done. If omitted, returns both Done and Not done activities.
	Done *GetDealActivitiesParamsDone `form:"done,omitempty" json:"done,omitempty"`

	// Exclude A comma-separated string of activity IDs to exclude from result
	Exclude *string `form:"exclude,omitempty" json:"exclude,omitempty"`
}

// GetDealActivitiesParamsDone defines parameters for GetDealActivities.
type GetDealActivitiesParamsDone float32

// GetDealChangelogParams defines parameters for GetDealChangelog.
type GetDealChangelogParams struct {
	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetDealFilesParams defines parameters for GetDealFiles.
type GetDealFilesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page. Please note that a maximum value of 100 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Supported fields: `id`, `update_time`
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetDealUpdatesParams defines parameters for GetDealUpdates.
type GetDealUpdatesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// AllChanges Whether to show custom field updates or not. 1 = Include custom field changes. If omitted returns changes without custom field updates.
	AllChanges *string `form:"all_changes,omitempty" json:"all_changes,omitempty"`

	// Items A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change).
	Items *string `form:"items,omitempty" json:"items,omitempty"`
}

// GetDealMailMessagesParams defines parameters for GetDealMailMessages.
type GetDealMailMessagesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// MergeDealsJSONBody defines parameters for MergeDeals.
type MergeDealsJSONBody struct {
	// MergeWithId The ID of the deal that the deal will be merged with
	MergeWithId int `json:"merge_with_id"`
}

// GetDealParticipantsParams defines parameters for GetDealParticipants.
type GetDealParticipantsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddDealParticipantJSONBody defines parameters for AddDealParticipant.
type AddDealParticipantJSONBody struct {
	// PersonId The ID of the person
	PersonId int `json:"person_id"`
}

// GetDealParticipantsChangelogParams defines parameters for GetDealParticipantsChangelog.
type GetDealParticipantsChangelogParams struct {
	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetDealPersonsParams defines parameters for GetDealPersons.
type GetDealPersonsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetFilesParams defines parameters for GetFiles.
type GetFilesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page. Please note that a maximum value of 100 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Supported fields: `id`, `update_time`
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// AddFileMultipartBody defines parameters for AddFile.
type AddFileMultipartBody struct {
	// ActivityId The ID of the activity to associate file(s) with
	ActivityId *int `json:"activity_id,omitempty"`

	// DealId The ID of the deal to associate file(s) with
	DealId *int `json:"deal_id,omitempty"`

	// File A single file, supplied in the multipart/form-data encoding and contained within the given boundaries
	File openapi_types.File `json:"file"`

	// LeadId The ID of the lead to associate file(s) with
	LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

	// OrgId The ID of the organization to associate file(s) with
	OrgId *int `json:"org_id,omitempty"`

	// PersonId The ID of the person to associate file(s) with
	PersonId *int `json:"person_id,omitempty"`

	// ProductId The ID of the product to associate file(s) with
	ProductId *int `json:"product_id,omitempty"`
}

// AddFileAndLinkItFormdataBody defines parameters for AddFileAndLinkIt.
type AddFileAndLinkItFormdataBody struct {
	// FileType The file type
	FileType AddFileAndLinkItFormdataBodyFileType `form:"file_type" json:"file_type"`

	// ItemId The ID of the item to associate the file with
	ItemId int `form:"item_id" json:"item_id"`

	// ItemType The item type
	ItemType AddFileAndLinkItFormdataBodyItemType `form:"item_type" json:"item_type"`

	// RemoteLocation The location type to send the file to. Only `googledrive` is supported at the moment.
	RemoteLocation AddFileAndLinkItFormdataBodyRemoteLocation `form:"remote_location" json:"remote_location"`

	// Title The title of the file
	Title string `form:"title" json:"title"`
}

// AddFileAndLinkItFormdataBodyFileType defines parameters for AddFileAndLinkIt.
type AddFileAndLinkItFormdataBodyFileType string

// AddFileAndLinkItFormdataBodyItemType defines parameters for AddFileAndLinkIt.
type AddFileAndLinkItFormdataBodyItemType string

// AddFileAndLinkItFormdataBodyRemoteLocation defines parameters for AddFileAndLinkIt.
type AddFileAndLinkItFormdataBodyRemoteLocation string

// LinkFileToItemFormdataBody defines parameters for LinkFileToItem.
type LinkFileToItemFormdataBody struct {
	// ItemId The ID of the item to associate the file with
	ItemId int `form:"item_id" json:"item_id"`

	// ItemType The item type
	ItemType LinkFileToItemFormdataBodyItemType `form:"item_type" json:"item_type"`

	// RemoteId The remote item ID
	RemoteId string `form:"remote_id" json:"remote_id"`

	// RemoteLocation The location type to send the file to. Only `googledrive` is supported at the moment.
	RemoteLocation LinkFileToItemFormdataBodyRemoteLocation `form:"remote_location" json:"remote_location"`
}

// LinkFileToItemFormdataBodyItemType defines parameters for LinkFileToItem.
type LinkFileToItemFormdataBodyItemType string

// LinkFileToItemFormdataBodyRemoteLocation defines parameters for LinkFileToItem.
type LinkFileToItemFormdataBodyRemoteLocation string

// UpdateFileFormdataBody defines parameters for UpdateFile.
type UpdateFileFormdataBody struct {
	// Description The description of the file
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Name The visible name of the file
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// DeleteFiltersParams defines parameters for DeleteFilters.
type DeleteFiltersParams struct {
	// Ids The comma-separated filter IDs to delete
	Ids string `form:"ids" json:"ids"`
}

// GetFiltersParams defines parameters for GetFilters.
type GetFiltersParams struct {
	// Type The types of filters to fetch
	Type *GetFiltersParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// GetFiltersParamsType defines parameters for GetFilters.
type GetFiltersParamsType string

// AddFilterJSONBody defines parameters for AddFilter.
type AddFilterJSONBody struct {
	// Conditions The conditions of the filter as a JSON object. Please note that a maximum of 16 conditions is allowed per filter and `date` values must be supplied in the `YYYY-MM-DD` format. It requires a minimum structure as follows: `{"glue":"and","conditions":[{"glue":"and","conditions": [CONDITION_OBJECTS]},{"glue":"or","conditions":[CONDITION_OBJECTS]}]}`. Replace `CONDITION_OBJECTS` with JSON objects of the following structure: `{"object":"","field_id":"", "operator":"","value":"", "extra_value":""}` or leave the array empty. Depending on the object type you should use another API endpoint to get `field_id`. There are five types of objects you can choose from: `"person"`, `"deal"`, `"organization"`, `"product"`, `"activity"` and you can use these types of operators depending on what type of a field you have: `"IS NOT NULL"`, `"IS NULL"`, `"<="`, `">="`, `"<"`, `">"`, `"!="`, `"="`, `"LIKE '$%'"`, `"LIKE '%$%'"`, `"NOT LIKE '$%'"`. To get a better understanding of how filters work try creating them directly from the Pipedrive application.
	Conditions map[string]interface{} `json:"conditions"`

	// Name The name of the filter
	Name string `json:"name"`

	// Type The type of filter to create
	Type AddFilterJSONBodyType `json:"type"`
}

// AddFilterJSONBodyType defines parameters for AddFilter.
type AddFilterJSONBodyType string

// UpdateFilterJSONBody defines parameters for UpdateFilter.
type UpdateFilterJSONBody struct {
	// Conditions The conditions of the filter as a JSON object. Please note that a maximum of 16 conditions is allowed per filter and `date` values must be supplied in the `YYYY-MM-DD` format. It requires a minimum structure as follows: `{"glue":"and","conditions":[{"glue":"and","conditions": [CONDITION_OBJECTS]},{"glue":"or","conditions":[CONDITION_OBJECTS]}]}`. Replace `CONDITION_OBJECTS` with JSON objects of the following structure: `{"object":"","field_id":"", "operator":"","value":"", "extra_value":""}` or leave the array empty. Depending on the object type you should use another API endpoint to get `field_id`. There are five types of objects you can choose from: `"person"`, `"deal"`, `"organization"`, `"product"`, `"activity"` and you can use these types of operators depending on what type of a field you have: `"IS NOT NULL"`, `"IS NULL"`, `"<="`, `">="`, `"<"`, `">"`, `"!="`, `"="`, `"LIKE '$%'"`, `"LIKE '%$%'"`, `"NOT LIKE '$%'"`. To get a better understanding of how filters work try creating them directly from the Pipedrive application.
	Conditions map[string]interface{} `json:"conditions"`

	// Name The name of the filter
	Name *string `json:"name,omitempty"`
}

// AddGoalJSONBody defines parameters for AddGoal.
type AddGoalJSONBody struct {
	// Assignee Who this goal is assigned to. It requires the following JSON structure: `{ "id": "1", "type": "person" }`. `type` can be either `person`, `company` or `team`. ID of the assignee person, company or team.
	Assignee map[string]interface{} `json:"assignee"`

	// Duration The date when the goal starts and ends. It requires the following JSON structure: `{ "start": "2019-01-01", "end": "2022-12-31" }`. Date in format of YYYY-MM-DD. "end" can be set to `null` for an infinite, open-ended goal.
	Duration map[string]interface{} `json:"duration"`

	// ExpectedOutcome The expected outcome of the goal. Expected outcome can be tracked either by `quantity` or by `sum`. It requires the following JSON structure: `{ "target": "50", "tracking_metric": "quantity" }` or `{ "target": "50", "tracking_metric": "sum", "currency_id": 1 }`. `currency_id` should only be added to `sum` type of goals.
	ExpectedOutcome map[string]interface{} `json:"expected_outcome"`

	// Interval The interval of the goal
	Interval AddGoalJSONBodyInterval `json:"interval"`

	// Title The title of the goal
	Title *string `json:"title,omitempty"`

	// Type The type of the goal. It requires the following JSON structure: `{ "name": "deals_started", "params": { "pipeline_id": [1, 2], "activity_type_id": [9] } }`. Type can be one of: `deals_won`, `deals_progressed`, `activities_completed`, `activities_added`, `deals_started` or `revenue_forecast`. `params` can include `pipeline_id`, `stage_id` or `activity_type_id`. `stage_id` is related to only `deals_progressed` type of goals and `activity_type_id` to `activities_completed` or `activities_added` types of goals. The `pipeline_id` and `activity_type_id` need to be given as an array of integers. To track the goal in all pipelines, set `pipeline_id` as `null` and similarly, to track the goal for all activities, set `activity_type_id` as `null`.
	Type map[string]interface{} `json:"type"`
}

// AddGoalJSONBodyInterval defines parameters for AddGoal.
type AddGoalJSONBodyInterval string

// GetGoalsParams defines parameters for GetGoals.
type GetGoalsParams struct {
	// TypeName The type of the goal. If provided, everyone's goals will be returned.
	TypeName *GetGoalsParamsTypeName `form:"type.name,omitempty" json:"type.name,omitempty"`

	// Title The title of the goal
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// IsActive Whether the goal is active or not
	IsActive *bool `form:"is_active,omitempty" json:"is_active,omitempty"`

	// AssigneeId The ID of the user who's goal to fetch. When omitted, only your goals will be returned.
	AssigneeId *int `form:"assignee.id,omitempty" json:"assignee.id,omitempty"`

	// AssigneeType The type of the goal's assignee. If provided, everyone's goals will be returned.
	AssigneeType *GetGoalsParamsAssigneeType `form:"assignee.type,omitempty" json:"assignee.type,omitempty"`

	// ExpectedOutcomeTarget The numeric value of the outcome. If provided, everyone's goals will be returned.
	ExpectedOutcomeTarget *float32 `form:"expected_outcome.target,omitempty" json:"expected_outcome.target,omitempty"`

	// ExpectedOutcomeTrackingMetric The tracking metric of the expected outcome of the goal. If provided, everyone's goals will be returned.
	ExpectedOutcomeTrackingMetric *GetGoalsParamsExpectedOutcomeTrackingMetric `form:"expected_outcome.tracking_metric,omitempty" json:"expected_outcome.tracking_metric,omitempty"`

	// ExpectedOutcomeCurrencyId The numeric ID of the goal's currency. Only applicable to goals with `expected_outcome.tracking_metric` with value `sum`. If provided, everyone's goals will be returned.
	ExpectedOutcomeCurrencyId *int `form:"expected_outcome.currency_id,omitempty" json:"expected_outcome.currency_id,omitempty"`

	// TypeParamsPipelineId An array of pipeline IDs or `null` for all pipelines. If provided, everyone's goals will be returned.
	TypeParamsPipelineId *[]int `form:"type.params.pipeline_id,omitempty" json:"type.params.pipeline_id,omitempty"`

	// TypeParamsStageId The ID of the stage. Applicable to only `deals_progressed` type of goals. If provided, everyone's goals will be returned.
	TypeParamsStageId *int `form:"type.params.stage_id,omitempty" json:"type.params.stage_id,omitempty"`

	// TypeParamsActivityTypeId An array of IDs or `null` for all activity types. Only applicable for `activities_completed` and/or `activities_added` types of goals. If provided, everyone's goals will be returned.
	TypeParamsActivityTypeId *[]int `form:"type.params.activity_type_id,omitempty" json:"type.params.activity_type_id,omitempty"`

	// PeriodStart The start date of the period for which to find goals. Date in format of YYYY-MM-DD. When `period.start` is provided, `period.end` must be provided too.
	PeriodStart *openapi_types.Date `form:"period.start,omitempty" json:"period.start,omitempty"`

	// PeriodEnd The end date of the period for which to find goals. Date in format of YYYY-MM-DD.
	PeriodEnd *openapi_types.Date `form:"period.end,omitempty" json:"period.end,omitempty"`
}

// GetGoalsParamsTypeName defines parameters for GetGoals.
type GetGoalsParamsTypeName string

// GetGoalsParamsAssigneeType defines parameters for GetGoals.
type GetGoalsParamsAssigneeType string

// GetGoalsParamsExpectedOutcomeTrackingMetric defines parameters for GetGoals.
type GetGoalsParamsExpectedOutcomeTrackingMetric string

// UpdateGoalJSONBody defines parameters for UpdateGoal.
type UpdateGoalJSONBody struct {
	// Assignee Who this goal is assigned to. It requires the following JSON structure: `{ "id": "1", "type": "person" }`. `type` can be either `person`, `company` or `team`. ID of the assignee person, company or team.
	Assignee *map[string]interface{} `json:"assignee,omitempty"`

	// Duration The date when the goal starts and ends. It requires the following JSON structure: `{ "start": "2019-01-01", "end": "2022-12-31" }`. Date in format of YYYY-MM-DD. "end" can be set to `null` for an infinite, open-ended goal.
	Duration *map[string]interface{} `json:"duration,omitempty"`

	// ExpectedOutcome The expected outcome of the goal. Expected outcome can be tracked either by `quantity` or by `sum`. It requires the following JSON structure: `{ "target": "50", "tracking_metric": "quantity" }` or `{ "target": "50", "tracking_metric": "sum", "currency_id": 1 }`. `currency_id` should only be added to `sum` type of goals.
	ExpectedOutcome *map[string]interface{} `json:"expected_outcome,omitempty"`

	// Interval The interval of the goal
	Interval *UpdateGoalJSONBodyInterval `json:"interval,omitempty"`

	// Title The title of the goal
	Title *string `json:"title,omitempty"`

	// Type The type of the goal. It requires the following JSON structure: `{ "name": "deals_started", "params": { "pipeline_id": [1, 2], "activity_type_id": [9] } }`. Type can be one of: `deals_won`, `deals_progressed`, `activities_completed`, `activities_added`, `deals_started` or `revenue_forecast`. `params` can include `pipeline_id`, `stage_id` or `activity_type_id`. `stage_id` is related to only `deals_progressed` type of goals and `activity_type_id` to `activities_completed` or `activities_added` types of goals. The `pipeline_id` and `activity_type_id` need to be given as an array of integers. To track the goal in all pipelines, set `pipeline_id` as `null` and similarly, to track the goal for all activities, set `activity_type_id` as `null`.
	Type *map[string]interface{} `json:"type,omitempty"`
}

// UpdateGoalJSONBodyInterval defines parameters for UpdateGoal.
type UpdateGoalJSONBodyInterval string

// GetGoalResultParams defines parameters for GetGoalResult.
type GetGoalResultParams struct {
	// PeriodStart The start date of the period for which to find the goal's progress. Format: YYYY-MM-DD. This date must be the same or after the goal duration start date.
	PeriodStart openapi_types.Date `form:"period.start" json:"period.start"`

	// PeriodEnd The end date of the period for which to find the goal's progress. Format: YYYY-MM-DD. This date must be the same or before the goal duration end date.
	PeriodEnd openapi_types.Date `form:"period.end" json:"period.end"`
}

// GetLeadFieldsParams defines parameters for GetLeadFields.
type GetLeadFieldsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddLeadLabelJSONBody defines parameters for AddLeadLabel.
type AddLeadLabelJSONBody struct {
	// Color The color of the label. Only a subset of colors can be used.
	Color AddLeadLabelJSONBodyColor `json:"color"`

	// Name The name of the lead label
	Name string `json:"name"`
}

// AddLeadLabelJSONBodyColor defines parameters for AddLeadLabel.
type AddLeadLabelJSONBodyColor string

// UpdateLeadLabelJSONBody defines parameters for UpdateLeadLabel.
type UpdateLeadLabelJSONBody struct {
	// Color The color of the label. Only a subset of colors can be used.
	Color *UpdateLeadLabelJSONBodyColor `json:"color,omitempty"`

	// Name The name of the lead label
	Name *string `json:"name,omitempty"`
}

// UpdateLeadLabelJSONBodyColor defines parameters for UpdateLeadLabel.
type UpdateLeadLabelJSONBodyColor string

// GetLeadsParams defines parameters for GetLeads.
type GetLeadsParams struct {
	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Start For pagination, the position that represents the first result for the page
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// OwnerId If supplied, only leads matching the given user will be returned. However, `filter_id` takes precedence over `owner_id` when supplied.
	OwnerId *int `form:"owner_id,omitempty" json:"owner_id,omitempty"`

	// PersonId If supplied, only leads matching the given person will be returned. However, `filter_id` takes precedence over `person_id` when supplied.
	PersonId *int `form:"person_id,omitempty" json:"person_id,omitempty"`

	// OrganizationId If supplied, only leads matching the given organization will be returned. However, `filter_id` takes precedence over `organization_id` when supplied.
	OrganizationId *int `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// FilterId The ID of the filter to use
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// Sort The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys).
	Sort *GetLeadsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetLeadsParamsSort defines parameters for GetLeads.
type GetLeadsParamsSort string

// AddLeadJSONBody defines parameters for AddLead.
type AddLeadJSONBody struct {
	// Channel The ID of Marketing channel this lead was created from. Provided value must be one of the channels configured for your company. You can fetch allowed values with <a href="https://developers.pipedrive.com/docs/api/v1/DealFields#getDealField" target="_blank" rel="noopener noreferrer">GET /v1/dealFields</a>. If omitted, channel will be set to null.
	Channel *int `json:"channel"`

	// ChannelId The optional ID to further distinguish the Marketing channel. If omitted, `channel_id` will be set to null.
	ChannelId *string `json:"channel_id"`

	// ExpectedCloseDate The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
	ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

	// LabelIds The IDs of the lead labels which will be associated with the lead
	LabelIds *[]openapi_types.UUID `json:"label_ids,omitempty"`

	// OrganizationId The ID of an organization which this lead will be linked to. If the organization does not exist yet, it needs to be created first. This property is required unless `person_id` is specified.
	OrganizationId *int `json:"organization_id,omitempty"`

	// OriginId The optional ID to further distinguish the origin of the lead - e.g. Which API integration created this lead. If omitted, `origin_id` will be set to null.
	OriginId *string `json:"origin_id"`

	// OwnerId The ID of the user which will be the owner of the created lead. If not provided, the user making the request will be used.
	OwnerId *int `json:"owner_id,omitempty"`

	// PersonId The ID of a person which this lead will be linked to. If the person does not exist yet, it needs to be created first. This property is required unless `organization_id` is specified.
	PersonId *int `json:"person_id,omitempty"`

	// Title The name of the lead
	Title string `json:"title"`

	// Value The potential value of the lead represented by a JSON object: `{ "amount": 200, "currency": "EUR" }`. Both amount and currency are required.
	Value *struct {
		Amount   float32 `json:"amount"`
		Currency string  `json:"currency"`
	} `json:"value"`

	// VisibleTo The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href="https://support.pipedrive.com/en/article/visibility-groups" target="_blank" rel="noopener noreferrer">here</a>.<h4>Light / Growth and Professional plans</h4><table><tr><th style="width: 40px">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Premium / Ultimate plan</h4><table><tr><th style="width: 40px">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
	VisibleTo *AddLeadJSONBodyVisibleTo `json:"visible_to,omitempty"`

	// WasSeen A flag indicating whether the lead was seen by someone in the Pipedrive UI
	WasSeen *bool `json:"was_seen,omitempty"`
}

// AddLeadJSONBodyVisibleTo defines parameters for AddLead.
type AddLeadJSONBodyVisibleTo string

// GetArchivedLeadsParams defines parameters for GetArchivedLeads.
type GetArchivedLeadsParams struct {
	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Start For pagination, the position that represents the first result for the page
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// OwnerId If supplied, only leads matching the given user will be returned. However, `filter_id` takes precedence over `owner_id` when supplied.
	OwnerId *int `form:"owner_id,omitempty" json:"owner_id,omitempty"`

	// PersonId If supplied, only leads matching the given person will be returned. However, `filter_id` takes precedence over `person_id` when supplied.
	PersonId *int `form:"person_id,omitempty" json:"person_id,omitempty"`

	// OrganizationId If supplied, only leads matching the given organization will be returned. However, `filter_id` takes precedence over `organization_id` when supplied.
	OrganizationId *int `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// FilterId The ID of the filter to use
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// Sort The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys).
	Sort *GetArchivedLeadsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetArchivedLeadsParamsSort defines parameters for GetArchivedLeads.
type GetArchivedLeadsParamsSort string

// UpdateLeadJSONBody defines parameters for UpdateLead.
type UpdateLeadJSONBody struct {
	// Channel The ID of Marketing channel this lead was created from. Provided value must be one of the channels configured for your company which you can fetch with <a href="https://developers.pipedrive.com/docs/api/v1/DealFields#getDealField" target="_blank" rel="noopener noreferrer">GET /v1/dealFields</a>.
	Channel *int `json:"channel"`

	// ChannelId The optional ID to further distinguish the Marketing channel.
	ChannelId *string `json:"channel_id"`

	// ExpectedCloseDate The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
	ExpectedCloseDate *openapi_types.Date `json:"expected_close_date"`

	// IsArchived A flag indicating whether the lead is archived or not
	IsArchived *bool `json:"is_archived,omitempty"`

	// LabelIds The IDs of the lead labels which will be associated with the lead
	LabelIds *[]openapi_types.UUID `json:"label_ids,omitempty"`

	// OrganizationId The ID of an organization which this lead will be linked to. If the organization does not exist yet, it needs to be created first. A lead always has to be linked to a person or organization or both.
	OrganizationId *int `json:"organization_id"`

	// OwnerId The ID of the user which will be the owner of the created lead. If not provided, the user making the request will be used.
	OwnerId *int `json:"owner_id,omitempty"`

	// PersonId The ID of a person which this lead will be linked to. If the person does not exist yet, it needs to be created first. A lead always has to be linked to a person or organization or both.
	PersonId *int `json:"person_id"`

	// Title The name of the lead
	Title *string `json:"title"`

	// Value The potential value of the lead represented by a JSON object: `{ "amount": 200, "currency": "EUR" }`. Both amount and currency are required.
	Value *struct {
		Amount   float32 `json:"amount"`
		Currency string  `json:"currency"`
	} `json:"value"`

	// VisibleTo The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href="https://support.pipedrive.com/en/article/visibility-groups" target="_blank" rel="noopener noreferrer">here</a>.<h4>Light / Growth and Professional plans</h4><table><tr><th style="width: 40px">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Premium / Ultimate plan</h4><table><tr><th style="width: 40px">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
	VisibleTo *UpdateLeadJSONBodyVisibleTo `json:"visible_to,omitempty"`

	// WasSeen A flag indicating whether the lead was seen by someone in the Pipedrive UI
	WasSeen *bool `json:"was_seen,omitempty"`
}

// UpdateLeadJSONBodyVisibleTo defines parameters for UpdateLead.
type UpdateLeadJSONBodyVisibleTo string

// GetTeamsParams defines parameters for GetTeams.
type GetTeamsParams struct {
	// OrderBy The field name to sort returned teams by
	OrderBy *GetTeamsParamsOrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// SkipUsers When enabled, the teams will not include IDs of member users
	SkipUsers *GetTeamsParamsSkipUsers `form:"skip_users,omitempty" json:"skip_users,omitempty"`
}

// GetTeamsParamsOrderBy defines parameters for GetTeams.
type GetTeamsParamsOrderBy string

// GetTeamsParamsSkipUsers defines parameters for GetTeams.
type GetTeamsParamsSkipUsers float32

// AddTeamJSONBody defines parameters for AddTeam.
type AddTeamJSONBody struct {
	// Description The team description
	Description *string `json:"description,omitempty"`

	// ManagerId The team manager ID
	ManagerId int `json:"manager_id"`

	// Name The team name
	Name string `json:"name"`

	// Users The list of user IDs
	Users *[]int `json:"users,omitempty"`
}

// GetUserTeamsParams defines parameters for GetUserTeams.
type GetUserTeamsParams struct {
	// OrderBy The field name to sort returned teams by
	OrderBy *GetUserTeamsParamsOrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// SkipUsers When enabled, the teams will not include IDs of member users
	SkipUsers *GetUserTeamsParamsSkipUsers `form:"skip_users,omitempty" json:"skip_users,omitempty"`
}

// GetUserTeamsParamsOrderBy defines parameters for GetUserTeams.
type GetUserTeamsParamsOrderBy string

// GetUserTeamsParamsSkipUsers defines parameters for GetUserTeams.
type GetUserTeamsParamsSkipUsers float32

// GetTeamParams defines parameters for GetTeam.
type GetTeamParams struct {
	// SkipUsers When enabled, the teams will not include IDs of member users
	SkipUsers *GetTeamParamsSkipUsers `form:"skip_users,omitempty" json:"skip_users,omitempty"`
}

// GetTeamParamsSkipUsers defines parameters for GetTeam.
type GetTeamParamsSkipUsers float32

// UpdateTeamJSONBody defines parameters for UpdateTeam.
type UpdateTeamJSONBody struct {
	// ActiveFlag Flag that indicates whether the team is active
	ActiveFlag *UpdateTeamJSONBodyActiveFlag `json:"active_flag,omitempty"`

	// DeletedFlag Flag that indicates whether the team is deleted
	DeletedFlag *UpdateTeamJSONBodyDeletedFlag `json:"deleted_flag,omitempty"`

	// Description The team description
	Description *string `json:"description,omitempty"`

	// ManagerId The team manager ID
	ManagerId *int `json:"manager_id,omitempty"`

	// Name The team name
	Name *string `json:"name,omitempty"`

	// Users The list of user IDs
	Users *[]int `json:"users,omitempty"`
}

// UpdateTeamJSONBodyActiveFlag defines parameters for UpdateTeam.
type UpdateTeamJSONBodyActiveFlag float32

// UpdateTeamJSONBodyDeletedFlag defines parameters for UpdateTeam.
type UpdateTeamJSONBodyDeletedFlag float32

// DeleteTeamUserJSONBody defines parameters for DeleteTeamUser.
type DeleteTeamUserJSONBody struct {
	// Users The list of user IDs
	Users []int `json:"users"`
}

// AddTeamUserJSONBody defines parameters for AddTeamUser.
type AddTeamUserJSONBody struct {
	// Users The list of user IDs
	Users []int `json:"users"`
}

// GetMailMessageParams defines parameters for GetMailMessage.
type GetMailMessageParams struct {
	// IncludeBody Whether to include the full message body or not. `0` = Don't include, `1` = Include.
	IncludeBody *GetMailMessageParamsIncludeBody `form:"include_body,omitempty" json:"include_body,omitempty"`
}

// GetMailMessageParamsIncludeBody defines parameters for GetMailMessage.
type GetMailMessageParamsIncludeBody float32

// GetMailThreadsParams defines parameters for GetMailThreads.
type GetMailThreadsParams struct {
	// Folder The type of folder to fetch
	Folder GetMailThreadsParamsFolder `form:"folder" json:"folder"`

	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetMailThreadsParamsFolder defines parameters for GetMailThreads.
type GetMailThreadsParamsFolder string

// UpdateMailThreadDetailsFormdataBody defines parameters for UpdateMailThreadDetails.
type UpdateMailThreadDetailsFormdataBody struct {
	// ArchivedFlag Whether this thread is archived or not. You can only archive threads that belong to Inbox folder. Archived threads will disappear from Inbox.
	ArchivedFlag *UpdateMailThreadDetailsFormdataBodyArchivedFlag `form:"archived_flag,omitempty" json:"archived_flag,omitempty"`

	// DealId The ID of the deal this thread is associated with
	DealId *int `form:"deal_id,omitempty" json:"deal_id,omitempty"`

	// LeadId The ID of the lead this thread is associated with
	LeadId *openapi_types.UUID `form:"lead_id,omitempty" json:"lead_id,omitempty"`

	// ReadFlag Whether this thread is read or unread
	ReadFlag *UpdateMailThreadDetailsFormdataBodyReadFlag `form:"read_flag,omitempty" json:"read_flag,omitempty"`

	// SharedFlag Whether this thread is shared with other users in your company
	SharedFlag *UpdateMailThreadDetailsFormdataBodySharedFlag `form:"shared_flag,omitempty" json:"shared_flag,omitempty"`
}

// UpdateMailThreadDetailsFormdataBodyArchivedFlag defines parameters for UpdateMailThreadDetails.
type UpdateMailThreadDetailsFormdataBodyArchivedFlag float32

// UpdateMailThreadDetailsFormdataBodyReadFlag defines parameters for UpdateMailThreadDetails.
type UpdateMailThreadDetailsFormdataBodyReadFlag float32

// UpdateMailThreadDetailsFormdataBodySharedFlag defines parameters for UpdateMailThreadDetails.
type UpdateMailThreadDetailsFormdataBodySharedFlag float32

// SaveUserProviderLinkJSONBody defines parameters for SaveUserProviderLink.
type SaveUserProviderLinkJSONBody struct {
	// CompanyId Pipedrive company ID
	CompanyId int `json:"company_id"`

	// MarketplaceClientId Pipedrive Marketplace client ID of the installed integration
	MarketplaceClientId string `json:"marketplace_client_id"`

	// UserId Pipedrive user ID
	UserId int `json:"user_id"`

	// UserProviderId Unique identifier linking a user to the installed integration. Generated by the integration.
	UserProviderId openapi_types.UUID `json:"user_provider_id"`
}

// GetNotesParams defines parameters for GetNotes.
type GetNotesParams struct {
	// UserId The ID of the user whose notes to fetch. If omitted, notes by all users will be returned.
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`

	// LeadId The ID of the lead which notes to fetch. If omitted, notes about all leads will be returned.
	LeadId *openapi_types.UUID `form:"lead_id,omitempty" json:"lead_id,omitempty"`

	// DealId The ID of the deal which notes to fetch. If omitted, notes about all deals will be returned.
	DealId *int `form:"deal_id,omitempty" json:"deal_id,omitempty"`

	// PersonId The ID of the person whose notes to fetch. If omitted, notes about all persons will be returned.
	PersonId *int `form:"person_id,omitempty" json:"person_id,omitempty"`

	// OrgId The ID of the organization which notes to fetch. If omitted, notes about all organizations will be returned.
	OrgId *int `form:"org_id,omitempty" json:"org_id,omitempty"`

	// ProjectId The ID of the project which notes to fetch. If omitted, notes about all projects will be returned.
	ProjectId *int `form:"project_id,omitempty" json:"project_id,omitempty"`

	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys). Supported fields: `id`, `user_id`, `deal_id`, `person_id`, `org_id`, `content`, `add_time`, `update_time`.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// StartDate The date in format of YYYY-MM-DD from which notes to fetch
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`

	// EndDate The date in format of YYYY-MM-DD until which notes to fetch to
	EndDate *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`

	// PinnedToLeadFlag If set, the results are filtered by note to lead pinning state
	PinnedToLeadFlag *GetNotesParamsPinnedToLeadFlag `form:"pinned_to_lead_flag,omitempty" json:"pinned_to_lead_flag,omitempty"`

	// PinnedToDealFlag If set, the results are filtered by note to deal pinning state
	PinnedToDealFlag *GetNotesParamsPinnedToDealFlag `form:"pinned_to_deal_flag,omitempty" json:"pinned_to_deal_flag,omitempty"`

	// PinnedToOrganizationFlag If set, the results are filtered by note to organization pinning state
	PinnedToOrganizationFlag *GetNotesParamsPinnedToOrganizationFlag `form:"pinned_to_organization_flag,omitempty" json:"pinned_to_organization_flag,omitempty"`

	// PinnedToPersonFlag If set, the results are filtered by note to person pinning state
	PinnedToPersonFlag *GetNotesParamsPinnedToPersonFlag `form:"pinned_to_person_flag,omitempty" json:"pinned_to_person_flag,omitempty"`

	// PinnedToProjectFlag If set, the results are filtered by note to project pinning state
	PinnedToProjectFlag *GetNotesParamsPinnedToProjectFlag `form:"pinned_to_project_flag,omitempty" json:"pinned_to_project_flag,omitempty"`
}

// GetNotesParamsPinnedToLeadFlag defines parameters for GetNotes.
type GetNotesParamsPinnedToLeadFlag float32

// GetNotesParamsPinnedToDealFlag defines parameters for GetNotes.
type GetNotesParamsPinnedToDealFlag float32

// GetNotesParamsPinnedToOrganizationFlag defines parameters for GetNotes.
type GetNotesParamsPinnedToOrganizationFlag float32

// GetNotesParamsPinnedToPersonFlag defines parameters for GetNotes.
type GetNotesParamsPinnedToPersonFlag float32

// GetNotesParamsPinnedToProjectFlag defines parameters for GetNotes.
type GetNotesParamsPinnedToProjectFlag float32

// AddNoteJSONBody defines parameters for AddNote.
type AddNoteJSONBody struct {
	// AddTime The optional creation date & time of the note in UTC. Can be set in the past or in the future. Format: YYYY-MM-DD HH:MM:SS
	AddTime *string `json:"add_time,omitempty"`

	// Content The content of the note in HTML format. Subject to sanitization on the back-end.
	Content string `json:"content"`

	// DealId The ID of the deal the note will be attached to. This property is required unless one of (`lead_id/person_id/org_id/project_id`) is specified.
	DealId *int `json:"deal_id,omitempty"`

	// LeadId The ID of the lead the note will be attached to. This property is required unless one of (`deal_id/person_id/org_id/project_id`) is specified.
	LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

	// OrgId The ID of the organization this note will be attached to. This property is required unless one of (`deal_id/lead_id/person_id/project_id`) is specified.
	OrgId *int `json:"org_id,omitempty"`

	// PersonId The ID of the person this note will be attached to. This property is required unless one of (`deal_id/lead_id/org_id/project_id`) is specified.
	PersonId *int `json:"person_id,omitempty"`

	// PinnedToDealFlag If set, the results are filtered by note to deal pinning state (`deal_id` is also required)
	PinnedToDealFlag *AddNoteJSONBodyPinnedToDealFlag `json:"pinned_to_deal_flag,omitempty"`

	// PinnedToLeadFlag If set, the results are filtered by note to lead pinning state (`lead_id` is also required)
	PinnedToLeadFlag *AddNoteJSONBodyPinnedToLeadFlag `json:"pinned_to_lead_flag,omitempty"`

	// PinnedToOrganizationFlag If set, the results are filtered by note to organization pinning state (`org_id` is also required)
	PinnedToOrganizationFlag *AddNoteJSONBodyPinnedToOrganizationFlag `json:"pinned_to_organization_flag,omitempty"`

	// PinnedToPersonFlag If set, the results are filtered by note to person pinning state (`person_id` is also required)
	PinnedToPersonFlag *AddNoteJSONBodyPinnedToPersonFlag `json:"pinned_to_person_flag,omitempty"`

	// PinnedToProjectFlag If set, the results are filtered by note to project pinning state (`project_id` is also required)
	PinnedToProjectFlag *AddNoteJSONBodyPinnedToProjectFlag `json:"pinned_to_project_flag,omitempty"`

	// ProjectId The ID of the project the note will be attached to. This property is required unless one of (`deal_id/lead_id/person_id/org_id`) is specified.
	ProjectId *int `json:"project_id,omitempty"`

	// UserId The ID of the user who will be marked as the author of the note. Only an admin can change the author.
	UserId               *int                   `json:"user_id,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AddNoteJSONBodyPinnedToDealFlag defines parameters for AddNote.
type AddNoteJSONBodyPinnedToDealFlag float32

// AddNoteJSONBodyPinnedToLeadFlag defines parameters for AddNote.
type AddNoteJSONBodyPinnedToLeadFlag float32

// AddNoteJSONBodyPinnedToOrganizationFlag defines parameters for AddNote.
type AddNoteJSONBodyPinnedToOrganizationFlag float32

// AddNoteJSONBodyPinnedToPersonFlag defines parameters for AddNote.
type AddNoteJSONBodyPinnedToPersonFlag float32

// AddNoteJSONBodyPinnedToProjectFlag defines parameters for AddNote.
type AddNoteJSONBodyPinnedToProjectFlag float32

// UpdateNoteJSONBody defines parameters for UpdateNote.
type UpdateNoteJSONBody struct {
	// AddTime The optional creation date & time of the note in UTC. Can be set in the past or in the future. Format: YYYY-MM-DD HH:MM:SS
	AddTime *string `json:"add_time,omitempty"`

	// Content The content of the note in HTML format. Subject to sanitization on the back-end.
	Content *string `json:"content,omitempty"`

	// DealId The ID of the deal the note will be attached to
	DealId *int `json:"deal_id,omitempty"`

	// LeadId The ID of the lead the note will be attached to
	LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

	// OrgId The ID of the organization the note will be attached to
	OrgId *int `json:"org_id,omitempty"`

	// PersonId The ID of the person the note will be attached to
	PersonId *int `json:"person_id,omitempty"`

	// PinnedToDealFlag If set, the results are filtered by note to deal pinning state (`deal_id` is also required)
	PinnedToDealFlag *UpdateNoteJSONBodyPinnedToDealFlag `json:"pinned_to_deal_flag,omitempty"`

	// PinnedToLeadFlag If set, the results are filtered by note to lead pinning state (`lead_id` is also required)
	PinnedToLeadFlag *UpdateNoteJSONBodyPinnedToLeadFlag `json:"pinned_to_lead_flag,omitempty"`

	// PinnedToOrganizationFlag If set, the results are filtered by note to organization pinning state (`org_id` is also required)
	PinnedToOrganizationFlag *UpdateNoteJSONBodyPinnedToOrganizationFlag `json:"pinned_to_organization_flag,omitempty"`

	// PinnedToPersonFlag If set, the results are filtered by note to person pinning state (`person_id` is also required)
	PinnedToPersonFlag *UpdateNoteJSONBodyPinnedToPersonFlag `json:"pinned_to_person_flag,omitempty"`

	// PinnedToProjectFlag If set, the results are filtered by note to project pinning state (`project_id` is also required)
	PinnedToProjectFlag *UpdateNoteJSONBodyPinnedToProjectFlag `json:"pinned_to_project_flag,omitempty"`

	// ProjectId The ID of the project the note will be attached to
	ProjectId *int `json:"project_id,omitempty"`

	// UserId The ID of the user who will be marked as the author of the note. Only an admin can change the author.
	UserId *int `json:"user_id,omitempty"`
}

// UpdateNoteJSONBodyPinnedToDealFlag defines parameters for UpdateNote.
type UpdateNoteJSONBodyPinnedToDealFlag float32

// UpdateNoteJSONBodyPinnedToLeadFlag defines parameters for UpdateNote.
type UpdateNoteJSONBodyPinnedToLeadFlag float32

// UpdateNoteJSONBodyPinnedToOrganizationFlag defines parameters for UpdateNote.
type UpdateNoteJSONBodyPinnedToOrganizationFlag float32

// UpdateNoteJSONBodyPinnedToPersonFlag defines parameters for UpdateNote.
type UpdateNoteJSONBodyPinnedToPersonFlag float32

// UpdateNoteJSONBodyPinnedToProjectFlag defines parameters for UpdateNote.
type UpdateNoteJSONBodyPinnedToProjectFlag float32

// GetNoteCommentsParams defines parameters for GetNoteComments.
type GetNoteCommentsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddNoteCommentJSONBody defines parameters for AddNoteComment.
type AddNoteCommentJSONBody struct {
	// Content The content of the comment in HTML format. Subject to sanitization on the back-end.
	Content string `json:"content"`
}

// UpdateCommentForNoteJSONBody defines parameters for UpdateCommentForNote.
type UpdateCommentForNoteJSONBody struct {
	// Content The content of the comment in HTML format. Subject to sanitization on the back-end.
	Content string `json:"content"`
}

// AuthorizeParams defines parameters for Authorize.
type AuthorizeParams struct {
	// ClientId The client ID provided to you by the Pipedrive Marketplace when you register your app
	ClientId string `form:"client_id" json:"client_id"`

	// RedirectUri The callback URL you provided when you registered your app. Authorization code will be sent to that URL (if it matches with the value you entered in the registration form) if a user approves the app install. Or, if a customer declines, the corresponding error will also be sent to this URL.
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`

	// State You may pass any random string as the state parameter and the same string will be returned to your app after a user authorizes access. It may be used to store the user's session ID from your app or distinguish different responses. Using state may increase security; see RFC-6749.
	State *string `form:"state,omitempty" json:"state,omitempty"`
}

// GetTokensFormdataBody defines parameters for GetTokens.
type GetTokensFormdataBody struct {
	// Code The authorization code that you received after the user confirmed app installation
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// GrantType Since you are trying to exchange an authorization code for a pair of tokens, you must use the value "authorization_code"
	GrantType *GetTokensFormdataBodyGrantType `form:"grant_type,omitempty" json:"grant_type,omitempty"`

	// RedirectUri The callback URL you provided when you registered your app
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`
}

// GetTokensParams defines parameters for GetTokens.
type GetTokensParams struct {
	// Authorization Base 64 encoded string containing the `client_id` and `client_secret` values. The header value should be `Basic <base64(client_id:client_secret)>`.
	Authorization string `json:"Authorization"`
}

// GetTokensFormdataBodyGrantType defines parameters for GetTokens.
type GetTokensFormdataBodyGrantType string

// RefreshTokensFormdataBody defines parameters for RefreshTokens.
type RefreshTokensFormdataBody struct {
	// GrantType Since you are to refresh your access_token, you must use the value "refresh_token"
	GrantType *RefreshTokensFormdataBodyGrantType `form:"grant_type,omitempty" json:"grant_type,omitempty"`

	// RefreshToken The refresh token that you received after you exchanged the authorization code
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty"`
}

// RefreshTokensParams defines parameters for RefreshTokens.
type RefreshTokensParams struct {
	// Authorization Base 64 encoded string containing the `client_id` and `client_secret` values. The header value should be `Basic <base64(client_id:client_secret)>`.
	Authorization string `json:"Authorization"`
}

// RefreshTokensFormdataBodyGrantType defines parameters for RefreshTokens.
type RefreshTokensFormdataBodyGrantType string

// DeleteOrganizationFieldsParams defines parameters for DeleteOrganizationFields.
type DeleteOrganizationFieldsParams struct {
	// Ids The comma-separated field IDs to delete
	Ids string `form:"ids" json:"ids"`
}

// GetOrganizationRelationshipsParams defines parameters for GetOrganizationRelationships.
type GetOrganizationRelationshipsParams struct {
	// OrgId The ID of the organization to get relationships for
	OrgId int `form:"org_id" json:"org_id"`
}

// AddOrganizationRelationshipJSONBody defines parameters for AddOrganizationRelationship.
type AddOrganizationRelationshipJSONBody struct {
	// OrgId The ID of the base organization for the returned calculated values
	OrgId *int `json:"org_id,omitempty"`

	// RelLinkedOrgId The linked organization in the relationship. If type is `parent`, then the linked organization is the daughter.
	RelLinkedOrgId int `json:"rel_linked_org_id"`

	// RelOwnerOrgId The owner of the relationship. If type is `parent`, then the owner is the parent and the linked organization is the daughter.
	RelOwnerOrgId int `json:"rel_owner_org_id"`

	// Type The type of organization relationship
	Type AddOrganizationRelationshipJSONBodyType `json:"type"`
}

// AddOrganizationRelationshipJSONBodyType defines parameters for AddOrganizationRelationship.
type AddOrganizationRelationshipJSONBodyType string

// GetOrganizationRelationshipParams defines parameters for GetOrganizationRelationship.
type GetOrganizationRelationshipParams struct {
	// OrgId The ID of the base organization for the returned calculated values
	OrgId *int `form:"org_id,omitempty" json:"org_id,omitempty"`
}

// UpdateOrganizationRelationshipJSONBody defines parameters for UpdateOrganizationRelationship.
type UpdateOrganizationRelationshipJSONBody struct {
	// OrgId The ID of the base organization for the returned calculated values
	OrgId *int `json:"org_id,omitempty"`

	// RelLinkedOrgId The linked organization in this relationship. If type is `parent`, then the linked organization is the daughter.
	RelLinkedOrgId *int `json:"rel_linked_org_id,omitempty"`

	// RelOwnerOrgId The owner of this relationship. If type is `parent`, then the owner is the parent and the linked organization is the daughter.
	RelOwnerOrgId *int `json:"rel_owner_org_id,omitempty"`

	// Type The type of organization relationship
	Type *UpdateOrganizationRelationshipJSONBodyType `json:"type,omitempty"`
}

// UpdateOrganizationRelationshipJSONBodyType defines parameters for UpdateOrganizationRelationship.
type UpdateOrganizationRelationshipJSONBodyType string

// DeleteOrganizationsParams defines parameters for DeleteOrganizations.
type DeleteOrganizationsParams struct {
	// Ids The comma-separated IDs that will be deleted
	Ids string `form:"ids" json:"ids"`
}

// GetOrganizationsCollectionParams defines parameters for GetOrganizationsCollection.
type GetOrganizationsCollectionParams struct {
	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Since The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field.
	Since *string `form:"since,omitempty" json:"since,omitempty"`

	// Until The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field.
	Until *string `form:"until,omitempty" json:"until,omitempty"`

	// OwnerId If supplied, only organizations owned by the given user will be returned
	OwnerId *int `form:"owner_id,omitempty" json:"owner_id,omitempty"`

	// FirstChar If supplied, only organizations whose name starts with the specified letter will be returned (case-insensitive)
	FirstChar *string `form:"first_char,omitempty" json:"first_char,omitempty"`
}

// GetOrganizationActivitiesParams defines parameters for GetOrganizationActivities.
type GetOrganizationActivitiesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Done Whether the activity is done or not. 0 = Not done, 1 = Done. If omitted returns both Done and Not done activities.
	Done *GetOrganizationActivitiesParamsDone `form:"done,omitempty" json:"done,omitempty"`

	// Exclude A comma-separated string of activity IDs to exclude from result
	Exclude *string `form:"exclude,omitempty" json:"exclude,omitempty"`
}

// GetOrganizationActivitiesParamsDone defines parameters for GetOrganizationActivities.
type GetOrganizationActivitiesParamsDone float32

// GetOrganizationChangelogParams defines parameters for GetOrganizationChangelog.
type GetOrganizationChangelogParams struct {
	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetOrganizationDealsParams defines parameters for GetOrganizationDeals.
type GetOrganizationDealsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Status Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
	Status *GetOrganizationDealsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Sort The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys).
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// OnlyPrimaryAssociation If set, only deals that are directly associated to the organization are fetched. If not set (default), all deals are fetched that are either directly or indirectly related to the organization. Indirect relations include relations through custom, organization-type fields and through persons of the given organization.
	OnlyPrimaryAssociation *GetOrganizationDealsParamsOnlyPrimaryAssociation `form:"only_primary_association,omitempty" json:"only_primary_association,omitempty"`
}

// GetOrganizationDealsParamsStatus defines parameters for GetOrganizationDeals.
type GetOrganizationDealsParamsStatus string

// GetOrganizationDealsParamsOnlyPrimaryAssociation defines parameters for GetOrganizationDeals.
type GetOrganizationDealsParamsOnlyPrimaryAssociation float32

// GetOrganizationFilesParams defines parameters for GetOrganizationFiles.
type GetOrganizationFilesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page. Please note that a maximum value of 100 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Supported fields: `id`, `update_time`
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetOrganizationUpdatesParams defines parameters for GetOrganizationUpdates.
type GetOrganizationUpdatesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// AllChanges Whether to show custom field updates or not. 1 = Include custom field changes. If omitted, returns changes without custom field updates.
	AllChanges *string `form:"all_changes,omitempty" json:"all_changes,omitempty"`

	// Items A comma-separated string for filtering out item specific updates. (Possible values - activity, plannedActivity, note, file, change, deal, follower, participant, mailMessage, mailMessageWithAttachment, invoice, activityFile, document).
	Items *string `form:"items,omitempty" json:"items,omitempty"`
}

// GetOrganizationMailMessagesParams defines parameters for GetOrganizationMailMessages.
type GetOrganizationMailMessagesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// MergeOrganizationsJSONBody defines parameters for MergeOrganizations.
type MergeOrganizationsJSONBody struct {
	// MergeWithId The ID of the organization that the organization will be merged with
	MergeWithId int `json:"merge_with_id"`
}

// GetOrganizationPersonsParams defines parameters for GetOrganizationPersons.
type GetOrganizationPersonsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPermissionSetsParams defines parameters for GetPermissionSets.
type GetPermissionSetsParams struct {
	// App The app to filter the permission sets by
	App *GetPermissionSetsParamsApp `form:"app,omitempty" json:"app,omitempty"`
}

// GetPermissionSetsParamsApp defines parameters for GetPermissionSets.
type GetPermissionSetsParamsApp string

// GetPermissionSetAssignmentsParams defines parameters for GetPermissionSetAssignments.
type GetPermissionSetAssignmentsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// DeletePersonFieldsParams defines parameters for DeletePersonFields.
type DeletePersonFieldsParams struct {
	// Ids The comma-separated field IDs to delete
	Ids string `form:"ids" json:"ids"`
}

// DeletePersonsParams defines parameters for DeletePersons.
type DeletePersonsParams struct {
	// Ids The comma-separated IDs that will be deleted
	Ids string `form:"ids" json:"ids"`
}

// GetPersonsCollectionParams defines parameters for GetPersonsCollection.
type GetPersonsCollectionParams struct {
	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Since The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field.
	Since *string `form:"since,omitempty" json:"since,omitempty"`

	// Until The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the `update_time` field.
	Until *string `form:"until,omitempty" json:"until,omitempty"`

	// OwnerId If supplied, only persons owned by the given user will be returned
	OwnerId *int `form:"owner_id,omitempty" json:"owner_id,omitempty"`

	// FirstChar If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)
	FirstChar *string `form:"first_char,omitempty" json:"first_char,omitempty"`
}

// GetPersonActivitiesParams defines parameters for GetPersonActivities.
type GetPersonActivitiesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Done Whether the activity is done or not. 0 = Not done, 1 = Done. If omitted, returns both Done and Not done activities.
	Done *GetPersonActivitiesParamsDone `form:"done,omitempty" json:"done,omitempty"`

	// Exclude A comma-separated string of activity IDs to exclude from result
	Exclude *string `form:"exclude,omitempty" json:"exclude,omitempty"`
}

// GetPersonActivitiesParamsDone defines parameters for GetPersonActivities.
type GetPersonActivitiesParamsDone float32

// GetPersonChangelogParams defines parameters for GetPersonChangelog.
type GetPersonChangelogParams struct {
	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPersonDealsParams defines parameters for GetPersonDeals.
type GetPersonDealsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Status Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
	Status *GetPersonDealsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Sort The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`). Only first-level field keys are supported (no nested keys).
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPersonDealsParamsStatus defines parameters for GetPersonDeals.
type GetPersonDealsParamsStatus string

// GetPersonFilesParams defines parameters for GetPersonFiles.
type GetPersonFilesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page. Please note that a maximum value of 100 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Supported fields: `id`, `update_time`
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPersonUpdatesParams defines parameters for GetPersonUpdates.
type GetPersonUpdatesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// AllChanges Whether to show custom field updates or not. 1 = Include custom field changes. If omitted returns changes without custom field updates.
	AllChanges *string `form:"all_changes,omitempty" json:"all_changes,omitempty"`

	// Items A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change).
	Items *string `form:"items,omitempty" json:"items,omitempty"`
}

// GetPersonMailMessagesParams defines parameters for GetPersonMailMessages.
type GetPersonMailMessagesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// MergePersonsJSONBody defines parameters for MergePersons.
type MergePersonsJSONBody struct {
	// MergeWithId The ID of the person that will not be overwritten. This persons data will be prioritized in case of conflict with the other person.
	MergeWithId int `json:"merge_with_id"`
}

// AddPersonPictureMultipartBody defines parameters for AddPersonPicture.
type AddPersonPictureMultipartBody struct {
	// CropHeight The height of the cropping area (in pixels)
	CropHeight *int `json:"crop_height,omitempty"`

	// CropWidth The width of the cropping area (in pixels)
	CropWidth *int `json:"crop_width,omitempty"`

	// CropX X coordinate to where start cropping form (in pixels)
	CropX *int `json:"crop_x,omitempty"`

	// CropY Y coordinate to where start cropping form (in pixels)
	CropY *int `json:"crop_y,omitempty"`

	// File One image supplied in the multipart/form-data encoding
	File openapi_types.File `json:"file"`
}

// GetPersonProductsParams defines parameters for GetPersonProducts.
type GetPersonProductsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPipelineConversionStatisticsParams defines parameters for GetPipelineConversionStatistics.
type GetPipelineConversionStatisticsParams struct {
	// StartDate The start of the period. Date in format of YYYY-MM-DD.
	StartDate openapi_types.Date `form:"start_date" json:"start_date"`

	// EndDate The end of the period. Date in format of YYYY-MM-DD.
	EndDate openapi_types.Date `form:"end_date" json:"end_date"`

	// UserId The ID of the user who's pipeline metrics statistics to fetch. If omitted, the authorized user will be used.
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// GetPipelineDealsParams defines parameters for GetPipelineDeals.
type GetPipelineDealsParams struct {
	// FilterId If supplied, only deals matching the given filter will be returned
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// UserId If supplied, `filter_id` will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`

	// Everyone If supplied, `filter_id` and `user_id` will not be considered  instead, deals owned by everyone will be returned
	Everyone *GetPipelineDealsParamsEveryone `form:"everyone,omitempty" json:"everyone,omitempty"`

	// StageId If supplied, only deals within the given stage will be returned
	StageId *int `form:"stage_id,omitempty" json:"stage_id,omitempty"`

	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// GetSummary Whether to include a summary of the pipeline in the `additional_data` or not
	GetSummary *GetPipelineDealsParamsGetSummary `form:"get_summary,omitempty" json:"get_summary,omitempty"`

	// TotalsConvertCurrency The 3-letter currency code of any of the supported currencies. When supplied, `per_stages_converted` is returned inside `deals_summary` inside `additional_data` which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to `default_currency` in which case users default currency is used. Only works when `get_summary` parameter flag is enabled.
	TotalsConvertCurrency *string `form:"totals_convert_currency,omitempty" json:"totals_convert_currency,omitempty"`
}

// GetPipelineDealsParamsEveryone defines parameters for GetPipelineDeals.
type GetPipelineDealsParamsEveryone float32

// GetPipelineDealsParamsGetSummary defines parameters for GetPipelineDeals.
type GetPipelineDealsParamsGetSummary float32

// GetPipelineMovementStatisticsParams defines parameters for GetPipelineMovementStatistics.
type GetPipelineMovementStatisticsParams struct {
	// StartDate The start of the period. Date in format of YYYY-MM-DD.
	StartDate openapi_types.Date `form:"start_date" json:"start_date"`

	// EndDate The end of the period. Date in format of YYYY-MM-DD.
	EndDate openapi_types.Date `form:"end_date" json:"end_date"`

	// UserId The ID of the user who's pipeline statistics to fetch. If omitted, the authorized user will be used.
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// DeleteProductFieldsParams defines parameters for DeleteProductFields.
type DeleteProductFieldsParams struct {
	// Ids The comma-separated field IDs to delete
	Ids string `form:"ids" json:"ids"`
}

// GetProductDealsParams defines parameters for GetProductDeals.
type GetProductDealsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Status Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
	Status *GetProductDealsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetProductDealsParamsStatus defines parameters for GetProductDeals.
type GetProductDealsParamsStatus string

// GetProductFilesParams defines parameters for GetProductFiles.
type GetProductFilesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page. Please note that a maximum value of 100 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Supported fields: `id`, `update_time`
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetProjectTemplatesParams defines parameters for GetProjectTemplates.
type GetProjectTemplatesParams struct {
	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, up to 500 items will be returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetProjectsParams defines parameters for GetProjects.
type GetProjectsParams struct {
	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// FilterId The ID of the filter to use
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// Status If supplied, includes only projects with the specified statuses. Possible values are `open`, `completed`, `canceled` and `deleted`. By default `deleted` projects are not returned.
	Status *string `form:"status,omitempty" json:"status,omitempty"`

	// PhaseId If supplied, only projects in specified phase are returned
	PhaseId *int `form:"phase_id,omitempty" json:"phase_id,omitempty"`

	// IncludeArchived If supplied with `true` then archived projects are also included in the response. By default only not archived projects are returned.
	IncludeArchived *bool `form:"include_archived,omitempty" json:"include_archived,omitempty"`
}

// AddProjectJSONBody defines parameters for AddProject.
type AddProjectJSONBody struct {
	// BoardId The ID of a project board
	BoardId float32 `json:"board_id"`

	// DealIds An array of IDs of the deals this project is associated with
	DealIds *[]int `json:"deal_ids,omitempty"`

	// Description The description of the project
	Description *string `json:"description,omitempty"`

	// EndDate The end date of the project. Format: YYYY-MM-DD.
	EndDate *openapi_types.Date `json:"end_date,omitempty"`

	// Labels An array of IDs of the labels this project has
	Labels *[]int `json:"labels,omitempty"`

	// OrgId The ID of the organization this project is associated with
	OrgId *float32 `json:"org_id,omitempty"`

	// OwnerId The ID of a project owner
	OwnerId *float32 `json:"owner_id,omitempty"`

	// PersonId The ID of the person this project is associated with
	PersonId *float32 `json:"person_id,omitempty"`

	// PhaseId The ID of a phase on a project board
	PhaseId float32 `json:"phase_id"`

	// StartDate The start date of the project. Format: YYYY-MM-DD.
	StartDate *openapi_types.Date `json:"start_date,omitempty"`

	// Status The status of the project
	Status *string `json:"status,omitempty"`

	// TemplateId The ID of the template the project will be based on
	TemplateId *float32 `json:"template_id,omitempty"`

	// Title The title of the project
	Title string `json:"title"`
}

// GetProjectsPhasesParams defines parameters for GetProjectsPhases.
type GetProjectsPhasesParams struct {
	// BoardId ID of the board for which phases are requested
	BoardId int `form:"board_id" json:"board_id"`
}

// UpdateProjectJSONBody defines parameters for UpdateProject.
type UpdateProjectJSONBody struct {
	// BoardId The ID of the board this project is associated with
	BoardId *float32 `json:"board_id,omitempty"`

	// DealIds An array of IDs of the deals this project is associated with
	DealIds *[]int `json:"deal_ids,omitempty"`

	// Description The description of the project
	Description *string `json:"description,omitempty"`

	// EndDate The end date of the project. Format: YYYY-MM-DD.
	EndDate *openapi_types.Date `json:"end_date,omitempty"`

	// Labels An array of IDs of the labels this project has
	Labels *[]int `json:"labels,omitempty"`

	// OrgId The ID of the organization this project is associated with
	OrgId *float32 `json:"org_id,omitempty"`

	// OwnerId The ID of a project owner
	OwnerId *float32 `json:"owner_id,omitempty"`

	// PersonId The ID of the person this project is associated with
	PersonId *float32 `json:"person_id,omitempty"`

	// PhaseId The ID of the phase this project is associated with
	PhaseId *float32 `json:"phase_id,omitempty"`

	// StartDate The start date of the project. Format: YYYY-MM-DD.
	StartDate *openapi_types.Date `json:"start_date,omitempty"`

	// Status The status of the project
	Status *string `json:"status,omitempty"`

	// Title The title of the project
	Title *string `json:"title,omitempty"`
}

// PutProjectPlanActivityJSONBody defines parameters for PutProjectPlanActivity.
type PutProjectPlanActivityJSONBody struct {
	// GroupId The ID of a group on a project board
	GroupId *float32 `json:"group_id,omitempty"`

	// PhaseId The ID of a phase on a project board
	PhaseId *float32 `json:"phase_id,omitempty"`
}

// PutProjectPlanTaskJSONBody defines parameters for PutProjectPlanTask.
type PutProjectPlanTaskJSONBody struct {
	// GroupId The ID of a group on a project board
	GroupId *float32 `json:"group_id,omitempty"`

	// PhaseId The ID of a phase on a project board
	PhaseId *float32 `json:"phase_id,omitempty"`
}

// GetRecentsParams defines parameters for GetRecents.
type GetRecentsParams struct {
	// SinceTimestamp The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS.
	SinceTimestamp string `form:"since_timestamp" json:"since_timestamp"`

	// Items Multiple selection of item types to include in the query (optional)
	Items *GetRecentsParamsItems `form:"items,omitempty" json:"items,omitempty"`

	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetRecentsParamsItems defines parameters for GetRecents.
type GetRecentsParamsItems string

// GetRolesParams defines parameters for GetRoles.
type GetRolesParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddRoleJSONBody defines parameters for AddRole.
type AddRoleJSONBody struct {
	// Name The name of the role
	Name string `json:"name"`

	// ParentRoleId The ID of the parent role
	ParentRoleId *int `json:"parent_role_id"`
}

// UpdateRoleJSONBody defines parameters for UpdateRole.
type UpdateRoleJSONBody struct {
	// Name The name of the role
	Name *string `json:"name,omitempty"`

	// ParentRoleId The ID of the parent role
	ParentRoleId *int `json:"parent_role_id"`
}

// DeleteRoleAssignmentJSONBody defines parameters for DeleteRoleAssignment.
type DeleteRoleAssignmentJSONBody struct {
	// UserId The ID of the user
	UserId int `json:"user_id"`
}

// GetRoleAssignmentsParams defines parameters for GetRoleAssignments.
type GetRoleAssignmentsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddRoleAssignmentJSONBody defines parameters for AddRoleAssignment.
type AddRoleAssignmentJSONBody struct {
	// UserId The ID of the user
	UserId int `json:"user_id"`
}

// GetRolePipelinesParams defines parameters for GetRolePipelines.
type GetRolePipelinesParams struct {
	// Visible Whether to return the visible or hidden pipelines for the role
	Visible *bool `form:"visible,omitempty" json:"visible,omitempty"`
}

// UpdateRolePipelinesJSONBody defines parameters for UpdateRolePipelines.
type UpdateRolePipelinesJSONBody struct {
	// VisiblePipelineIds The pipeline IDs to make the pipelines visible (add) and/or hidden (remove) for the specified role. It requires the following JSON structure: `{ "add": "[1]", "remove": "[3, 4]" }`.
	VisiblePipelineIds map[string]interface{} `json:"visible_pipeline_ids"`
}

// AddOrUpdateRoleSettingJSONBody defines parameters for AddOrUpdateRoleSetting.
type AddOrUpdateRoleSettingJSONBody struct {
	SettingKey AddOrUpdateRoleSettingJSONBodySettingKey `json:"setting_key"`

	// Value Possible values for the `default_visibility` setting depending on the subscription plan:<br> <table class='role-setting'> <caption><b>Light / Growth and Professional plans</b></caption> <tr><th><b>Value</b></th><th><b>Description</b></th></tr> <tr><td>`1`</td><td>Owner & Followers</td></tr> <tr><td>`3`</td><td>Entire company</td></tr> </table> <br> <table class='role-setting'> <caption><b>Premium / Ultimate plan</b></caption> <tr><th><b>Value</b></th><th><b>Description</b></th></tr> <tr><td>`1`</td><td>Owner only</td></tr> <tr><td>`3`</td><td>Owner&#39;s visibility group</td></tr> <tr><td>`5`</td><td>Owner&#39;s visibility group and sub-groups</td></tr> <tr><td>`7`</td><td>Entire company</td></tr> </table> <br> Read more about visibility groups <a href='https://support.pipedrive.com/en/article/visibility-groups'>here</a>.
	Value AddOrUpdateRoleSettingJSONBodyValue `json:"value"`
}

// AddOrUpdateRoleSettingJSONBodySettingKey defines parameters for AddOrUpdateRoleSetting.
type AddOrUpdateRoleSettingJSONBodySettingKey string

// AddOrUpdateRoleSettingJSONBodyValue defines parameters for AddOrUpdateRoleSetting.
type AddOrUpdateRoleSettingJSONBodyValue int

// DeleteStagesParams defines parameters for DeleteStages.
type DeleteStagesParams struct {
	// Ids The comma-separated stage IDs to delete
	Ids string `form:"ids" json:"ids"`
}

// GetStageDealsParams defines parameters for GetStageDeals.
type GetStageDealsParams struct {
	// FilterId If supplied, only deals matching the given filter will be returned
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// UserId If supplied, `filter_id` will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`

	// Everyone If supplied, `filter_id` and `user_id` will not be considered  instead, deals owned by everyone will be returned
	Everyone *GetStageDealsParamsEveryone `form:"everyone,omitempty" json:"everyone,omitempty"`

	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetStageDealsParamsEveryone defines parameters for GetStageDeals.
type GetStageDealsParamsEveryone float32

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {
	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, up to 500 items will be returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// AssigneeId If supplied, only tasks that are assigned to this user are returned
	AssigneeId *int `form:"assignee_id,omitempty" json:"assignee_id,omitempty"`

	// ProjectId If supplied, only tasks that are assigned to this project are returned
	ProjectId *int `form:"project_id,omitempty" json:"project_id,omitempty"`

	// ParentTaskId If `null` is supplied then only parent tasks are returned. If integer is supplied then only subtasks of a specific task are returned. By default all tasks are returned.
	ParentTaskId *int `form:"parent_task_id,omitempty" json:"parent_task_id,omitempty"`

	// Done Whether the task is done or not. `0` = Not done, `1` = Done. If not omitted then returns both done and not done tasks.
	Done *GetTasksParamsDone `form:"done,omitempty" json:"done,omitempty"`
}

// GetTasksParamsDone defines parameters for GetTasks.
type GetTasksParamsDone float32

// AddTaskJSONBody defines parameters for AddTask.
type AddTaskJSONBody struct {
	// AssigneeId The ID of the user who will be the assignee of the task
	AssigneeId *float32 `json:"assignee_id,omitempty"`

	// Description The description of the task
	Description *string `json:"description,omitempty"`

	// Done Whether the task is done or not. 0 = Not done, 1 = Done.
	Done *AddTaskJSONBodyDone `json:"done,omitempty"`

	// DueDate The due date of the task. Format: YYYY-MM-DD.
	DueDate *openapi_types.Date `json:"due_date,omitempty"`

	// ParentTaskId The ID of a parent task. Can not be ID of a task which is already a subtask.
	ParentTaskId *float32 `json:"parent_task_id,omitempty"`

	// ProjectId The ID of a project
	ProjectId float32 `json:"project_id"`

	// Title The title of the task
	Title string `json:"title"`
}

// AddTaskJSONBodyDone defines parameters for AddTask.
type AddTaskJSONBodyDone float32

// UpdateTaskJSONBody defines parameters for UpdateTask.
type UpdateTaskJSONBody struct {
	// AssigneeId The ID of the user who will be the assignee of the task
	AssigneeId *float32 `json:"assignee_id,omitempty"`

	// Description The description of the task
	Description *string `json:"description,omitempty"`

	// Done Whether the task is done or not. 0 = Not done, 1 = Done.
	Done *UpdateTaskJSONBodyDone `json:"done,omitempty"`

	// DueDate The due date of the task. Format: YYYY-MM-DD.
	DueDate *openapi_types.Date `json:"due_date,omitempty"`

	// ParentTaskId The ID of a parent task. Can not be ID of a task which is already a subtask.
	ParentTaskId *float32 `json:"parent_task_id,omitempty"`

	// ProjectId The ID of the project this task is associated with
	ProjectId *float32 `json:"project_id,omitempty"`

	// Title The title of the task
	Title *string `json:"title,omitempty"`
}

// UpdateTaskJSONBodyDone defines parameters for UpdateTask.
type UpdateTaskJSONBodyDone float32

// AddUserJSONBody defines parameters for AddUser.
type AddUserJSONBody struct {
	// Access The access given to the user. Each item in the array represents access to a specific app. Optionally may include either admin flag or permission set ID to specify which access to give within the app. If both are omitted, the default access for the corresponding app will be used. It requires structure as follows: `[{ app: 'sales', permission_set_id: '62cc4d7f-4038-4352-abf3-a8c1c822b631' }, { app: 'global', admin: true }, { app: 'account_settings' }]`
	Access *[]struct {
		Admin           *bool                    `json:"admin,omitempty"`
		App             AddUserJSONBodyAccessApp `json:"app"`
		PermissionSetId *string                  `json:"permission_set_id,omitempty"`
	} `json:"access,omitempty"`

	// ActiveFlag Whether the user is active or not. `false` = Not activated, `true` = Activated
	ActiveFlag *bool `json:"active_flag,omitempty"`

	// Email The email of the user
	Email string `json:"email"`
}

// AddUserJSONBodyAccessApp defines parameters for AddUser.
type AddUserJSONBodyAccessApp string

// FindUsersByNameParams defines parameters for FindUsersByName.
type FindUsersByNameParams struct {
	// Term The search term to look for
	Term string `form:"term" json:"term"`

	// SearchByEmail When enabled, the term will only be matched against email addresses of users. Default: `false`.
	SearchByEmail *FindUsersByNameParamsSearchByEmail `form:"search_by_email,omitempty" json:"search_by_email,omitempty"`
}

// FindUsersByNameParamsSearchByEmail defines parameters for FindUsersByName.
type FindUsersByNameParamsSearchByEmail float32

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	// ActiveFlag Whether the user is active or not. `false` = Not activated, `true` = Activated
	ActiveFlag bool `json:"active_flag"`
}

// GetUserRoleAssignmentsParams defines parameters for GetUserRoleAssignments.
type GetUserRoleAssignmentsParams struct {
	// Start Pagination start
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// Limit Items shown per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddWebhookJSONBody defines parameters for AddWebhook.
type AddWebhookJSONBody struct {
	// EventAction The type of action to receive notifications about. Wildcard will match all supported actions.
	EventAction AddWebhookJSONBodyEventAction `json:"event_action"`

	// EventObject The type of object to receive notifications about. Wildcard will match all supported objects.
	EventObject AddWebhookJSONBodyEventObject `json:"event_object"`

	// HttpAuthPassword The HTTP basic auth password of the subscription URL endpoint (if required)
	HttpAuthPassword *string `json:"http_auth_password"`

	// HttpAuthUser The HTTP basic auth username of the subscription URL endpoint (if required)
	HttpAuthUser *string `json:"http_auth_user"`

	// Name The webhook's name
	Name string `json:"name"`

	// SubscriptionUrl A full, valid, publicly accessible URL which determines where to send the notifications. Please note that you cannot use Pipedrive API endpoints as the `subscription_url` and the chosen URL must not redirect to another link.
	SubscriptionUrl string `json:"subscription_url"`

	// UserId The ID of the user that this webhook will be authorized with. You have the option to use a different user's `user_id`. If it is not set, the current user's `user_id` will be used. As each webhook event is checked against a user's permissions, the webhook will only be sent if the user has access to the specified object(s). If you want to receive notifications for all events, please use a top-level admin users `user_id`.
	UserId *int `json:"user_id,omitempty"`

	// Version The webhook's version. NB! Webhooks v2 is the default from March 17th, 2025. See <a href="https://developers.pipedrive.com/changelog/post/breaking-change-webhooks-v2-will-become-the-new-default-version" target="_blank" rel="noopener noreferrer">this Changelog post</a> for more details.
	Version *AddWebhookJSONBodyVersion `json:"version,omitempty"`
}

// AddWebhookJSONBodyEventAction defines parameters for AddWebhook.
type AddWebhookJSONBodyEventAction string

// AddWebhookJSONBodyEventObject defines parameters for AddWebhook.
type AddWebhookJSONBodyEventObject string

// AddWebhookJSONBodyVersion defines parameters for AddWebhook.
type AddWebhookJSONBodyVersion string

// AddActivityTypeJSONRequestBody defines body for AddActivityType for application/json ContentType.
type AddActivityTypeJSONRequestBody AddActivityTypeJSONBody

// UpdateActivityTypeJSONRequestBody defines body for UpdateActivityType for application/json ContentType.
type UpdateActivityTypeJSONRequestBody UpdateActivityTypeJSONBody

// AddCallLogJSONRequestBody defines body for AddCallLog for application/json ContentType.
type AddCallLogJSONRequestBody AddCallLogJSONBody

// AddCallLogAudioFileMultipartRequestBody defines body for AddCallLogAudioFile for multipart/form-data ContentType.
type AddCallLogAudioFileMultipartRequestBody AddCallLogAudioFileMultipartBody

// AddChannelJSONRequestBody defines body for AddChannel for application/json ContentType.
type AddChannelJSONRequestBody AddChannelJSONBody

// ReceiveMessageJSONRequestBody defines body for ReceiveMessage for application/json ContentType.
type ReceiveMessageJSONRequestBody ReceiveMessageJSONBody

// MergeDealsJSONRequestBody defines body for MergeDeals for application/json ContentType.
type MergeDealsJSONRequestBody MergeDealsJSONBody

// AddDealParticipantJSONRequestBody defines body for AddDealParticipant for application/json ContentType.
type AddDealParticipantJSONRequestBody AddDealParticipantJSONBody

// AddFileMultipartRequestBody defines body for AddFile for multipart/form-data ContentType.
type AddFileMultipartRequestBody AddFileMultipartBody

// AddFileAndLinkItFormdataRequestBody defines body for AddFileAndLinkIt for application/x-www-form-urlencoded ContentType.
type AddFileAndLinkItFormdataRequestBody AddFileAndLinkItFormdataBody

// LinkFileToItemFormdataRequestBody defines body for LinkFileToItem for application/x-www-form-urlencoded ContentType.
type LinkFileToItemFormdataRequestBody LinkFileToItemFormdataBody

// UpdateFileFormdataRequestBody defines body for UpdateFile for application/x-www-form-urlencoded ContentType.
type UpdateFileFormdataRequestBody UpdateFileFormdataBody

// AddFilterJSONRequestBody defines body for AddFilter for application/json ContentType.
type AddFilterJSONRequestBody AddFilterJSONBody

// UpdateFilterJSONRequestBody defines body for UpdateFilter for application/json ContentType.
type UpdateFilterJSONRequestBody UpdateFilterJSONBody

// AddGoalJSONRequestBody defines body for AddGoal for application/json ContentType.
type AddGoalJSONRequestBody AddGoalJSONBody

// UpdateGoalJSONRequestBody defines body for UpdateGoal for application/json ContentType.
type UpdateGoalJSONRequestBody UpdateGoalJSONBody

// AddLeadLabelJSONRequestBody defines body for AddLeadLabel for application/json ContentType.
type AddLeadLabelJSONRequestBody AddLeadLabelJSONBody

// UpdateLeadLabelJSONRequestBody defines body for UpdateLeadLabel for application/json ContentType.
type UpdateLeadLabelJSONRequestBody UpdateLeadLabelJSONBody

// AddLeadJSONRequestBody defines body for AddLead for application/json ContentType.
type AddLeadJSONRequestBody AddLeadJSONBody

// UpdateLeadJSONRequestBody defines body for UpdateLead for application/json ContentType.
type UpdateLeadJSONRequestBody UpdateLeadJSONBody

// AddTeamJSONRequestBody defines body for AddTeam for application/json ContentType.
type AddTeamJSONRequestBody AddTeamJSONBody

// UpdateTeamJSONRequestBody defines body for UpdateTeam for application/json ContentType.
type UpdateTeamJSONRequestBody UpdateTeamJSONBody

// DeleteTeamUserJSONRequestBody defines body for DeleteTeamUser for application/json ContentType.
type DeleteTeamUserJSONRequestBody DeleteTeamUserJSONBody

// AddTeamUserJSONRequestBody defines body for AddTeamUser for application/json ContentType.
type AddTeamUserJSONRequestBody AddTeamUserJSONBody

// UpdateMailThreadDetailsFormdataRequestBody defines body for UpdateMailThreadDetails for application/x-www-form-urlencoded ContentType.
type UpdateMailThreadDetailsFormdataRequestBody UpdateMailThreadDetailsFormdataBody

// SaveUserProviderLinkJSONRequestBody defines body for SaveUserProviderLink for application/json ContentType.
type SaveUserProviderLinkJSONRequestBody SaveUserProviderLinkJSONBody

// AddNoteJSONRequestBody defines body for AddNote for application/json ContentType.
type AddNoteJSONRequestBody AddNoteJSONBody

// UpdateNoteJSONRequestBody defines body for UpdateNote for application/json ContentType.
type UpdateNoteJSONRequestBody UpdateNoteJSONBody

// AddNoteCommentJSONRequestBody defines body for AddNoteComment for application/json ContentType.
type AddNoteCommentJSONRequestBody AddNoteCommentJSONBody

// UpdateCommentForNoteJSONRequestBody defines body for UpdateCommentForNote for application/json ContentType.
type UpdateCommentForNoteJSONRequestBody UpdateCommentForNoteJSONBody

// GetTokensFormdataRequestBody defines body for GetTokens for application/x-www-form-urlencoded ContentType.
type GetTokensFormdataRequestBody GetTokensFormdataBody

// RefreshTokensFormdataRequestBody defines body for RefreshTokens for application/x-www-form-urlencoded ContentType.
type RefreshTokensFormdataRequestBody RefreshTokensFormdataBody

// AddOrganizationRelationshipJSONRequestBody defines body for AddOrganizationRelationship for application/json ContentType.
type AddOrganizationRelationshipJSONRequestBody AddOrganizationRelationshipJSONBody

// UpdateOrganizationRelationshipJSONRequestBody defines body for UpdateOrganizationRelationship for application/json ContentType.
type UpdateOrganizationRelationshipJSONRequestBody UpdateOrganizationRelationshipJSONBody

// MergeOrganizationsJSONRequestBody defines body for MergeOrganizations for application/json ContentType.
type MergeOrganizationsJSONRequestBody MergeOrganizationsJSONBody

// MergePersonsJSONRequestBody defines body for MergePersons for application/json ContentType.
type MergePersonsJSONRequestBody MergePersonsJSONBody

// AddPersonPictureMultipartRequestBody defines body for AddPersonPicture for multipart/form-data ContentType.
type AddPersonPictureMultipartRequestBody AddPersonPictureMultipartBody

// AddProjectJSONRequestBody defines body for AddProject for application/json ContentType.
type AddProjectJSONRequestBody AddProjectJSONBody

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody UpdateProjectJSONBody

// PutProjectPlanActivityJSONRequestBody defines body for PutProjectPlanActivity for application/json ContentType.
type PutProjectPlanActivityJSONRequestBody PutProjectPlanActivityJSONBody

// PutProjectPlanTaskJSONRequestBody defines body for PutProjectPlanTask for application/json ContentType.
type PutProjectPlanTaskJSONRequestBody PutProjectPlanTaskJSONBody

// AddRoleJSONRequestBody defines body for AddRole for application/json ContentType.
type AddRoleJSONRequestBody AddRoleJSONBody

// UpdateRoleJSONRequestBody defines body for UpdateRole for application/json ContentType.
type UpdateRoleJSONRequestBody UpdateRoleJSONBody

// DeleteRoleAssignmentJSONRequestBody defines body for DeleteRoleAssignment for application/json ContentType.
type DeleteRoleAssignmentJSONRequestBody DeleteRoleAssignmentJSONBody

// AddRoleAssignmentJSONRequestBody defines body for AddRoleAssignment for application/json ContentType.
type AddRoleAssignmentJSONRequestBody AddRoleAssignmentJSONBody

// UpdateRolePipelinesJSONRequestBody defines body for UpdateRolePipelines for application/json ContentType.
type UpdateRolePipelinesJSONRequestBody UpdateRolePipelinesJSONBody

// AddOrUpdateRoleSettingJSONRequestBody defines body for AddOrUpdateRoleSetting for application/json ContentType.
type AddOrUpdateRoleSettingJSONRequestBody AddOrUpdateRoleSettingJSONBody

// AddTaskJSONRequestBody defines body for AddTask for application/json ContentType.
type AddTaskJSONRequestBody AddTaskJSONBody

// UpdateTaskJSONRequestBody defines body for UpdateTask for application/json ContentType.
type UpdateTaskJSONRequestBody UpdateTaskJSONBody

// AddUserJSONRequestBody defines body for AddUser for application/json ContentType.
type AddUserJSONRequestBody AddUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// AddWebhookJSONRequestBody defines body for AddWebhook for application/json ContentType.
type AddWebhookJSONRequestBody AddWebhookJSONBody

// Getter for additional properties for AddNoteJSONBody. Returns the specified
// element and whether it was found
func (a AddNoteJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AddNoteJSONBody
func (a *AddNoteJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AddNoteJSONBody to handle AdditionalProperties
func (a *AddNoteJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["add_time"]; found {
		err = json.Unmarshal(raw, &a.AddTime)
		if err != nil {
			return fmt.Errorf("error reading 'add_time': %w", err)
		}
		delete(object, "add_time")
	}

	if raw, found := object["content"]; found {
		err = json.Unmarshal(raw, &a.Content)
		if err != nil {
			return fmt.Errorf("error reading 'content': %w", err)
		}
		delete(object, "content")
	}

	if raw, found := object["deal_id"]; found {
		err = json.Unmarshal(raw, &a.DealId)
		if err != nil {
			return fmt.Errorf("error reading 'deal_id': %w", err)
		}
		delete(object, "deal_id")
	}

	if raw, found := object["lead_id"]; found {
		err = json.Unmarshal(raw, &a.LeadId)
		if err != nil {
			return fmt.Errorf("error reading 'lead_id': %w", err)
		}
		delete(object, "lead_id")
	}

	if raw, found := object["org_id"]; found {
		err = json.Unmarshal(raw, &a.OrgId)
		if err != nil {
			return fmt.Errorf("error reading 'org_id': %w", err)
		}
		delete(object, "org_id")
	}

	if raw, found := object["person_id"]; found {
		err = json.Unmarshal(raw, &a.PersonId)
		if err != nil {
			return fmt.Errorf("error reading 'person_id': %w", err)
		}
		delete(object, "person_id")
	}

	if raw, found := object["pinned_to_deal_flag"]; found {
		err = json.Unmarshal(raw, &a.PinnedToDealFlag)
		if err != nil {
			return fmt.Errorf("error reading 'pinned_to_deal_flag': %w", err)
		}
		delete(object, "pinned_to_deal_flag")
	}

	if raw, found := object["pinned_to_lead_flag"]; found {
		err = json.Unmarshal(raw, &a.PinnedToLeadFlag)
		if err != nil {
			return fmt.Errorf("error reading 'pinned_to_lead_flag': %w", err)
		}
		delete(object, "pinned_to_lead_flag")
	}

	if raw, found := object["pinned_to_organization_flag"]; found {
		err = json.Unmarshal(raw, &a.PinnedToOrganizationFlag)
		if err != nil {
			return fmt.Errorf("error reading 'pinned_to_organization_flag': %w", err)
		}
		delete(object, "pinned_to_organization_flag")
	}

	if raw, found := object["pinned_to_person_flag"]; found {
		err = json.Unmarshal(raw, &a.PinnedToPersonFlag)
		if err != nil {
			return fmt.Errorf("error reading 'pinned_to_person_flag': %w", err)
		}
		delete(object, "pinned_to_person_flag")
	}

	if raw, found := object["pinned_to_project_flag"]; found {
		err = json.Unmarshal(raw, &a.PinnedToProjectFlag)
		if err != nil {
			return fmt.Errorf("error reading 'pinned_to_project_flag': %w", err)
		}
		delete(object, "pinned_to_project_flag")
	}

	if raw, found := object["project_id"]; found {
		err = json.Unmarshal(raw, &a.ProjectId)
		if err != nil {
			return fmt.Errorf("error reading 'project_id': %w", err)
		}
		delete(object, "project_id")
	}

	if raw, found := object["user_id"]; found {
		err = json.Unmarshal(raw, &a.UserId)
		if err != nil {
			return fmt.Errorf("error reading 'user_id': %w", err)
		}
		delete(object, "user_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AddNoteJSONBody to handle AdditionalProperties
func (a AddNoteJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AddTime != nil {
		object["add_time"], err = json.Marshal(a.AddTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_time': %w", err)
		}
	}

	object["content"], err = json.Marshal(a.Content)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'content': %w", err)
	}

	if a.DealId != nil {
		object["deal_id"], err = json.Marshal(a.DealId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deal_id': %w", err)
		}
	}

	if a.LeadId != nil {
		object["lead_id"], err = json.Marshal(a.LeadId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lead_id': %w", err)
		}
	}

	if a.OrgId != nil {
		object["org_id"], err = json.Marshal(a.OrgId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'org_id': %w", err)
		}
	}

	if a.PersonId != nil {
		object["person_id"], err = json.Marshal(a.PersonId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'person_id': %w", err)
		}
	}

	if a.PinnedToDealFlag != nil {
		object["pinned_to_deal_flag"], err = json.Marshal(a.PinnedToDealFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pinned_to_deal_flag': %w", err)
		}
	}

	if a.PinnedToLeadFlag != nil {
		object["pinned_to_lead_flag"], err = json.Marshal(a.PinnedToLeadFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pinned_to_lead_flag': %w", err)
		}
	}

	if a.PinnedToOrganizationFlag != nil {
		object["pinned_to_organization_flag"], err = json.Marshal(a.PinnedToOrganizationFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pinned_to_organization_flag': %w", err)
		}
	}

	if a.PinnedToPersonFlag != nil {
		object["pinned_to_person_flag"], err = json.Marshal(a.PinnedToPersonFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pinned_to_person_flag': %w", err)
		}
	}

	if a.PinnedToProjectFlag != nil {
		object["pinned_to_project_flag"], err = json.Marshal(a.PinnedToProjectFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pinned_to_project_flag': %w", err)
		}
	}

	if a.ProjectId != nil {
		object["project_id"], err = json.Marshal(a.ProjectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project_id': %w", err)
		}
	}

	if a.UserId != nil {
		object["user_id"], err = json.Marshal(a.UserId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user_id': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteActivities request
	DeleteActivities(ctx context.Context, params *DeleteActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivitiesCollection request
	GetActivitiesCollection(ctx context.Context, params *GetActivitiesCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteActivityTypes request
	DeleteActivityTypes(ctx context.Context, params *DeleteActivityTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityTypes request
	GetActivityTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddActivityTypeWithBody request with any body
	AddActivityTypeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddActivityType(ctx context.Context, body AddActivityTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteActivityType request
	DeleteActivityType(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateActivityTypeWithBody request with any body
	UpdateActivityTypeWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateActivityType(ctx context.Context, id int, body UpdateActivityTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompanyAddons request
	GetCompanyAddons(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserCallLogs request
	GetUserCallLogs(ctx context.Context, params *GetUserCallLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddCallLogWithBody request with any body
	AddCallLogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddCallLog(ctx context.Context, body AddCallLogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCallLog request
	DeleteCallLog(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCallLog request
	GetCallLog(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddCallLogAudioFileWithBody request with any body
	AddCallLogAudioFileWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddChannelWithBody request with any body
	AddChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddChannel(ctx context.Context, body AddChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiveMessageWithBody request with any body
	ReceiveMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReceiveMessage(ctx context.Context, body ReceiveMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConversation request
	DeleteConversation(ctx context.Context, channelId string, conversationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteChannel request
	DeleteChannel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrencies request
	GetCurrencies(ctx context.Context, params *GetCurrenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDealFields request
	DeleteDealFields(ctx context.Context, params *DeleteDealFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDeals request
	DeleteDeals(ctx context.Context, params *DeleteDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealsCollection request
	GetDealsCollection(ctx context.Context, params *GetDealsCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealsSummary request
	GetDealsSummary(ctx context.Context, params *GetDealsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArchivedDealsSummary request
	GetArchivedDealsSummary(ctx context.Context, params *GetArchivedDealsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealsTimeline request
	GetDealsTimeline(ctx context.Context, params *GetDealsTimelineParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArchivedDealsTimeline request
	GetArchivedDealsTimeline(ctx context.Context, params *GetArchivedDealsTimelineParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealActivities request
	GetDealActivities(ctx context.Context, id int, params *GetDealActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealChangelog request
	GetDealChangelog(ctx context.Context, id int, params *GetDealChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DuplicateDeal request
	DuplicateDeal(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealFiles request
	GetDealFiles(ctx context.Context, id int, params *GetDealFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealUpdates request
	GetDealUpdates(ctx context.Context, id int, params *GetDealUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealMailMessages request
	GetDealMailMessages(ctx context.Context, id int, params *GetDealMailMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeDealsWithBody request with any body
	MergeDealsWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MergeDeals(ctx context.Context, id int, body MergeDealsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealParticipants request
	GetDealParticipants(ctx context.Context, id int, params *GetDealParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDealParticipantWithBody request with any body
	AddDealParticipantWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDealParticipant(ctx context.Context, id int, body AddDealParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDealParticipant request
	DeleteDealParticipant(ctx context.Context, id int, dealParticipantId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealParticipantsChangelog request
	GetDealParticipantsChangelog(ctx context.Context, id int, params *GetDealParticipantsChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealUsers request
	GetDealUsers(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealPersons request
	GetDealPersons(ctx context.Context, id int, params *GetDealPersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFiles request
	GetFiles(ctx context.Context, params *GetFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddFileWithBody request with any body
	AddFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddFileAndLinkItWithBody request with any body
	AddFileAndLinkItWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddFileAndLinkItWithFormdataBody(ctx context.Context, body AddFileAndLinkItFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkFileToItemWithBody request with any body
	LinkFileToItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkFileToItemWithFormdataBody(ctx context.Context, body LinkFileToItemFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFile request
	DeleteFile(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFile request
	GetFile(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFileWithBody request with any body
	UpdateFileWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFileWithFormdataBody(ctx context.Context, id int, body UpdateFileFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadFile request
	DownloadFile(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFilters request
	DeleteFilters(ctx context.Context, params *DeleteFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilters request
	GetFilters(ctx context.Context, params *GetFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddFilterWithBody request with any body
	AddFilterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddFilter(ctx context.Context, body AddFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilterHelpers request
	GetFilterHelpers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFilter request
	DeleteFilter(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilter request
	GetFilter(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFilterWithBody request with any body
	UpdateFilterWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFilter(ctx context.Context, id int, body UpdateFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddGoalWithBody request with any body
	AddGoalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddGoal(ctx context.Context, body AddGoalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGoals request
	GetGoals(ctx context.Context, params *GetGoalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGoal request
	DeleteGoal(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGoalWithBody request with any body
	UpdateGoalWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGoal(ctx context.Context, id string, body UpdateGoalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGoalResult request
	GetGoalResult(ctx context.Context, id string, params *GetGoalResultParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeadFields request
	GetLeadFields(ctx context.Context, params *GetLeadFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeadLabels request
	GetLeadLabels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddLeadLabelWithBody request with any body
	AddLeadLabelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddLeadLabel(ctx context.Context, body AddLeadLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLeadLabel request
	DeleteLeadLabel(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLeadLabelWithBody request with any body
	UpdateLeadLabelWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLeadLabel(ctx context.Context, id openapi_types.UUID, body UpdateLeadLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeadSources request
	GetLeadSources(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeads request
	GetLeads(ctx context.Context, params *GetLeadsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddLeadWithBody request with any body
	AddLeadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddLead(ctx context.Context, body AddLeadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArchivedLeads request
	GetArchivedLeads(ctx context.Context, params *GetArchivedLeadsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLead request
	DeleteLead(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLead request
	GetLead(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLeadWithBody request with any body
	UpdateLeadWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLead(ctx context.Context, id openapi_types.UUID, body UpdateLeadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeadUsers request
	GetLeadUsers(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeams request
	GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTeamWithBody request with any body
	AddTeamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTeam(ctx context.Context, body AddTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserTeams request
	GetUserTeams(ctx context.Context, id int, params *GetUserTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeam request
	GetTeam(ctx context.Context, id int, params *GetTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTeamWithBody request with any body
	UpdateTeamWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTeam(ctx context.Context, id int, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamUserWithBody request with any body
	DeleteTeamUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTeamUser(ctx context.Context, id int, body DeleteTeamUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamUsers request
	GetTeamUsers(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTeamUserWithBody request with any body
	AddTeamUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTeamUser(ctx context.Context, id int, body AddTeamUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailMessage request
	GetMailMessage(ctx context.Context, id int, params *GetMailMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailThreads request
	GetMailThreads(ctx context.Context, params *GetMailThreadsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMailThread request
	DeleteMailThread(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailThread request
	GetMailThread(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMailThreadDetailsWithBody request with any body
	UpdateMailThreadDetailsWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMailThreadDetailsWithFormdataBody(ctx context.Context, id int, body UpdateMailThreadDetailsFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailThreadMessages request
	GetMailThreadMessages(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveUserProviderLinkWithBody request with any body
	SaveUserProviderLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveUserProviderLink(ctx context.Context, body SaveUserProviderLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserProviderLink request
	DeleteUserProviderLink(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNoteFields request
	GetNoteFields(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotes request
	GetNotes(ctx context.Context, params *GetNotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddNoteWithBody request with any body
	AddNoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddNote(ctx context.Context, body AddNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNote request
	DeleteNote(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNote request
	GetNote(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNoteWithBody request with any body
	UpdateNoteWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNote(ctx context.Context, id int, body UpdateNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNoteComments request
	GetNoteComments(ctx context.Context, id int, params *GetNoteCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddNoteCommentWithBody request with any body
	AddNoteCommentWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddNoteComment(ctx context.Context, id int, body AddNoteCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteComment request
	DeleteComment(ctx context.Context, id int, commentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComment request
	GetComment(ctx context.Context, id int, commentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCommentForNoteWithBody request with any body
	UpdateCommentForNoteWithBody(ctx context.Context, id int, commentId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCommentForNote(ctx context.Context, id int, commentId openapi_types.UUID, body UpdateCommentForNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Authorize request
	Authorize(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokensWithBody request with any body
	GetTokensWithBody(ctx context.Context, params *GetTokensParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetTokensWithFormdataBody(ctx context.Context, params *GetTokensParams, body GetTokensFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshTokensWithBody request with any body
	RefreshTokensWithBody(ctx context.Context, params *RefreshTokensParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefreshTokensWithFormdataBody(ctx context.Context, params *RefreshTokensParams, body RefreshTokensFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationFields request
	DeleteOrganizationFields(ctx context.Context, params *DeleteOrganizationFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationRelationships request
	GetOrganizationRelationships(ctx context.Context, params *GetOrganizationRelationshipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationRelationshipWithBody request with any body
	AddOrganizationRelationshipWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrganizationRelationship(ctx context.Context, body AddOrganizationRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationRelationship request
	DeleteOrganizationRelationship(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationRelationship request
	GetOrganizationRelationship(ctx context.Context, id int, params *GetOrganizationRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrganizationRelationshipWithBody request with any body
	UpdateOrganizationRelationshipWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrganizationRelationship(ctx context.Context, id int, body UpdateOrganizationRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizations request
	DeleteOrganizations(ctx context.Context, params *DeleteOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationsCollection request
	GetOrganizationsCollection(ctx context.Context, params *GetOrganizationsCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationActivities request
	GetOrganizationActivities(ctx context.Context, id int, params *GetOrganizationActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationChangelog request
	GetOrganizationChangelog(ctx context.Context, id int, params *GetOrganizationChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationDeals request
	GetOrganizationDeals(ctx context.Context, id int, params *GetOrganizationDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationFiles request
	GetOrganizationFiles(ctx context.Context, id int, params *GetOrganizationFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationUpdates request
	GetOrganizationUpdates(ctx context.Context, id int, params *GetOrganizationUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationMailMessages request
	GetOrganizationMailMessages(ctx context.Context, id int, params *GetOrganizationMailMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeOrganizationsWithBody request with any body
	MergeOrganizationsWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MergeOrganizations(ctx context.Context, id int, body MergeOrganizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationUsers request
	GetOrganizationUsers(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationPersons request
	GetOrganizationPersons(ctx context.Context, id int, params *GetOrganizationPersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionSets request
	GetPermissionSets(ctx context.Context, params *GetPermissionSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionSet request
	GetPermissionSet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionSetAssignments request
	GetPermissionSetAssignments(ctx context.Context, id string, params *GetPermissionSetAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersonFields request
	DeletePersonFields(ctx context.Context, params *DeletePersonFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersons request
	DeletePersons(ctx context.Context, params *DeletePersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonsCollection request
	GetPersonsCollection(ctx context.Context, params *GetPersonsCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonActivities request
	GetPersonActivities(ctx context.Context, id int, params *GetPersonActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonChangelog request
	GetPersonChangelog(ctx context.Context, id int, params *GetPersonChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonDeals request
	GetPersonDeals(ctx context.Context, id int, params *GetPersonDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonFiles request
	GetPersonFiles(ctx context.Context, id int, params *GetPersonFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonUpdates request
	GetPersonUpdates(ctx context.Context, id int, params *GetPersonUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonMailMessages request
	GetPersonMailMessages(ctx context.Context, id int, params *GetPersonMailMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergePersonsWithBody request with any body
	MergePersonsWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MergePersons(ctx context.Context, id int, body MergePersonsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonUsers request
	GetPersonUsers(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersonPicture request
	DeletePersonPicture(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPersonPictureWithBody request with any body
	AddPersonPictureWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonProducts request
	GetPersonProducts(ctx context.Context, id int, params *GetPersonProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelineConversionStatistics request
	GetPipelineConversionStatistics(ctx context.Context, id int, params *GetPipelineConversionStatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelineDeals request
	GetPipelineDeals(ctx context.Context, id int, params *GetPipelineDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelineMovementStatistics request
	GetPipelineMovementStatistics(ctx context.Context, id int, params *GetPipelineMovementStatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductFields request
	DeleteProductFields(ctx context.Context, params *DeleteProductFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductDeals request
	GetProductDeals(ctx context.Context, id int, params *GetProductDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductFiles request
	GetProductFiles(ctx context.Context, id int, params *GetProductFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductUsers request
	GetProductUsers(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectTemplates request
	GetProjectTemplates(ctx context.Context, params *GetProjectTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectTemplate request
	GetProjectTemplate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjects request
	GetProjects(ctx context.Context, params *GetProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddProjectWithBody request with any body
	AddProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddProject(ctx context.Context, body AddProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectsBoards request
	GetProjectsBoards(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectsBoard request
	GetProjectsBoard(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectsPhases request
	GetProjectsPhases(ctx context.Context, params *GetProjectsPhasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectsPhase request
	GetProjectsPhase(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProject request
	DeleteProject(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProject request
	GetProject(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectWithBody request with any body
	UpdateProjectWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProject(ctx context.Context, id int, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectActivities request
	GetProjectActivities(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveProject request
	ArchiveProject(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectGroups request
	GetProjectGroups(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectPlan request
	GetProjectPlan(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutProjectPlanActivityWithBody request with any body
	PutProjectPlanActivityWithBody(ctx context.Context, id int, activityId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutProjectPlanActivity(ctx context.Context, id int, activityId int, body PutProjectPlanActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutProjectPlanTaskWithBody request with any body
	PutProjectPlanTaskWithBody(ctx context.Context, id int, taskId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutProjectPlanTask(ctx context.Context, id int, taskId int, body PutProjectPlanTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectTasks request
	GetProjectTasks(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecents request
	GetRecents(ctx context.Context, params *GetRecentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoles request
	GetRoles(ctx context.Context, params *GetRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRoleWithBody request with any body
	AddRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRole(ctx context.Context, body AddRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRole request
	DeleteRole(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoleWithBody request with any body
	UpdateRoleWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRole(ctx context.Context, id int, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRoleAssignmentWithBody request with any body
	DeleteRoleAssignmentWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRoleAssignment(ctx context.Context, id int, body DeleteRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoleAssignments request
	GetRoleAssignments(ctx context.Context, id int, params *GetRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRoleAssignmentWithBody request with any body
	AddRoleAssignmentWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRoleAssignment(ctx context.Context, id int, body AddRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRolePipelines request
	GetRolePipelines(ctx context.Context, id int, params *GetRolePipelinesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRolePipelinesWithBody request with any body
	UpdateRolePipelinesWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRolePipelines(ctx context.Context, id int, body UpdateRolePipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoleSettings request
	GetRoleSettings(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrUpdateRoleSettingWithBody request with any body
	AddOrUpdateRoleSettingWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrUpdateRoleSetting(ctx context.Context, id int, body AddOrUpdateRoleSettingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStages request
	DeleteStages(ctx context.Context, params *DeleteStagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStageDeals request
	GetStageDeals(ctx context.Context, id int, params *GetStageDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTasks request
	GetTasks(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTaskWithBody request with any body
	AddTaskWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTask(ctx context.Context, body AddTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTask request
	DeleteTask(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTask request
	GetTask(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTaskWithBody request with any body
	UpdateTaskWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTask(ctx context.Context, id int, body UpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserConnections request
	GetUserConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserSettings request
	GetUserSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserWithBody request with any body
	AddUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUser(ctx context.Context, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindUsersByName request
	FindUsersByName(ctx context.Context, params *FindUsersByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserPermissions request
	GetUserPermissions(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserRoleAssignments request
	GetUserRoleAssignments(ctx context.Context, id int, params *GetUserRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserRoleSettings request
	GetUserRoleSettings(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhooks request
	GetWebhooks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddWebhookWithBody request with any body
	AddWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddWebhook(ctx context.Context, body AddWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhook request
	DeleteWebhook(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteActivities(ctx context.Context, params *DeleteActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteActivitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivitiesCollection(ctx context.Context, params *GetActivitiesCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivitiesCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteActivityTypes(ctx context.Context, params *DeleteActivityTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteActivityTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddActivityTypeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddActivityTypeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddActivityType(ctx context.Context, body AddActivityTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddActivityTypeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteActivityType(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteActivityTypeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateActivityTypeWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateActivityTypeRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateActivityType(ctx context.Context, id int, body UpdateActivityTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateActivityTypeRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompanyAddons(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompanyAddonsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserCallLogs(ctx context.Context, params *GetUserCallLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserCallLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCallLogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCallLogRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCallLog(ctx context.Context, body AddCallLogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCallLogRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCallLog(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCallLogRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCallLog(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCallLogRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCallLogAudioFileWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCallLogAudioFileRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddChannelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddChannel(ctx context.Context, body AddChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddChannelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiveMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiveMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiveMessage(ctx context.Context, body ReceiveMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiveMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConversation(ctx context.Context, channelId string, conversationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConversationRequest(c.Server, channelId, conversationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteChannel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteChannelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrencies(ctx context.Context, params *GetCurrenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrenciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDealFields(ctx context.Context, params *DeleteDealFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDealFieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDeals(ctx context.Context, params *DeleteDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDealsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealsCollection(ctx context.Context, params *GetDealsCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealsCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealsSummary(ctx context.Context, params *GetDealsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealsSummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArchivedDealsSummary(ctx context.Context, params *GetArchivedDealsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArchivedDealsSummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealsTimeline(ctx context.Context, params *GetDealsTimelineParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealsTimelineRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArchivedDealsTimeline(ctx context.Context, params *GetArchivedDealsTimelineParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArchivedDealsTimelineRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealActivities(ctx context.Context, id int, params *GetDealActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealActivitiesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealChangelog(ctx context.Context, id int, params *GetDealChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealChangelogRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuplicateDeal(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuplicateDealRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealFiles(ctx context.Context, id int, params *GetDealFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealFilesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealUpdates(ctx context.Context, id int, params *GetDealUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealUpdatesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealMailMessages(ctx context.Context, id int, params *GetDealMailMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealMailMessagesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeDealsWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeDealsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeDeals(ctx context.Context, id int, body MergeDealsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeDealsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealParticipants(ctx context.Context, id int, params *GetDealParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealParticipantsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDealParticipantWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDealParticipantRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDealParticipant(ctx context.Context, id int, body AddDealParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDealParticipantRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDealParticipant(ctx context.Context, id int, dealParticipantId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDealParticipantRequest(c.Server, id, dealParticipantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealParticipantsChangelog(ctx context.Context, id int, params *GetDealParticipantsChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealParticipantsChangelogRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealUsers(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealUsersRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealPersons(ctx context.Context, id int, params *GetDealPersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealPersonsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFiles(ctx context.Context, params *GetFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddFileAndLinkItWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddFileAndLinkItRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddFileAndLinkItWithFormdataBody(ctx context.Context, body AddFileAndLinkItFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddFileAndLinkItRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkFileToItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkFileToItemRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkFileToItemWithFormdataBody(ctx context.Context, body LinkFileToItemFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkFileToItemRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFile(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFile(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFileWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFileRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFileWithFormdataBody(ctx context.Context, id int, body UpdateFileFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFileRequestWithFormdataBody(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadFile(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadFileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFilters(ctx context.Context, params *DeleteFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFiltersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilters(ctx context.Context, params *GetFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFiltersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddFilterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddFilterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddFilter(ctx context.Context, body AddFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddFilterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilterHelpers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterHelpersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFilter(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFilterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilter(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFilterWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFilterRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFilter(ctx context.Context, id int, body UpdateFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFilterRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGoalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGoalRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGoal(ctx context.Context, body AddGoalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGoalRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGoals(ctx context.Context, params *GetGoalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGoalsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGoal(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGoalRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGoalWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGoalRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGoal(ctx context.Context, id string, body UpdateGoalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGoalRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGoalResult(ctx context.Context, id string, params *GetGoalResultParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGoalResultRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLeadFields(ctx context.Context, params *GetLeadFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeadFieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLeadLabels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeadLabelsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddLeadLabelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddLeadLabelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddLeadLabel(ctx context.Context, body AddLeadLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddLeadLabelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLeadLabel(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLeadLabelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLeadLabelWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLeadLabelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLeadLabel(ctx context.Context, id openapi_types.UUID, body UpdateLeadLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLeadLabelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLeadSources(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeadSourcesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLeads(ctx context.Context, params *GetLeadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeadsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddLeadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddLeadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddLead(ctx context.Context, body AddLeadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddLeadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArchivedLeads(ctx context.Context, params *GetArchivedLeadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArchivedLeadsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLead(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLeadRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLead(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeadRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLeadWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLeadRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLead(ctx context.Context, id openapi_types.UUID, body UpdateLeadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLeadRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLeadUsers(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeadUsersRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeam(ctx context.Context, body AddTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserTeams(ctx context.Context, id int, params *GetUserTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserTeamsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeam(ctx context.Context, id int, params *GetTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeam(ctx context.Context, id int, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamUserRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamUser(ctx context.Context, id int, body DeleteTeamUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamUserRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamUsers(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamUsersRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeamUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamUserRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeamUser(ctx context.Context, id int, body AddTeamUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamUserRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailMessage(ctx context.Context, id int, params *GetMailMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailMessageRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailThreads(ctx context.Context, params *GetMailThreadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailThreadsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMailThread(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMailThreadRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailThread(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailThreadRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMailThreadDetailsWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMailThreadDetailsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMailThreadDetailsWithFormdataBody(ctx context.Context, id int, body UpdateMailThreadDetailsFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMailThreadDetailsRequestWithFormdataBody(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailThreadMessages(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailThreadMessagesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserProviderLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserProviderLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserProviderLink(ctx context.Context, body SaveUserProviderLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserProviderLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserProviderLink(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserProviderLinkRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNoteFields(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNoteFieldsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotes(ctx context.Context, params *GetNotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddNoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddNoteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddNote(ctx context.Context, body AddNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddNoteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNote(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNoteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNote(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNoteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNoteWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNoteRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNote(ctx context.Context, id int, body UpdateNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNoteRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNoteComments(ctx context.Context, id int, params *GetNoteCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNoteCommentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddNoteCommentWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddNoteCommentRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddNoteComment(ctx context.Context, id int, body AddNoteCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddNoteCommentRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteComment(ctx context.Context, id int, commentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommentRequest(c.Server, id, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComment(ctx context.Context, id int, commentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommentRequest(c.Server, id, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCommentForNoteWithBody(ctx context.Context, id int, commentId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommentForNoteRequestWithBody(c.Server, id, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCommentForNote(ctx context.Context, id int, commentId openapi_types.UUID, body UpdateCommentForNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommentForNoteRequest(c.Server, id, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Authorize(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokensWithBody(ctx context.Context, params *GetTokensParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokensRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokensWithFormdataBody(ctx context.Context, params *GetTokensParams, body GetTokensFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokensRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshTokensWithBody(ctx context.Context, params *RefreshTokensParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokensRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshTokensWithFormdataBody(ctx context.Context, params *RefreshTokensParams, body RefreshTokensFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokensRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationFields(ctx context.Context, params *DeleteOrganizationFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationFieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationRelationships(ctx context.Context, params *GetOrganizationRelationshipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRelationshipsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationRelationshipWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRelationshipRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationRelationship(ctx context.Context, body AddOrganizationRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRelationshipRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationRelationship(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationRelationshipRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationRelationship(ctx context.Context, id int, params *GetOrganizationRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRelationshipRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationRelationshipWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationRelationship(ctx context.Context, id int, body UpdateOrganizationRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizations(ctx context.Context, params *DeleteOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationsCollection(ctx context.Context, params *GetOrganizationsCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationsCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationActivities(ctx context.Context, id int, params *GetOrganizationActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationActivitiesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationChangelog(ctx context.Context, id int, params *GetOrganizationChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationChangelogRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationDeals(ctx context.Context, id int, params *GetOrganizationDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationDealsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationFiles(ctx context.Context, id int, params *GetOrganizationFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationFilesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationUpdates(ctx context.Context, id int, params *GetOrganizationUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationUpdatesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationMailMessages(ctx context.Context, id int, params *GetOrganizationMailMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationMailMessagesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeOrganizationsWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeOrganizationsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeOrganizations(ctx context.Context, id int, body MergeOrganizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeOrganizationsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationUsers(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationUsersRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationPersons(ctx context.Context, id int, params *GetOrganizationPersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationPersonsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionSets(ctx context.Context, params *GetPermissionSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionSetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionSet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionSetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionSetAssignments(ctx context.Context, id string, params *GetPermissionSetAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionSetAssignmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersonFields(ctx context.Context, params *DeletePersonFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersonFieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersons(ctx context.Context, params *DeletePersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonsCollection(ctx context.Context, params *GetPersonsCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonsCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonActivities(ctx context.Context, id int, params *GetPersonActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonActivitiesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonChangelog(ctx context.Context, id int, params *GetPersonChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonChangelogRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonDeals(ctx context.Context, id int, params *GetPersonDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonDealsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonFiles(ctx context.Context, id int, params *GetPersonFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonFilesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonUpdates(ctx context.Context, id int, params *GetPersonUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonUpdatesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonMailMessages(ctx context.Context, id int, params *GetPersonMailMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonMailMessagesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergePersonsWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergePersonsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergePersons(ctx context.Context, id int, body MergePersonsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergePersonsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonUsers(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonUsersRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersonPicture(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersonPictureRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPersonPictureWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPersonPictureRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonProducts(ctx context.Context, id int, params *GetPersonProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonProductsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelineConversionStatistics(ctx context.Context, id int, params *GetPipelineConversionStatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineConversionStatisticsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelineDeals(ctx context.Context, id int, params *GetPipelineDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineDealsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelineMovementStatistics(ctx context.Context, id int, params *GetPipelineMovementStatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineMovementStatisticsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductFields(ctx context.Context, params *DeleteProductFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductFieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductDeals(ctx context.Context, id int, params *GetProductDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductDealsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductFiles(ctx context.Context, id int, params *GetProductFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductFilesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductUsers(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductUsersRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectTemplates(ctx context.Context, params *GetProjectTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectTemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectTemplate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectTemplateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjects(ctx context.Context, params *GetProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProject(ctx context.Context, body AddProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectsBoards(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectsBoardsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectsBoard(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectsBoardRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectsPhases(ctx context.Context, params *GetProjectsPhasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectsPhasesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectsPhase(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectsPhaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProject(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProject(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProject(ctx context.Context, id int, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectActivities(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectActivitiesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveProject(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveProjectRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectGroups(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectGroupsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectPlan(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectPlanRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutProjectPlanActivityWithBody(ctx context.Context, id int, activityId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutProjectPlanActivityRequestWithBody(c.Server, id, activityId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutProjectPlanActivity(ctx context.Context, id int, activityId int, body PutProjectPlanActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutProjectPlanActivityRequest(c.Server, id, activityId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutProjectPlanTaskWithBody(ctx context.Context, id int, taskId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutProjectPlanTaskRequestWithBody(c.Server, id, taskId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutProjectPlanTask(ctx context.Context, id int, taskId int, body PutProjectPlanTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutProjectPlanTaskRequest(c.Server, id, taskId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectTasks(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectTasksRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecents(ctx context.Context, params *GetRecentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoles(ctx context.Context, params *GetRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRole(ctx context.Context, body AddRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRole(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRole(ctx context.Context, id int, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoleAssignmentWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleAssignmentRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoleAssignment(ctx context.Context, id int, body DeleteRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleAssignmentRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoleAssignments(ctx context.Context, id int, params *GetRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleAssignmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRoleAssignmentWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRoleAssignmentRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRoleAssignment(ctx context.Context, id int, body AddRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRoleAssignmentRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolePipelines(ctx context.Context, id int, params *GetRolePipelinesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolePipelinesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRolePipelinesWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRolePipelinesRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRolePipelines(ctx context.Context, id int, body UpdateRolePipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRolePipelinesRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoleSettings(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleSettingsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateRoleSettingWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateRoleSettingRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateRoleSetting(ctx context.Context, id int, body AddOrUpdateRoleSettingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateRoleSettingRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStages(ctx context.Context, params *DeleteStagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStageDeals(ctx context.Context, id int, params *GetStageDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStageDealsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTasks(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTaskWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTaskRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTask(ctx context.Context, body AddTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTaskRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTask(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTask(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTaskWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTaskRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTask(ctx context.Context, id int, body UpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTaskRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserConnectionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUser(ctx context.Context, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindUsersByName(ctx context.Context, params *FindUsersByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindUsersByNameRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserPermissions(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserPermissionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserRoleAssignments(ctx context.Context, id int, params *GetUserRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRoleAssignmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserRoleSettings(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRoleSettingsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhooks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhooksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddWebhookRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddWebhook(ctx context.Context, body AddWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddWebhookRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhook(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteActivitiesRequest generates requests for DeleteActivities
func NewDeleteActivitiesRequest(server string, params *DeleteActivitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivitiesCollectionRequest generates requests for GetActivitiesCollection
func NewGetActivitiesCollectionRequest(server string, params *GetActivitiesCollectionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/collection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Done != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "done", runtime.ParamLocationQuery, *params.Done); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteActivityTypesRequest generates requests for DeleteActivityTypes
func NewDeleteActivityTypesRequest(server string, params *DeleteActivityTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activityTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivityTypesRequest generates requests for GetActivityTypes
func NewGetActivityTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activityTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddActivityTypeRequest calls the generic AddActivityType builder with application/json body
func NewAddActivityTypeRequest(server string, body AddActivityTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddActivityTypeRequestWithBody(server, "application/json", bodyReader)
}

// NewAddActivityTypeRequestWithBody generates requests for AddActivityType with any type of body
func NewAddActivityTypeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activityTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteActivityTypeRequest generates requests for DeleteActivityType
func NewDeleteActivityTypeRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activityTypes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateActivityTypeRequest calls the generic UpdateActivityType builder with application/json body
func NewUpdateActivityTypeRequest(server string, id int, body UpdateActivityTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateActivityTypeRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateActivityTypeRequestWithBody generates requests for UpdateActivityType with any type of body
func NewUpdateActivityTypeRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activityTypes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCompanyAddonsRequest generates requests for GetCompanyAddons
func NewGetCompanyAddonsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/billing/subscriptions/addons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserCallLogsRequest generates requests for GetUserCallLogs
func NewGetUserCallLogsRequest(server string, params *GetUserCallLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/callLogs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddCallLogRequest calls the generic AddCallLog builder with application/json body
func NewAddCallLogRequest(server string, body AddCallLogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddCallLogRequestWithBody(server, "application/json", bodyReader)
}

// NewAddCallLogRequestWithBody generates requests for AddCallLog with any type of body
func NewAddCallLogRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/callLogs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCallLogRequest generates requests for DeleteCallLog
func NewDeleteCallLogRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/callLogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCallLogRequest generates requests for GetCallLog
func NewGetCallLogRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/callLogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddCallLogAudioFileRequestWithBody generates requests for AddCallLogAudioFile with any type of body
func NewAddCallLogAudioFileRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/callLogs/%s/recordings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddChannelRequest calls the generic AddChannel builder with application/json body
func NewAddChannelRequest(server string, body AddChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddChannelRequestWithBody(server, "application/json", bodyReader)
}

// NewAddChannelRequestWithBody generates requests for AddChannel with any type of body
func NewAddChannelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReceiveMessageRequest calls the generic ReceiveMessage builder with application/json body
func NewReceiveMessageRequest(server string, body ReceiveMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReceiveMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewReceiveMessageRequestWithBody generates requests for ReceiveMessage with any type of body
func NewReceiveMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/messages/receive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteConversationRequest generates requests for DeleteConversation
func NewDeleteConversationRequest(server string, channelId string, conversationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel-id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "conversation-id", runtime.ParamLocationPath, conversationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/%s/conversations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteChannelRequest generates requests for DeleteChannel
func NewDeleteChannelRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrenciesRequest generates requests for GetCurrencies
func NewGetCurrenciesRequest(server string, params *GetCurrenciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/currencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Term != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "term", runtime.ParamLocationQuery, *params.Term); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDealFieldsRequest generates requests for DeleteDealFields
func NewDeleteDealFieldsRequest(server string, params *DeleteDealFieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dealFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDealsRequest generates requests for DeleteDeals
func NewDeleteDealsRequest(server string, params *DeleteDealsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealsCollectionRequest generates requests for GetDealsCollection
func NewGetDealsCollectionRequest(server string, params *GetDealsCollectionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/collection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stage_id", runtime.ParamLocationQuery, *params.StageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealsSummaryRequest generates requests for GetDealsSummary
func NewGetDealsSummaryRequest(server string, params *GetDealsSummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PipelineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pipeline_id", runtime.ParamLocationQuery, *params.PipelineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stage_id", runtime.ParamLocationQuery, *params.StageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArchivedDealsSummaryRequest generates requests for GetArchivedDealsSummary
func NewGetArchivedDealsSummaryRequest(server string, params *GetArchivedDealsSummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/summary/archived")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PipelineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pipeline_id", runtime.ParamLocationQuery, *params.PipelineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stage_id", runtime.ParamLocationQuery, *params.StageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealsTimelineRequest generates requests for GetDealsTimeline
func NewGetDealsTimelineRequest(server string, params *GetDealsTimelineParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/timeline")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, params.Interval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "field_key", runtime.ParamLocationQuery, params.FieldKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PipelineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pipeline_id", runtime.ParamLocationQuery, *params.PipelineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeDeals != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_deals", runtime.ParamLocationQuery, *params.ExcludeDeals); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalsConvertCurrency != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "totals_convert_currency", runtime.ParamLocationQuery, *params.TotalsConvertCurrency); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArchivedDealsTimelineRequest generates requests for GetArchivedDealsTimeline
func NewGetArchivedDealsTimelineRequest(server string, params *GetArchivedDealsTimelineParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/timeline/archived")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, params.Interval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "field_key", runtime.ParamLocationQuery, params.FieldKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PipelineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pipeline_id", runtime.ParamLocationQuery, *params.PipelineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeDeals != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_deals", runtime.ParamLocationQuery, *params.ExcludeDeals); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalsConvertCurrency != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "totals_convert_currency", runtime.ParamLocationQuery, *params.TotalsConvertCurrency); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealActivitiesRequest generates requests for GetDealActivities
func NewGetDealActivitiesRequest(server string, id int, params *GetDealActivitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/activities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Done != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "done", runtime.ParamLocationQuery, *params.Done); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Exclude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealChangelogRequest generates requests for GetDealChangelog
func NewGetDealChangelogRequest(server string, id int, params *GetDealChangelogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/changelog", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDuplicateDealRequest generates requests for DuplicateDeal
func NewDuplicateDealRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/duplicate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealFilesRequest generates requests for GetDealFiles
func NewGetDealFilesRequest(server string, id int, params *GetDealFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealUpdatesRequest generates requests for GetDealUpdates
func NewGetDealUpdatesRequest(server string, id int, params *GetDealUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/flow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllChanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_changes", runtime.ParamLocationQuery, *params.AllChanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Items != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "items", runtime.ParamLocationQuery, *params.Items); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealMailMessagesRequest generates requests for GetDealMailMessages
func NewGetDealMailMessagesRequest(server string, id int, params *GetDealMailMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/mailMessages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMergeDealsRequest calls the generic MergeDeals builder with application/json body
func NewMergeDealsRequest(server string, id int, body MergeDealsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeDealsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewMergeDealsRequestWithBody generates requests for MergeDeals with any type of body
func NewMergeDealsRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/merge", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDealParticipantsRequest generates requests for GetDealParticipants
func NewGetDealParticipantsRequest(server string, id int, params *GetDealParticipantsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/participants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddDealParticipantRequest calls the generic AddDealParticipant builder with application/json body
func NewAddDealParticipantRequest(server string, id int, body AddDealParticipantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDealParticipantRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddDealParticipantRequestWithBody generates requests for AddDealParticipant with any type of body
func NewAddDealParticipantRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/participants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDealParticipantRequest generates requests for DeleteDealParticipant
func NewDeleteDealParticipantRequest(server string, id int, dealParticipantId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deal_participant_id", runtime.ParamLocationPath, dealParticipantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/participants/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealParticipantsChangelogRequest generates requests for GetDealParticipantsChangelog
func NewGetDealParticipantsChangelogRequest(server string, id int, params *GetDealParticipantsChangelogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/participantsChangelog", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealUsersRequest generates requests for GetDealUsers
func NewGetDealUsersRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/permittedUsers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealPersonsRequest generates requests for GetDealPersons
func NewGetDealPersonsRequest(server string, id int, params *GetDealPersonsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/persons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilesRequest generates requests for GetFiles
func NewGetFilesRequest(server string, params *GetFilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddFileRequestWithBody generates requests for AddFile with any type of body
func NewAddFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddFileAndLinkItRequestWithFormdataBody calls the generic AddFileAndLinkIt builder with application/x-www-form-urlencoded body
func NewAddFileAndLinkItRequestWithFormdataBody(server string, body AddFileAndLinkItFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewAddFileAndLinkItRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewAddFileAndLinkItRequestWithBody generates requests for AddFileAndLinkIt with any type of body
func NewAddFileAndLinkItRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/remote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkFileToItemRequestWithFormdataBody calls the generic LinkFileToItem builder with application/x-www-form-urlencoded body
func NewLinkFileToItemRequestWithFormdataBody(server string, body LinkFileToItemFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewLinkFileToItemRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewLinkFileToItemRequestWithBody generates requests for LinkFileToItem with any type of body
func NewLinkFileToItemRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/remoteLink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFileRequest generates requests for DeleteFile
func NewDeleteFileRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFileRequest generates requests for GetFile
func NewGetFileRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFileRequestWithFormdataBody calls the generic UpdateFile builder with application/x-www-form-urlencoded body
func NewUpdateFileRequestWithFormdataBody(server string, id int, body UpdateFileFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateFileRequestWithBody(server, id, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateFileRequestWithBody generates requests for UpdateFile with any type of body
func NewUpdateFileRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadFileRequest generates requests for DownloadFile
func NewDownloadFileRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFiltersRequest generates requests for DeleteFilters
func NewDeleteFiltersRequest(server string, params *DeleteFiltersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFiltersRequest generates requests for GetFilters
func NewGetFiltersRequest(server string, params *GetFiltersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddFilterRequest calls the generic AddFilter builder with application/json body
func NewAddFilterRequest(server string, body AddFilterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddFilterRequestWithBody(server, "application/json", bodyReader)
}

// NewAddFilterRequestWithBody generates requests for AddFilter with any type of body
func NewAddFilterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFilterHelpersRequest generates requests for GetFilterHelpers
func NewGetFilterHelpersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/helpers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFilterRequest generates requests for DeleteFilter
func NewDeleteFilterRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilterRequest generates requests for GetFilter
func NewGetFilterRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFilterRequest calls the generic UpdateFilter builder with application/json body
func NewUpdateFilterRequest(server string, id int, body UpdateFilterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFilterRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateFilterRequestWithBody generates requests for UpdateFilter with any type of body
func NewUpdateFilterRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddGoalRequest calls the generic AddGoal builder with application/json body
func NewAddGoalRequest(server string, body AddGoalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddGoalRequestWithBody(server, "application/json", bodyReader)
}

// NewAddGoalRequestWithBody generates requests for AddGoal with any type of body
func NewAddGoalRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/goals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGoalsRequest generates requests for GetGoals
func NewGetGoalsRequest(server string, params *GetGoalsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/goals/find")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TypeName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type.name", runtime.ParamLocationQuery, *params.TypeName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_active", runtime.ParamLocationQuery, *params.IsActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssigneeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assignee.id", runtime.ParamLocationQuery, *params.AssigneeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssigneeType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assignee.type", runtime.ParamLocationQuery, *params.AssigneeType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpectedOutcomeTarget != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expected_outcome.target", runtime.ParamLocationQuery, *params.ExpectedOutcomeTarget); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpectedOutcomeTrackingMetric != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expected_outcome.tracking_metric", runtime.ParamLocationQuery, *params.ExpectedOutcomeTrackingMetric); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExpectedOutcomeCurrencyId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expected_outcome.currency_id", runtime.ParamLocationQuery, *params.ExpectedOutcomeCurrencyId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeParamsPipelineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type.params.pipeline_id", runtime.ParamLocationQuery, *params.TypeParamsPipelineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeParamsStageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type.params.stage_id", runtime.ParamLocationQuery, *params.TypeParamsStageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeParamsActivityTypeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type.params.activity_type_id", runtime.ParamLocationQuery, *params.TypeParamsActivityTypeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period.start", runtime.ParamLocationQuery, *params.PeriodStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period.end", runtime.ParamLocationQuery, *params.PeriodEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteGoalRequest generates requests for DeleteGoal
func NewDeleteGoalRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/goals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGoalRequest calls the generic UpdateGoal builder with application/json body
func NewUpdateGoalRequest(server string, id string, body UpdateGoalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGoalRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateGoalRequestWithBody generates requests for UpdateGoal with any type of body
func NewUpdateGoalRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/goals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGoalResultRequest generates requests for GetGoalResult
func NewGetGoalResultRequest(server string, id string, params *GetGoalResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/goals/%s/results", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period.start", runtime.ParamLocationQuery, params.PeriodStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period.end", runtime.ParamLocationQuery, params.PeriodEnd); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLeadFieldsRequest generates requests for GetLeadFields
func NewGetLeadFieldsRequest(server string, params *GetLeadFieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leadFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLeadLabelsRequest generates requests for GetLeadLabels
func NewGetLeadLabelsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leadLabels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddLeadLabelRequest calls the generic AddLeadLabel builder with application/json body
func NewAddLeadLabelRequest(server string, body AddLeadLabelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddLeadLabelRequestWithBody(server, "application/json", bodyReader)
}

// NewAddLeadLabelRequestWithBody generates requests for AddLeadLabel with any type of body
func NewAddLeadLabelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leadLabels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLeadLabelRequest generates requests for DeleteLeadLabel
func NewDeleteLeadLabelRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leadLabels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLeadLabelRequest calls the generic UpdateLeadLabel builder with application/json body
func NewUpdateLeadLabelRequest(server string, id openapi_types.UUID, body UpdateLeadLabelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLeadLabelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateLeadLabelRequestWithBody generates requests for UpdateLeadLabel with any type of body
func NewUpdateLeadLabelRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leadLabels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLeadSourcesRequest generates requests for GetLeadSources
func NewGetLeadSourcesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leadSources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLeadsRequest generates requests for GetLeads
func NewGetLeadsRequest(server string, params *GetLeadsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_id", runtime.ParamLocationQuery, *params.OwnerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person_id", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddLeadRequest calls the generic AddLead builder with application/json body
func NewAddLeadRequest(server string, body AddLeadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddLeadRequestWithBody(server, "application/json", bodyReader)
}

// NewAddLeadRequestWithBody generates requests for AddLead with any type of body
func NewAddLeadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetArchivedLeadsRequest generates requests for GetArchivedLeads
func NewGetArchivedLeadsRequest(server string, params *GetArchivedLeadsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leads/archived")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_id", runtime.ParamLocationQuery, *params.OwnerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person_id", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteLeadRequest generates requests for DeleteLead
func NewDeleteLeadRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLeadRequest generates requests for GetLead
func NewGetLeadRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLeadRequest calls the generic UpdateLead builder with application/json body
func NewUpdateLeadRequest(server string, id openapi_types.UUID, body UpdateLeadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLeadRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateLeadRequestWithBody generates requests for UpdateLead with any type of body
func NewUpdateLeadRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLeadUsersRequest generates requests for GetLeadUsers
func NewGetLeadUsersRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leads/%s/permittedUsers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsRequest generates requests for GetTeams
func NewGetTeamsRequest(server string, params *GetTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacyTeams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipUsers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_users", runtime.ParamLocationQuery, *params.SkipUsers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTeamRequest calls the generic AddTeam builder with application/json body
func NewAddTeamRequest(server string, body AddTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTeamRequestWithBody(server, "application/json", bodyReader)
}

// NewAddTeamRequestWithBody generates requests for AddTeam with any type of body
func NewAddTeamRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacyTeams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserTeamsRequest generates requests for GetUserTeams
func NewGetUserTeamsRequest(server string, id int, params *GetUserTeamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacyTeams/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipUsers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_users", runtime.ParamLocationQuery, *params.SkipUsers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamRequest generates requests for GetTeam
func NewGetTeamRequest(server string, id int, params *GetTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacyTeams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipUsers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_users", runtime.ParamLocationQuery, *params.SkipUsers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTeamRequest calls the generic UpdateTeam builder with application/json body
func NewUpdateTeamRequest(server string, id int, body UpdateTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTeamRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateTeamRequestWithBody generates requests for UpdateTeam with any type of body
func NewUpdateTeamRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacyTeams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTeamUserRequest calls the generic DeleteTeamUser builder with application/json body
func NewDeleteTeamUserRequest(server string, id int, body DeleteTeamUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTeamUserRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteTeamUserRequestWithBody generates requests for DeleteTeamUser with any type of body
func NewDeleteTeamUserRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacyTeams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamUsersRequest generates requests for GetTeamUsers
func NewGetTeamUsersRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacyTeams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTeamUserRequest calls the generic AddTeamUser builder with application/json body
func NewAddTeamUserRequest(server string, id int, body AddTeamUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTeamUserRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddTeamUserRequestWithBody generates requests for AddTeamUser with any type of body
func NewAddTeamUserRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacyTeams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMailMessageRequest generates requests for GetMailMessage
func NewGetMailMessageRequest(server string, id int, params *GetMailMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mailbox/mailMessages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeBody != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_body", runtime.ParamLocationQuery, *params.IncludeBody); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMailThreadsRequest generates requests for GetMailThreads
func NewGetMailThreadsRequest(server string, params *GetMailThreadsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mailbox/mailThreads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folder", runtime.ParamLocationQuery, params.Folder); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMailThreadRequest generates requests for DeleteMailThread
func NewDeleteMailThreadRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mailbox/mailThreads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMailThreadRequest generates requests for GetMailThread
func NewGetMailThreadRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mailbox/mailThreads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMailThreadDetailsRequestWithFormdataBody calls the generic UpdateMailThreadDetails builder with application/x-www-form-urlencoded body
func NewUpdateMailThreadDetailsRequestWithFormdataBody(server string, id int, body UpdateMailThreadDetailsFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateMailThreadDetailsRequestWithBody(server, id, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateMailThreadDetailsRequestWithBody generates requests for UpdateMailThreadDetails with any type of body
func NewUpdateMailThreadDetailsRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mailbox/mailThreads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMailThreadMessagesRequest generates requests for GetMailThreadMessages
func NewGetMailThreadMessagesRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mailbox/mailThreads/%s/mailMessages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveUserProviderLinkRequest calls the generic SaveUserProviderLink builder with application/json body
func NewSaveUserProviderLinkRequest(server string, body SaveUserProviderLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveUserProviderLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveUserProviderLinkRequestWithBody generates requests for SaveUserProviderLink with any type of body
func NewSaveUserProviderLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/userProviderLinks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserProviderLinkRequest generates requests for DeleteUserProviderLink
func NewDeleteUserProviderLinkRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/userProviderLinks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNoteFieldsRequest generates requests for GetNoteFields
func NewGetNoteFieldsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/noteFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotesRequest generates requests for GetNotes
func NewGetNotesRequest(server string, params *GetNotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeadId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lead_id", runtime.ParamLocationQuery, *params.LeadId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DealId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deal_id", runtime.ParamLocationQuery, *params.DealId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person_id", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrgId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org_id", runtime.ParamLocationQuery, *params.OrgId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PinnedToLeadFlag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pinned_to_lead_flag", runtime.ParamLocationQuery, *params.PinnedToLeadFlag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PinnedToDealFlag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pinned_to_deal_flag", runtime.ParamLocationQuery, *params.PinnedToDealFlag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PinnedToOrganizationFlag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pinned_to_organization_flag", runtime.ParamLocationQuery, *params.PinnedToOrganizationFlag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PinnedToPersonFlag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pinned_to_person_flag", runtime.ParamLocationQuery, *params.PinnedToPersonFlag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PinnedToProjectFlag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pinned_to_project_flag", runtime.ParamLocationQuery, *params.PinnedToProjectFlag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddNoteRequest calls the generic AddNote builder with application/json body
func NewAddNoteRequest(server string, body AddNoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddNoteRequestWithBody(server, "application/json", bodyReader)
}

// NewAddNoteRequestWithBody generates requests for AddNote with any type of body
func NewAddNoteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNoteRequest generates requests for DeleteNote
func NewDeleteNoteRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNoteRequest generates requests for GetNote
func NewGetNoteRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNoteRequest calls the generic UpdateNote builder with application/json body
func NewUpdateNoteRequest(server string, id int, body UpdateNoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNoteRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateNoteRequestWithBody generates requests for UpdateNote with any type of body
func NewUpdateNoteRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNoteCommentsRequest generates requests for GetNoteComments
func NewGetNoteCommentsRequest(server string, id int, params *GetNoteCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddNoteCommentRequest calls the generic AddNoteComment builder with application/json body
func NewAddNoteCommentRequest(server string, id int, body AddNoteCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddNoteCommentRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddNoteCommentRequestWithBody generates requests for AddNoteComment with any type of body
func NewAddNoteCommentRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCommentRequest generates requests for DeleteComment
func NewDeleteCommentRequest(server string, id int, commentId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommentRequest generates requests for GetComment
func NewGetCommentRequest(server string, id int, commentId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCommentForNoteRequest calls the generic UpdateCommentForNote builder with application/json body
func NewUpdateCommentForNoteRequest(server string, id int, commentId openapi_types.UUID, body UpdateCommentForNoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCommentForNoteRequestWithBody(server, id, commentId, "application/json", bodyReader)
}

// NewUpdateCommentForNoteRequestWithBody generates requests for UpdateCommentForNote with any type of body
func NewUpdateCommentForNoteRequestWithBody(server string, id int, commentId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthorizeRequest generates requests for Authorize
func NewAuthorizeRequest(server string, params *AuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokensRequestWithFormdataBody calls the generic GetTokens builder with application/x-www-form-urlencoded body
func NewGetTokensRequestWithFormdataBody(server string, params *GetTokensParams, body GetTokensFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewGetTokensRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewGetTokensRequestWithBody generates requests for GetTokens with any type of body
func NewGetTokensRequestWithBody(server string, params *GetTokensParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewRefreshTokensRequestWithFormdataBody calls the generic RefreshTokens builder with application/x-www-form-urlencoded body
func NewRefreshTokensRequestWithFormdataBody(server string, params *RefreshTokensParams, body RefreshTokensFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRefreshTokensRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewRefreshTokensRequestWithBody generates requests for RefreshTokens with any type of body
func NewRefreshTokensRequestWithBody(server string, params *RefreshTokensParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/token/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewDeleteOrganizationFieldsRequest generates requests for DeleteOrganizationFields
func NewDeleteOrganizationFieldsRequest(server string, params *DeleteOrganizationFieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRelationshipsRequest generates requests for GetOrganizationRelationships
func NewGetOrganizationRelationshipsRequest(server string, params *GetOrganizationRelationshipsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationRelationships")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org_id", runtime.ParamLocationQuery, params.OrgId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrganizationRelationshipRequest calls the generic AddOrganizationRelationship builder with application/json body
func NewAddOrganizationRelationshipRequest(server string, body AddOrganizationRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrganizationRelationshipRequestWithBody(server, "application/json", bodyReader)
}

// NewAddOrganizationRelationshipRequestWithBody generates requests for AddOrganizationRelationship with any type of body
func NewAddOrganizationRelationshipRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationRelationships")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationRelationshipRequest generates requests for DeleteOrganizationRelationship
func NewDeleteOrganizationRelationshipRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationRelationships/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRelationshipRequest generates requests for GetOrganizationRelationship
func NewGetOrganizationRelationshipRequest(server string, id int, params *GetOrganizationRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationRelationships/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrgId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org_id", runtime.ParamLocationQuery, *params.OrgId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrganizationRelationshipRequest calls the generic UpdateOrganizationRelationship builder with application/json body
func NewUpdateOrganizationRelationshipRequest(server string, id int, body UpdateOrganizationRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrganizationRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateOrganizationRelationshipRequestWithBody generates requests for UpdateOrganizationRelationship with any type of body
func NewUpdateOrganizationRelationshipRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationRelationships/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationsRequest generates requests for DeleteOrganizations
func NewDeleteOrganizationsRequest(server string, params *DeleteOrganizationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationsCollectionRequest generates requests for GetOrganizationsCollection
func NewGetOrganizationsCollectionRequest(server string, params *GetOrganizationsCollectionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/collection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_id", runtime.ParamLocationQuery, *params.OwnerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstChar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_char", runtime.ParamLocationQuery, *params.FirstChar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationActivitiesRequest generates requests for GetOrganizationActivities
func NewGetOrganizationActivitiesRequest(server string, id int, params *GetOrganizationActivitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/activities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Done != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "done", runtime.ParamLocationQuery, *params.Done); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Exclude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationChangelogRequest generates requests for GetOrganizationChangelog
func NewGetOrganizationChangelogRequest(server string, id int, params *GetOrganizationChangelogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/changelog", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationDealsRequest generates requests for GetOrganizationDeals
func NewGetOrganizationDealsRequest(server string, id int, params *GetOrganizationDealsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/deals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyPrimaryAssociation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_primary_association", runtime.ParamLocationQuery, *params.OnlyPrimaryAssociation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationFilesRequest generates requests for GetOrganizationFiles
func NewGetOrganizationFilesRequest(server string, id int, params *GetOrganizationFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationUpdatesRequest generates requests for GetOrganizationUpdates
func NewGetOrganizationUpdatesRequest(server string, id int, params *GetOrganizationUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/flow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllChanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_changes", runtime.ParamLocationQuery, *params.AllChanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Items != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "items", runtime.ParamLocationQuery, *params.Items); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationMailMessagesRequest generates requests for GetOrganizationMailMessages
func NewGetOrganizationMailMessagesRequest(server string, id int, params *GetOrganizationMailMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/mailMessages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMergeOrganizationsRequest calls the generic MergeOrganizations builder with application/json body
func NewMergeOrganizationsRequest(server string, id int, body MergeOrganizationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeOrganizationsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewMergeOrganizationsRequestWithBody generates requests for MergeOrganizations with any type of body
func NewMergeOrganizationsRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/merge", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrganizationUsersRequest generates requests for GetOrganizationUsers
func NewGetOrganizationUsersRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/permittedUsers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationPersonsRequest generates requests for GetOrganizationPersons
func NewGetOrganizationPersonsRequest(server string, id int, params *GetOrganizationPersonsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/persons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionSetsRequest generates requests for GetPermissionSets
func NewGetPermissionSetsRequest(server string, params *GetPermissionSetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/permissionSets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.App != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app", runtime.ParamLocationQuery, *params.App); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionSetRequest generates requests for GetPermissionSet
func NewGetPermissionSetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/permissionSets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionSetAssignmentsRequest generates requests for GetPermissionSetAssignments
func NewGetPermissionSetAssignmentsRequest(server string, id string, params *GetPermissionSetAssignmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/permissionSets/%s/assignments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePersonFieldsRequest generates requests for DeletePersonFields
func NewDeletePersonFieldsRequest(server string, params *DeletePersonFieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePersonsRequest generates requests for DeletePersons
func NewDeletePersonsRequest(server string, params *DeletePersonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonsCollectionRequest generates requests for GetPersonsCollection
func NewGetPersonsCollectionRequest(server string, params *GetPersonsCollectionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/collection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_id", runtime.ParamLocationQuery, *params.OwnerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstChar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_char", runtime.ParamLocationQuery, *params.FirstChar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonActivitiesRequest generates requests for GetPersonActivities
func NewGetPersonActivitiesRequest(server string, id int, params *GetPersonActivitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/activities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Done != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "done", runtime.ParamLocationQuery, *params.Done); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Exclude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonChangelogRequest generates requests for GetPersonChangelog
func NewGetPersonChangelogRequest(server string, id int, params *GetPersonChangelogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/changelog", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonDealsRequest generates requests for GetPersonDeals
func NewGetPersonDealsRequest(server string, id int, params *GetPersonDealsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/deals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonFilesRequest generates requests for GetPersonFiles
func NewGetPersonFilesRequest(server string, id int, params *GetPersonFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonUpdatesRequest generates requests for GetPersonUpdates
func NewGetPersonUpdatesRequest(server string, id int, params *GetPersonUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/flow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllChanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_changes", runtime.ParamLocationQuery, *params.AllChanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Items != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "items", runtime.ParamLocationQuery, *params.Items); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonMailMessagesRequest generates requests for GetPersonMailMessages
func NewGetPersonMailMessagesRequest(server string, id int, params *GetPersonMailMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/mailMessages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMergePersonsRequest calls the generic MergePersons builder with application/json body
func NewMergePersonsRequest(server string, id int, body MergePersonsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergePersonsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewMergePersonsRequestWithBody generates requests for MergePersons with any type of body
func NewMergePersonsRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/merge", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersonUsersRequest generates requests for GetPersonUsers
func NewGetPersonUsersRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/permittedUsers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePersonPictureRequest generates requests for DeletePersonPicture
func NewDeletePersonPictureRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/picture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPersonPictureRequestWithBody generates requests for AddPersonPicture with any type of body
func NewAddPersonPictureRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/picture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersonProductsRequest generates requests for GetPersonProducts
func NewGetPersonProductsRequest(server string, id int, params *GetPersonProductsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/products", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineConversionStatisticsRequest generates requests for GetPipelineConversionStatistics
func NewGetPipelineConversionStatisticsRequest(server string, id int, params *GetPipelineConversionStatisticsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s/conversion_statistics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, params.EndDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineDealsRequest generates requests for GetPipelineDeals
func NewGetPipelineDealsRequest(server string, id int, params *GetPipelineDealsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s/deals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Everyone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "everyone", runtime.ParamLocationQuery, *params.Everyone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stage_id", runtime.ParamLocationQuery, *params.StageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetSummary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "get_summary", runtime.ParamLocationQuery, *params.GetSummary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalsConvertCurrency != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "totals_convert_currency", runtime.ParamLocationQuery, *params.TotalsConvertCurrency); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineMovementStatisticsRequest generates requests for GetPipelineMovementStatistics
func NewGetPipelineMovementStatisticsRequest(server string, id int, params *GetPipelineMovementStatisticsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s/movement_statistics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, params.EndDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProductFieldsRequest generates requests for DeleteProductFields
func NewDeleteProductFieldsRequest(server string, params *DeleteProductFieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/productFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductDealsRequest generates requests for GetProductDeals
func NewGetProductDealsRequest(server string, id int, params *GetProductDealsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/deals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductFilesRequest generates requests for GetProductFiles
func NewGetProductFilesRequest(server string, id int, params *GetProductFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductUsersRequest generates requests for GetProductUsers
func NewGetProductUsersRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/permittedUsers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectTemplatesRequest generates requests for GetProjectTemplates
func NewGetProjectTemplatesRequest(server string, params *GetProjectTemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projectTemplates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectTemplateRequest generates requests for GetProjectTemplate
func NewGetProjectTemplateRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projectTemplates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectsRequest generates requests for GetProjects
func NewGetProjectsRequest(server string, params *GetProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PhaseId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phase_id", runtime.ParamLocationQuery, *params.PhaseId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeArchived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_archived", runtime.ParamLocationQuery, *params.IncludeArchived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddProjectRequest calls the generic AddProject builder with application/json body
func NewAddProjectRequest(server string, body AddProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewAddProjectRequestWithBody generates requests for AddProject with any type of body
func NewAddProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProjectsBoardsRequest generates requests for GetProjectsBoards
func NewGetProjectsBoardsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/boards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectsBoardRequest generates requests for GetProjectsBoard
func NewGetProjectsBoardRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/boards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectsPhasesRequest generates requests for GetProjectsPhases
func NewGetProjectsPhasesRequest(server string, params *GetProjectsPhasesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/phases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "board_id", runtime.ParamLocationQuery, params.BoardId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectsPhaseRequest generates requests for GetProjectsPhase
func NewGetProjectsPhaseRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/phases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProjectRequest generates requests for DeleteProject
func NewDeleteProjectRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectRequest generates requests for GetProject
func NewGetProjectRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRequest calls the generic UpdateProject builder with application/json body
func NewUpdateProjectRequest(server string, id int, body UpdateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateProjectRequestWithBody generates requests for UpdateProject with any type of body
func NewUpdateProjectRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProjectActivitiesRequest generates requests for GetProjectActivities
func NewGetProjectActivitiesRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/activities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveProjectRequest generates requests for ArchiveProject
func NewArchiveProjectRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectGroupsRequest generates requests for GetProjectGroups
func NewGetProjectGroupsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectPlanRequest generates requests for GetProjectPlan
func NewGetProjectPlanRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/plan", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutProjectPlanActivityRequest calls the generic PutProjectPlanActivity builder with application/json body
func NewPutProjectPlanActivityRequest(server string, id int, activityId int, body PutProjectPlanActivityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutProjectPlanActivityRequestWithBody(server, id, activityId, "application/json", bodyReader)
}

// NewPutProjectPlanActivityRequestWithBody generates requests for PutProjectPlanActivity with any type of body
func NewPutProjectPlanActivityRequestWithBody(server string, id int, activityId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "activityId", runtime.ParamLocationPath, activityId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/plan/activities/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutProjectPlanTaskRequest calls the generic PutProjectPlanTask builder with application/json body
func NewPutProjectPlanTaskRequest(server string, id int, taskId int, body PutProjectPlanTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutProjectPlanTaskRequestWithBody(server, id, taskId, "application/json", bodyReader)
}

// NewPutProjectPlanTaskRequestWithBody generates requests for PutProjectPlanTask with any type of body
func NewPutProjectPlanTaskRequestWithBody(server string, id int, taskId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/plan/tasks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProjectTasksRequest generates requests for GetProjectTasks
func NewGetProjectTasksRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecentsRequest generates requests for GetRecents
func NewGetRecentsRequest(server string, params *GetRecentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_timestamp", runtime.ParamLocationQuery, params.SinceTimestamp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Items != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "items", runtime.ParamLocationQuery, *params.Items); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRolesRequest generates requests for GetRoles
func NewGetRolesRequest(server string, params *GetRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRoleRequest calls the generic AddRole builder with application/json body
func NewAddRoleRequest(server string, body AddRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewAddRoleRequestWithBody generates requests for AddRole with any type of body
func NewAddRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRoleRequest generates requests for DeleteRole
func NewDeleteRoleRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleRequest calls the generic UpdateRole builder with application/json body
func NewUpdateRoleRequest(server string, id int, body UpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateRoleRequestWithBody generates requests for UpdateRole with any type of body
func NewUpdateRoleRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRoleAssignmentRequest calls the generic DeleteRoleAssignment builder with application/json body
func NewDeleteRoleAssignmentRequest(server string, id int, body DeleteRoleAssignmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRoleAssignmentRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteRoleAssignmentRequestWithBody generates requests for DeleteRoleAssignment with any type of body
func NewDeleteRoleAssignmentRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/assignments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRoleAssignmentsRequest generates requests for GetRoleAssignments
func NewGetRoleAssignmentsRequest(server string, id int, params *GetRoleAssignmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/assignments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRoleAssignmentRequest calls the generic AddRoleAssignment builder with application/json body
func NewAddRoleAssignmentRequest(server string, id int, body AddRoleAssignmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRoleAssignmentRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddRoleAssignmentRequestWithBody generates requests for AddRoleAssignment with any type of body
func NewAddRoleAssignmentRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/assignments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRolePipelinesRequest generates requests for GetRolePipelines
func NewGetRolePipelinesRequest(server string, id int, params *GetRolePipelinesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/pipelines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Visible != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "visible", runtime.ParamLocationQuery, *params.Visible); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRolePipelinesRequest calls the generic UpdateRolePipelines builder with application/json body
func NewUpdateRolePipelinesRequest(server string, id int, body UpdateRolePipelinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRolePipelinesRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateRolePipelinesRequestWithBody generates requests for UpdateRolePipelines with any type of body
func NewUpdateRolePipelinesRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/pipelines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRoleSettingsRequest generates requests for GetRoleSettings
func NewGetRoleSettingsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrUpdateRoleSettingRequest calls the generic AddOrUpdateRoleSetting builder with application/json body
func NewAddOrUpdateRoleSettingRequest(server string, id int, body AddOrUpdateRoleSettingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrUpdateRoleSettingRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddOrUpdateRoleSettingRequestWithBody generates requests for AddOrUpdateRoleSetting with any type of body
func NewAddOrUpdateRoleSettingRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStagesRequest generates requests for DeleteStages
func NewDeleteStagesRequest(server string, params *DeleteStagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStageDealsRequest generates requests for GetStageDeals
func NewGetStageDealsRequest(server string, id int, params *GetStageDealsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages/%s/deals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Everyone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "everyone", runtime.ParamLocationQuery, *params.Everyone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTasksRequest generates requests for GetTasks
func NewGetTasksRequest(server string, params *GetTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssigneeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assignee_id", runtime.ParamLocationQuery, *params.AssigneeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentTaskId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_task_id", runtime.ParamLocationQuery, *params.ParentTaskId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Done != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "done", runtime.ParamLocationQuery, *params.Done); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTaskRequest calls the generic AddTask builder with application/json body
func NewAddTaskRequest(server string, body AddTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTaskRequestWithBody(server, "application/json", bodyReader)
}

// NewAddTaskRequestWithBody generates requests for AddTask with any type of body
func NewAddTaskRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTaskRequest generates requests for DeleteTask
func NewDeleteTaskRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaskRequest generates requests for GetTask
func NewGetTaskRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTaskRequest calls the generic UpdateTask builder with application/json body
func NewUpdateTaskRequest(server string, id int, body UpdateTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTaskRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateTaskRequestWithBody generates requests for UpdateTask with any type of body
func NewUpdateTaskRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserConnectionsRequest generates requests for GetUserConnections
func NewGetUserConnectionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/userConnections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserSettingsRequest generates requests for GetUserSettings
func NewGetUserSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/userSettings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUserRequest calls the generic AddUser builder with application/json body
func NewAddUserRequest(server string, body AddUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserRequestWithBody(server, "application/json", bodyReader)
}

// NewAddUserRequestWithBody generates requests for AddUser with any type of body
func NewAddUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindUsersByNameRequest generates requests for FindUsersByName
func NewFindUsersByNameRequest(server string, params *FindUsersByNameParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/find")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "term", runtime.ParamLocationQuery, params.Term); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SearchByEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_by_email", runtime.ParamLocationQuery, *params.SearchByEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, id int, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserPermissionsRequest generates requests for GetUserPermissions
func NewGetUserPermissionsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRoleAssignmentsRequest generates requests for GetUserRoleAssignments
func NewGetUserRoleAssignmentsRequest(server string, id int, params *GetUserRoleAssignmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/roleAssignments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRoleSettingsRequest generates requests for GetUserRoleSettings
func NewGetUserRoleSettingsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/roleSettings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhooksRequest generates requests for GetWebhooks
func NewGetWebhooksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddWebhookRequest calls the generic AddWebhook builder with application/json body
func NewAddWebhookRequest(server string, body AddWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddWebhookRequestWithBody(server, "application/json", bodyReader)
}

// NewAddWebhookRequestWithBody generates requests for AddWebhook with any type of body
func NewAddWebhookRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWebhookRequest generates requests for DeleteWebhook
func NewDeleteWebhookRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteActivitiesWithResponse request
	DeleteActivitiesWithResponse(ctx context.Context, params *DeleteActivitiesParams, reqEditors ...RequestEditorFn) (*DeleteActivitiesResponse, error)

	// GetActivitiesCollectionWithResponse request
	GetActivitiesCollectionWithResponse(ctx context.Context, params *GetActivitiesCollectionParams, reqEditors ...RequestEditorFn) (*GetActivitiesCollectionResponse, error)

	// DeleteActivityTypesWithResponse request
	DeleteActivityTypesWithResponse(ctx context.Context, params *DeleteActivityTypesParams, reqEditors ...RequestEditorFn) (*DeleteActivityTypesResponse, error)

	// GetActivityTypesWithResponse request
	GetActivityTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetActivityTypesResponse, error)

	// AddActivityTypeWithBodyWithResponse request with any body
	AddActivityTypeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddActivityTypeResponse, error)

	AddActivityTypeWithResponse(ctx context.Context, body AddActivityTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*AddActivityTypeResponse, error)

	// DeleteActivityTypeWithResponse request
	DeleteActivityTypeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteActivityTypeResponse, error)

	// UpdateActivityTypeWithBodyWithResponse request with any body
	UpdateActivityTypeWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateActivityTypeResponse, error)

	UpdateActivityTypeWithResponse(ctx context.Context, id int, body UpdateActivityTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateActivityTypeResponse, error)

	// GetCompanyAddonsWithResponse request
	GetCompanyAddonsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCompanyAddonsResponse, error)

	// GetUserCallLogsWithResponse request
	GetUserCallLogsWithResponse(ctx context.Context, params *GetUserCallLogsParams, reqEditors ...RequestEditorFn) (*GetUserCallLogsResponse, error)

	// AddCallLogWithBodyWithResponse request with any body
	AddCallLogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCallLogResponse, error)

	AddCallLogWithResponse(ctx context.Context, body AddCallLogJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCallLogResponse, error)

	// DeleteCallLogWithResponse request
	DeleteCallLogWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCallLogResponse, error)

	// GetCallLogWithResponse request
	GetCallLogWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCallLogResponse, error)

	// AddCallLogAudioFileWithBodyWithResponse request with any body
	AddCallLogAudioFileWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCallLogAudioFileResponse, error)

	// AddChannelWithBodyWithResponse request with any body
	AddChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddChannelResponse, error)

	AddChannelWithResponse(ctx context.Context, body AddChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*AddChannelResponse, error)

	// ReceiveMessageWithBodyWithResponse request with any body
	ReceiveMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveMessageResponse, error)

	ReceiveMessageWithResponse(ctx context.Context, body ReceiveMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*ReceiveMessageResponse, error)

	// DeleteConversationWithResponse request
	DeleteConversationWithResponse(ctx context.Context, channelId string, conversationId string, reqEditors ...RequestEditorFn) (*DeleteConversationResponse, error)

	// DeleteChannelWithResponse request
	DeleteChannelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteChannelResponse, error)

	// GetCurrenciesWithResponse request
	GetCurrenciesWithResponse(ctx context.Context, params *GetCurrenciesParams, reqEditors ...RequestEditorFn) (*GetCurrenciesResponse, error)

	// DeleteDealFieldsWithResponse request
	DeleteDealFieldsWithResponse(ctx context.Context, params *DeleteDealFieldsParams, reqEditors ...RequestEditorFn) (*DeleteDealFieldsResponse, error)

	// DeleteDealsWithResponse request
	DeleteDealsWithResponse(ctx context.Context, params *DeleteDealsParams, reqEditors ...RequestEditorFn) (*DeleteDealsResponse, error)

	// GetDealsCollectionWithResponse request
	GetDealsCollectionWithResponse(ctx context.Context, params *GetDealsCollectionParams, reqEditors ...RequestEditorFn) (*GetDealsCollectionResponse, error)

	// GetDealsSummaryWithResponse request
	GetDealsSummaryWithResponse(ctx context.Context, params *GetDealsSummaryParams, reqEditors ...RequestEditorFn) (*GetDealsSummaryResponse, error)

	// GetArchivedDealsSummaryWithResponse request
	GetArchivedDealsSummaryWithResponse(ctx context.Context, params *GetArchivedDealsSummaryParams, reqEditors ...RequestEditorFn) (*GetArchivedDealsSummaryResponse, error)

	// GetDealsTimelineWithResponse request
	GetDealsTimelineWithResponse(ctx context.Context, params *GetDealsTimelineParams, reqEditors ...RequestEditorFn) (*GetDealsTimelineResponse, error)

	// GetArchivedDealsTimelineWithResponse request
	GetArchivedDealsTimelineWithResponse(ctx context.Context, params *GetArchivedDealsTimelineParams, reqEditors ...RequestEditorFn) (*GetArchivedDealsTimelineResponse, error)

	// GetDealActivitiesWithResponse request
	GetDealActivitiesWithResponse(ctx context.Context, id int, params *GetDealActivitiesParams, reqEditors ...RequestEditorFn) (*GetDealActivitiesResponse, error)

	// GetDealChangelogWithResponse request
	GetDealChangelogWithResponse(ctx context.Context, id int, params *GetDealChangelogParams, reqEditors ...RequestEditorFn) (*GetDealChangelogResponse, error)

	// DuplicateDealWithResponse request
	DuplicateDealWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DuplicateDealResponse, error)

	// GetDealFilesWithResponse request
	GetDealFilesWithResponse(ctx context.Context, id int, params *GetDealFilesParams, reqEditors ...RequestEditorFn) (*GetDealFilesResponse, error)

	// GetDealUpdatesWithResponse request
	GetDealUpdatesWithResponse(ctx context.Context, id int, params *GetDealUpdatesParams, reqEditors ...RequestEditorFn) (*GetDealUpdatesResponse, error)

	// GetDealMailMessagesWithResponse request
	GetDealMailMessagesWithResponse(ctx context.Context, id int, params *GetDealMailMessagesParams, reqEditors ...RequestEditorFn) (*GetDealMailMessagesResponse, error)

	// MergeDealsWithBodyWithResponse request with any body
	MergeDealsWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeDealsResponse, error)

	MergeDealsWithResponse(ctx context.Context, id int, body MergeDealsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeDealsResponse, error)

	// GetDealParticipantsWithResponse request
	GetDealParticipantsWithResponse(ctx context.Context, id int, params *GetDealParticipantsParams, reqEditors ...RequestEditorFn) (*GetDealParticipantsResponse, error)

	// AddDealParticipantWithBodyWithResponse request with any body
	AddDealParticipantWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDealParticipantResponse, error)

	AddDealParticipantWithResponse(ctx context.Context, id int, body AddDealParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDealParticipantResponse, error)

	// DeleteDealParticipantWithResponse request
	DeleteDealParticipantWithResponse(ctx context.Context, id int, dealParticipantId int, reqEditors ...RequestEditorFn) (*DeleteDealParticipantResponse, error)

	// GetDealParticipantsChangelogWithResponse request
	GetDealParticipantsChangelogWithResponse(ctx context.Context, id int, params *GetDealParticipantsChangelogParams, reqEditors ...RequestEditorFn) (*GetDealParticipantsChangelogResponse, error)

	// GetDealUsersWithResponse request
	GetDealUsersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetDealUsersResponse, error)

	// GetDealPersonsWithResponse request
	GetDealPersonsWithResponse(ctx context.Context, id int, params *GetDealPersonsParams, reqEditors ...RequestEditorFn) (*GetDealPersonsResponse, error)

	// GetFilesWithResponse request
	GetFilesWithResponse(ctx context.Context, params *GetFilesParams, reqEditors ...RequestEditorFn) (*GetFilesResponse, error)

	// AddFileWithBodyWithResponse request with any body
	AddFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddFileResponse, error)

	// AddFileAndLinkItWithBodyWithResponse request with any body
	AddFileAndLinkItWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddFileAndLinkItResponse, error)

	AddFileAndLinkItWithFormdataBodyWithResponse(ctx context.Context, body AddFileAndLinkItFormdataRequestBody, reqEditors ...RequestEditorFn) (*AddFileAndLinkItResponse, error)

	// LinkFileToItemWithBodyWithResponse request with any body
	LinkFileToItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkFileToItemResponse, error)

	LinkFileToItemWithFormdataBodyWithResponse(ctx context.Context, body LinkFileToItemFormdataRequestBody, reqEditors ...RequestEditorFn) (*LinkFileToItemResponse, error)

	// DeleteFileWithResponse request
	DeleteFileWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteFileResponse, error)

	// GetFileWithResponse request
	GetFileWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetFileResponse, error)

	// UpdateFileWithBodyWithResponse request with any body
	UpdateFileWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFileResponse, error)

	UpdateFileWithFormdataBodyWithResponse(ctx context.Context, id int, body UpdateFileFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateFileResponse, error)

	// DownloadFileWithResponse request
	DownloadFileWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DownloadFileResponse, error)

	// DeleteFiltersWithResponse request
	DeleteFiltersWithResponse(ctx context.Context, params *DeleteFiltersParams, reqEditors ...RequestEditorFn) (*DeleteFiltersResponse, error)

	// GetFiltersWithResponse request
	GetFiltersWithResponse(ctx context.Context, params *GetFiltersParams, reqEditors ...RequestEditorFn) (*GetFiltersResponse, error)

	// AddFilterWithBodyWithResponse request with any body
	AddFilterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddFilterResponse, error)

	AddFilterWithResponse(ctx context.Context, body AddFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*AddFilterResponse, error)

	// GetFilterHelpersWithResponse request
	GetFilterHelpersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFilterHelpersResponse, error)

	// DeleteFilterWithResponse request
	DeleteFilterWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteFilterResponse, error)

	// GetFilterWithResponse request
	GetFilterWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetFilterResponse, error)

	// UpdateFilterWithBodyWithResponse request with any body
	UpdateFilterWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFilterResponse, error)

	UpdateFilterWithResponse(ctx context.Context, id int, body UpdateFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFilterResponse, error)

	// AddGoalWithBodyWithResponse request with any body
	AddGoalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGoalResponse, error)

	AddGoalWithResponse(ctx context.Context, body AddGoalJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGoalResponse, error)

	// GetGoalsWithResponse request
	GetGoalsWithResponse(ctx context.Context, params *GetGoalsParams, reqEditors ...RequestEditorFn) (*GetGoalsResponse, error)

	// DeleteGoalWithResponse request
	DeleteGoalWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteGoalResponse, error)

	// UpdateGoalWithBodyWithResponse request with any body
	UpdateGoalWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGoalResponse, error)

	UpdateGoalWithResponse(ctx context.Context, id string, body UpdateGoalJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGoalResponse, error)

	// GetGoalResultWithResponse request
	GetGoalResultWithResponse(ctx context.Context, id string, params *GetGoalResultParams, reqEditors ...RequestEditorFn) (*GetGoalResultResponse, error)

	// GetLeadFieldsWithResponse request
	GetLeadFieldsWithResponse(ctx context.Context, params *GetLeadFieldsParams, reqEditors ...RequestEditorFn) (*GetLeadFieldsResponse, error)

	// GetLeadLabelsWithResponse request
	GetLeadLabelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLeadLabelsResponse, error)

	// AddLeadLabelWithBodyWithResponse request with any body
	AddLeadLabelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddLeadLabelResponse, error)

	AddLeadLabelWithResponse(ctx context.Context, body AddLeadLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*AddLeadLabelResponse, error)

	// DeleteLeadLabelWithResponse request
	DeleteLeadLabelWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteLeadLabelResponse, error)

	// UpdateLeadLabelWithBodyWithResponse request with any body
	UpdateLeadLabelWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLeadLabelResponse, error)

	UpdateLeadLabelWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateLeadLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLeadLabelResponse, error)

	// GetLeadSourcesWithResponse request
	GetLeadSourcesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLeadSourcesResponse, error)

	// GetLeadsWithResponse request
	GetLeadsWithResponse(ctx context.Context, params *GetLeadsParams, reqEditors ...RequestEditorFn) (*GetLeadsResponse, error)

	// AddLeadWithBodyWithResponse request with any body
	AddLeadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddLeadResponse, error)

	AddLeadWithResponse(ctx context.Context, body AddLeadJSONRequestBody, reqEditors ...RequestEditorFn) (*AddLeadResponse, error)

	// GetArchivedLeadsWithResponse request
	GetArchivedLeadsWithResponse(ctx context.Context, params *GetArchivedLeadsParams, reqEditors ...RequestEditorFn) (*GetArchivedLeadsResponse, error)

	// DeleteLeadWithResponse request
	DeleteLeadWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteLeadResponse, error)

	// GetLeadWithResponse request
	GetLeadWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetLeadResponse, error)

	// UpdateLeadWithBodyWithResponse request with any body
	UpdateLeadWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLeadResponse, error)

	UpdateLeadWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateLeadJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLeadResponse, error)

	// GetLeadUsersWithResponse request
	GetLeadUsersWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLeadUsersResponse, error)

	// GetTeamsWithResponse request
	GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error)

	// AddTeamWithBodyWithResponse request with any body
	AddTeamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTeamResponse, error)

	AddTeamWithResponse(ctx context.Context, body AddTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTeamResponse, error)

	// GetUserTeamsWithResponse request
	GetUserTeamsWithResponse(ctx context.Context, id int, params *GetUserTeamsParams, reqEditors ...RequestEditorFn) (*GetUserTeamsResponse, error)

	// GetTeamWithResponse request
	GetTeamWithResponse(ctx context.Context, id int, params *GetTeamParams, reqEditors ...RequestEditorFn) (*GetTeamResponse, error)

	// UpdateTeamWithBodyWithResponse request with any body
	UpdateTeamWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error)

	UpdateTeamWithResponse(ctx context.Context, id int, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error)

	// DeleteTeamUserWithBodyWithResponse request with any body
	DeleteTeamUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTeamUserResponse, error)

	DeleteTeamUserWithResponse(ctx context.Context, id int, body DeleteTeamUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTeamUserResponse, error)

	// GetTeamUsersWithResponse request
	GetTeamUsersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTeamUsersResponse, error)

	// AddTeamUserWithBodyWithResponse request with any body
	AddTeamUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTeamUserResponse, error)

	AddTeamUserWithResponse(ctx context.Context, id int, body AddTeamUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTeamUserResponse, error)

	// GetMailMessageWithResponse request
	GetMailMessageWithResponse(ctx context.Context, id int, params *GetMailMessageParams, reqEditors ...RequestEditorFn) (*GetMailMessageResponse, error)

	// GetMailThreadsWithResponse request
	GetMailThreadsWithResponse(ctx context.Context, params *GetMailThreadsParams, reqEditors ...RequestEditorFn) (*GetMailThreadsResponse, error)

	// DeleteMailThreadWithResponse request
	DeleteMailThreadWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteMailThreadResponse, error)

	// GetMailThreadWithResponse request
	GetMailThreadWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMailThreadResponse, error)

	// UpdateMailThreadDetailsWithBodyWithResponse request with any body
	UpdateMailThreadDetailsWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMailThreadDetailsResponse, error)

	UpdateMailThreadDetailsWithFormdataBodyWithResponse(ctx context.Context, id int, body UpdateMailThreadDetailsFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateMailThreadDetailsResponse, error)

	// GetMailThreadMessagesWithResponse request
	GetMailThreadMessagesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMailThreadMessagesResponse, error)

	// SaveUserProviderLinkWithBodyWithResponse request with any body
	SaveUserProviderLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserProviderLinkResponse, error)

	SaveUserProviderLinkWithResponse(ctx context.Context, body SaveUserProviderLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveUserProviderLinkResponse, error)

	// DeleteUserProviderLinkWithResponse request
	DeleteUserProviderLinkWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteUserProviderLinkResponse, error)

	// GetNoteFieldsWithResponse request
	GetNoteFieldsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNoteFieldsResponse, error)

	// GetNotesWithResponse request
	GetNotesWithResponse(ctx context.Context, params *GetNotesParams, reqEditors ...RequestEditorFn) (*GetNotesResponse, error)

	// AddNoteWithBodyWithResponse request with any body
	AddNoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddNoteResponse, error)

	AddNoteWithResponse(ctx context.Context, body AddNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*AddNoteResponse, error)

	// DeleteNoteWithResponse request
	DeleteNoteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteNoteResponse, error)

	// GetNoteWithResponse request
	GetNoteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetNoteResponse, error)

	// UpdateNoteWithBodyWithResponse request with any body
	UpdateNoteWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNoteResponse, error)

	UpdateNoteWithResponse(ctx context.Context, id int, body UpdateNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNoteResponse, error)

	// GetNoteCommentsWithResponse request
	GetNoteCommentsWithResponse(ctx context.Context, id int, params *GetNoteCommentsParams, reqEditors ...RequestEditorFn) (*GetNoteCommentsResponse, error)

	// AddNoteCommentWithBodyWithResponse request with any body
	AddNoteCommentWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddNoteCommentResponse, error)

	AddNoteCommentWithResponse(ctx context.Context, id int, body AddNoteCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*AddNoteCommentResponse, error)

	// DeleteCommentWithResponse request
	DeleteCommentWithResponse(ctx context.Context, id int, commentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteCommentResponse, error)

	// GetCommentWithResponse request
	GetCommentWithResponse(ctx context.Context, id int, commentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetCommentResponse, error)

	// UpdateCommentForNoteWithBodyWithResponse request with any body
	UpdateCommentForNoteWithBodyWithResponse(ctx context.Context, id int, commentId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCommentForNoteResponse, error)

	UpdateCommentForNoteWithResponse(ctx context.Context, id int, commentId openapi_types.UUID, body UpdateCommentForNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCommentForNoteResponse, error)

	// AuthorizeWithResponse request
	AuthorizeWithResponse(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*AuthorizeResponse, error)

	// GetTokensWithBodyWithResponse request with any body
	GetTokensWithBodyWithResponse(ctx context.Context, params *GetTokensParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTokensResponse, error)

	GetTokensWithFormdataBodyWithResponse(ctx context.Context, params *GetTokensParams, body GetTokensFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetTokensResponse, error)

	// RefreshTokensWithBodyWithResponse request with any body
	RefreshTokensWithBodyWithResponse(ctx context.Context, params *RefreshTokensParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokensResponse, error)

	RefreshTokensWithFormdataBodyWithResponse(ctx context.Context, params *RefreshTokensParams, body RefreshTokensFormdataRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokensResponse, error)

	// DeleteOrganizationFieldsWithResponse request
	DeleteOrganizationFieldsWithResponse(ctx context.Context, params *DeleteOrganizationFieldsParams, reqEditors ...RequestEditorFn) (*DeleteOrganizationFieldsResponse, error)

	// GetOrganizationRelationshipsWithResponse request
	GetOrganizationRelationshipsWithResponse(ctx context.Context, params *GetOrganizationRelationshipsParams, reqEditors ...RequestEditorFn) (*GetOrganizationRelationshipsResponse, error)

	// AddOrganizationRelationshipWithBodyWithResponse request with any body
	AddOrganizationRelationshipWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationRelationshipResponse, error)

	AddOrganizationRelationshipWithResponse(ctx context.Context, body AddOrganizationRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationRelationshipResponse, error)

	// DeleteOrganizationRelationshipWithResponse request
	DeleteOrganizationRelationshipWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteOrganizationRelationshipResponse, error)

	// GetOrganizationRelationshipWithResponse request
	GetOrganizationRelationshipWithResponse(ctx context.Context, id int, params *GetOrganizationRelationshipParams, reqEditors ...RequestEditorFn) (*GetOrganizationRelationshipResponse, error)

	// UpdateOrganizationRelationshipWithBodyWithResponse request with any body
	UpdateOrganizationRelationshipWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationRelationshipResponse, error)

	UpdateOrganizationRelationshipWithResponse(ctx context.Context, id int, body UpdateOrganizationRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationRelationshipResponse, error)

	// DeleteOrganizationsWithResponse request
	DeleteOrganizationsWithResponse(ctx context.Context, params *DeleteOrganizationsParams, reqEditors ...RequestEditorFn) (*DeleteOrganizationsResponse, error)

	// GetOrganizationsCollectionWithResponse request
	GetOrganizationsCollectionWithResponse(ctx context.Context, params *GetOrganizationsCollectionParams, reqEditors ...RequestEditorFn) (*GetOrganizationsCollectionResponse, error)

	// GetOrganizationActivitiesWithResponse request
	GetOrganizationActivitiesWithResponse(ctx context.Context, id int, params *GetOrganizationActivitiesParams, reqEditors ...RequestEditorFn) (*GetOrganizationActivitiesResponse, error)

	// GetOrganizationChangelogWithResponse request
	GetOrganizationChangelogWithResponse(ctx context.Context, id int, params *GetOrganizationChangelogParams, reqEditors ...RequestEditorFn) (*GetOrganizationChangelogResponse, error)

	// GetOrganizationDealsWithResponse request
	GetOrganizationDealsWithResponse(ctx context.Context, id int, params *GetOrganizationDealsParams, reqEditors ...RequestEditorFn) (*GetOrganizationDealsResponse, error)

	// GetOrganizationFilesWithResponse request
	GetOrganizationFilesWithResponse(ctx context.Context, id int, params *GetOrganizationFilesParams, reqEditors ...RequestEditorFn) (*GetOrganizationFilesResponse, error)

	// GetOrganizationUpdatesWithResponse request
	GetOrganizationUpdatesWithResponse(ctx context.Context, id int, params *GetOrganizationUpdatesParams, reqEditors ...RequestEditorFn) (*GetOrganizationUpdatesResponse, error)

	// GetOrganizationMailMessagesWithResponse request
	GetOrganizationMailMessagesWithResponse(ctx context.Context, id int, params *GetOrganizationMailMessagesParams, reqEditors ...RequestEditorFn) (*GetOrganizationMailMessagesResponse, error)

	// MergeOrganizationsWithBodyWithResponse request with any body
	MergeOrganizationsWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeOrganizationsResponse, error)

	MergeOrganizationsWithResponse(ctx context.Context, id int, body MergeOrganizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeOrganizationsResponse, error)

	// GetOrganizationUsersWithResponse request
	GetOrganizationUsersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetOrganizationUsersResponse, error)

	// GetOrganizationPersonsWithResponse request
	GetOrganizationPersonsWithResponse(ctx context.Context, id int, params *GetOrganizationPersonsParams, reqEditors ...RequestEditorFn) (*GetOrganizationPersonsResponse, error)

	// GetPermissionSetsWithResponse request
	GetPermissionSetsWithResponse(ctx context.Context, params *GetPermissionSetsParams, reqEditors ...RequestEditorFn) (*GetPermissionSetsResponse, error)

	// GetPermissionSetWithResponse request
	GetPermissionSetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPermissionSetResponse, error)

	// GetPermissionSetAssignmentsWithResponse request
	GetPermissionSetAssignmentsWithResponse(ctx context.Context, id string, params *GetPermissionSetAssignmentsParams, reqEditors ...RequestEditorFn) (*GetPermissionSetAssignmentsResponse, error)

	// DeletePersonFieldsWithResponse request
	DeletePersonFieldsWithResponse(ctx context.Context, params *DeletePersonFieldsParams, reqEditors ...RequestEditorFn) (*DeletePersonFieldsResponse, error)

	// DeletePersonsWithResponse request
	DeletePersonsWithResponse(ctx context.Context, params *DeletePersonsParams, reqEditors ...RequestEditorFn) (*DeletePersonsResponse, error)

	// GetPersonsCollectionWithResponse request
	GetPersonsCollectionWithResponse(ctx context.Context, params *GetPersonsCollectionParams, reqEditors ...RequestEditorFn) (*GetPersonsCollectionResponse, error)

	// GetPersonActivitiesWithResponse request
	GetPersonActivitiesWithResponse(ctx context.Context, id int, params *GetPersonActivitiesParams, reqEditors ...RequestEditorFn) (*GetPersonActivitiesResponse, error)

	// GetPersonChangelogWithResponse request
	GetPersonChangelogWithResponse(ctx context.Context, id int, params *GetPersonChangelogParams, reqEditors ...RequestEditorFn) (*GetPersonChangelogResponse, error)

	// GetPersonDealsWithResponse request
	GetPersonDealsWithResponse(ctx context.Context, id int, params *GetPersonDealsParams, reqEditors ...RequestEditorFn) (*GetPersonDealsResponse, error)

	// GetPersonFilesWithResponse request
	GetPersonFilesWithResponse(ctx context.Context, id int, params *GetPersonFilesParams, reqEditors ...RequestEditorFn) (*GetPersonFilesResponse, error)

	// GetPersonUpdatesWithResponse request
	GetPersonUpdatesWithResponse(ctx context.Context, id int, params *GetPersonUpdatesParams, reqEditors ...RequestEditorFn) (*GetPersonUpdatesResponse, error)

	// GetPersonMailMessagesWithResponse request
	GetPersonMailMessagesWithResponse(ctx context.Context, id int, params *GetPersonMailMessagesParams, reqEditors ...RequestEditorFn) (*GetPersonMailMessagesResponse, error)

	// MergePersonsWithBodyWithResponse request with any body
	MergePersonsWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergePersonsResponse, error)

	MergePersonsWithResponse(ctx context.Context, id int, body MergePersonsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergePersonsResponse, error)

	// GetPersonUsersWithResponse request
	GetPersonUsersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonUsersResponse, error)

	// DeletePersonPictureWithResponse request
	DeletePersonPictureWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeletePersonPictureResponse, error)

	// AddPersonPictureWithBodyWithResponse request with any body
	AddPersonPictureWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPersonPictureResponse, error)

	// GetPersonProductsWithResponse request
	GetPersonProductsWithResponse(ctx context.Context, id int, params *GetPersonProductsParams, reqEditors ...RequestEditorFn) (*GetPersonProductsResponse, error)

	// GetPipelineConversionStatisticsWithResponse request
	GetPipelineConversionStatisticsWithResponse(ctx context.Context, id int, params *GetPipelineConversionStatisticsParams, reqEditors ...RequestEditorFn) (*GetPipelineConversionStatisticsResponse, error)

	// GetPipelineDealsWithResponse request
	GetPipelineDealsWithResponse(ctx context.Context, id int, params *GetPipelineDealsParams, reqEditors ...RequestEditorFn) (*GetPipelineDealsResponse, error)

	// GetPipelineMovementStatisticsWithResponse request
	GetPipelineMovementStatisticsWithResponse(ctx context.Context, id int, params *GetPipelineMovementStatisticsParams, reqEditors ...RequestEditorFn) (*GetPipelineMovementStatisticsResponse, error)

	// DeleteProductFieldsWithResponse request
	DeleteProductFieldsWithResponse(ctx context.Context, params *DeleteProductFieldsParams, reqEditors ...RequestEditorFn) (*DeleteProductFieldsResponse, error)

	// GetProductDealsWithResponse request
	GetProductDealsWithResponse(ctx context.Context, id int, params *GetProductDealsParams, reqEditors ...RequestEditorFn) (*GetProductDealsResponse, error)

	// GetProductFilesWithResponse request
	GetProductFilesWithResponse(ctx context.Context, id int, params *GetProductFilesParams, reqEditors ...RequestEditorFn) (*GetProductFilesResponse, error)

	// GetProductUsersWithResponse request
	GetProductUsersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProductUsersResponse, error)

	// GetProjectTemplatesWithResponse request
	GetProjectTemplatesWithResponse(ctx context.Context, params *GetProjectTemplatesParams, reqEditors ...RequestEditorFn) (*GetProjectTemplatesResponse, error)

	// GetProjectTemplateWithResponse request
	GetProjectTemplateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectTemplateResponse, error)

	// GetProjectsWithResponse request
	GetProjectsWithResponse(ctx context.Context, params *GetProjectsParams, reqEditors ...RequestEditorFn) (*GetProjectsResponse, error)

	// AddProjectWithBodyWithResponse request with any body
	AddProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProjectResponse, error)

	AddProjectWithResponse(ctx context.Context, body AddProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProjectResponse, error)

	// GetProjectsBoardsWithResponse request
	GetProjectsBoardsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProjectsBoardsResponse, error)

	// GetProjectsBoardWithResponse request
	GetProjectsBoardWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectsBoardResponse, error)

	// GetProjectsPhasesWithResponse request
	GetProjectsPhasesWithResponse(ctx context.Context, params *GetProjectsPhasesParams, reqEditors ...RequestEditorFn) (*GetProjectsPhasesResponse, error)

	// GetProjectsPhaseWithResponse request
	GetProjectsPhaseWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectsPhaseResponse, error)

	// DeleteProjectWithResponse request
	DeleteProjectWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error)

	// GetProjectWithResponse request
	GetProjectWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectResponse, error)

	// UpdateProjectWithBodyWithResponse request with any body
	UpdateProjectWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	UpdateProjectWithResponse(ctx context.Context, id int, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	// GetProjectActivitiesWithResponse request
	GetProjectActivitiesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectActivitiesResponse, error)

	// ArchiveProjectWithResponse request
	ArchiveProjectWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ArchiveProjectResponse, error)

	// GetProjectGroupsWithResponse request
	GetProjectGroupsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectGroupsResponse, error)

	// GetProjectPlanWithResponse request
	GetProjectPlanWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectPlanResponse, error)

	// PutProjectPlanActivityWithBodyWithResponse request with any body
	PutProjectPlanActivityWithBodyWithResponse(ctx context.Context, id int, activityId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutProjectPlanActivityResponse, error)

	PutProjectPlanActivityWithResponse(ctx context.Context, id int, activityId int, body PutProjectPlanActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*PutProjectPlanActivityResponse, error)

	// PutProjectPlanTaskWithBodyWithResponse request with any body
	PutProjectPlanTaskWithBodyWithResponse(ctx context.Context, id int, taskId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutProjectPlanTaskResponse, error)

	PutProjectPlanTaskWithResponse(ctx context.Context, id int, taskId int, body PutProjectPlanTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*PutProjectPlanTaskResponse, error)

	// GetProjectTasksWithResponse request
	GetProjectTasksWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectTasksResponse, error)

	// GetRecentsWithResponse request
	GetRecentsWithResponse(ctx context.Context, params *GetRecentsParams, reqEditors ...RequestEditorFn) (*GetRecentsResponse, error)

	// GetRolesWithResponse request
	GetRolesWithResponse(ctx context.Context, params *GetRolesParams, reqEditors ...RequestEditorFn) (*GetRolesResponse, error)

	// AddRoleWithBodyWithResponse request with any body
	AddRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRoleResponse, error)

	AddRoleWithResponse(ctx context.Context, body AddRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRoleResponse, error)

	// DeleteRoleWithResponse request
	DeleteRoleWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error)

	// GetRoleWithResponse request
	GetRoleWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// UpdateRoleWithBodyWithResponse request with any body
	UpdateRoleWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	UpdateRoleWithResponse(ctx context.Context, id int, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	// DeleteRoleAssignmentWithBodyWithResponse request with any body
	DeleteRoleAssignmentWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRoleAssignmentResponse, error)

	DeleteRoleAssignmentWithResponse(ctx context.Context, id int, body DeleteRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRoleAssignmentResponse, error)

	// GetRoleAssignmentsWithResponse request
	GetRoleAssignmentsWithResponse(ctx context.Context, id int, params *GetRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*GetRoleAssignmentsResponse, error)

	// AddRoleAssignmentWithBodyWithResponse request with any body
	AddRoleAssignmentWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRoleAssignmentResponse, error)

	AddRoleAssignmentWithResponse(ctx context.Context, id int, body AddRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRoleAssignmentResponse, error)

	// GetRolePipelinesWithResponse request
	GetRolePipelinesWithResponse(ctx context.Context, id int, params *GetRolePipelinesParams, reqEditors ...RequestEditorFn) (*GetRolePipelinesResponse, error)

	// UpdateRolePipelinesWithBodyWithResponse request with any body
	UpdateRolePipelinesWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRolePipelinesResponse, error)

	UpdateRolePipelinesWithResponse(ctx context.Context, id int, body UpdateRolePipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRolePipelinesResponse, error)

	// GetRoleSettingsWithResponse request
	GetRoleSettingsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetRoleSettingsResponse, error)

	// AddOrUpdateRoleSettingWithBodyWithResponse request with any body
	AddOrUpdateRoleSettingWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateRoleSettingResponse, error)

	AddOrUpdateRoleSettingWithResponse(ctx context.Context, id int, body AddOrUpdateRoleSettingJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateRoleSettingResponse, error)

	// DeleteStagesWithResponse request
	DeleteStagesWithResponse(ctx context.Context, params *DeleteStagesParams, reqEditors ...RequestEditorFn) (*DeleteStagesResponse, error)

	// GetStageDealsWithResponse request
	GetStageDealsWithResponse(ctx context.Context, id int, params *GetStageDealsParams, reqEditors ...RequestEditorFn) (*GetStageDealsResponse, error)

	// GetTasksWithResponse request
	GetTasksWithResponse(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*GetTasksResponse, error)

	// AddTaskWithBodyWithResponse request with any body
	AddTaskWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTaskResponse, error)

	AddTaskWithResponse(ctx context.Context, body AddTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTaskResponse, error)

	// DeleteTaskWithResponse request
	DeleteTaskWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteTaskResponse, error)

	// GetTaskWithResponse request
	GetTaskWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTaskResponse, error)

	// UpdateTaskWithBodyWithResponse request with any body
	UpdateTaskWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error)

	UpdateTaskWithResponse(ctx context.Context, id int, body UpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error)

	// GetUserConnectionsWithResponse request
	GetUserConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserConnectionsResponse, error)

	// GetUserSettingsWithResponse request
	GetUserSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserSettingsResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// AddUserWithBodyWithResponse request with any body
	AddUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserResponse, error)

	AddUserWithResponse(ctx context.Context, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserResponse, error)

	// FindUsersByNameWithResponse request
	FindUsersByNameWithResponse(ctx context.Context, params *FindUsersByNameParams, reqEditors ...RequestEditorFn) (*FindUsersByNameResponse, error)

	// GetCurrentUserWithResponse request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// GetUserPermissionsWithResponse request
	GetUserPermissionsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUserPermissionsResponse, error)

	// GetUserRoleAssignmentsWithResponse request
	GetUserRoleAssignmentsWithResponse(ctx context.Context, id int, params *GetUserRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*GetUserRoleAssignmentsResponse, error)

	// GetUserRoleSettingsWithResponse request
	GetUserRoleSettingsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUserRoleSettingsResponse, error)

	// GetWebhooksWithResponse request
	GetWebhooksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebhooksResponse, error)

	// AddWebhookWithBodyWithResponse request with any body
	AddWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddWebhookResponse, error)

	AddWebhookWithResponse(ctx context.Context, body AddWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*AddWebhookResponse, error)

	// DeleteWebhookWithResponse request
	DeleteWebhookWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error)
}

type DeleteActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id An array of the IDs of activities that were deleted
			Id *[]int `json:"id,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivitiesCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// ActiveFlag Whether the activity is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// BusyFlag Marks if the activity is set as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
			BusyFlag *bool `json:"busy_flag,omitempty"`

			// CompanyId The user's company ID
			CompanyId *int `json:"company_id,omitempty"`

			// ConferenceMeetingClient The ID of the Marketplace app, which is connected to this activity
			ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

			// ConferenceMeetingId The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
			ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

			// ConferenceMeetingUrl The link to join the meeting which is associated with this activity
			ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

			// DealId The ID of the deal this activity is associated with
			DealId *int `json:"deal_id,omitempty"`

			// Done Whether the activity is done or not
			Done *bool `json:"done,omitempty"`

			// DueDate The due date of the activity. Format: YYYY-MM-DD
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// DueTime The due time of the activity in UTC. Format: HH:MM
			DueTime *string `json:"due_time,omitempty"`

			// Duration The duration of the activity. Format: HH:MM
			Duration *string `json:"duration,omitempty"`

			// Id The ID of the activity, generated when the activity was created
			Id *int `json:"id,omitempty"`

			// LeadId The ID of the lead in the UUID format this activity is associated with
			LeadId *openapi_types.UUID `json:"lead_id"`

			// Location The address of the activity.
			Location *string `json:"location,omitempty"`

			// LocationAdminAreaLevel1 A subfield of the location field. Indicates state/county.
			LocationAdminAreaLevel1 *string `json:"location_admin_area_level_1,omitempty"`

			// LocationAdminAreaLevel2 A subfield of the location field. Indicates region.
			LocationAdminAreaLevel2 *string `json:"location_admin_area_level_2,omitempty"`

			// LocationCountry A subfield of the location field. Indicates country.
			LocationCountry *string `json:"location_country,omitempty"`

			// LocationFormattedAddress A subfield of the location field. Indicates full/combined address.
			LocationFormattedAddress *string `json:"location_formatted_address,omitempty"`

			// LocationLocality A subfield of the location field. Indicates city/town/village/locality.
			LocationLocality *string `json:"location_locality,omitempty"`

			// LocationPostalCode A subfield of the location field. Indicates ZIP/postal code.
			LocationPostalCode *string `json:"location_postal_code,omitempty"`

			// LocationRoute A subfield of the location field. Indicates street name.
			LocationRoute *string `json:"location_route,omitempty"`

			// LocationStreetNumber A subfield of the location field. Indicates house number.
			LocationStreetNumber *string `json:"location_street_number,omitempty"`

			// LocationSublocality A subfield of the location field. Indicates district/sublocality.
			LocationSublocality *string `json:"location_sublocality,omitempty"`

			// LocationSubpremise A subfield of the location field. Indicates apartment/suite number.
			LocationSubpremise *string `json:"location_subpremise,omitempty"`

			// MarkedAsDoneTime The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// OrgId The ID of the organization this activity is associated with
			OrgId *int `json:"org_id,omitempty"`

			// PersonId The ID of the person this activity is associated with
			PersonId *int `json:"person_id,omitempty"`

			// ProjectId The ID of the project this activity is associated with
			ProjectId *int `json:"project_id"`

			// PublicDescription Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
			PublicDescription *string `json:"public_description,omitempty"`

			// SourceTimezone The timezone the activity was created in an external calendar
			SourceTimezone *string `json:"source_timezone,omitempty"`

			// Subject The subject of the activity
			Subject *string `json:"subject,omitempty"`

			// Type The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
			Type *string `json:"type,omitempty"`

			// UpdateTime The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`

			// UpdateUserId The ID of the user who was the last to update this activity
			UpdateUserId *int `json:"update_user_id,omitempty"`

			// UserId The ID of the user whom the activity is assigned to
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetActivitiesCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivitiesCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteActivityTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The IDs of the deleted activity types
			Id *[]int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteActivityTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteActivityTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The array of activity types
		Data *[]struct {
			// ActiveFlag The active flag of the activity type
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation time of the activity type
			AddTime *time.Time `json:"add_time,omitempty"`

			// Color A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
			Color *string `json:"color,omitempty"`

			// IconKey Icon graphic to use for representing this activity type
			IconKey *GetActivityTypes200DataIconKey `json:"icon_key,omitempty"`

			// Id The ID of the activity type
			Id *int `json:"id,omitempty"`

			// IsCustomFlag Whether the activity type is a custom one or not
			IsCustomFlag *bool `json:"is_custom_flag,omitempty"`

			// KeyString A string that is generated by the API based on the given name of the activity type upon creation
			KeyString *string `json:"key_string,omitempty"`

			// Name The name of the activity type
			Name *string `json:"name,omitempty"`

			// OrderNr An order number for the activity type. Order numbers should be used to order the types in the activity type selections.
			OrderNr *int `json:"order_nr,omitempty"`

			// UpdateTime The update time of the activity type
			UpdateTime *time.Time `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetActivityTypes200DataIconKey string

// Status returns HTTPResponse.Status
func (r GetActivityTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddActivityTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag The active flag of the activity type
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation time of the activity type
			AddTime *time.Time `json:"add_time,omitempty"`

			// Color A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
			Color *string `json:"color,omitempty"`

			// IconKey Icon graphic to use for representing this activity type
			IconKey *AddActivityType200DataIconKey `json:"icon_key,omitempty"`

			// Id The ID of the activity type
			Id *int `json:"id,omitempty"`

			// IsCustomFlag Whether the activity type is a custom one or not
			IsCustomFlag *bool `json:"is_custom_flag,omitempty"`

			// KeyString A string that is generated by the API based on the given name of the activity type upon creation
			KeyString *string `json:"key_string,omitempty"`

			// Name The name of the activity type
			Name *string `json:"name,omitempty"`

			// OrderNr An order number for the activity type. Order numbers should be used to order the types in the activity type selections.
			OrderNr *int `json:"order_nr,omitempty"`

			// UpdateTime The update time of the activity type
			UpdateTime *time.Time `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type AddActivityType200DataIconKey string

// Status returns HTTPResponse.Status
func (r AddActivityTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddActivityTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteActivityTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag The active flag of the activity type
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation time of the activity type
			AddTime *time.Time `json:"add_time,omitempty"`

			// Color A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
			Color *string `json:"color,omitempty"`

			// IconKey Icon graphic to use for representing this activity type
			IconKey *DeleteActivityType200DataIconKey `json:"icon_key,omitempty"`

			// Id The ID of the activity type
			Id *int `json:"id,omitempty"`

			// IsCustomFlag Whether the activity type is a custom one or not
			IsCustomFlag *bool `json:"is_custom_flag,omitempty"`

			// KeyString A string that is generated by the API based on the given name of the activity type upon creation
			KeyString *string `json:"key_string,omitempty"`

			// Name The name of the activity type
			Name *string `json:"name,omitempty"`

			// OrderNr An order number for the activity type. Order numbers should be used to order the types in the activity type selections.
			OrderNr *int `json:"order_nr,omitempty"`

			// UpdateTime The update time of the activity type
			UpdateTime *time.Time `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type DeleteActivityType200DataIconKey string

// Status returns HTTPResponse.Status
func (r DeleteActivityTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteActivityTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateActivityTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag The active flag of the activity type
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation time of the activity type
			AddTime *time.Time `json:"add_time,omitempty"`

			// Color A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
			Color *string `json:"color,omitempty"`

			// IconKey Icon graphic to use for representing this activity type
			IconKey *UpdateActivityType200DataIconKey `json:"icon_key,omitempty"`

			// Id The ID of the activity type
			Id *int `json:"id,omitempty"`

			// IsCustomFlag Whether the activity type is a custom one or not
			IsCustomFlag *bool `json:"is_custom_flag,omitempty"`

			// KeyString A string that is generated by the API based on the given name of the activity type upon creation
			KeyString *string `json:"key_string,omitempty"`

			// Name The name of the activity type
			Name *string `json:"name,omitempty"`

			// OrderNr An order number for the activity type. Order numbers should be used to order the types in the activity type selections.
			OrderNr *int `json:"order_nr,omitempty"`

			// UpdateTime The update time of the activity type
			UpdateTime *time.Time `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type UpdateActivityType200DataIconKey string

// Status returns HTTPResponse.Status
func (r UpdateActivityTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateActivityTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompanyAddonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An array of add-ons that the company has.
		Data *[]map[string]interface{} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCompanyAddonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompanyAddonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserCallLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// Pagination The additional data of the list
			Pagination *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"pagination,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// ActivityId If specified, this activity will be converted into a call log, with the information provided. When this field is used, you don't need to specify `deal_id`, `person_id` or `org_id`, as they will be ignored in favor of the values already available in the activity. The `activity_id` must refer to a `call` type activity.
			ActivityId *int `json:"activity_id,omitempty"`

			// CompanyId The company ID of the owner of the call log
			CompanyId *int `json:"company_id,omitempty"`

			// DealId The ID of the deal this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
			DealId *int `json:"deal_id,omitempty"`

			// Duration The duration of the call in seconds
			Duration *string `json:"duration,omitempty"`

			// EndTime The date and time of the end of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
			EndTime time.Time `json:"end_time"`

			// FromPhoneNumber The number that made the call
			FromPhoneNumber *string `json:"from_phone_number,omitempty"`

			// HasRecording If the call log has an audio recording attached, the value should be true
			HasRecording *bool `json:"has_recording,omitempty"`

			// Id The call log ID, generated when the call log was created
			Id *string `json:"id,omitempty"`

			// LeadId The ID of the lead in the UUID format this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// Note The note for the call log in HTML format
			Note *string `json:"note,omitempty"`

			// OrgId The ID of the organization this call is associated with
			OrgId *int `json:"org_id,omitempty"`

			// Outcome Describes the outcome of the call
			Outcome GetUserCallLogs200DataOutcome `json:"outcome"`

			// PersonId The ID of the person this call is associated with
			PersonId *int `json:"person_id,omitempty"`

			// StartTime The date and time of the start of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
			StartTime time.Time `json:"start_time"`

			// Subject The name of the activity this call is attached to
			Subject *string `json:"subject,omitempty"`

			// ToPhoneNumber The number called
			ToPhoneNumber string `json:"to_phone_number"`

			// UserId The ID of the owner of the call log. Please note that a user without account settings access cannot create call logs for other users.
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetUserCallLogs200DataOutcome string

// Status returns HTTPResponse.Status
func (r GetUserCallLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserCallLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddCallLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActivityId If specified, this activity will be converted into a call log, with the information provided. When this field is used, you don't need to specify `deal_id`, `person_id` or `org_id`, as they will be ignored in favor of the values already available in the activity. The `activity_id` must refer to a `call` type activity.
			ActivityId *int `json:"activity_id,omitempty"`

			// CompanyId The company ID of the owner of the call log
			CompanyId *int `json:"company_id,omitempty"`

			// DealId The ID of the deal this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
			DealId *int `json:"deal_id,omitempty"`

			// Duration The duration of the call in seconds
			Duration *string `json:"duration,omitempty"`

			// EndTime The date and time of the end of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
			EndTime time.Time `json:"end_time"`

			// FromPhoneNumber The number that made the call
			FromPhoneNumber *string `json:"from_phone_number,omitempty"`

			// HasRecording If the call log has an audio recording attached, the value should be true
			HasRecording *bool `json:"has_recording,omitempty"`

			// Id The call log ID, generated when the call log was created
			Id *string `json:"id,omitempty"`

			// LeadId The ID of the lead in the UUID format this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// Note The note for the call log in HTML format
			Note *string `json:"note,omitempty"`

			// OrgId The ID of the organization this call is associated with
			OrgId *int `json:"org_id,omitempty"`

			// Outcome Describes the outcome of the call
			Outcome AddCallLog200DataOutcome `json:"outcome"`

			// PersonId The ID of the person this call is associated with
			PersonId *int `json:"person_id,omitempty"`

			// StartTime The date and time of the start of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
			StartTime time.Time `json:"start_time"`

			// Subject The name of the activity this call is attached to
			Subject *string `json:"subject,omitempty"`

			// ToPhoneNumber The number called
			ToPhoneNumber string `json:"to_phone_number"`

			// UserId The ID of the owner of the call log. Please note that a user without account settings access cannot create call logs for other users.
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON400 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
	JSON403 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
	JSON500 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}
type AddCallLog200DataOutcome string

// Status returns HTTPResponse.Status
func (r AddCallLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddCallLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCallLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
	JSON410 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
	JSON500 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteCallLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCallLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCallLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActivityId If specified, this activity will be converted into a call log, with the information provided. When this field is used, you don't need to specify `deal_id`, `person_id` or `org_id`, as they will be ignored in favor of the values already available in the activity. The `activity_id` must refer to a `call` type activity.
			ActivityId *int `json:"activity_id,omitempty"`

			// CompanyId The company ID of the owner of the call log
			CompanyId *int `json:"company_id,omitempty"`

			// DealId The ID of the deal this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
			DealId *int `json:"deal_id,omitempty"`

			// Duration The duration of the call in seconds
			Duration *string `json:"duration,omitempty"`

			// EndTime The date and time of the end of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
			EndTime time.Time `json:"end_time"`

			// FromPhoneNumber The number that made the call
			FromPhoneNumber *string `json:"from_phone_number,omitempty"`

			// HasRecording If the call log has an audio recording attached, the value should be true
			HasRecording *bool `json:"has_recording,omitempty"`

			// Id The call log ID, generated when the call log was created
			Id *string `json:"id,omitempty"`

			// LeadId The ID of the lead in the UUID format this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// Note The note for the call log in HTML format
			Note *string `json:"note,omitempty"`

			// OrgId The ID of the organization this call is associated with
			OrgId *int `json:"org_id,omitempty"`

			// Outcome Describes the outcome of the call
			Outcome GetCallLog200DataOutcome `json:"outcome"`

			// PersonId The ID of the person this call is associated with
			PersonId *int `json:"person_id,omitempty"`

			// StartTime The date and time of the start of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
			StartTime time.Time `json:"start_time"`

			// Subject The name of the activity this call is attached to
			Subject *string `json:"subject,omitempty"`

			// ToPhoneNumber The number called
			ToPhoneNumber string `json:"to_phone_number"`

			// UserId The ID of the owner of the call log. Please note that a user without account settings access cannot create call logs for other users.
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}
type GetCallLog200DataOutcome string

// Status returns HTTPResponse.Status
func (r GetCallLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCallLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddCallLogAudioFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
	JSON409 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
	JSON500 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddCallLogAudioFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddCallLogAudioFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// AvatarUrl The URL for an icon that represents your channel
			AvatarUrl *string `json:"avatar_url,omitempty"`

			// CreatedAt The date and time when your channel was created in the API
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Id The unique channel ID used internally in omnichannel-api and the frontend of the extension
			Id *string `json:"id,omitempty"`

			// MarketplaceClientId The client_id of your app in Pipedrive marketplace
			MarketplaceClientId *string `json:"marketplace_client_id,omitempty"`

			// Name The name of the channel
			Name *string `json:"name,omitempty"`

			// PdCompanyId The ID of the user's company in Pipedrive
			PdCompanyId *int `json:"pd_company_id,omitempty"`

			// PdUserId The ID of the user in Pipedrive
			PdUserId *int `json:"pd_user_id,omitempty"`

			// ProviderChannelId The channel ID you specified while creating the channel
			ProviderChannelId *string `json:"provider_channel_id,omitempty"`

			// ProviderType Value of the provider_type sent to this endpoint
			ProviderType *AddChannel200DataProviderType `json:"provider_type,omitempty"`

			// TemplateSupport Value of the template_support sent to this endpoint
			TemplateSupport *bool `json:"template_support,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON400 *struct {
		AdditionalData *struct {
			// Code An error code sent by the API
			Code *string `json:"code,omitempty"`
		} `json:"additional_data,omitempty"`

		// Error The error description
		Error     *string `json:"error,omitempty"`
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
	JSON403 *struct {
		AdditionalData *struct {
			// Code An error code sent by the API
			Code *string `json:"code,omitempty"`
		} `json:"additional_data,omitempty"`

		// Error The error description
		Error     *string `json:"error,omitempty"`
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}
type AddChannel200DataProviderType string

// Status returns HTTPResponse.Status
func (r AddChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiveMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Attachments The list of attachments available in the message
			Attachments *[]struct {
				// Id The ID of the attachment
				Id string `json:"id"`

				// LinkExpires If true, it will use the getMessageById endpoint for fetching updated attachment's urls. Find out more [here](https://pipedrive.readme.io/docs/implementing-messaging-app-extension)
				LinkExpires *bool `json:"link_expires,omitempty"`

				// Name The name of the attachment
				Name *string `json:"name,omitempty"`

				// PreviewUrl A URL to a preview picture of the file
				PreviewUrl *string `json:"preview_url,omitempty"`

				// Size The size of the attachment
				Size *float32 `json:"size,omitempty"`

				// Type The mime-type of the attachment
				Type string `json:"type"`

				// Url A URL to the file
				Url string `json:"url"`
			} `json:"attachments,omitempty"`

			// ChannelId The channel ID as in the provider
			ChannelId string `json:"channel_id"`

			// ConversationId The ID of the conversation
			ConversationId string `json:"conversation_id"`

			// ConversationLink A URL that can open the conversation in the provider's side
			ConversationLink *string `json:"conversation_link,omitempty"`

			// CreatedAt The date and time when the message was created in the provider, in UTC. Format: YYYY-MM-DD HH:MM
			CreatedAt time.Time `json:"created_at"`

			// Id The ID of the message
			Id string `json:"id"`

			// Message The body of the message
			Message string `json:"message"`

			// ReplyBy The date and time when the message can no longer receive a reply, in UTC. Format: YYYY-MM-DD HH:MM
			ReplyBy *time.Time `json:"reply_by,omitempty"`

			// SenderId The ID of the provider's user that sent the message
			SenderId string `json:"sender_id"`

			// Status The status of the message
			Status ReceiveMessage200DataStatus `json:"status"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON400 *struct {
		AdditionalData *struct {
			// Code An error code sent by the API
			Code *string `json:"code,omitempty"`
		} `json:"additional_data,omitempty"`

		// Error The error description
		Error     *string `json:"error,omitempty"`
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}
type ReceiveMessage200DataStatus string

// Status returns HTTPResponse.Status
func (r ReceiveMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiveMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		AdditionalData *struct {
			// Code An error code sent by the API
			Code *string `json:"code,omitempty"`
		} `json:"additional_data,omitempty"`

		// Error The error description
		Error     *string `json:"error,omitempty"`
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
	JSON404 *struct {
		AdditionalData *struct {
			// Code An error code sent by the API
			Code *string `json:"code,omitempty"`
		} `json:"additional_data,omitempty"`

		// Error The error description
		Error     *string `json:"error,omitempty"`
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Success *bool `json:"success,omitempty"`
	}
	JSON400 *struct {
		AdditionalData *struct {
			// Code An error code sent by the API
			Code *string `json:"code,omitempty"`
		} `json:"additional_data,omitempty"`

		// Error The error description
		Error     *string `json:"error,omitempty"`
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The array of currencies
		Data *[]struct {
			// ActiveFlag Whether the currency is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// Code The code of the currency
			Code *string `json:"code,omitempty"`

			// DecimalPoints The amount of decimal points of the currency
			DecimalPoints *int `json:"decimal_points,omitempty"`

			// Id The ID of the currency
			Id *int `json:"id,omitempty"`

			// IsCustomFlag Whether the currency is a custom one or not
			IsCustomFlag *bool `json:"is_custom_flag,omitempty"`

			// Name The name of the currency
			Name *string `json:"name,omitempty"`

			// Symbol The symbol of the currency
			Symbol *string `json:"symbol,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCurrenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDealFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The list of deleted field IDs
			Id *[]int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDealFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDealFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The list of deleted deals IDs
			Id *[]int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealsCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// AddTime The creation date and time of the deal in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// CloseTime The date and time of closing the deal in UTC. Format: YYYY-MM-DD HH:MM:SS.
			CloseTime *string `json:"close_time"`

			// CreatorUserId The ID of the deal creator
			CreatorUserId *int `json:"creator_user_id,omitempty"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// Label The label or multiple labels assigned to the deal
			Label *string `json:"label,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status to lost in UTC. Format: YYYY-MM-DD HH:MM:SS.
			LostTime *string `json:"lost_time,omitempty"`

			// OrgId The ID of the organization associated with the deal
			OrgId *int `json:"org_id,omitempty"`

			// PersonId The ID of the person associated with the deal
			PersonId *int `json:"person_id,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UpdateTime The last update date and time of the deal in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`

			// UserId The ID of the user
			UserId *int `json:"user_id,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *string `json:"visible_to,omitempty"`

			// WonTime The date and time of changing the deal status to won in UTC. Format: YYYY-MM-DD HH:MM:SS.
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealsCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealsCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealsSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The summary of deals
		Data *struct {
			// TotalCount The total number of deals
			TotalCount *int `json:"total_count,omitempty"`

			// TotalCurrencyConvertedValue The total value of deals converted into the company default currency
			TotalCurrencyConvertedValue *float32 `json:"total_currency_converted_value,omitempty"`

			// TotalCurrencyConvertedValueFormatted The total converted value of deals formatted with the company default currency. E.g. US$5,100.96
			TotalCurrencyConvertedValueFormatted *string `json:"total_currency_converted_value_formatted,omitempty"`

			// TotalWeightedCurrencyConvertedValue The total weighted value of deals converted into the company default currency
			TotalWeightedCurrencyConvertedValue *float32 `json:"total_weighted_currency_converted_value,omitempty"`

			// TotalWeightedCurrencyConvertedValueFormatted The total weighted value of deals formatted with the company default currency. E.g. US$5,100.96
			TotalWeightedCurrencyConvertedValueFormatted *string `json:"total_weighted_currency_converted_value_formatted,omitempty"`

			// ValuesTotal The total values of the deals grouped by deal currency
			ValuesTotal *struct {
				// Count The number of deals in the deal currency group
				Count *int `json:"count,omitempty"`

				// Value The total value of deals in the deal currency group
				Value *float32 `json:"value,omitempty"`

				// ValueConverted The total value of deals converted into the company default currency
				ValueConverted *float32 `json:"value_converted,omitempty"`

				// ValueConvertedFormatted The value_converted formatted with deal currency. E.g. US$50.10
				ValueConvertedFormatted *string `json:"value_converted_formatted,omitempty"`

				// ValueFormatted The total value of deals formatted with deal currency. E.g. 50
				ValueFormatted *string `json:"value_formatted,omitempty"`
			} `json:"values_total,omitempty"`

			// WeightedValuesTotal The total weighted values of the deals grouped by deal currency. The weighted value is calculated as probability times deal value.
			WeightedValuesTotal *struct {
				// Count The number of deals in the deal currency group
				Count *int `json:"count,omitempty"`

				// Value The total weighted value of the deals in the deal currency group
				Value *float32 `json:"value,omitempty"`

				// ValueFormatted The total weighted value of the deals formatted with deal currency. E.g. 50
				ValueFormatted *string `json:"value_formatted,omitempty"`
			} `json:"weighted_values_total,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealsSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealsSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArchivedDealsSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The summary of deals
		Data *struct {
			// TotalCount The total number of deals
			TotalCount *int `json:"total_count,omitempty"`

			// TotalCurrencyConvertedValue The total value of deals converted into the company default currency
			TotalCurrencyConvertedValue *float32 `json:"total_currency_converted_value,omitempty"`

			// TotalCurrencyConvertedValueFormatted The total converted value of deals formatted with the company default currency. E.g. US$5,100.96
			TotalCurrencyConvertedValueFormatted *string `json:"total_currency_converted_value_formatted,omitempty"`

			// TotalWeightedCurrencyConvertedValue The total weighted value of deals converted into the company default currency
			TotalWeightedCurrencyConvertedValue *float32 `json:"total_weighted_currency_converted_value,omitempty"`

			// TotalWeightedCurrencyConvertedValueFormatted The total weighted value of deals formatted with the company default currency. E.g. US$5,100.96
			TotalWeightedCurrencyConvertedValueFormatted *string `json:"total_weighted_currency_converted_value_formatted,omitempty"`

			// ValuesTotal The total values of the deals grouped by deal currency
			ValuesTotal *struct {
				// Count The number of deals in the deal currency group
				Count *int `json:"count,omitempty"`

				// Value The total value of deals in the deal currency group
				Value *float32 `json:"value,omitempty"`

				// ValueConverted The total value of deals converted into the company default currency
				ValueConverted *float32 `json:"value_converted,omitempty"`

				// ValueConvertedFormatted The value_converted formatted with deal currency. E.g. US$50.10
				ValueConvertedFormatted *string `json:"value_converted_formatted,omitempty"`

				// ValueFormatted The total value of deals formatted with deal currency. E.g. 50
				ValueFormatted *string `json:"value_formatted,omitempty"`
			} `json:"values_total,omitempty"`

			// WeightedValuesTotal The total weighted values of the deals grouped by deal currency. The weighted value is calculated as probability times deal value.
			WeightedValuesTotal *struct {
				// Count The number of deals in the deal currency group
				Count *int `json:"count,omitempty"`

				// Value The total weighted value of the deals in the deal currency group
				Value *float32 `json:"value,omitempty"`

				// ValueFormatted The total weighted value of the deals formatted with deal currency. E.g. 50
				ValueFormatted *string `json:"value_formatted,omitempty"`
			} `json:"weighted_values_total,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetArchivedDealsSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArchivedDealsSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealsTimelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Open and won deals grouped into periods by defined interval, amount and date-type dealField (`field_key`)
		Data *struct {
			Deals *[]struct {
				// Active Whether the deal is active or not
				Active *bool `json:"active,omitempty"`

				// ActivitiesCount The number of activities associated with the deal
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AcvCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Contract Value of the deal
				//
				// If the `acv` is null, this will also be null
				AcvCurrency *string `json:"acv_currency"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// ArrCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Recurring Revenue of the deal
				//
				// If the `arr` is null, this will also be null
				ArrCurrency *string `json:"arr_currency"`

				// CcEmail The BCC email of the deal
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// CreatorUserId The ID of the deal creator
				CreatorUserId *int `json:"creator_user_id,omitempty"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// Deleted Whether the deal is deleted or not
				Deleted *bool `json:"deleted,omitempty"`

				// DoneActivitiesCount The number of completed activities associated with the deal
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// EmailMessagesCount The number of emails associated with the deal
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// FilesCount The number of files associated with the deal
				FilesCount *int `json:"files_count,omitempty"`

				// FirstWonTime The date and time of the first time changing the deal status as won
				FirstWonTime *string `json:"first_won_time,omitempty"`

				// FollowersCount The number of followers associated with the deal
				FollowersCount *int `json:"followers_count,omitempty"`

				// FormattedValue The deal value formatted with selected currency. E.g. US$500
				FormattedValue *string `json:"formatted_value,omitempty"`

				// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
				FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// Label The label or multiple labels assigned to the deal
				Label *string `json:"label,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the deal
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// MrrCurrency Only available in Growth and above plans
				//
				// The Currency for Monthly Recurring Revenue of the deal
				//
				// If the `mrr` is null, this will also be null
				MrrCurrency *string `json:"mrr_currency"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date,omitempty"`

				// NextActivityDuration The duration of the next activity associated with the deal
				NextActivityDuration *string `json:"next_activity_duration,omitempty"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityNote The note of the next activity associated with the deal
				NextActivityNote *string `json:"next_activity_note,omitempty"`

				// NextActivitySubject The subject of the next activity associated with the deal
				NextActivitySubject *string `json:"next_activity_subject,omitempty"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time,omitempty"`

				// NextActivityType The type of the next activity associated with the deal
				NextActivityType *string `json:"next_activity_type,omitempty"`

				// NotesCount The number of notes associated with the deal
				NotesCount *int `json:"notes_count,omitempty"`

				// OrgHidden If the organization that is associated with the deal is hidden or not
				OrgHidden *bool `json:"org_hidden,omitempty"`

				// OrgId The ID of the organization associated with the deal
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the deal
				OrgName *string `json:"org_name,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerName The name of the deal owner
				OwnerName *string `json:"owner_name,omitempty"`

				// ParticipantsCount The number of participants associated with the deal
				ParticipantsCount *int `json:"participants_count,omitempty"`

				// PersonHidden If the person that is associated with the deal is hidden or not
				PersonHidden *bool `json:"person_hidden,omitempty"`

				// PersonId The ID of the person associated with the deal
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the deal
				PersonName *string `json:"person_name,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// ProductsCount The number of products associated with the deal
				ProductsCount *int `json:"products_count,omitempty"`

				// RottenTime The date and time of changing the deal status as rotten
				RottenTime *string `json:"rotten_time"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// StageOrderNr The order number of the deal stage associated with the deal
				StageOrderNr *int `json:"stage_order_nr,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UndoneActivitiesCount The number of incomplete activities associated with the deal
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`

				// UserId The ID of the user
				UserId *int `json:"user_id,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *string `json:"visible_to,omitempty"`

				// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
				WeightedValue *float32 `json:"weighted_value,omitempty"`

				// WeightedValueCurrency The currency associated with the deal
				WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"deals,omitempty"`

			// PeriodEnd The end date and time of the period
			PeriodEnd *string `json:"period_end,omitempty"`

			// PeriodStart The start date and time of the period
			PeriodStart *string `json:"period_start,omitempty"`

			// Totals The total values of deals for the given period
			Totals *struct {
				// Count The number of deals for the given period
				Count *int `json:"count,omitempty"`

				// OpenCount The number of open deals for the given period
				OpenCount *int `json:"open_count,omitempty"`

				// OpenValues The total values of open deals for the given period grouped by deal currency
				OpenValues *map[string]interface{} `json:"open_values,omitempty"`

				// Values The total values of deals grouped by deal currency
				Values *map[string]interface{} `json:"values,omitempty"`

				// WeightedOpenValues The total weighted values of open deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value.
				WeightedOpenValues *map[string]interface{} `json:"weighted_open_values,omitempty"`

				// WeightedValues The total weighted values of deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value.
				WeightedValues *map[string]interface{} `json:"weighted_values,omitempty"`

				// WonCount The number of won deals for the given period
				WonCount *int `json:"won_count,omitempty"`

				// WonValues The total values of won deals for the given period grouped by deal currency
				WonValues *map[string]interface{} `json:"won_values,omitempty"`
			} `json:"totals,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealsTimelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealsTimelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArchivedDealsTimelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Open and won deals grouped into periods by defined interval, amount and date-type dealField (`field_key`)
		Data *struct {
			Deals *[]struct {
				// Active Whether the deal is active or not
				Active *bool `json:"active,omitempty"`

				// ActivitiesCount The number of activities associated with the deal
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AcvCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Contract Value of the deal
				//
				// If the `acv` is null, this will also be null
				AcvCurrency *string `json:"acv_currency"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// ArrCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Recurring Revenue of the deal
				//
				// If the `arr` is null, this will also be null
				ArrCurrency *string `json:"arr_currency"`

				// CcEmail The BCC email of the deal
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// CreatorUserId The ID of the deal creator
				CreatorUserId *int `json:"creator_user_id,omitempty"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// Deleted Whether the deal is deleted or not
				Deleted *bool `json:"deleted,omitempty"`

				// DoneActivitiesCount The number of completed activities associated with the deal
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// EmailMessagesCount The number of emails associated with the deal
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// FilesCount The number of files associated with the deal
				FilesCount *int `json:"files_count,omitempty"`

				// FirstWonTime The date and time of the first time changing the deal status as won
				FirstWonTime *string `json:"first_won_time,omitempty"`

				// FollowersCount The number of followers associated with the deal
				FollowersCount *int `json:"followers_count,omitempty"`

				// FormattedValue The deal value formatted with selected currency. E.g. US$500
				FormattedValue *string `json:"formatted_value,omitempty"`

				// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
				FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// Label The label or multiple labels assigned to the deal
				Label *string `json:"label,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the deal
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// MrrCurrency Only available in Growth and above plans
				//
				// The Currency for Monthly Recurring Revenue of the deal
				//
				// If the `mrr` is null, this will also be null
				MrrCurrency *string `json:"mrr_currency"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date,omitempty"`

				// NextActivityDuration The duration of the next activity associated with the deal
				NextActivityDuration *string `json:"next_activity_duration,omitempty"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityNote The note of the next activity associated with the deal
				NextActivityNote *string `json:"next_activity_note,omitempty"`

				// NextActivitySubject The subject of the next activity associated with the deal
				NextActivitySubject *string `json:"next_activity_subject,omitempty"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time,omitempty"`

				// NextActivityType The type of the next activity associated with the deal
				NextActivityType *string `json:"next_activity_type,omitempty"`

				// NotesCount The number of notes associated with the deal
				NotesCount *int `json:"notes_count,omitempty"`

				// OrgHidden If the organization that is associated with the deal is hidden or not
				OrgHidden *bool `json:"org_hidden,omitempty"`

				// OrgId The ID of the organization associated with the deal
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the deal
				OrgName *string `json:"org_name,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerName The name of the deal owner
				OwnerName *string `json:"owner_name,omitempty"`

				// ParticipantsCount The number of participants associated with the deal
				ParticipantsCount *int `json:"participants_count,omitempty"`

				// PersonHidden If the person that is associated with the deal is hidden or not
				PersonHidden *bool `json:"person_hidden,omitempty"`

				// PersonId The ID of the person associated with the deal
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the deal
				PersonName *string `json:"person_name,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// ProductsCount The number of products associated with the deal
				ProductsCount *int `json:"products_count,omitempty"`

				// RottenTime The date and time of changing the deal status as rotten
				RottenTime *string `json:"rotten_time"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// StageOrderNr The order number of the deal stage associated with the deal
				StageOrderNr *int `json:"stage_order_nr,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UndoneActivitiesCount The number of incomplete activities associated with the deal
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`

				// UserId The ID of the user
				UserId *int `json:"user_id,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *string `json:"visible_to,omitempty"`

				// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
				WeightedValue *float32 `json:"weighted_value,omitempty"`

				// WeightedValueCurrency The currency associated with the deal
				WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"deals,omitempty"`

			// PeriodEnd The end date and time of the period
			PeriodEnd *string `json:"period_end,omitempty"`

			// PeriodStart The start date and time of the period
			PeriodStart *string `json:"period_start,omitempty"`

			// Totals The total values of deals for the given period
			Totals *struct {
				// Count The number of deals for the given period
				Count *int `json:"count,omitempty"`

				// OpenCount The number of open deals for the given period
				OpenCount *int `json:"open_count,omitempty"`

				// OpenValues The total values of open deals for the given period grouped by deal currency
				OpenValues *map[string]interface{} `json:"open_values,omitempty"`

				// Values The total values of deals grouped by deal currency
				Values *map[string]interface{} `json:"values,omitempty"`

				// WeightedOpenValues The total weighted values of open deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value.
				WeightedOpenValues *map[string]interface{} `json:"weighted_open_values,omitempty"`

				// WeightedValues The total weighted values of deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value.
				WeightedValues *map[string]interface{} `json:"weighted_values,omitempty"`

				// WonCount The number of won deals for the given period
				WonCount *int `json:"won_count,omitempty"`

				// WonValues The total values of won deals for the given period grouped by deal currency
				WonValues *map[string]interface{} `json:"won_values,omitempty"`
			} `json:"totals,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetArchivedDealsTimelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArchivedDealsTimelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// ActivityDistribution The distribution of activities related to the organization grouped by the user ID
			ActivityDistribution *struct {
				// ASSIGNEDTOUSERID The ID of the user
				ASSIGNEDTOUSERID *struct {
					// Activities The count of activities related to the user grouped by activity type
					Activities *struct {
						// ACTIVITYTYPENAME The count of activities related to a specific type
						ACTIVITYTYPENAME *int `json:"ACTIVITY_TYPE_NAME,omitempty"`
					} `json:"activities,omitempty"`

					// ActivityCount The overall count of activities for the user
					ActivityCount *int `json:"activity_count,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// Share The percentage of activities belongs to the user
					Share *int `json:"share,omitempty"`
				} `json:"ASSIGNED_TO_USER_ID,omitempty"`
			} `json:"activity_distribution,omitempty"`

			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of activities
		Data *[]struct {
			// ActiveFlag Whether the activity is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// AssignedToUserId The ID of the user to whom the activity is assigned to. Equal to `user_id`.
			AssignedToUserId *int `json:"assigned_to_user_id,omitempty"`

			// Attendees The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address.
			Attendees *[]map[string]interface{} `json:"attendees"`

			// BusyFlag Marks if the activity is set as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
			BusyFlag *bool `json:"busy_flag,omitempty"`

			// CalendarSyncIncludeContext For activities that sync to an external calendar, this setting indicates if the activity syncs with context (what are the deals, persons, organizations this activity is related to)
			CalendarSyncIncludeContext *string `json:"calendar_sync_include_context,omitempty"`

			// CompanyId The user's company ID
			CompanyId *int `json:"company_id,omitempty"`

			// ConferenceMeetingClient The ID of the Marketplace app, which is connected to this activity
			ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

			// ConferenceMeetingId The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
			ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

			// ConferenceMeetingUrl The link to join the meeting which is associated with this activity
			ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

			// CreatedByUserId The ID of the user who created the activity
			CreatedByUserId *int `json:"created_by_user_id,omitempty"`

			// DealDropboxBcc The BCC email address of the deal
			DealDropboxBcc *string `json:"deal_dropbox_bcc,omitempty"`

			// DealId The ID of the deal this activity is associated with
			DealId *int `json:"deal_id,omitempty"`

			// DealTitle The name of the deal this activity is associated with
			DealTitle *string `json:"deal_title,omitempty"`

			// Done Whether the activity is done or not
			Done *bool `json:"done,omitempty"`

			// DueDate The due date of the activity. Format: YYYY-MM-DD
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// DueTime The due time of the activity in UTC. Format: HH:MM
			DueTime *string `json:"due_time,omitempty"`

			// Duration The duration of the activity. Format: HH:MM
			Duration *string `json:"duration,omitempty"`

			// File The file that is attached to this activity. For example, this can be a reference to an audio note file generated with Pipedrive mobile app.
			File *map[string]interface{} `json:"file,omitempty"`

			// GcalEventId For the activity which syncs to Google calendar, this is the Google event ID. NB! This field is related to old Google calendar sync and will be deprecated soon.
			GcalEventId *string `json:"gcal_event_id,omitempty"`

			// GoogleCalendarEtag The Google calendar API etag (version) that is used for syncing this activity. NB! This field is related to old Google calendar sync and will be deprecated soon.
			GoogleCalendarEtag *string `json:"google_calendar_etag,omitempty"`

			// GoogleCalendarId The Google calendar ID that this activity syncs to. NB! This field is related to old Google calendar sync and will be deprecated soon.
			GoogleCalendarId *string `json:"google_calendar_id,omitempty"`

			// Id The ID of the activity, generated when the activity was created
			Id *int `json:"id,omitempty"`

			// LastNotificationTime The date and time of latest notifications sent about this activity to the participants or the attendees of this activity
			LastNotificationTime *string `json:"last_notification_time,omitempty"`

			// LastNotificationUserId The ID of the user who triggered the sending of the latest notifications about this activity to the participants or the attendees of this activity
			LastNotificationUserId *int `json:"last_notification_user_id,omitempty"`

			// LeadId The ID of the lead in the UUID format this activity is associated with
			LeadId *openapi_types.UUID `json:"lead_id"`

			// Location The address of the activity.
			Location *string `json:"location,omitempty"`

			// LocationAdminAreaLevel1 A subfield of the location field. Indicates state/county.
			LocationAdminAreaLevel1 *string `json:"location_admin_area_level_1,omitempty"`

			// LocationAdminAreaLevel2 A subfield of the location field. Indicates region.
			LocationAdminAreaLevel2 *string `json:"location_admin_area_level_2,omitempty"`

			// LocationCountry A subfield of the location field. Indicates country.
			LocationCountry *string `json:"location_country,omitempty"`

			// LocationFormattedAddress A subfield of the location field. Indicates full/combined address.
			LocationFormattedAddress *string `json:"location_formatted_address,omitempty"`

			// LocationLocality A subfield of the location field. Indicates city/town/village/locality.
			LocationLocality *string `json:"location_locality,omitempty"`

			// LocationPostalCode A subfield of the location field. Indicates ZIP/postal code.
			LocationPostalCode *string `json:"location_postal_code,omitempty"`

			// LocationRoute A subfield of the location field. Indicates street name.
			LocationRoute *string `json:"location_route,omitempty"`

			// LocationStreetNumber A subfield of the location field. Indicates house number.
			LocationStreetNumber *string `json:"location_street_number,omitempty"`

			// LocationSublocality A subfield of the location field. Indicates district/sublocality.
			LocationSublocality *string `json:"location_sublocality,omitempty"`

			// LocationSubpremise A subfield of the location field. Indicates apartment/suite number.
			LocationSubpremise *string `json:"location_subpremise,omitempty"`

			// MarkedAsDoneTime The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// Note The note of the activity (HTML format)
			Note *string `json:"note,omitempty"`

			// NotificationLanguageId The ID of the language the notifications are sent in
			NotificationLanguageId *int `json:"notification_language_id,omitempty"`

			// OrgId The ID of the organization this activity is associated with
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization this activity is associated with
			OrgName *string `json:"org_name,omitempty"`

			// OwnerName The name of the user this activity is owned by
			OwnerName *string `json:"owner_name,omitempty"`

			// Participants List of multiple persons (participants) this activity is associated with
			Participants *[]map[string]interface{} `json:"participants"`

			// PersonDropboxBcc The BCC email address of the person
			PersonDropboxBcc *string `json:"person_dropbox_bcc,omitempty"`

			// PersonId The ID of the person this activity is associated with
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person this activity is associated with
			PersonName *string `json:"person_name,omitempty"`

			// ProjectId The ID of the project this activity is associated with
			ProjectId *int `json:"project_id"`

			// PublicDescription Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
			PublicDescription *string `json:"public_description,omitempty"`

			// RecMasterActivityId The ID of parent activity for a recurrent activity if the current activity is an exception to recurrence rules
			RecMasterActivityId *int `json:"rec_master_activity_id,omitempty"`

			// RecRule The rule for the recurrence of the activity. Is important for activities synced into Pipedrive from an external calendar. Example: "RRULE:FREQ=WEEKLY;BYDAY=WE"
			RecRule *string `json:"rec_rule,omitempty"`

			// RecRuleExtension Additional rules for the recurrence of the activity, extend the `rec_rule`. Is important for activities synced into Pipedrive from an external calendar.
			RecRuleExtension *string `json:"rec_rule_extension,omitempty"`

			// ReferenceId Together with the `reference_type`, gives the ID of the other object
			ReferenceId *int `json:"reference_id,omitempty"`

			// ReferenceType If the activity references some other object, it is indicated here. For example, value `Salesphone` refers to activities created with Caller.
			ReferenceType *string `json:"reference_type,omitempty"`

			// Series The list of recurring activity instances. It is in a structure as follows: `[{due_date: "2020-06-24", due_time: "10:00:00"}]`
			Series *[]map[string]interface{} `json:"series,omitempty"`

			// SourceTimezone The timezone the activity was created in an external calendar
			SourceTimezone *string `json:"source_timezone,omitempty"`

			// Subject The subject of the activity
			Subject *string `json:"subject,omitempty"`

			// Type The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
			Type *string `json:"type,omitempty"`

			// UpdateTime The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`

			// UpdateUserId The ID of the user who was the last to update this activity
			UpdateUserId *int `json:"update_user_id,omitempty"`

			// UserId The ID of the user whom the activity is assigned to
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Deal *struct {
				// DEALID The ID of the deal which is associated with the item
				DEALID *struct {
					// Currency The currency of the deal value
					Currency *string `json:"currency,omitempty"`

					// Id The ID of the deal associated with the item
					Id *int `json:"id,omitempty"`

					// PipelineId The ID of the pipeline the deal is in
					PipelineId *int `json:"pipeline_id,omitempty"`

					// StageId The ID of the stage the deal is currently at
					StageId *int `json:"stage_id,omitempty"`

					// Status The status of the deal associated with the item
					Status *string `json:"status,omitempty"`

					// Title The title of the deal associated with the item
					Title *string `json:"title,omitempty"`

					// Value The value of the deal that is associated with the item
					Value *float32 `json:"value,omitempty"`
				} `json:"DEAL_ID,omitempty"`
			} `json:"deal,omitempty"`
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
			Person *struct {
				// PERSONID The ID of the person associated with the item
				PERSONID *struct {
					// ActiveFlag Whether the associated person is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The emails of the person associated with the item
					Email *[]struct {
						// Label The type of the email
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary email or not
						Primary *bool `json:"primary,omitempty"`

						// Value The email of the associated person
						Value *string `json:"value,omitempty"`
					} `json:"email,omitempty"`

					// Id The ID of the person associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the person associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the person that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// Phone The phone numbers of the person associated with the item
					Phone *[]struct {
						// Label The type of the phone number
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary phone number or not
						Primary *bool `json:"primary,omitempty"`

						// Value The phone number of the person associated with the item
						Value *string `json:"value,omitempty"`
					} `json:"phone,omitempty"`
				} `json:"PERSON_ID,omitempty"`
			} `json:"person,omitempty"`
			User *struct {
				USERID *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`
				} `json:"USER_ID,omitempty"`
			} `json:"user,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealChangelogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// ActorUserId The ID of the user who made the change
			ActorUserId *int `json:"actor_user_id,omitempty"`

			// ChangeSource The source of change, for example 'app', 'mobile', 'api', etc.
			ChangeSource *string `json:"change_source"`

			// ChangeSourceUserAgent The user agent from which the change was made
			ChangeSourceUserAgent *string `json:"change_source_user_agent"`

			// FieldKey The key of the field that was changed
			FieldKey *string `json:"field_key,omitempty"`

			// IsBulkUpdateFlag Whether the change was made as part of a bulk update
			IsBulkUpdateFlag *bool `json:"is_bulk_update_flag,omitempty"`

			// NewValue The value of the field after the change
			NewValue *string `json:"new_value"`

			// OldValue The value of the field before the change
			OldValue *string `json:"old_value"`

			// Time The date and time of the change
			Time *string `json:"time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealChangelogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealChangelogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DuplicateDealResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Active Whether the deal is active or not
			Active *bool `json:"active,omitempty"`

			// ActivitiesCount The number of activities associated with the deal
			ActivitiesCount *int `json:"activities_count,omitempty"`

			// Acv Only available in Growth and above plans
			//
			// The Annual Contract Value of the deal
			//
			// Null if there are no products attached to the deal
			Acv *float32 `json:"acv"`

			// AcvCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Contract Value of the deal
			//
			// If the `acv` is null, this will also be null
			AcvCurrency *string `json:"acv_currency"`

			// AddTime The creation date and time of the deal
			AddTime *string `json:"add_time,omitempty"`

			// Arr Only available in Growth and above plans
			//
			// The Annual Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Arr *float32 `json:"arr"`

			// ArrCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Recurring Revenue of the deal
			//
			// If the `arr` is null, this will also be null
			ArrCurrency *string `json:"arr_currency"`

			// CcEmail The BCC email of the deal
			CcEmail *string `json:"cc_email,omitempty"`

			// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CloseTime The date and time of closing the deal
			CloseTime *string `json:"close_time"`

			// CreatorUserId The ID of the deal creator
			CreatorUserId *int `json:"creator_user_id,omitempty"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// Deleted Whether the deal is deleted or not
			Deleted *bool `json:"deleted,omitempty"`

			// DoneActivitiesCount The number of completed activities associated with the deal
			DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

			// EmailMessagesCount The number of emails associated with the deal
			EmailMessagesCount *int `json:"email_messages_count,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// FilesCount The number of files associated with the deal
			FilesCount *int `json:"files_count,omitempty"`

			// FirstWonTime The date and time of the first time changing the deal status as won
			FirstWonTime *string `json:"first_won_time,omitempty"`

			// FollowersCount The number of followers associated with the deal
			FollowersCount *int `json:"followers_count,omitempty"`

			// FormattedValue The deal value formatted with selected currency. E.g. US$500
			FormattedValue *string `json:"formatted_value,omitempty"`

			// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
			FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// IsArchived Whether the deal is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// Label The label or multiple labels assigned to the deal
			Label *string `json:"label,omitempty"`

			// LastActivityDate The date of the last activity associated with the deal
			LastActivityDate *string `json:"last_activity_date"`

			// LastActivityId The ID of the last activity associated with the deal
			LastActivityId *int `json:"last_activity_id"`

			// LastIncomingMailTime The date and time of the last incoming email associated with the deal
			LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

			// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
			LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status as lost
			LostTime *string `json:"lost_time,omitempty"`

			// Mrr Only available in Growth and above plans
			//
			// The Monthly Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Mrr *float32 `json:"mrr"`

			// MrrCurrency Only available in Growth and above plans
			//
			// The Currency for Monthly Recurring Revenue of the deal
			//
			// If the `mrr` is null, this will also be null
			MrrCurrency *string `json:"mrr_currency"`

			// NextActivityDate The date of the next activity associated with the deal
			NextActivityDate *string `json:"next_activity_date,omitempty"`

			// NextActivityDuration The duration of the next activity associated with the deal
			NextActivityDuration *string `json:"next_activity_duration,omitempty"`

			// NextActivityId The ID of the next activity associated with the deal
			NextActivityId *int `json:"next_activity_id"`

			// NextActivityNote The note of the next activity associated with the deal
			NextActivityNote *string `json:"next_activity_note,omitempty"`

			// NextActivitySubject The subject of the next activity associated with the deal
			NextActivitySubject *string `json:"next_activity_subject,omitempty"`

			// NextActivityTime The time of the next activity associated with the deal
			NextActivityTime *string `json:"next_activity_time,omitempty"`

			// NextActivityType The type of the next activity associated with the deal
			NextActivityType *string `json:"next_activity_type,omitempty"`

			// NotesCount The number of notes associated with the deal
			NotesCount *int `json:"notes_count,omitempty"`

			// OrgHidden If the organization that is associated with the deal is hidden or not
			OrgHidden *bool `json:"org_hidden,omitempty"`

			// OrgId The ID of the organization associated with the deal
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the deal
			OrgName *string `json:"org_name,omitempty"`

			// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
			OriginId *string `json:"origin_id"`

			// OwnerName The name of the deal owner
			OwnerName *string `json:"owner_name,omitempty"`

			// ParticipantsCount The number of participants associated with the deal
			ParticipantsCount *int `json:"participants_count,omitempty"`

			// PersonHidden If the person that is associated with the deal is hidden or not
			PersonHidden *bool `json:"person_hidden,omitempty"`

			// PersonId The ID of the person associated with the deal
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the deal
			PersonName *string `json:"person_name,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// ProductsCount The number of products associated with the deal
			ProductsCount *int `json:"products_count,omitempty"`

			// RottenTime The date and time of changing the deal status as rotten
			RottenTime *string `json:"rotten_time"`

			// StageChangeTime The last updated date and time of the deal stage
			StageChangeTime *string `json:"stage_change_time,omitempty"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// StageOrderNr The order number of the deal stage associated with the deal
			StageOrderNr *int `json:"stage_order_nr,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UndoneActivitiesCount The number of incomplete activities associated with the deal
			UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

			// UpdateTime The last updated date and time of the deal
			UpdateTime *string `json:"update_time,omitempty"`

			// UserId The ID of the user
			UserId *int `json:"user_id,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *string `json:"visible_to,omitempty"`

			// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
			WeightedValue *float32 `json:"weighted_value,omitempty"`

			// WeightedValueCurrency The currency associated with the deal
			WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

			// WonTime The date and time of changing the deal status as won
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DuplicateDealResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DuplicateDealResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of files
		Data *[]struct {
			// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivityId The ID of the activity to associate the file with
			ActivityId *int `json:"activity_id,omitempty"`

			// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// Cid The ID of the inline attachment
			Cid *string `json:"cid,omitempty"`

			// DealId The ID of the deal to associate the file with
			DealId *int `json:"deal_id,omitempty"`

			// DealName The name of the deal associated with the dile
			DealName *string `json:"deal_name,omitempty"`

			// Description The description of the file
			Description *string `json:"description,omitempty"`

			// FileName The original name of the file
			FileName *string `json:"file_name,omitempty"`

			// FileSize The size of the file
			FileSize *int `json:"file_size,omitempty"`

			// Id The ID of the file
			Id *int `json:"id,omitempty"`

			// InlineFlag Whether the file was uploaded as inline or not
			InlineFlag *bool `json:"inline_flag,omitempty"`

			// LeadId The ID of the lead to associate the file with
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// LeadName The name of the lead associated with the file
			LeadName *string `json:"lead_name,omitempty"`

			// MailMessageId The ID of the mail message to associate the file with
			MailMessageId *string `json:"mail_message_id,omitempty"`

			// MailTemplateId The ID of the mail template to associate the file with
			MailTemplateId *string `json:"mail_template_id,omitempty"`

			// Name The visible name of the file
			Name *string `json:"name,omitempty"`

			// OrgId The ID of the organization to associate the file with
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the file
			OrgName *string `json:"org_name,omitempty"`

			// PersonId The ID of the person to associate the file with
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the file
			PersonName *string `json:"person_name,omitempty"`

			// ProductId The ID of the product to associate the file with
			ProductId *int `json:"product_id,omitempty"`

			// ProductName The name of the product associated with the file
			ProductName *string `json:"product_name,omitempty"`

			// RemoteId The ID of the remote item
			RemoteId *string `json:"remote_id,omitempty"`

			// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
			RemoteLocation *string `json:"remote_location,omitempty"`

			// S3Bucket The location of the cloud storage
			S3Bucket *string `json:"s3_bucket,omitempty"`

			// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// Url The URL of the download file
			Url *string `json:"url,omitempty"`

			// UserId The ID of the user to associate the file with
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// Data The data related to the update
			Data *map[string]interface{} `json:"data,omitempty"`

			// Object The type of the deal update. (Possible object types - dealChange, note, activity, mailMessage, invoice, document, file)
			Object *string `json:"object,omitempty"`

			// Timestamp The creation date and time of the update
			Timestamp *string `json:"timestamp,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Deal *struct {
				// DEALID The ID of the deal which is associated with the item
				DEALID *struct {
					// Currency The currency of the deal value
					Currency *string `json:"currency,omitempty"`

					// Id The ID of the deal associated with the item
					Id *int `json:"id,omitempty"`

					// PipelineId The ID of the pipeline the deal is in
					PipelineId *int `json:"pipeline_id,omitempty"`

					// StageId The ID of the stage the deal is currently at
					StageId *int `json:"stage_id,omitempty"`

					// Status The status of the deal associated with the item
					Status *string `json:"status,omitempty"`

					// Title The title of the deal associated with the item
					Title *string `json:"title,omitempty"`

					// Value The value of the deal that is associated with the item
					Value *float32 `json:"value,omitempty"`
				} `json:"DEAL_ID,omitempty"`
			} `json:"deal,omitempty"`
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
			Person *struct {
				// PERSONID The ID of the person associated with the item
				PERSONID *struct {
					// ActiveFlag Whether the associated person is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The emails of the person associated with the item
					Email *[]struct {
						// Label The type of the email
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary email or not
						Primary *bool `json:"primary,omitempty"`

						// Value The email of the associated person
						Value *string `json:"value,omitempty"`
					} `json:"email,omitempty"`

					// Id The ID of the person associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the person associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the person that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// Phone The phone numbers of the person associated with the item
					Phone *[]struct {
						// Label The type of the phone number
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary phone number or not
						Primary *bool `json:"primary,omitempty"`

						// Value The phone number of the person associated with the item
						Value *string `json:"value,omitempty"`
					} `json:"phone,omitempty"`
				} `json:"PERSON_ID,omitempty"`
			} `json:"person,omitempty"`
			User *struct {
				USERID *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`
				} `json:"USER_ID,omitempty"`
			} `json:"user,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealMailMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of mail messages
		Data *[]struct {
			Data *struct {
				// AccountId The connection account ID
				AccountId *string `json:"account_id,omitempty"`

				// AddTime The insertion into the database time of the mail message
				AddTime *time.Time `json:"add_time,omitempty"`

				// Bcc The array of mail message blind copies (object)
				Bcc *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"bcc,omitempty"`

				// BodyUrl The mail message body URL
				BodyUrl *string `json:"body_url,omitempty"`

				// Cc The array of mail message copies (object)
				Cc *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"cc,omitempty"`

				// CompanyId The ID of the company
				CompanyId *int `json:"company_id,omitempty"`

				// DeletedFlag Whether the mail message is deleted or not
				DeletedFlag *GetDealMailMessages200DataDataDeletedFlag `json:"deleted_flag,omitempty"`

				// Draft If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
				Draft *string `json:"draft,omitempty"`

				// DraftFlag Whether the mail message is a draft or not
				DraftFlag *GetDealMailMessages200DataDataDraftFlag `json:"draft_flag,omitempty"`

				// ExternalDeletedFlag If the Mail Message has been deleted on the provider side or not
				ExternalDeletedFlag *bool `json:"external_deleted_flag,omitempty"`

				// From The array of mail message sender (object)
				From *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"from,omitempty"`

				// HasAttachmentsFlag Whether the mail message has an attachment or not
				HasAttachmentsFlag *GetDealMailMessages200DataDataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

				// HasBodyFlag Whether the mail message has a body or not
				HasBodyFlag *GetDealMailMessages200DataDataHasBodyFlag `json:"has_body_flag,omitempty"`

				// HasInlineAttachmentsFlag Whether the mail message has an inline attachment or not
				HasInlineAttachmentsFlag *GetDealMailMessages200DataDataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

				// HasRealAttachmentsFlag Whether the mail message has an attachment (which is not inline) or not
				HasRealAttachmentsFlag *GetDealMailMessages200DataDataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

				// Id ID of the mail message.
				Id *int `json:"id,omitempty"`

				// ItemType The type of the data item
				ItemType *string `json:"item_type,omitempty"`

				// MailLinkTrackingEnabledFlag Whether the link tracking in mail message body is enabled.
				MailLinkTrackingEnabledFlag *GetDealMailMessages200DataDataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

				// MailThreadId ID of the mail message thread
				MailThreadId *int `json:"mail_thread_id,omitempty"`

				// MailTrackingStatus The status of tracking mail message. Value is `null` if tracking is not enabled.
				MailTrackingStatus *GetDealMailMessages200DataDataMailTrackingStatus `json:"mail_tracking_status"`

				// MessageTime Creation or receival time of the mail message
				MessageTime *time.Time `json:"message_time,omitempty"`

				// MuaMessageId The Mail Message ID assigned by the mail user agent
				MuaMessageId *string `json:"mua_message_id,omitempty"`

				// NylasId The Mail Message ID assigned by the sync provider
				NylasId *string `json:"nylas_id,omitempty"`

				// ReadFlag Whether the mail message is read or not by the user
				ReadFlag *GetDealMailMessages200DataDataReadFlag `json:"read_flag,omitempty"`

				// S3Bucket The name of the S3 bucket
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// S3BucketPath The path of the S3 bucket
				S3BucketPath *string `json:"s3_bucket_path,omitempty"`

				// SentFlag Whether the mail message has been sent or not
				SentFlag *GetDealMailMessages200DataDataSentFlag `json:"sent_flag,omitempty"`

				// SentFromPipedriveFlag Whether the mail message has been sent from Pipedrive app or not
				SentFromPipedriveFlag *GetDealMailMessages200DataDataSentFromPipedriveFlag `json:"sent_from_pipedrive_flag,omitempty"`

				// SmartBccFlag Whether the mail message has been created by Smart Email BCC feature or not
				SmartBccFlag *GetDealMailMessages200DataDataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

				// Snippet The snippet of mail message. Snippet length is up to 225 characters.
				Snippet *string `json:"snippet,omitempty"`

				// Subject The subject of mail message
				Subject *string `json:"subject,omitempty"`

				// SyncedFlag Whether the mail message is synced with the provider or not
				SyncedFlag *GetDealMailMessages200DataDataSyncedFlag `json:"synced_flag,omitempty"`

				// TemplateId The ID of the mail template
				TemplateId *int `json:"template_id,omitempty"`

				// Timestamp The add date and time of the Mail Message
				Timestamp *string `json:"timestamp,omitempty"`

				// To The array of mail message receiver (object)
				To *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"to,omitempty"`

				// UpdateTime The updating time in the database of the mail message
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// UserId ID of the user whom mail message will be assigned to
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Object The type of the data item
			Object *string `json:"object,omitempty"`

			// Timestamp The date and time when the item was created
			Timestamp *string `json:"timestamp,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetDealMailMessages200DataDataDeletedFlag float32
type GetDealMailMessages200DataDataDraftFlag float32
type GetDealMailMessages200DataDataHasAttachmentsFlag float32
type GetDealMailMessages200DataDataHasBodyFlag float32
type GetDealMailMessages200DataDataHasInlineAttachmentsFlag float32
type GetDealMailMessages200DataDataHasRealAttachmentsFlag float32
type GetDealMailMessages200DataDataMailLinkTrackingEnabledFlag float32
type GetDealMailMessages200DataDataMailTrackingStatus string
type GetDealMailMessages200DataDataReadFlag float32
type GetDealMailMessages200DataDataSentFlag float32
type GetDealMailMessages200DataDataSentFromPipedriveFlag float32
type GetDealMailMessages200DataDataSmartBccFlag float32
type GetDealMailMessages200DataDataSyncedFlag float32

// Status returns HTTPResponse.Status
func (r GetDealMailMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealMailMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Active Whether the deal is active or not
			Active *bool `json:"active,omitempty"`

			// ActivitiesCount The number of activities associated with the deal
			ActivitiesCount *int `json:"activities_count,omitempty"`

			// Acv Only available in Growth and above plans
			//
			// The Annual Contract Value of the deal
			//
			// Null if there are no products attached to the deal
			Acv *float32 `json:"acv"`

			// AcvCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Contract Value of the deal
			//
			// If the `acv` is null, this will also be null
			AcvCurrency *string `json:"acv_currency"`

			// AddTime The creation date and time of the deal
			AddTime *string `json:"add_time,omitempty"`

			// Arr Only available in Growth and above plans
			//
			// The Annual Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Arr *float32 `json:"arr"`

			// ArrCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Recurring Revenue of the deal
			//
			// If the `arr` is null, this will also be null
			ArrCurrency *string `json:"arr_currency"`

			// CcEmail The BCC email of the deal
			CcEmail *string `json:"cc_email,omitempty"`

			// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CloseTime The date and time of closing the deal
			CloseTime *string `json:"close_time"`

			// CreatorUserId The ID of the deal creator
			CreatorUserId *int `json:"creator_user_id,omitempty"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// Deleted Whether the deal is deleted or not
			Deleted *bool `json:"deleted,omitempty"`

			// DoneActivitiesCount The number of completed activities associated with the deal
			DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

			// EmailMessagesCount The number of emails associated with the deal
			EmailMessagesCount *int `json:"email_messages_count,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// FilesCount The number of files associated with the deal
			FilesCount *int `json:"files_count,omitempty"`

			// FirstWonTime The date and time of the first time changing the deal status as won
			FirstWonTime *string `json:"first_won_time,omitempty"`

			// FollowersCount The number of followers associated with the deal
			FollowersCount *int `json:"followers_count,omitempty"`

			// FormattedValue The deal value formatted with selected currency. E.g. US$500
			FormattedValue *string `json:"formatted_value,omitempty"`

			// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
			FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// IsArchived Whether the deal is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// Label The label or multiple labels assigned to the deal
			Label *string `json:"label,omitempty"`

			// LastActivityDate The date of the last activity associated with the deal
			LastActivityDate *string `json:"last_activity_date"`

			// LastActivityId The ID of the last activity associated with the deal
			LastActivityId *int `json:"last_activity_id"`

			// LastIncomingMailTime The date and time of the last incoming email associated with the deal
			LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

			// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
			LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status as lost
			LostTime *string `json:"lost_time,omitempty"`

			// MergeWhatId The deal ID of the deal which the original deal was merged with
			MergeWhatId *int `json:"merge_what_id,omitempty"`

			// Mrr Only available in Growth and above plans
			//
			// The Monthly Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Mrr *float32 `json:"mrr"`

			// MrrCurrency Only available in Growth and above plans
			//
			// The Currency for Monthly Recurring Revenue of the deal
			//
			// If the `mrr` is null, this will also be null
			MrrCurrency *string `json:"mrr_currency"`

			// NextActivityDate The date of the next activity associated with the deal
			NextActivityDate *string `json:"next_activity_date,omitempty"`

			// NextActivityDuration The duration of the next activity associated with the deal
			NextActivityDuration *string `json:"next_activity_duration,omitempty"`

			// NextActivityId The ID of the next activity associated with the deal
			NextActivityId *int `json:"next_activity_id"`

			// NextActivityNote The note of the next activity associated with the deal
			NextActivityNote *string `json:"next_activity_note,omitempty"`

			// NextActivitySubject The subject of the next activity associated with the deal
			NextActivitySubject *string `json:"next_activity_subject,omitempty"`

			// NextActivityTime The time of the next activity associated with the deal
			NextActivityTime *string `json:"next_activity_time,omitempty"`

			// NextActivityType The type of the next activity associated with the deal
			NextActivityType *string `json:"next_activity_type,omitempty"`

			// NotesCount The number of notes associated with the deal
			NotesCount *int `json:"notes_count,omitempty"`

			// OrgHidden If the organization that is associated with the deal is hidden or not
			OrgHidden *bool `json:"org_hidden,omitempty"`

			// OrgId The ID of the organization associated with the deal
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the deal
			OrgName *string `json:"org_name,omitempty"`

			// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
			OriginId *string `json:"origin_id"`

			// OwnerName The name of the deal owner
			OwnerName *string `json:"owner_name,omitempty"`

			// ParticipantsCount The number of participants associated with the deal
			ParticipantsCount *int `json:"participants_count,omitempty"`

			// PersonHidden If the person that is associated with the deal is hidden or not
			PersonHidden *bool `json:"person_hidden,omitempty"`

			// PersonId The ID of the person associated with the deal
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the deal
			PersonName *string `json:"person_name,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// ProductsCount The number of products associated with the deal
			ProductsCount *int `json:"products_count,omitempty"`

			// RottenTime The date and time of changing the deal status as rotten
			RottenTime *string `json:"rotten_time"`

			// StageChangeTime The last updated date and time of the deal stage
			StageChangeTime *string `json:"stage_change_time,omitempty"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// StageOrderNr The order number of the deal stage associated with the deal
			StageOrderNr *int `json:"stage_order_nr,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UndoneActivitiesCount The number of incomplete activities associated with the deal
			UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

			// UpdateTime The last updated date and time of the deal
			UpdateTime *string `json:"update_time,omitempty"`

			// UserId The ID of the user
			UserId *int `json:"user_id,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *string `json:"visible_to,omitempty"`

			// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
			WeightedValue *float32 `json:"weighted_value,omitempty"`

			// WeightedValueCurrency The currency associated with the deal
			WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

			// WonTime The date and time of changing the deal status as won
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MergeDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of participants
		Data *[]struct {
			// ActiveFlag Whether the person is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivitiesCount The count of activities related to the person
			ActivitiesCount *int `json:"activities_count,omitempty"`

			// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// CcEmail The BCC email associated with the person
			CcEmail *string `json:"cc_email,omitempty"`

			// ClosedDealsCount The count of closed deals related with the item
			ClosedDealsCount *int `json:"closed_deals_count,omitempty"`

			// CompanyId The ID of the company related to the person
			CompanyId *int `json:"company_id,omitempty"`

			// DoneActivitiesCount The count of done activities related to the person
			DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

			// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" } ]`. Please note that only `value` is required.
			Email *[]struct {
				// Label The label that indicates the type of the email. (Possible values - work, home or other)
				Label *string `json:"label,omitempty"`

				// Primary Boolean that indicates if email is primary for the person or not
				Primary *bool `json:"primary,omitempty"`

				// Value Email
				Value *string `json:"value,omitempty"`
			} `json:"email,omitempty"`

			// EmailMessagesCount The count of email messages related to the person
			EmailMessagesCount *int `json:"email_messages_count,omitempty"`

			// FilesCount The count of files related to the person
			FilesCount *int `json:"files_count,omitempty"`

			// FirstChar The first letter of the name of the person
			FirstChar *string `json:"first_char,omitempty"`

			// FirstName The first name of the person
			FirstName *string `json:"first_name,omitempty"`

			// FollowersCount The count of followers related to the person
			FollowersCount *int `json:"followers_count,omitempty"`

			// Id The ID of the person
			Id *int `json:"id,omitempty"`

			// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
			Label *int `json:"label,omitempty"`

			// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LastActivityDate The date of the last activity associated with the deal
			LastActivityDate *string `json:"last_activity_date"`

			// LastActivityId The ID of the last activity associated with the deal
			LastActivityId *int `json:"last_activity_id"`

			// LastIncomingMailTime The date and time of the last incoming email associated with the person
			LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

			// LastName The last name of the person
			LastName *string `json:"last_name,omitempty"`

			// LastOutgoingMailTime The date and time of the last outgoing email associated with the person
			LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

			// LostDealsCount The count of lost deals related with the item
			LostDealsCount *int `json:"lost_deals_count,omitempty"`

			// Name The name of the person
			Name *string `json:"name,omitempty"`

			// NextActivityDate The date of the next activity associated with the deal
			NextActivityDate *string `json:"next_activity_date"`

			// NextActivityId The ID of the next activity associated with the deal
			NextActivityId *int `json:"next_activity_id"`

			// NextActivityTime The time of the next activity associated with the deal
			NextActivityTime *string `json:"next_activity_time"`

			// NotesCount The count of notes related to the person
			NotesCount *int `json:"notes_count,omitempty"`

			// OpenDealsCount The count of open deals related with the item
			OpenDealsCount *int `json:"open_deals_count,omitempty"`
			OrgId          *struct {
				// ActiveFlag Whether the associated organization is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Address The address of the organization
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the item
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the item
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the item
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the item
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization
				Value *int `json:"value,omitempty"`
			} `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the person
			OrgName *string `json:"org_name,omitempty"`
			OwnerId *struct {
				// ActiveFlag Whether the user is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The email of the user
				Email *string `json:"email,omitempty"`

				// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
				HasPic *int `json:"has_pic,omitempty"`

				// Id The ID of the user
				Id *int `json:"id,omitempty"`

				// Name The name of the user
				Name *string `json:"name,omitempty"`

				// PicHash The user picture hash
				PicHash *string `json:"pic_hash"`

				// Value The ID of the owner
				Value *int `json:"value,omitempty"`
			} `json:"owner_id,omitempty"`

			// OwnerName The name of the owner associated with the person
			OwnerName *string `json:"owner_name,omitempty"`

			// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
			Phone *[]struct {
				// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
				Label *string `json:"label,omitempty"`

				// Primary Boolean that indicates if phone number is primary for the person or not
				Primary *bool `json:"primary,omitempty"`

				// Value The phone number
				Value *string `json:"value,omitempty"`
			} `json:"phone,omitempty"`
			PictureId *struct {
				// ActiveFlag Whether the associated picture is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The add time of the picture
				AddTime *string `json:"add_time,omitempty"`

				// AddedByUserId The ID of the user who added the picture
				AddedByUserId *int `json:"added_by_user_id,omitempty"`

				// Id The ID of the picture associated with the item
				Id *int `json:"id,omitempty"`

				// ItemId The ID of related item
				ItemId *int `json:"item_id,omitempty"`

				// ItemType The type of item the picture is related to
				ItemType *string `json:"item_type,omitempty"`
				Pictures *struct {
					// N128 The URL of the 128*128 picture
					N128 *string `json:"128,omitempty"`

					// N512 The URL of the 512*512 picture
					N512 *string `json:"512,omitempty"`
				} `json:"pictures,omitempty"`

				// UpdateTime The update time of the picture
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"picture_id,omitempty"`

			// RelatedClosedDealsCount The count of related closed deals related with the item
			RelatedClosedDealsCount *int `json:"related_closed_deals_count,omitempty"`

			// RelatedLostDealsCount The count of related lost deals related with the item
			RelatedLostDealsCount *int `json:"related_lost_deals_count,omitempty"`

			// RelatedOpenDealsCount The count of related open deals related with the item
			RelatedOpenDealsCount *int `json:"related_open_deals_count,omitempty"`

			// RelatedWonDealsCount The count of related won deals related with the item
			RelatedWonDealsCount *int `json:"related_won_deals_count,omitempty"`

			// UndoneActivitiesCount The count of undone activities related to the person
			UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

			// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility group ID of who can see the person
			VisibleTo *string `json:"visible_to,omitempty"`

			// WonDealsCount The count of won deals related with the item
			WonDealsCount *int `json:"won_deals_count,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
			Person *struct {
				// PERSONID The ID of the person associated with the item
				PERSONID *struct {
					// ActiveFlag Whether the associated person is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The emails of the person associated with the item
					Email *[]struct {
						// Label The type of the email
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary email or not
						Primary *bool `json:"primary,omitempty"`

						// Value The email of the associated person
						Value *string `json:"value,omitempty"`
					} `json:"email,omitempty"`

					// Id The ID of the person associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the person associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the person that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// Phone The phone numbers of the person associated with the item
					Phone *[]struct {
						// Label The type of the phone number
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary phone number or not
						Primary *bool `json:"primary,omitempty"`

						// Value The phone number of the person associated with the item
						Value *string `json:"value,omitempty"`
					} `json:"phone,omitempty"`
				} `json:"PERSON_ID,omitempty"`
			} `json:"person,omitempty"`
			User *struct {
				USERID *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`
				} `json:"USER_ID,omitempty"`
			} `json:"user,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDealParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The object of participant
		Data *struct {
			// ActiveFlag Whether the person is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivitiesCount The count of activities related to the person
			ActivitiesCount *int `json:"activities_count,omitempty"`

			// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// CcEmail The BCC email associated with the person
			CcEmail *string `json:"cc_email,omitempty"`

			// ClosedDealsCount The count of closed deals related with the item
			ClosedDealsCount *int `json:"closed_deals_count,omitempty"`

			// CompanyId The ID of the company related to the person
			CompanyId *int `json:"company_id,omitempty"`

			// DoneActivitiesCount The count of done activities related to the person
			DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

			// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" } ]`. Please note that only `value` is required.
			Email *[]struct {
				// Label The label that indicates the type of the email. (Possible values - work, home or other)
				Label *string `json:"label,omitempty"`

				// Primary Boolean that indicates if email is primary for the person or not
				Primary *bool `json:"primary,omitempty"`

				// Value Email
				Value *string `json:"value,omitempty"`
			} `json:"email,omitempty"`

			// EmailMessagesCount The count of email messages related to the person
			EmailMessagesCount *int `json:"email_messages_count,omitempty"`

			// FilesCount The count of files related to the person
			FilesCount *int `json:"files_count,omitempty"`

			// FirstChar The first letter of the name of the person
			FirstChar *string `json:"first_char,omitempty"`

			// FirstName The first name of the person
			FirstName *string `json:"first_name,omitempty"`

			// FollowersCount The count of followers related to the person
			FollowersCount *int `json:"followers_count,omitempty"`

			// Id The ID of the person
			Id *int `json:"id,omitempty"`

			// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
			Label *int `json:"label,omitempty"`

			// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LastActivityDate The date of the last activity associated with the deal
			LastActivityDate *string `json:"last_activity_date"`

			// LastActivityId The ID of the last activity associated with the deal
			LastActivityId *int `json:"last_activity_id"`

			// LastIncomingMailTime The date and time of the last incoming email associated with the person
			LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

			// LastName The last name of the person
			LastName *string `json:"last_name,omitempty"`

			// LastOutgoingMailTime The date and time of the last outgoing email associated with the person
			LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

			// LostDealsCount The count of lost deals related with the item
			LostDealsCount *int `json:"lost_deals_count,omitempty"`

			// Name The name of the person
			Name *string `json:"name,omitempty"`

			// NextActivityDate The date of the next activity associated with the deal
			NextActivityDate *string `json:"next_activity_date"`

			// NextActivityId The ID of the next activity associated with the deal
			NextActivityId *int `json:"next_activity_id"`

			// NextActivityTime The time of the next activity associated with the deal
			NextActivityTime *string `json:"next_activity_time"`

			// NotesCount The count of notes related to the person
			NotesCount *int `json:"notes_count,omitempty"`

			// OpenDealsCount The count of open deals related with the item
			OpenDealsCount *int `json:"open_deals_count,omitempty"`
			OrgId          *struct {
				// ActiveFlag Whether the associated organization is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Address The address of the organization
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the item
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the item
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the item
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the item
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization
				Value *int `json:"value,omitempty"`
			} `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the person
			OrgName *string `json:"org_name,omitempty"`
			OwnerId *struct {
				// ActiveFlag Whether the user is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The email of the user
				Email *string `json:"email,omitempty"`

				// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
				HasPic *int `json:"has_pic,omitempty"`

				// Id The ID of the user
				Id *int `json:"id,omitempty"`

				// Name The name of the user
				Name *string `json:"name,omitempty"`

				// PicHash The user picture hash
				PicHash *string `json:"pic_hash"`

				// Value The ID of the owner
				Value *int `json:"value,omitempty"`
			} `json:"owner_id,omitempty"`

			// OwnerName The name of the owner associated with the person
			OwnerName *string `json:"owner_name,omitempty"`

			// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
			Phone *[]struct {
				// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
				Label *string `json:"label,omitempty"`

				// Primary Boolean that indicates if phone number is primary for the person or not
				Primary *bool `json:"primary,omitempty"`

				// Value The phone number
				Value *string `json:"value,omitempty"`
			} `json:"phone,omitempty"`
			PictureId *struct {
				// ActiveFlag Whether the associated picture is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The add time of the picture
				AddTime *string `json:"add_time,omitempty"`

				// AddedByUserId The ID of the user who added the picture
				AddedByUserId *int `json:"added_by_user_id,omitempty"`

				// Id The ID of the picture associated with the item
				Id *int `json:"id,omitempty"`

				// ItemId The ID of related item
				ItemId *int `json:"item_id,omitempty"`

				// ItemType The type of item the picture is related to
				ItemType *string `json:"item_type,omitempty"`
				Pictures *struct {
					// N128 The URL of the 128*128 picture
					N128 *string `json:"128,omitempty"`

					// N512 The URL of the 512*512 picture
					N512 *string `json:"512,omitempty"`
				} `json:"pictures,omitempty"`

				// UpdateTime The update time of the picture
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"picture_id,omitempty"`

			// RelatedClosedDealsCount The count of related closed deals related with the item
			RelatedClosedDealsCount *int `json:"related_closed_deals_count,omitempty"`

			// RelatedLostDealsCount The count of related lost deals related with the item
			RelatedLostDealsCount *int `json:"related_lost_deals_count,omitempty"`

			// RelatedOpenDealsCount The count of related open deals related with the item
			RelatedOpenDealsCount *int `json:"related_open_deals_count,omitempty"`

			// RelatedWonDealsCount The count of related won deals related with the item
			RelatedWonDealsCount *int `json:"related_won_deals_count,omitempty"`

			// UndoneActivitiesCount The count of undone activities related to the person
			UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

			// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility group ID of who can see the person
			VisibleTo *string `json:"visible_to,omitempty"`

			// WonDealsCount The count of won deals related with the item
			WonDealsCount *int `json:"won_deals_count,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Person *struct {
				// PERSONID The ID of the person associated with the item
				PERSONID *struct {
					// ActiveFlag Whether the associated person is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The emails of the person associated with the item
					Email *[]struct {
						// Label The type of the email
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary email or not
						Primary *bool `json:"primary,omitempty"`

						// Value The email of the associated person
						Value *string `json:"value,omitempty"`
					} `json:"email,omitempty"`

					// Id The ID of the person associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the person associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the person that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// Phone The phone numbers of the person associated with the item
					Phone *[]struct {
						// Label The type of the phone number
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary phone number or not
						Primary *bool `json:"primary,omitempty"`

						// Value The phone number of the person associated with the item
						Value *string `json:"value,omitempty"`
					} `json:"phone,omitempty"`
				} `json:"PERSON_ID,omitempty"`
			} `json:"person,omitempty"`
			User *struct {
				USERID *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`
				} `json:"USER_ID,omitempty"`
			} `json:"user,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddDealParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDealParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDealParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of the deal participant that was deleted
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDealParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDealParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealParticipantsChangelogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of participant changelog
		Data *[]struct {
			// Action Deal participant action type
			Action *string `json:"action,omitempty"`

			// ActorUserId The ID of the user
			ActorUserId *int `json:"actor_user_id,omitempty"`

			// PersonId The ID of the person
			PersonId *int `json:"person_id,omitempty"`

			// Time The deal participant action log time
			Time *string `json:"time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealParticipantsChangelogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealParticipantsChangelogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealPersonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of persons
		Data *[]struct {
			// ActiveFlag Whether the person is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivitiesCount The count of activities related to the person
			ActivitiesCount *int `json:"activities_count,omitempty"`

			// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// CcEmail The BCC email associated with the person
			CcEmail *string `json:"cc_email,omitempty"`

			// ClosedDealsCount The count of closed deals related with the item
			ClosedDealsCount *int `json:"closed_deals_count,omitempty"`

			// CompanyId The ID of the company related to the person
			CompanyId *int `json:"company_id,omitempty"`

			// DoneActivitiesCount The count of done activities related to the person
			DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

			// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" } ]`. Please note that only `value` is required.
			Email *[]struct {
				// Label The label that indicates the type of the email. (Possible values - work, home or other)
				Label *string `json:"label,omitempty"`

				// Primary Boolean that indicates if email is primary for the person or not
				Primary *bool `json:"primary,omitempty"`

				// Value Email
				Value *string `json:"value,omitempty"`
			} `json:"email,omitempty"`

			// EmailMessagesCount The count of email messages related to the person
			EmailMessagesCount *int `json:"email_messages_count,omitempty"`

			// FilesCount The count of files related to the person
			FilesCount *int `json:"files_count,omitempty"`

			// FirstChar The first letter of the name of the person
			FirstChar *string `json:"first_char,omitempty"`

			// FirstName The first name of the person
			FirstName *string `json:"first_name,omitempty"`

			// FollowersCount The count of followers related to the person
			FollowersCount *int `json:"followers_count,omitempty"`

			// Id The ID of the person
			Id *int `json:"id,omitempty"`

			// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
			Label *int `json:"label,omitempty"`

			// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LastActivityDate The date of the last activity associated with the deal
			LastActivityDate *string `json:"last_activity_date"`

			// LastActivityId The ID of the last activity associated with the deal
			LastActivityId *int `json:"last_activity_id"`

			// LastIncomingMailTime The date and time of the last incoming email associated with the person
			LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

			// LastName The last name of the person
			LastName *string `json:"last_name,omitempty"`

			// LastOutgoingMailTime The date and time of the last outgoing email associated with the person
			LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

			// LostDealsCount The count of lost deals related with the item
			LostDealsCount *int `json:"lost_deals_count,omitempty"`

			// Name The name of the person
			Name *string `json:"name,omitempty"`

			// NextActivityDate The date of the next activity associated with the deal
			NextActivityDate *string `json:"next_activity_date"`

			// NextActivityId The ID of the next activity associated with the deal
			NextActivityId *int `json:"next_activity_id"`

			// NextActivityTime The time of the next activity associated with the deal
			NextActivityTime *string `json:"next_activity_time"`

			// NotesCount The count of notes related to the person
			NotesCount *int `json:"notes_count,omitempty"`

			// OpenDealsCount The count of open deals related with the item
			OpenDealsCount *int `json:"open_deals_count,omitempty"`
			OrgId          *struct {
				// ActiveFlag Whether the associated organization is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Address The address of the organization
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the item
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the item
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the item
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the item
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization
				Value *int `json:"value,omitempty"`
			} `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the person
			OrgName *string `json:"org_name,omitempty"`
			OwnerId *struct {
				// ActiveFlag Whether the user is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The email of the user
				Email *string `json:"email,omitempty"`

				// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
				HasPic *int `json:"has_pic,omitempty"`

				// Id The ID of the user
				Id *int `json:"id,omitempty"`

				// Name The name of the user
				Name *string `json:"name,omitempty"`

				// PicHash The user picture hash
				PicHash *string `json:"pic_hash"`

				// Value The ID of the owner
				Value *int `json:"value,omitempty"`
			} `json:"owner_id,omitempty"`

			// OwnerName The name of the owner associated with the person
			OwnerName *string `json:"owner_name,omitempty"`

			// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
			Phone *[]struct {
				// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
				Label *string `json:"label,omitempty"`

				// Primary Boolean that indicates if phone number is primary for the person or not
				Primary *bool `json:"primary,omitempty"`

				// Value The phone number
				Value *string `json:"value,omitempty"`
			} `json:"phone,omitempty"`
			PictureId *struct {
				// ActiveFlag Whether the associated picture is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The add time of the picture
				AddTime *string `json:"add_time,omitempty"`

				// AddedByUserId The ID of the user who added the picture
				AddedByUserId *int `json:"added_by_user_id,omitempty"`

				// Id The ID of the picture associated with the item
				Id *int `json:"id,omitempty"`

				// ItemId The ID of related item
				ItemId *int `json:"item_id,omitempty"`

				// ItemType The type of item the picture is related to
				ItemType *string `json:"item_type,omitempty"`
				Pictures *struct {
					// N128 The URL of the 128*128 picture
					N128 *string `json:"128,omitempty"`

					// N512 The URL of the 512*512 picture
					N512 *string `json:"512,omitempty"`
				} `json:"pictures,omitempty"`

				// UpdateTime The update time of the picture
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"picture_id,omitempty"`

			// RelatedClosedDealsCount The count of related closed deals related with the item
			RelatedClosedDealsCount *int `json:"related_closed_deals_count,omitempty"`

			// RelatedLostDealsCount The count of related lost deals related with the item
			RelatedLostDealsCount *int `json:"related_lost_deals_count,omitempty"`

			// RelatedOpenDealsCount The count of related open deals related with the item
			RelatedOpenDealsCount *int `json:"related_open_deals_count,omitempty"`

			// RelatedWonDealsCount The count of related won deals related with the item
			RelatedWonDealsCount *int `json:"related_won_deals_count,omitempty"`

			// UndoneActivitiesCount The count of undone activities related to the person
			UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

			// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility group ID of who can see the person
			VisibleTo *string `json:"visible_to,omitempty"`

			// WonDealsCount The count of won deals related with the item
			WonDealsCount *int `json:"won_deals_count,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
			User *struct {
				USERID *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`
				} `json:"USER_ID,omitempty"`
			} `json:"user,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealPersonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealPersonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// Pagination Pagination details of the list
			Pagination *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// NextStart Next pagination start
				NextStart *int `json:"next_start,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"pagination,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of all uploaded files
		Data *[]struct {
			// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivityId The ID of the activity to associate the file with
			ActivityId *int `json:"activity_id,omitempty"`

			// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// Cid The ID of the inline attachment
			Cid *string `json:"cid,omitempty"`

			// DealId The ID of the deal to associate the file with
			DealId *int `json:"deal_id,omitempty"`

			// DealName The name of the deal associated with the file
			DealName *string `json:"deal_name,omitempty"`

			// Description The description of the file
			Description *string `json:"description,omitempty"`

			// FileName The original name of the file
			FileName *string `json:"file_name,omitempty"`

			// FileSize The size of the file
			FileSize *int `json:"file_size,omitempty"`

			// Id The ID of the file
			Id *int `json:"id,omitempty"`

			// InlineFlag Whether the file was uploaded as inline or not
			InlineFlag *bool `json:"inline_flag,omitempty"`

			// LeadId The ID of the lead to associate the file with
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// LeadName The name of the lead associated with the file
			LeadName *string `json:"lead_name,omitempty"`

			// MailMessageId The ID of the mail message to associate the file with
			MailMessageId *string `json:"mail_message_id,omitempty"`

			// MailTemplateId The ID of the mail template to associate the file with
			MailTemplateId *string `json:"mail_template_id,omitempty"`

			// Name The visible name of the file
			Name *string `json:"name,omitempty"`

			// OrgId The ID of the organization to associate the file with
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the file
			OrgName *string `json:"org_name,omitempty"`

			// PersonId The ID of the person to associate the file with
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the file
			PersonName *string `json:"person_name,omitempty"`

			// ProductId The ID of the product to associate the file with
			ProductId *int `json:"product_id,omitempty"`

			// ProductName The name of the product associated with the file
			ProductName *string `json:"product_name,omitempty"`

			// RemoteId The ID of the remote item
			RemoteId *string `json:"remote_id,omitempty"`

			// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
			RemoteLocation *string `json:"remote_location,omitempty"`

			// S3Bucket The location of the cloud storage
			S3Bucket *string `json:"s3_bucket,omitempty"`

			// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// Url The URL of the download file
			Url *string `json:"url,omitempty"`

			// UserId The ID of the user to associate the file with
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The file data
		Data *struct {
			// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivityId The ID of the activity to associate the file with
			ActivityId *int `json:"activity_id,omitempty"`

			// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// Cid The ID of the inline attachment
			Cid *string `json:"cid,omitempty"`

			// DealId The ID of the deal to associate the file with
			DealId *int `json:"deal_id,omitempty"`

			// DealName The name of the deal associated with the file
			DealName *string `json:"deal_name,omitempty"`

			// Description The description of the file
			Description *string `json:"description,omitempty"`

			// FileName The original name of the file
			FileName *string `json:"file_name,omitempty"`

			// FileSize The size of the file
			FileSize *int `json:"file_size,omitempty"`

			// Id The ID of the file
			Id *int `json:"id,omitempty"`

			// InlineFlag Whether the file was uploaded as inline or not
			InlineFlag *bool `json:"inline_flag,omitempty"`

			// LeadId The ID of the lead to associate the file with
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// LeadName The name of the lead associated with the file
			LeadName *string `json:"lead_name,omitempty"`

			// MailMessageId The ID of the mail message to associate the file with
			MailMessageId *string `json:"mail_message_id,omitempty"`

			// MailTemplateId The ID of the mail template to associate the file with
			MailTemplateId *string `json:"mail_template_id,omitempty"`

			// Name The visible name of the file
			Name *string `json:"name,omitempty"`

			// OrgId The ID of the organization to associate the file with
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the file
			OrgName *string `json:"org_name,omitempty"`

			// PersonId The ID of the person to associate the file with
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the file
			PersonName *string `json:"person_name,omitempty"`

			// ProductId The ID of the product to associate the file with
			ProductId *int `json:"product_id,omitempty"`

			// ProductName The name of the product associated with the file
			ProductName *string `json:"product_name,omitempty"`

			// RemoteId The ID of the remote item
			RemoteId *string `json:"remote_id,omitempty"`

			// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
			RemoteLocation *string `json:"remote_location,omitempty"`

			// S3Bucket The location of the cloud storage
			S3Bucket *string `json:"s3_bucket,omitempty"`

			// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// Url The URL of the download file
			Url *string `json:"url,omitempty"`

			// UserId The ID of the user to associate the file with
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddFileAndLinkItResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The file data
		Data *struct {
			// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivityId The ID of the activity to associate the file with
			ActivityId *int `json:"activity_id,omitempty"`

			// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// Cid The ID of the inline attachment
			Cid *string `json:"cid,omitempty"`

			// DealId The ID of the deal to associate the file with
			DealId *int `json:"deal_id,omitempty"`

			// DealName The name of the deal associated with the file
			DealName *string `json:"deal_name,omitempty"`

			// Description The description of the file
			Description *string `json:"description,omitempty"`

			// FileName The original name of the file
			FileName *string `json:"file_name,omitempty"`

			// FileSize The size of the file
			FileSize *int `json:"file_size,omitempty"`

			// Id The ID of the file
			Id *int `json:"id,omitempty"`

			// InlineFlag Whether the file was uploaded as inline or not
			InlineFlag *bool `json:"inline_flag,omitempty"`

			// LeadId The ID of the lead to associate the file with
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// LeadName The name of the lead associated with the file
			LeadName *string `json:"lead_name,omitempty"`

			// MailMessageId The ID of the mail message to associate the file with
			MailMessageId *string `json:"mail_message_id,omitempty"`

			// MailTemplateId The ID of the mail template to associate the file with
			MailTemplateId *string `json:"mail_template_id,omitempty"`

			// Name The visible name of the file
			Name *string `json:"name,omitempty"`

			// OrgId The ID of the organization to associate the file with
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the file
			OrgName *string `json:"org_name,omitempty"`

			// PersonId The ID of the person to associate the file with
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the file
			PersonName *string `json:"person_name,omitempty"`

			// ProductId The ID of the product to associate the file with
			ProductId *int `json:"product_id,omitempty"`

			// ProductName The name of the product associated with the file
			ProductName *string `json:"product_name,omitempty"`

			// RemoteId The ID of the remote item
			RemoteId *string `json:"remote_id,omitempty"`

			// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
			RemoteLocation *string `json:"remote_location,omitempty"`

			// S3Bucket The location of the cloud storage
			S3Bucket *string `json:"s3_bucket,omitempty"`

			// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// Url The URL of the download file
			Url *string `json:"url,omitempty"`

			// UserId The ID of the user to associate the file with
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddFileAndLinkItResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddFileAndLinkItResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkFileToItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The file data
		Data *struct {
			// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivityId The ID of the activity to associate the file with
			ActivityId *int `json:"activity_id,omitempty"`

			// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// Cid The ID of the inline attachment
			Cid *string `json:"cid,omitempty"`

			// DealId The ID of the deal to associate the file with
			DealId *int `json:"deal_id,omitempty"`

			// DealName The name of the deal associated with the file
			DealName *string `json:"deal_name,omitempty"`

			// Description The description of the file
			Description *string `json:"description,omitempty"`

			// FileName The original name of the file
			FileName *string `json:"file_name,omitempty"`

			// FileSize The size of the file
			FileSize *int `json:"file_size,omitempty"`

			// Id The ID of the file
			Id *int `json:"id,omitempty"`

			// InlineFlag Whether the file was uploaded as inline or not
			InlineFlag *bool `json:"inline_flag,omitempty"`

			// LeadId The ID of the lead to associate the file with
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// LeadName The name of the lead associated with the file
			LeadName *string `json:"lead_name,omitempty"`

			// MailMessageId The ID of the mail message to associate the file with
			MailMessageId *string `json:"mail_message_id,omitempty"`

			// MailTemplateId The ID of the mail template to associate the file with
			MailTemplateId *string `json:"mail_template_id,omitempty"`

			// Name The visible name of the file
			Name *string `json:"name,omitempty"`

			// OrgId The ID of the organization to associate the file with
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the file
			OrgName *string `json:"org_name,omitempty"`

			// PersonId The ID of the person to associate the file with
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the file
			PersonName *string `json:"person_name,omitempty"`

			// ProductId The ID of the product to associate the file with
			ProductId *int `json:"product_id,omitempty"`

			// ProductName The name of the product associated with the file
			ProductName *string `json:"product_name,omitempty"`

			// RemoteId The ID of the remote item
			RemoteId *string `json:"remote_id,omitempty"`

			// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
			RemoteLocation *string `json:"remote_location,omitempty"`

			// S3Bucket The location of the cloud storage
			S3Bucket *string `json:"s3_bucket,omitempty"`

			// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// Url The URL of the download file
			Url *string `json:"url,omitempty"`

			// UserId The ID of the user to associate the file with
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r LinkFileToItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkFileToItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of the file
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The file data
		Data *struct {
			// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivityId The ID of the activity to associate the file with
			ActivityId *int `json:"activity_id,omitempty"`

			// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// Cid The ID of the inline attachment
			Cid *string `json:"cid,omitempty"`

			// DealId The ID of the deal to associate the file with
			DealId *int `json:"deal_id,omitempty"`

			// DealName The name of the deal associated with the file
			DealName *string `json:"deal_name,omitempty"`

			// Description The description of the file
			Description *string `json:"description,omitempty"`

			// FileName The original name of the file
			FileName *string `json:"file_name,omitempty"`

			// FileSize The size of the file
			FileSize *int `json:"file_size,omitempty"`

			// Id The ID of the file
			Id *int `json:"id,omitempty"`

			// InlineFlag Whether the file was uploaded as inline or not
			InlineFlag *bool `json:"inline_flag,omitempty"`

			// LeadId The ID of the lead to associate the file with
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// LeadName The name of the lead associated with the file
			LeadName *string `json:"lead_name,omitempty"`

			// MailMessageId The ID of the mail message to associate the file with
			MailMessageId *string `json:"mail_message_id,omitempty"`

			// MailTemplateId The ID of the mail template to associate the file with
			MailTemplateId *string `json:"mail_template_id,omitempty"`

			// Name The visible name of the file
			Name *string `json:"name,omitempty"`

			// OrgId The ID of the organization to associate the file with
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the file
			OrgName *string `json:"org_name,omitempty"`

			// PersonId The ID of the person to associate the file with
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the file
			PersonName *string `json:"person_name,omitempty"`

			// ProductId The ID of the product to associate the file with
			ProductId *int `json:"product_id,omitempty"`

			// ProductName The name of the product associated with the file
			ProductName *string `json:"product_name,omitempty"`

			// RemoteId The ID of the remote item
			RemoteId *string `json:"remote_id,omitempty"`

			// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
			RemoteLocation *string `json:"remote_location,omitempty"`

			// S3Bucket The location of the cloud storage
			S3Bucket *string `json:"s3_bucket,omitempty"`

			// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// Url The URL of the download file
			Url *string `json:"url,omitempty"`

			// UserId The ID of the user to associate the file with
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The file data
		Data *struct {
			// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivityId The ID of the activity to associate the file with
			ActivityId *int `json:"activity_id,omitempty"`

			// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// Cid The ID of the inline attachment
			Cid *string `json:"cid,omitempty"`

			// DealId The ID of the deal to associate the file with
			DealId *int `json:"deal_id,omitempty"`

			// DealName The name of the deal associated with the file
			DealName *string `json:"deal_name,omitempty"`

			// Description The description of the file
			Description *string `json:"description,omitempty"`

			// FileName The original name of the file
			FileName *string `json:"file_name,omitempty"`

			// FileSize The size of the file
			FileSize *int `json:"file_size,omitempty"`

			// Id The ID of the file
			Id *int `json:"id,omitempty"`

			// InlineFlag Whether the file was uploaded as inline or not
			InlineFlag *bool `json:"inline_flag,omitempty"`

			// LeadId The ID of the lead to associate the file with
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// LeadName The name of the lead associated with the file
			LeadName *string `json:"lead_name,omitempty"`

			// MailMessageId The ID of the mail message to associate the file with
			MailMessageId *string `json:"mail_message_id,omitempty"`

			// MailTemplateId The ID of the mail template to associate the file with
			MailTemplateId *string `json:"mail_template_id,omitempty"`

			// Name The visible name of the file
			Name *string `json:"name,omitempty"`

			// OrgId The ID of the organization to associate the file with
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the file
			OrgName *string `json:"org_name,omitempty"`

			// PersonId The ID of the person to associate the file with
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the file
			PersonName *string `json:"person_name,omitempty"`

			// ProductId The ID of the product to associate the file with
			ProductId *int `json:"product_id,omitempty"`

			// ProductName The name of the product associated with the file
			ProductName *string `json:"product_name,omitempty"`

			// RemoteId The ID of the remote item
			RemoteId *string `json:"remote_id,omitempty"`

			// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
			RemoteLocation *string `json:"remote_location,omitempty"`

			// S3Bucket The location of the cloud storage
			S3Bucket *string `json:"s3_bucket,omitempty"`

			// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// Url The URL of the download file
			Url *string `json:"url,omitempty"`

			// UserId The ID of the user to associate the file with
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The array of the IDs of the deleted filter
			Id *[]int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The array of filters
		Data *[]struct {
			// ActiveFlag The active flag of the filter
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The date and time when the filter was added
			AddTime *string `json:"add_time,omitempty"`

			// CustomViewId Used by Pipedrive webapp
			CustomViewId *int `json:"custom_view_id,omitempty"`

			// Id The ID of the filter
			Id *int `json:"id,omitempty"`

			// Name The name of the filter
			Name *string `json:"name,omitempty"`

			// Type The type of the item
			Type *string `json:"type,omitempty"`

			// UpdateTime The date and time when the filter was updated
			UpdateTime *string `json:"update_time,omitempty"`

			// UserId The owner of the filter
			UserId *int `json:"user_id,omitempty"`

			// VisibleTo The visibility group ID of who can see then filter
			VisibleTo *int `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag The activity flag of the created filter
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The add time of the created filter
			AddTime *string `json:"add_time,omitempty"`

			// Conditions The created filter conditions object
			Conditions *map[string]interface{} `json:"conditions,omitempty"`

			// CustomViewId The custom view ID of the created filter
			CustomViewId *int `json:"custom_view_id,omitempty"`

			// Id The ID of the created filter
			Id *int `json:"id,omitempty"`

			// Name The name of the created filter
			Name *string `json:"name,omitempty"`

			// TemporaryFlag If the created filter is temporary or not
			TemporaryFlag *bool                 `json:"temporary_flag,omitempty"`
			Type          *AddFilter200DataType `json:"type,omitempty"`

			// UpdateTime The update time of the created filter
			UpdateTime *string `json:"update_time,omitempty"`

			// UserId The user ID of the created filter
			UserId *int `json:"user_id,omitempty"`

			// VisibleTo The visibility group ID of the created filter
			VisibleTo *int `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type AddFilter200DataType string

// Status returns HTTPResponse.Status
func (r AddFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilterHelpersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetFilterHelpersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilterHelpersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of the deleted filter
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The filter object
		Data *struct {
			// ActiveFlag The active flag of the filter
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The date and time when the filter was added
			AddTime *string `json:"add_time,omitempty"`

			// CustomViewId Used by Pipedrive webapp
			CustomViewId *int `json:"custom_view_id,omitempty"`

			// Id The ID of the filter
			Id *int `json:"id,omitempty"`

			// Name The name of the filter
			Name *string `json:"name,omitempty"`

			// Type The type of the item
			Type *string `json:"type,omitempty"`

			// UpdateTime The date and time when the filter was updated
			UpdateTime *string `json:"update_time,omitempty"`

			// UserId The owner of the filter
			UserId *int `json:"user_id,omitempty"`

			// VisibleTo The visibility group ID of who can see then filter
			VisibleTo *int `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag The activity flag of the created filter
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The add time of the created filter
			AddTime *string `json:"add_time,omitempty"`

			// Conditions The created filter conditions object
			Conditions *map[string]interface{} `json:"conditions,omitempty"`

			// CustomViewId The custom view ID of the created filter
			CustomViewId *int `json:"custom_view_id,omitempty"`

			// Id The ID of the created filter
			Id *int `json:"id,omitempty"`

			// Name The name of the created filter
			Name *string `json:"name,omitempty"`

			// TemporaryFlag If the created filter is temporary or not
			TemporaryFlag *bool                    `json:"temporary_flag,omitempty"`
			Type          *UpdateFilter200DataType `json:"type,omitempty"`

			// UpdateTime The update time of the created filter
			UpdateTime *string `json:"update_time,omitempty"`

			// UserId The user ID of the created filter
			UserId *int `json:"user_id,omitempty"`

			// VisibleTo The visibility group ID of the created filter
			VisibleTo *int `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type UpdateFilter200DataType string

// Status returns HTTPResponse.Status
func (r UpdateFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddGoalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Goal *struct {
				// Assignee Who the goal is assigned to
				Assignee *struct {
					// Id The ID of the goal assignee
					Id *int `json:"id,omitempty"`

					// Type The type of the assignee
					Type *string `json:"type,omitempty"`
				} `json:"assignee,omitempty"`

				// Duration The duration of the goal
				Duration *struct {
					// End The end date of the goal
					End *string `json:"end,omitempty"`

					// Start The start date of the goal
					Start *string `json:"start,omitempty"`
				} `json:"duration,omitempty"`

				// ExpectedOutcome The expected outcome of the goal
				ExpectedOutcome *struct {
					// Target The numeric target of the goal
					Target *int `json:"target,omitempty"`

					// TrackingMetric The tracking metric of the goal
					TrackingMetric *string `json:"tracking_metric,omitempty"`
				} `json:"expected_outcome,omitempty"`

				// Id The ID of the goal
				Id *string `json:"id,omitempty"`

				// Interval The interval of the goal
				Interval *string `json:"interval,omitempty"`

				// IsActive Whether the goal is currently active or not
				IsActive *bool `json:"is_active,omitempty"`

				// OwnerId The ID of the creator of the goal
				OwnerId *int `json:"owner_id,omitempty"`

				// ReportIds The IDs of the reports that belong to the goal
				ReportIds *[]string `json:"report_ids,omitempty"`

				// Title The title of the goal
				Title *string `json:"title,omitempty"`

				// Type The type of the goal
				Type *struct {
					// Name The name of the goal type
					Name *string `json:"name,omitempty"`

					// Params The parameters that accompany the goal type
					Params *struct {
						// ActivityTypeId The IDs of activity types of the goal
						ActivityTypeId *[]int `json:"activity_type_id,omitempty"`

						// PipelineId The IDs of pipelines of the goal
						PipelineId *[]int `json:"pipeline_id,omitempty"`
					} `json:"params,omitempty"`
				} `json:"type,omitempty"`
			} `json:"goal,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddGoalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddGoalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGoalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Goals *[]struct {
				// Assignee Who the goal is assigned to
				Assignee *struct {
					// Id The ID of the goal assignee
					Id *int `json:"id,omitempty"`

					// Type The type of the assignee
					Type *string `json:"type,omitempty"`
				} `json:"assignee,omitempty"`

				// Duration The duration of the goal
				Duration *struct {
					// End The end date of the goal
					End *string `json:"end,omitempty"`

					// Start The start date of the goal
					Start *string `json:"start,omitempty"`
				} `json:"duration,omitempty"`

				// ExpectedOutcome The expected outcome of the goal
				ExpectedOutcome *struct {
					// Target The numeric target of the goal
					Target *int `json:"target,omitempty"`

					// TrackingMetric The tracking metric of the goal
					TrackingMetric *string `json:"tracking_metric,omitempty"`
				} `json:"expected_outcome,omitempty"`

				// Id The ID of the goal
				Id *string `json:"id,omitempty"`

				// Interval The interval of the goal
				Interval *string `json:"interval,omitempty"`

				// IsActive Whether the goal is currently active or not
				IsActive *bool `json:"is_active,omitempty"`

				// OwnerId The ID of the creator of the goal
				OwnerId *int `json:"owner_id,omitempty"`

				// ReportIds The IDs of the reports that belong to the goal
				ReportIds *[]string `json:"report_ids,omitempty"`

				// Title The title of the goal
				Title *string `json:"title,omitempty"`

				// Type The type of the goal
				Type *struct {
					// Name The name of the goal type
					Name *string `json:"name,omitempty"`

					// Params The parameters that accompany the goal type
					Params *struct {
						// ActivityTypeId The IDs of activity types of the goal
						ActivityTypeId *[]int `json:"activity_type_id,omitempty"`

						// PipelineId The IDs of pipelines of the goal
						PipelineId *[]int `json:"pipeline_id,omitempty"`
					} `json:"params,omitempty"`
				} `json:"type,omitempty"`
			} `json:"goals,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGoalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGoalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGoalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteGoalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGoalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGoalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Goal *struct {
				// Assignee Who the goal is assigned to
				Assignee *struct {
					// Id The ID of the goal assignee
					Id *int `json:"id,omitempty"`

					// Type The type of the assignee
					Type *string `json:"type,omitempty"`
				} `json:"assignee,omitempty"`

				// Duration The duration of the goal
				Duration *struct {
					// End The end date of the goal
					End *string `json:"end,omitempty"`

					// Start The start date of the goal
					Start *string `json:"start,omitempty"`
				} `json:"duration,omitempty"`

				// ExpectedOutcome The expected outcome of the goal
				ExpectedOutcome *struct {
					// Target The numeric target of the goal
					Target *int `json:"target,omitempty"`

					// TrackingMetric The tracking metric of the goal
					TrackingMetric *string `json:"tracking_metric,omitempty"`
				} `json:"expected_outcome,omitempty"`

				// Id The ID of the goal
				Id *string `json:"id,omitempty"`

				// Interval The interval of the goal
				Interval *string `json:"interval,omitempty"`

				// IsActive Whether the goal is currently active or not
				IsActive *bool `json:"is_active,omitempty"`

				// OwnerId The ID of the creator of the goal
				OwnerId *int `json:"owner_id,omitempty"`

				// ReportIds The IDs of the reports that belong to the goal
				ReportIds *[]string `json:"report_ids,omitempty"`

				// Title The title of the goal
				Title *string `json:"title,omitempty"`

				// Type The type of the goal
				Type *struct {
					// Name The name of the goal type
					Name *string `json:"name,omitempty"`

					// Params The parameters that accompany the goal type
					Params *struct {
						// ActivityTypeId The IDs of activity types of the goal
						ActivityTypeId *[]int `json:"activity_type_id,omitempty"`

						// PipelineId The IDs of pipelines of the goal
						PipelineId *[]int `json:"pipeline_id,omitempty"`
					} `json:"params,omitempty"`
				} `json:"type,omitempty"`
			} `json:"goal,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateGoalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGoalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGoalResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Goal *struct {
				// Assignee Who the goal is assigned to
				Assignee *struct {
					// Id The ID of the goal assignee
					Id *int `json:"id,omitempty"`

					// Type The type of the assignee
					Type *string `json:"type,omitempty"`
				} `json:"assignee,omitempty"`

				// Duration The duration of the goal
				Duration *struct {
					// End The end date of the goal
					End *string `json:"end,omitempty"`

					// Start The start date of the goal
					Start *string `json:"start,omitempty"`
				} `json:"duration,omitempty"`

				// ExpectedOutcome The expected outcome of the goal
				ExpectedOutcome *struct {
					// Target The numeric target of the goal
					Target *int `json:"target,omitempty"`

					// TrackingMetric The tracking metric of the goal
					TrackingMetric *string `json:"tracking_metric,omitempty"`
				} `json:"expected_outcome,omitempty"`

				// Id The ID of the goal
				Id *string `json:"id,omitempty"`

				// Interval The interval of the goal
				Interval *string `json:"interval,omitempty"`

				// IsActive Whether the goal is currently active or not
				IsActive *bool `json:"is_active,omitempty"`

				// OwnerId The ID of the creator of the goal
				OwnerId *int `json:"owner_id,omitempty"`

				// ReportIds The IDs of the reports that belong to the goal
				ReportIds *[]string `json:"report_ids,omitempty"`

				// Title The title of the goal
				Title *string `json:"title,omitempty"`

				// Type The type of the goal
				Type *struct {
					// Name The name of the goal type
					Name *string `json:"name,omitempty"`

					// Params The parameters that accompany the goal type
					Params *struct {
						// ActivityTypeId The IDs of activity types of the goal
						ActivityTypeId *[]int `json:"activity_type_id,omitempty"`

						// PipelineId The IDs of pipelines of the goal
						PipelineId *[]int `json:"pipeline_id,omitempty"`
					} `json:"params,omitempty"`
				} `json:"type,omitempty"`
			} `json:"goal,omitempty"`

			// Progress The numeric progress of the goal
			Progress *int `json:"progress,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGoalResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGoalResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeadFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// ActiveFlag The active flag of the field
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation time of the field
			AddTime *time.Time `json:"add_time,omitempty"`

			// AddVisibleFlag Not used
			AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

			// BulkEditAllowed Whether or not the field of an item can be edited in bulk
			BulkEditAllowed *bool `json:"bulk_edit_allowed,omitempty"`

			// CreatedByUserId The ID of the user who created the field
			CreatedByUserId *int `json:"created_by_user_id"`

			// DetailsVisibleFlag Not used
			DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

			// EditFlag The edit flag of the field
			EditFlag *bool `json:"edit_flag,omitempty"`

			// FieldType List of all possible field types
			FieldType *GetLeadFields200DataFieldType `json:"field_type,omitempty"`

			// FilteringAllowed Whether or not items can be filtered by this field
			FilteringAllowed *bool `json:"filtering_allowed,omitempty"`

			// Id The ID of the field. Value is `null` in case of subfields.
			Id *int `json:"id"`

			// ImportantFlag Not used
			ImportantFlag *bool `json:"important_flag,omitempty"`

			// IndexVisibleFlag Not used
			IndexVisibleFlag *bool `json:"index_visible_flag,omitempty"`

			// IsSubfield Whether or not the field is a subfield of another field. Only present if field is subfield.
			IsSubfield *bool `json:"is_subfield,omitempty"`

			// Key The key of the field. For custom fields this is generated upon creation.
			Key *string `json:"key,omitempty"`

			// LastUpdatedByUserId The ID of the user who created or most recently updated the field, only applicable for custom fields
			LastUpdatedByUserId *int `json:"last_updated_by_user_id"`

			// MandatoryFlag Whether or not the field is mandatory
			MandatoryFlag *bool `json:"mandatory_flag,omitempty"`

			// Name The name of the field
			Name *string `json:"name,omitempty"`

			// Options The options of the field. When there are no options, `null` is returned.
			Options *[]map[string]interface{} `json:"options"`

			// OptionsDeleted The deleted options of the field. Only present when there is at least 1 deleted option.
			OptionsDeleted *[]map[string]interface{} `json:"options_deleted,omitempty"`

			// OrderNr The order number of the field
			OrderNr *int `json:"order_nr,omitempty"`

			// SearchableFlag Whether or not items can be searched by this field
			SearchableFlag *bool `json:"searchable_flag,omitempty"`

			// SortableFlag Whether or not items can be sorted by this field
			SortableFlag *bool `json:"sortable_flag,omitempty"`

			// Subfields The subfields of the field. Only present when the field has subfields.
			Subfields *[]map[string]interface{} `json:"subfields,omitempty"`

			// UpdateTime The update time of the field
			UpdateTime *time.Time `json:"update_time"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetLeadFields200DataFieldType string

// Status returns HTTPResponse.Status
func (r GetLeadFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeadFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeadLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			// AddTime The date and time of when the lead label was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			AddTime *time.Time `json:"add_time,omitempty"`

			// Color The color of the label. Only a subset of colors can be used.
			Color *GetLeadLabels200DataColor `json:"color,omitempty"`

			// Id The unique ID of the lead label
			Id *openapi_types.UUID `json:"id,omitempty"`

			// Name The name of the lead label
			Name *string `json:"name,omitempty"`

			// UpdateTime The date and time of when the lead label was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			UpdateTime *time.Time `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}
type GetLeadLabels200DataColor string

// Status returns HTTPResponse.Status
func (r GetLeadLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeadLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddLeadLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// AddTime The date and time of when the lead label was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			AddTime *time.Time `json:"add_time,omitempty"`

			// Color The color of the label. Only a subset of colors can be used.
			Color *AddLeadLabel200DataColor `json:"color,omitempty"`

			// Id The unique ID of the lead label
			Id *openapi_types.UUID `json:"id,omitempty"`

			// Name The name of the lead label
			Name *string `json:"name,omitempty"`

			// UpdateTime The date and time of when the lead label was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			UpdateTime *time.Time `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}
type AddLeadLabel200DataColor string

// Status returns HTTPResponse.Status
func (r AddLeadLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddLeadLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLeadLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Id *openapi_types.UUID `json:"id,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteLeadLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLeadLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLeadLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// AddTime The date and time of when the lead label was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			AddTime *time.Time `json:"add_time,omitempty"`

			// Color The color of the label. Only a subset of colors can be used.
			Color *UpdateLeadLabel200DataColor `json:"color,omitempty"`

			// Id The unique ID of the lead label
			Id *openapi_types.UUID `json:"id,omitempty"`

			// Name The name of the lead label
			Name *string `json:"name,omitempty"`

			// UpdateTime The date and time of when the lead label was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			UpdateTime *time.Time `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}
type UpdateLeadLabel200DataColor string

// Status returns HTTPResponse.Status
func (r UpdateLeadLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLeadLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeadSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			// Name The unique name of a lead source
			Name *string `json:"name,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLeadSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeadSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// AddTime The date and time of when the lead was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			AddTime *time.Time `json:"add_time,omitempty"`

			// CcEmail The BCC email of the lead
			CcEmail *string `json:"cc_email,omitempty"`

			// Channel The ID of your Marketing channel this Lead was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CreatorId The ID of the user who created the lead
			CreatorId *int `json:"creator_id,omitempty"`

			// ExpectedCloseDate The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date"`

			// Id The unique ID of the lead in the UUID format
			Id *openapi_types.UUID `json:"id,omitempty"`

			// IsArchived A flag indicating whether the lead is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// LabelIds The IDs of the lead labels which are associated with the lead
			LabelIds *[]openapi_types.UUID `json:"label_ids,omitempty"`

			// NextActivityId The ID of the next activity associated with the lead
			NextActivityId *int `json:"next_activity_id"`

			// OrganizationId The ID of an organization which this lead is linked to
			OrganizationId *int `json:"organization_id"`

			// Origin The way this Lead was created. `origin` field is set by Pipedrive when Lead is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the lead - e.g. Which API integration created this Lead.
			OriginId *string `json:"origin_id"`

			// OwnerId The ID of the user who owns the lead
			OwnerId *int `json:"owner_id,omitempty"`

			// PersonId The ID of a person which this lead is linked to
			PersonId *int `json:"person_id"`

			// SourceName Defines where the lead comes from. Will be `API` if the lead was created through the Public API and will be `Manually created` if the lead was created manually through the UI.
			SourceName *string `json:"source_name,omitempty"`

			// Title The title of the lead
			Title *string `json:"title,omitempty"`

			// UpdateTime The date and time of when the lead was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			UpdateTime *time.Time `json:"update_time,omitempty"`

			// Value The potential value of the lead represented by a JSON object: `{ "amount": 200, "currency": "EUR" }`. Both amount and currency are required.
			Value *struct {
				Amount   float32 `json:"amount"`
				Currency string  `json:"currency"`
			} `json:"value"`

			// VisibleTo The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
			VisibleTo *GetLeads200DataVisibleTo `json:"visible_to,omitempty"`

			// WasSeen A flag indicating whether the lead was seen by someone in the Pipedrive UI
			WasSeen *bool `json:"was_seen,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}
type GetLeads200DataVisibleTo string

// Status returns HTTPResponse.Status
func (r GetLeadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddLeadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// AddTime The date and time of when the lead was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			AddTime *time.Time `json:"add_time,omitempty"`

			// CcEmail The BCC email of the lead
			CcEmail *string `json:"cc_email,omitempty"`

			// Channel The ID of your Marketing channel this Lead was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CreatorId The ID of the user who created the lead
			CreatorId *int `json:"creator_id,omitempty"`

			// ExpectedCloseDate The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date"`

			// Id The unique ID of the lead in the UUID format
			Id *openapi_types.UUID `json:"id,omitempty"`

			// IsArchived A flag indicating whether the lead is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// LabelIds The IDs of the lead labels which are associated with the lead
			LabelIds *[]openapi_types.UUID `json:"label_ids,omitempty"`

			// NextActivityId The ID of the next activity associated with the lead
			NextActivityId *int `json:"next_activity_id"`

			// OrganizationId The ID of an organization which this lead is linked to
			OrganizationId *int `json:"organization_id"`

			// Origin The way this Lead was created. `origin` field is set by Pipedrive when Lead is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the lead - e.g. Which API integration created this Lead.
			OriginId *string `json:"origin_id"`

			// OwnerId The ID of the user who owns the lead
			OwnerId *int `json:"owner_id,omitempty"`

			// PersonId The ID of a person which this lead is linked to
			PersonId *int `json:"person_id"`

			// SourceName Defines where the lead comes from. Will be `API` if the lead was created through the Public API and will be `Manually created` if the lead was created manually through the UI.
			SourceName *string `json:"source_name,omitempty"`

			// Title The title of the lead
			Title *string `json:"title,omitempty"`

			// UpdateTime The date and time of when the lead was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			UpdateTime *time.Time `json:"update_time,omitempty"`

			// Value The potential value of the lead represented by a JSON object: `{ "amount": 200, "currency": "EUR" }`. Both amount and currency are required.
			Value *struct {
				Amount   float32 `json:"amount"`
				Currency string  `json:"currency"`
			} `json:"value"`

			// VisibleTo The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
			VisibleTo *AddLead201DataVisibleTo `json:"visible_to,omitempty"`

			// WasSeen A flag indicating whether the lead was seen by someone in the Pipedrive UI
			WasSeen *bool `json:"was_seen,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}
type AddLead201DataVisibleTo string

// Status returns HTTPResponse.Status
func (r AddLeadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddLeadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArchivedLeadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// AddTime The date and time of when the lead was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			AddTime *time.Time `json:"add_time,omitempty"`

			// CcEmail The BCC email of the lead
			CcEmail *string `json:"cc_email,omitempty"`

			// Channel The ID of your Marketing channel this Lead was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CreatorId The ID of the user who created the lead
			CreatorId *int `json:"creator_id,omitempty"`

			// ExpectedCloseDate The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date"`

			// Id The unique ID of the lead in the UUID format
			Id *openapi_types.UUID `json:"id,omitempty"`

			// IsArchived A flag indicating whether the lead is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// LabelIds The IDs of the lead labels which are associated with the lead
			LabelIds *[]openapi_types.UUID `json:"label_ids,omitempty"`

			// NextActivityId The ID of the next activity associated with the lead
			NextActivityId *int `json:"next_activity_id"`

			// OrganizationId The ID of an organization which this lead is linked to
			OrganizationId *int `json:"organization_id"`

			// Origin The way this Lead was created. `origin` field is set by Pipedrive when Lead is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the lead - e.g. Which API integration created this Lead.
			OriginId *string `json:"origin_id"`

			// OwnerId The ID of the user who owns the lead
			OwnerId *int `json:"owner_id,omitempty"`

			// PersonId The ID of a person which this lead is linked to
			PersonId *int `json:"person_id"`

			// SourceName Defines where the lead comes from. Will be `API` if the lead was created through the Public API and will be `Manually created` if the lead was created manually through the UI.
			SourceName *string `json:"source_name,omitempty"`

			// Title The title of the lead
			Title *string `json:"title,omitempty"`

			// UpdateTime The date and time of when the lead was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			UpdateTime *time.Time `json:"update_time,omitempty"`

			// Value The potential value of the lead represented by a JSON object: `{ "amount": 200, "currency": "EUR" }`. Both amount and currency are required.
			Value *struct {
				Amount   float32 `json:"amount"`
				Currency string  `json:"currency"`
			} `json:"value"`

			// VisibleTo The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
			VisibleTo *GetArchivedLeads200DataVisibleTo `json:"visible_to,omitempty"`

			// WasSeen A flag indicating whether the lead was seen by someone in the Pipedrive UI
			WasSeen *bool `json:"was_seen,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}
type GetArchivedLeads200DataVisibleTo string

// Status returns HTTPResponse.Status
func (r GetArchivedLeadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArchivedLeadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLeadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Id *openapi_types.UUID `json:"id,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteLeadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLeadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// AddTime The date and time of when the lead was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			AddTime *time.Time `json:"add_time,omitempty"`

			// CcEmail The BCC email of the lead
			CcEmail *string `json:"cc_email,omitempty"`

			// Channel The ID of your Marketing channel this Lead was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CreatorId The ID of the user who created the lead
			CreatorId *int `json:"creator_id,omitempty"`

			// ExpectedCloseDate The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date"`

			// Id The unique ID of the lead in the UUID format
			Id *openapi_types.UUID `json:"id,omitempty"`

			// IsArchived A flag indicating whether the lead is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// LabelIds The IDs of the lead labels which are associated with the lead
			LabelIds *[]openapi_types.UUID `json:"label_ids,omitempty"`

			// NextActivityId The ID of the next activity associated with the lead
			NextActivityId *int `json:"next_activity_id"`

			// OrganizationId The ID of an organization which this lead is linked to
			OrganizationId *int `json:"organization_id"`

			// Origin The way this Lead was created. `origin` field is set by Pipedrive when Lead is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the lead - e.g. Which API integration created this Lead.
			OriginId *string `json:"origin_id"`

			// OwnerId The ID of the user who owns the lead
			OwnerId *int `json:"owner_id,omitempty"`

			// PersonId The ID of a person which this lead is linked to
			PersonId *int `json:"person_id"`

			// SourceName Defines where the lead comes from. Will be `API` if the lead was created through the Public API and will be `Manually created` if the lead was created manually through the UI.
			SourceName *string `json:"source_name,omitempty"`

			// Title The title of the lead
			Title *string `json:"title,omitempty"`

			// UpdateTime The date and time of when the lead was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			UpdateTime *time.Time `json:"update_time,omitempty"`

			// Value The potential value of the lead represented by a JSON object: `{ "amount": 200, "currency": "EUR" }`. Both amount and currency are required.
			Value *struct {
				Amount   float32 `json:"amount"`
				Currency string  `json:"currency"`
			} `json:"value"`

			// VisibleTo The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
			VisibleTo *GetLead200DataVisibleTo `json:"visible_to,omitempty"`

			// WasSeen A flag indicating whether the lead was seen by someone in the Pipedrive UI
			WasSeen *bool `json:"was_seen,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}
type GetLead200DataVisibleTo string

// Status returns HTTPResponse.Status
func (r GetLeadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLeadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// AddTime The date and time of when the lead was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			AddTime *time.Time `json:"add_time,omitempty"`

			// CcEmail The BCC email of the lead
			CcEmail *string `json:"cc_email,omitempty"`

			// Channel The ID of your Marketing channel this Lead was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CreatorId The ID of the user who created the lead
			CreatorId *int `json:"creator_id,omitempty"`

			// ExpectedCloseDate The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date"`

			// Id The unique ID of the lead in the UUID format
			Id *openapi_types.UUID `json:"id,omitempty"`

			// IsArchived A flag indicating whether the lead is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// LabelIds The IDs of the lead labels which are associated with the lead
			LabelIds *[]openapi_types.UUID `json:"label_ids,omitempty"`

			// NextActivityId The ID of the next activity associated with the lead
			NextActivityId *int `json:"next_activity_id"`

			// OrganizationId The ID of an organization which this lead is linked to
			OrganizationId *int `json:"organization_id"`

			// Origin The way this Lead was created. `origin` field is set by Pipedrive when Lead is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the lead - e.g. Which API integration created this Lead.
			OriginId *string `json:"origin_id"`

			// OwnerId The ID of the user who owns the lead
			OwnerId *int `json:"owner_id,omitempty"`

			// PersonId The ID of a person which this lead is linked to
			PersonId *int `json:"person_id"`

			// SourceName Defines where the lead comes from. Will be `API` if the lead was created through the Public API and will be `Manually created` if the lead was created manually through the UI.
			SourceName *string `json:"source_name,omitempty"`

			// Title The title of the lead
			Title *string `json:"title,omitempty"`

			// UpdateTime The date and time of when the lead was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
			UpdateTime *time.Time `json:"update_time,omitempty"`

			// Value The potential value of the lead represented by a JSON object: `{ "amount": 200, "currency": "EUR" }`. Both amount and currency are required.
			Value *struct {
				Amount   float32 `json:"amount"`
				Currency string  `json:"currency"`
			} `json:"value"`

			// VisibleTo The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
			VisibleTo *UpdateLead200DataVisibleTo `json:"visible_to,omitempty"`

			// WasSeen A flag indicating whether the lead was seen by someone in the Pipedrive UI
			WasSeen *bool `json:"was_seen,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}
type UpdateLead200DataVisibleTo string

// Status returns HTTPResponse.Status
func (r UpdateLeadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLeadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeadUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The list of user IDs
		Data *[]int `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLeadUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeadUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			// ActiveFlag Flag that indicates whether the team is active
			ActiveFlag *GetTeams200DataActiveFlag `json:"active_flag,omitempty"`

			// AddTime The team creation time. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// CreatedByUserId The ID of the user who created the team
			CreatedByUserId *int `json:"created_by_user_id,omitempty"`

			// DeletedFlag Flag that indicates whether the team is deleted
			DeletedFlag *GetTeams200DataDeletedFlag `json:"deleted_flag,omitempty"`

			// Description The team description
			Description *string `json:"description,omitempty"`

			// Id The team ID
			Id *int `json:"id,omitempty"`

			// ManagerId The team manager ID
			ManagerId *int `json:"manager_id,omitempty"`

			// Name The team name
			Name *string `json:"name,omitempty"`

			// Users The list of user IDs
			Users *[]int `json:"users,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetTeams200DataActiveFlag float32
type GetTeams200DataDeletedFlag float32

// Status returns HTTPResponse.Status
func (r GetTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Flag that indicates whether the team is active
			ActiveFlag *AddTeam200DataActiveFlag `json:"active_flag,omitempty"`

			// AddTime The team creation time. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// CreatedByUserId The ID of the user who created the team
			CreatedByUserId *int `json:"created_by_user_id,omitempty"`

			// DeletedFlag Flag that indicates whether the team is deleted
			DeletedFlag *AddTeam200DataDeletedFlag `json:"deleted_flag,omitempty"`

			// Description The team description
			Description *string `json:"description,omitempty"`

			// Id The team ID
			Id *int `json:"id,omitempty"`

			// ManagerId The team manager ID
			ManagerId *int `json:"manager_id,omitempty"`

			// Name The team name
			Name *string `json:"name,omitempty"`

			// Users The list of user IDs
			Users *[]int `json:"users,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type AddTeam200DataActiveFlag float32
type AddTeam200DataDeletedFlag float32

// Status returns HTTPResponse.Status
func (r AddTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			// ActiveFlag Flag that indicates whether the team is active
			ActiveFlag *GetUserTeams200DataActiveFlag `json:"active_flag,omitempty"`

			// AddTime The team creation time. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// CreatedByUserId The ID of the user who created the team
			CreatedByUserId *int `json:"created_by_user_id,omitempty"`

			// DeletedFlag Flag that indicates whether the team is deleted
			DeletedFlag *GetUserTeams200DataDeletedFlag `json:"deleted_flag,omitempty"`

			// Description The team description
			Description *string `json:"description,omitempty"`

			// Id The team ID
			Id *int `json:"id,omitempty"`

			// ManagerId The team manager ID
			ManagerId *int `json:"manager_id,omitempty"`

			// Name The team name
			Name *string `json:"name,omitempty"`

			// Users The list of user IDs
			Users *[]int `json:"users,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetUserTeams200DataActiveFlag float32
type GetUserTeams200DataDeletedFlag float32

// Status returns HTTPResponse.Status
func (r GetUserTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Flag that indicates whether the team is active
			ActiveFlag *GetTeam200DataActiveFlag `json:"active_flag,omitempty"`

			// AddTime The team creation time. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// CreatedByUserId The ID of the user who created the team
			CreatedByUserId *int `json:"created_by_user_id,omitempty"`

			// DeletedFlag Flag that indicates whether the team is deleted
			DeletedFlag *GetTeam200DataDeletedFlag `json:"deleted_flag,omitempty"`

			// Description The team description
			Description *string `json:"description,omitempty"`

			// Id The team ID
			Id *int `json:"id,omitempty"`

			// ManagerId The team manager ID
			ManagerId *int `json:"manager_id,omitempty"`

			// Name The team name
			Name *string `json:"name,omitempty"`

			// Users The list of user IDs
			Users *[]int `json:"users,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetTeam200DataActiveFlag float32
type GetTeam200DataDeletedFlag float32

// Status returns HTTPResponse.Status
func (r GetTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Flag that indicates whether the team is active
			ActiveFlag *UpdateTeam200DataActiveFlag `json:"active_flag,omitempty"`

			// AddTime The team creation time. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// CreatedByUserId The ID of the user who created the team
			CreatedByUserId *int `json:"created_by_user_id,omitempty"`

			// DeletedFlag Flag that indicates whether the team is deleted
			DeletedFlag *UpdateTeam200DataDeletedFlag `json:"deleted_flag,omitempty"`

			// Description The team description
			Description *string `json:"description,omitempty"`

			// Id The team ID
			Id *int `json:"id,omitempty"`

			// ManagerId The team manager ID
			ManagerId *int `json:"manager_id,omitempty"`

			// Name The team name
			Name *string `json:"name,omitempty"`

			// Users The list of user IDs
			Users *[]int `json:"users,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type UpdateTeam200DataActiveFlag float32
type UpdateTeam200DataDeletedFlag float32

// Status returns HTTPResponse.Status
func (r UpdateTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The list of user IDs
		Data *[]int `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteTeamUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The list of user IDs
		Data *[]int `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTeamUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTeamUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The list of user IDs
		Data *[]int `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddTeamUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTeamUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// AccountId The connection account ID
			AccountId *string `json:"account_id,omitempty"`

			// AddTime The insertion into the database time of the mail message
			AddTime *time.Time `json:"add_time,omitempty"`

			// Bcc The array of mail message blind copies (object)
			Bcc *[]struct {
				// EmailAddress Mail address of the mail participant
				EmailAddress *string `json:"email_address,omitempty"`

				// Id ID of the mail participant
				Id *int `json:"id,omitempty"`

				// LinkedPersonId ID of the linked person to the mail message
				LinkedPersonId *int `json:"linked_person_id,omitempty"`

				// LinkedPersonName Name of the linked person to the mail message
				LinkedPersonName *string `json:"linked_person_name,omitempty"`

				// MailMessagePartyId ID of the mail message participant
				MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

				// Name Name of the mail participant
				Name *string `json:"name,omitempty"`
			} `json:"bcc,omitempty"`

			// BodyUrl The mail message body URL
			BodyUrl *string `json:"body_url,omitempty"`

			// Cc The array of mail message copies (object)
			Cc *[]struct {
				// EmailAddress Mail address of the mail participant
				EmailAddress *string `json:"email_address,omitempty"`

				// Id ID of the mail participant
				Id *int `json:"id,omitempty"`

				// LinkedPersonId ID of the linked person to the mail message
				LinkedPersonId *int `json:"linked_person_id,omitempty"`

				// LinkedPersonName Name of the linked person to the mail message
				LinkedPersonName *string `json:"linked_person_name,omitempty"`

				// MailMessagePartyId ID of the mail message participant
				MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

				// Name Name of the mail participant
				Name *string `json:"name,omitempty"`
			} `json:"cc,omitempty"`

			// DeletedFlag Whether the mail message is deleted or not
			DeletedFlag *GetMailMessage200DataDeletedFlag `json:"deleted_flag,omitempty"`

			// Draft If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
			Draft *string `json:"draft,omitempty"`

			// DraftFlag Whether the mail message is a draft or not
			DraftFlag *GetMailMessage200DataDraftFlag `json:"draft_flag,omitempty"`

			// From The array of mail message sender (object)
			From *[]struct {
				// EmailAddress Mail address of the mail participant
				EmailAddress *string `json:"email_address,omitempty"`

				// Id ID of the mail participant
				Id *int `json:"id,omitempty"`

				// LinkedPersonId ID of the linked person to the mail message
				LinkedPersonId *int `json:"linked_person_id,omitempty"`

				// LinkedPersonName Name of the linked person to the mail message
				LinkedPersonName *string `json:"linked_person_name,omitempty"`

				// MailMessagePartyId ID of the mail message participant
				MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

				// Name Name of the mail participant
				Name *string `json:"name,omitempty"`
			} `json:"from,omitempty"`

			// HasAttachmentsFlag Whether the mail message has an attachment or not
			HasAttachmentsFlag *GetMailMessage200DataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

			// HasBodyFlag Whether the mail message has a body or not
			HasBodyFlag *GetMailMessage200DataHasBodyFlag `json:"has_body_flag,omitempty"`

			// HasInlineAttachmentsFlag Whether the mail message has an inline attachment or not
			HasInlineAttachmentsFlag *GetMailMessage200DataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

			// HasRealAttachmentsFlag Whether the mail message has an attachment (which is not inline) or not
			HasRealAttachmentsFlag *GetMailMessage200DataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

			// Id ID of the mail message.
			Id *int `json:"id,omitempty"`

			// MailLinkTrackingEnabledFlag Whether the link tracking in mail message body is enabled.
			MailLinkTrackingEnabledFlag *GetMailMessage200DataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

			// MailThreadId ID of the mail message thread
			MailThreadId *int `json:"mail_thread_id,omitempty"`

			// MailTrackingStatus The status of tracking mail message. Value is `null` if tracking is not enabled.
			MailTrackingStatus *GetMailMessage200DataMailTrackingStatus `json:"mail_tracking_status"`

			// MessageTime Creation or receival time of the mail message
			MessageTime *time.Time `json:"message_time,omitempty"`

			// ReadFlag Whether the mail message is read or not by the user
			ReadFlag *GetMailMessage200DataReadFlag `json:"read_flag,omitempty"`

			// SentFlag Whether the mail message has been sent or not
			SentFlag *GetMailMessage200DataSentFlag `json:"sent_flag,omitempty"`

			// SentFromPipedriveFlag Whether the mail message has been sent from Pipedrive app or not
			SentFromPipedriveFlag *GetMailMessage200DataSentFromPipedriveFlag `json:"sent_from_pipedrive_flag,omitempty"`

			// SmartBccFlag Whether the mail message has been created by Smart Email BCC feature or not
			SmartBccFlag *GetMailMessage200DataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

			// Snippet The snippet of mail message. Snippet length is up to 225 characters.
			Snippet *string `json:"snippet,omitempty"`

			// Subject The subject of mail message
			Subject *string `json:"subject,omitempty"`

			// SyncedFlag Whether the mail message is synced with the provider or not
			SyncedFlag *GetMailMessage200DataSyncedFlag `json:"synced_flag,omitempty"`

			// To The array of mail message receiver (object)
			To *[]struct {
				// EmailAddress Mail address of the mail participant
				EmailAddress *string `json:"email_address,omitempty"`

				// Id ID of the mail participant
				Id *int `json:"id,omitempty"`

				// LinkedPersonId ID of the linked person to the mail message
				LinkedPersonId *int `json:"linked_person_id,omitempty"`

				// LinkedPersonName Name of the linked person to the mail message
				LinkedPersonName *string `json:"linked_person_name,omitempty"`

				// MailMessagePartyId ID of the mail message participant
				MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

				// Name Name of the mail participant
				Name *string `json:"name,omitempty"`
			} `json:"to,omitempty"`

			// UpdateTime The updating time in the database of the mail message
			UpdateTime *time.Time `json:"update_time,omitempty"`

			// UserId ID of the user whom mail message will be assigned to
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Service The service name of the response.
		Service *string `json:"service,omitempty"`

		// StatusCode The email service specific status code and it is returned through the response body.
		StatusCode *int `json:"statusCode,omitempty"`

		// StatusText The status text of the response.
		StatusText *string `json:"statusText,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetMailMessage200DataDeletedFlag float32
type GetMailMessage200DataDraftFlag float32
type GetMailMessage200DataHasAttachmentsFlag float32
type GetMailMessage200DataHasBodyFlag float32
type GetMailMessage200DataHasInlineAttachmentsFlag float32
type GetMailMessage200DataHasRealAttachmentsFlag float32
type GetMailMessage200DataMailLinkTrackingEnabledFlag float32
type GetMailMessage200DataMailTrackingStatus string
type GetMailMessage200DataReadFlag float32
type GetMailMessage200DataSentFlag float32
type GetMailMessage200DataSentFromPipedriveFlag float32
type GetMailMessage200DataSmartBccFlag float32
type GetMailMessage200DataSyncedFlag float32

// Status returns HTTPResponse.Status
func (r GetMailMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailThreadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The array of mail threads
		Data *[]struct {
			// AccountId The connection account ID
			AccountId *string `json:"account_id,omitempty"`

			// AddTime The time when the mail thread was inserted to database
			AddTime *time.Time `json:"add_time,omitempty"`

			// AllMessagesSentFlag Whether all the mail thread messages have been sent
			AllMessagesSentFlag *GetMailThreads200DataAllMessagesSentFlag `json:"all_messages_sent_flag,omitempty"`

			// ArchivedFlag Whether the mail thread is archived
			ArchivedFlag *GetMailThreads200DataArchivedFlag `json:"archived_flag,omitempty"`

			// DealId The ID of the deal
			DealId *int `json:"deal_id"`

			// DealStatus Status of the deal
			DealStatus *string `json:"deal_status"`

			// DeletedFlag Whether the mail thread is deleted
			DeletedFlag *GetMailThreads200DataDeletedFlag `json:"deleted_flag,omitempty"`

			// DraftsParties Parties of the drafted mail thread
			DraftsParties *[]map[string]interface{} `json:"drafts_parties,omitempty"`

			// ExternalDeletedFlag Whether the mail thread has been deleted externally
			ExternalDeletedFlag *GetMailThreads200DataExternalDeletedFlag `json:"external_deleted_flag,omitempty"`

			// FirstMessageTimestamp The time when the mail thread has had the first message received or created
			FirstMessageTimestamp *time.Time `json:"first_message_timestamp,omitempty"`

			// FirstMessageToMeFlag Whether the mail thread was initialized by others
			FirstMessageToMeFlag *GetMailThreads200DataFirstMessageToMeFlag `json:"first_message_to_me_flag,omitempty"`

			// Folders Folders in which messages from thread are being stored
			Folders *[]string `json:"folders,omitempty"`

			// HasAttachmentsFlag Whether the mail thread has an attachment
			HasAttachmentsFlag *GetMailThreads200DataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

			// HasDraftFlag Whether the mail thread has any drafts
			HasDraftFlag *GetMailThreads200DataHasDraftFlag `json:"has_draft_flag,omitempty"`

			// HasInlineAttachmentsFlag Whether the mail thread has inline attachments
			HasInlineAttachmentsFlag *GetMailThreads200DataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

			// HasRealAttachmentsFlag Whether the mail thread has real attachments (which are not inline)
			HasRealAttachmentsFlag *GetMailThreads200DataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

			// HasSentFlag Whether the mail thread has messages sent
			HasSentFlag *GetMailThreads200DataHasSentFlag `json:"has_sent_flag,omitempty"`

			// Id ID of the mail thread
			Id *int `json:"id,omitempty"`

			// LastMessageReceivedTimestamp The last time when the mail thread has had a message received
			LastMessageReceivedTimestamp *time.Time `json:"last_message_received_timestamp,omitempty"`

			// LastMessageSentTimestamp The last time when the mail thread has had a message sent
			LastMessageSentTimestamp *time.Time `json:"last_message_sent_timestamp"`

			// LastMessageTimestamp Last message timestamp
			LastMessageTimestamp *time.Time `json:"last_message_timestamp,omitempty"`

			// LeadId The ID of the lead
			LeadId *openapi_types.UUID `json:"lead_id"`

			// MailLinkTrackingEnabledFlag Whether the link tracking of the mail thread is enabled
			MailLinkTrackingEnabledFlag *GetMailThreads200DataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

			// MailTrackingStatus Mail tracking status
			MailTrackingStatus *string `json:"mail_tracking_status"`

			// MessageCount An amount of messages
			MessageCount *int `json:"message_count,omitempty"`

			// Parties Parties of the mail thread
			Parties *struct {
				// From Senders of the mail thread
				From *[]struct {
					// EmailAddress Email address of the mail thread participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail thread participant
					Id *int `json:"id,omitempty"`

					// LatestSent Whether the mail thread participant was last to send an email
					LatestSent *bool `json:"latest_sent,omitempty"`

					// LinkedOrganizationId Linked Organization ID
					LinkedOrganizationId *int `json:"linked_organization_id"`

					// LinkedPersonId ID of the linked person
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Email of the linked person
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message party
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// MessageTime Message time
					MessageTime *float32 `json:"message_time,omitempty"`

					// Name Name of the mail thread participant
					Name *string `json:"name,omitempty"`
				} `json:"from,omitempty"`

				// To Recipients of the mail thread
				To *[]struct {
					// EmailAddress Email address of the mail thread participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail thread participant
					Id *int `json:"id,omitempty"`

					// LatestSent Whether the mail thread participant was last to send an email
					LatestSent *bool `json:"latest_sent,omitempty"`

					// LinkedOrganizationId Linked Organization ID
					LinkedOrganizationId *int `json:"linked_organization_id"`

					// LinkedPersonId ID of the linked person
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Email of the linked person
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message party
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// MessageTime Message time
					MessageTime *float32 `json:"message_time,omitempty"`

					// Name Name of the mail thread participant
					Name *string `json:"name,omitempty"`
				} `json:"to,omitempty"`
			} `json:"parties,omitempty"`

			// ReadFlag Whether the mail thread is read
			ReadFlag *GetMailThreads200DataReadFlag `json:"read_flag,omitempty"`

			// SharedFlag Whether the mail thread is shared
			SharedFlag *GetMailThreads200DataSharedFlag `json:"shared_flag,omitempty"`

			// SmartBccFlag Whether one of the parties of the mail thread is Bcc
			SmartBccFlag *GetMailThreads200DataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

			// Snippet A snippet
			Snippet *string `json:"snippet,omitempty"`

			// SnippetDraft A snippet from a draft
			SnippetDraft *string `json:"snippet_draft"`

			// SnippetSent A snippet from a message sent
			SnippetSent *string `json:"snippet_sent,omitempty"`

			// Subject The subject
			Subject *string `json:"subject,omitempty"`

			// SyncedFlag Whether the mail thread is synced
			SyncedFlag *GetMailThreads200DataSyncedFlag `json:"synced_flag,omitempty"`

			// UpdateTime The time when the mail thread was updated in database received
			UpdateTime *time.Time `json:"update_time,omitempty"`

			// UserId ID of the user whom mail message will be assigned to
			UserId *int `json:"user_id,omitempty"`

			// Version Version
			Version *float32 `json:"version,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetMailThreads200DataAllMessagesSentFlag float32
type GetMailThreads200DataArchivedFlag float32
type GetMailThreads200DataDeletedFlag float32
type GetMailThreads200DataExternalDeletedFlag float32
type GetMailThreads200DataFirstMessageToMeFlag float32
type GetMailThreads200DataHasAttachmentsFlag float32
type GetMailThreads200DataHasDraftFlag float32
type GetMailThreads200DataHasInlineAttachmentsFlag float32
type GetMailThreads200DataHasRealAttachmentsFlag float32
type GetMailThreads200DataHasSentFlag float32
type GetMailThreads200DataMailLinkTrackingEnabledFlag float32
type GetMailThreads200DataReadFlag float32
type GetMailThreads200DataSharedFlag float32
type GetMailThreads200DataSmartBccFlag float32
type GetMailThreads200DataSyncedFlag float32

// Status returns HTTPResponse.Status
func (r GetMailThreadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailThreadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMailThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of the deleted mail thread
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteMailThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMailThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The mail thread object
		Data *struct {
			// AccountId The connection account ID
			AccountId *string `json:"account_id,omitempty"`

			// AddTime The time when the mail thread was inserted to database
			AddTime *time.Time `json:"add_time,omitempty"`

			// AllMessagesSentFlag Whether all the mail thread messages have been sent
			AllMessagesSentFlag *GetMailThread200DataAllMessagesSentFlag `json:"all_messages_sent_flag,omitempty"`

			// ArchivedFlag Whether the mail thread is archived
			ArchivedFlag *GetMailThread200DataArchivedFlag `json:"archived_flag,omitempty"`

			// DealId The ID of the deal
			DealId *int `json:"deal_id"`

			// DealStatus Status of the deal
			DealStatus *string `json:"deal_status"`

			// DeletedFlag Whether the mail thread is deleted
			DeletedFlag *GetMailThread200DataDeletedFlag `json:"deleted_flag,omitempty"`

			// DraftsParties Parties of the drafted mail thread
			DraftsParties *[]map[string]interface{} `json:"drafts_parties,omitempty"`

			// ExternalDeletedFlag Whether the mail thread has been deleted externally
			ExternalDeletedFlag *GetMailThread200DataExternalDeletedFlag `json:"external_deleted_flag,omitempty"`

			// FirstMessageTimestamp The time when the mail thread has had the first message received or created
			FirstMessageTimestamp *time.Time `json:"first_message_timestamp,omitempty"`

			// FirstMessageToMeFlag Whether the mail thread was initialized by others
			FirstMessageToMeFlag *GetMailThread200DataFirstMessageToMeFlag `json:"first_message_to_me_flag,omitempty"`

			// Folders Folders in which messages from thread are being stored
			Folders *[]string `json:"folders,omitempty"`

			// HasAttachmentsFlag Whether the mail thread has an attachment
			HasAttachmentsFlag *GetMailThread200DataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

			// HasDraftFlag Whether the mail thread has any drafts
			HasDraftFlag *GetMailThread200DataHasDraftFlag `json:"has_draft_flag,omitempty"`

			// HasInlineAttachmentsFlag Whether the mail thread has inline attachments
			HasInlineAttachmentsFlag *GetMailThread200DataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

			// HasRealAttachmentsFlag Whether the mail thread has real attachments (which are not inline)
			HasRealAttachmentsFlag *GetMailThread200DataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

			// HasSentFlag Whether the mail thread has messages sent
			HasSentFlag *GetMailThread200DataHasSentFlag `json:"has_sent_flag,omitempty"`

			// Id ID of the mail thread
			Id *int `json:"id,omitempty"`

			// LastMessageReceivedTimestamp The last time when the mail thread has had a message received
			LastMessageReceivedTimestamp *time.Time `json:"last_message_received_timestamp,omitempty"`

			// LastMessageSentTimestamp The last time when the mail thread has had a message sent
			LastMessageSentTimestamp *time.Time `json:"last_message_sent_timestamp"`

			// LastMessageTimestamp Last message timestamp
			LastMessageTimestamp *time.Time `json:"last_message_timestamp,omitempty"`

			// LeadId The ID of the lead
			LeadId *openapi_types.UUID `json:"lead_id"`

			// MailLinkTrackingEnabledFlag Whether the link tracking of the mail thread is enabled
			MailLinkTrackingEnabledFlag *GetMailThread200DataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

			// MailTrackingStatus Mail tracking status
			MailTrackingStatus *string `json:"mail_tracking_status"`

			// MessageCount An amount of messages
			MessageCount *int `json:"message_count,omitempty"`

			// Parties Parties of the mail thread
			Parties *struct {
				// From Senders of the mail thread
				From *[]struct {
					// EmailAddress Email address of the mail thread participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail thread participant
					Id *int `json:"id,omitempty"`

					// LatestSent Whether the mail thread participant was last to send an email
					LatestSent *bool `json:"latest_sent,omitempty"`

					// LinkedOrganizationId Linked Organization ID
					LinkedOrganizationId *int `json:"linked_organization_id"`

					// LinkedPersonId ID of the linked person
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Email of the linked person
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message party
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// MessageTime Message time
					MessageTime *float32 `json:"message_time,omitempty"`

					// Name Name of the mail thread participant
					Name *string `json:"name,omitempty"`
				} `json:"from,omitempty"`

				// To Recipients of the mail thread
				To *[]struct {
					// EmailAddress Email address of the mail thread participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail thread participant
					Id *int `json:"id,omitempty"`

					// LatestSent Whether the mail thread participant was last to send an email
					LatestSent *bool `json:"latest_sent,omitempty"`

					// LinkedOrganizationId Linked Organization ID
					LinkedOrganizationId *int `json:"linked_organization_id"`

					// LinkedPersonId ID of the linked person
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Email of the linked person
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message party
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// MessageTime Message time
					MessageTime *float32 `json:"message_time,omitempty"`

					// Name Name of the mail thread participant
					Name *string `json:"name,omitempty"`
				} `json:"to,omitempty"`
			} `json:"parties,omitempty"`

			// ReadFlag Whether the mail thread is read
			ReadFlag *GetMailThread200DataReadFlag `json:"read_flag,omitempty"`

			// SharedFlag Whether the mail thread is shared
			SharedFlag *GetMailThread200DataSharedFlag `json:"shared_flag,omitempty"`

			// SmartBccFlag Whether one of the parties of the mail thread is Bcc
			SmartBccFlag *GetMailThread200DataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

			// Snippet A snippet
			Snippet *string `json:"snippet,omitempty"`

			// SnippetDraft A snippet from a draft
			SnippetDraft *string `json:"snippet_draft"`

			// SnippetSent A snippet from a message sent
			SnippetSent *string `json:"snippet_sent,omitempty"`

			// Subject The subject
			Subject *string `json:"subject,omitempty"`

			// SyncedFlag Whether the mail thread is synced
			SyncedFlag *GetMailThread200DataSyncedFlag `json:"synced_flag,omitempty"`

			// UpdateTime The time when the mail thread was updated in database received
			UpdateTime *time.Time `json:"update_time,omitempty"`

			// UserId ID of the user whom mail message will be assigned to
			UserId *int `json:"user_id,omitempty"`

			// Version Version
			Version *float32 `json:"version,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetMailThread200DataAllMessagesSentFlag float32
type GetMailThread200DataArchivedFlag float32
type GetMailThread200DataDeletedFlag float32
type GetMailThread200DataExternalDeletedFlag float32
type GetMailThread200DataFirstMessageToMeFlag float32
type GetMailThread200DataHasAttachmentsFlag float32
type GetMailThread200DataHasDraftFlag float32
type GetMailThread200DataHasInlineAttachmentsFlag float32
type GetMailThread200DataHasRealAttachmentsFlag float32
type GetMailThread200DataHasSentFlag float32
type GetMailThread200DataMailLinkTrackingEnabledFlag float32
type GetMailThread200DataReadFlag float32
type GetMailThread200DataSharedFlag float32
type GetMailThread200DataSmartBccFlag float32
type GetMailThread200DataSyncedFlag float32

// Status returns HTTPResponse.Status
func (r GetMailThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMailThreadDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The mail thread object
		Data *struct {
			// AccountId The connection account ID
			AccountId *string `json:"account_id,omitempty"`

			// AddTime The time when the mail thread was inserted to database
			AddTime *time.Time `json:"add_time,omitempty"`

			// AllMessagesSentFlag Whether all the mail thread messages have been sent
			AllMessagesSentFlag *UpdateMailThreadDetails200DataAllMessagesSentFlag `json:"all_messages_sent_flag,omitempty"`

			// ArchivedFlag Whether the mail thread is archived
			ArchivedFlag *UpdateMailThreadDetails200DataArchivedFlag `json:"archived_flag,omitempty"`

			// DealId The ID of the deal
			DealId *int `json:"deal_id"`

			// DealStatus Status of the deal
			DealStatus *string `json:"deal_status"`

			// DeletedFlag Whether the mail thread is deleted
			DeletedFlag *UpdateMailThreadDetails200DataDeletedFlag `json:"deleted_flag,omitempty"`

			// DraftsParties Parties of the drafted mail thread
			DraftsParties *[]map[string]interface{} `json:"drafts_parties,omitempty"`

			// ExternalDeletedFlag Whether the mail thread has been deleted externally
			ExternalDeletedFlag *UpdateMailThreadDetails200DataExternalDeletedFlag `json:"external_deleted_flag,omitempty"`

			// FirstMessageTimestamp The time when the mail thread has had the first message received or created
			FirstMessageTimestamp *time.Time `json:"first_message_timestamp,omitempty"`

			// FirstMessageToMeFlag Whether the mail thread was initialized by others
			FirstMessageToMeFlag *UpdateMailThreadDetails200DataFirstMessageToMeFlag `json:"first_message_to_me_flag,omitempty"`

			// Folders Folders in which messages from thread are being stored
			Folders *[]string `json:"folders,omitempty"`

			// HasAttachmentsFlag Whether the mail thread has an attachment
			HasAttachmentsFlag *UpdateMailThreadDetails200DataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

			// HasDraftFlag Whether the mail thread has any drafts
			HasDraftFlag *UpdateMailThreadDetails200DataHasDraftFlag `json:"has_draft_flag,omitempty"`

			// HasInlineAttachmentsFlag Whether the mail thread has inline attachments
			HasInlineAttachmentsFlag *UpdateMailThreadDetails200DataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

			// HasRealAttachmentsFlag Whether the mail thread has real attachments (which are not inline)
			HasRealAttachmentsFlag *UpdateMailThreadDetails200DataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

			// HasSentFlag Whether the mail thread has messages sent
			HasSentFlag *UpdateMailThreadDetails200DataHasSentFlag `json:"has_sent_flag,omitempty"`

			// Id ID of the mail thread
			Id *int `json:"id,omitempty"`

			// LastMessageReceivedTimestamp The last time when the mail thread has had a message received
			LastMessageReceivedTimestamp *time.Time `json:"last_message_received_timestamp,omitempty"`

			// LastMessageSentTimestamp The last time when the mail thread has had a message sent
			LastMessageSentTimestamp *time.Time `json:"last_message_sent_timestamp"`

			// LastMessageTimestamp Last message timestamp
			LastMessageTimestamp *time.Time `json:"last_message_timestamp,omitempty"`

			// LeadId The ID of the lead
			LeadId *openapi_types.UUID `json:"lead_id"`

			// MailLinkTrackingEnabledFlag Whether the link tracking of the mail thread is enabled
			MailLinkTrackingEnabledFlag *UpdateMailThreadDetails200DataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

			// MailTrackingStatus Mail tracking status
			MailTrackingStatus *string `json:"mail_tracking_status"`

			// MessageCount An amount of messages
			MessageCount *int `json:"message_count,omitempty"`

			// Parties Parties of the mail thread
			Parties *struct {
				// From Senders of the mail thread
				From *[]struct {
					// EmailAddress Email address of the mail thread participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail thread participant
					Id *int `json:"id,omitempty"`

					// LatestSent Whether the mail thread participant was last to send an email
					LatestSent *bool `json:"latest_sent,omitempty"`

					// LinkedOrganizationId Linked Organization ID
					LinkedOrganizationId *int `json:"linked_organization_id"`

					// LinkedPersonId ID of the linked person
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Email of the linked person
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message party
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// MessageTime Message time
					MessageTime *float32 `json:"message_time,omitempty"`

					// Name Name of the mail thread participant
					Name *string `json:"name,omitempty"`
				} `json:"from,omitempty"`

				// To Recipients of the mail thread
				To *[]struct {
					// EmailAddress Email address of the mail thread participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail thread participant
					Id *int `json:"id,omitempty"`

					// LatestSent Whether the mail thread participant was last to send an email
					LatestSent *bool `json:"latest_sent,omitempty"`

					// LinkedOrganizationId Linked Organization ID
					LinkedOrganizationId *int `json:"linked_organization_id"`

					// LinkedPersonId ID of the linked person
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Email of the linked person
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message party
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// MessageTime Message time
					MessageTime *float32 `json:"message_time,omitempty"`

					// Name Name of the mail thread participant
					Name *string `json:"name,omitempty"`
				} `json:"to,omitempty"`
			} `json:"parties,omitempty"`

			// ReadFlag Whether the mail thread is read
			ReadFlag *UpdateMailThreadDetails200DataReadFlag `json:"read_flag,omitempty"`

			// SharedFlag Whether the mail thread is shared
			SharedFlag *UpdateMailThreadDetails200DataSharedFlag `json:"shared_flag,omitempty"`

			// SmartBccFlag Whether one of the parties of the mail thread is Bcc
			SmartBccFlag *UpdateMailThreadDetails200DataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

			// Snippet A snippet
			Snippet *string `json:"snippet,omitempty"`

			// SnippetDraft A snippet from a draft
			SnippetDraft *string `json:"snippet_draft"`

			// SnippetSent A snippet from a message sent
			SnippetSent *string `json:"snippet_sent,omitempty"`

			// Subject The subject
			Subject *string `json:"subject,omitempty"`

			// SyncedFlag Whether the mail thread is synced
			SyncedFlag *UpdateMailThreadDetails200DataSyncedFlag `json:"synced_flag,omitempty"`

			// UpdateTime The time when the mail thread was updated in database received
			UpdateTime *time.Time `json:"update_time,omitempty"`

			// UserId ID of the user whom mail message will be assigned to
			UserId *int `json:"user_id,omitempty"`

			// Version Version
			Version *float32 `json:"version,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type UpdateMailThreadDetails200DataAllMessagesSentFlag float32
type UpdateMailThreadDetails200DataArchivedFlag float32
type UpdateMailThreadDetails200DataDeletedFlag float32
type UpdateMailThreadDetails200DataExternalDeletedFlag float32
type UpdateMailThreadDetails200DataFirstMessageToMeFlag float32
type UpdateMailThreadDetails200DataHasAttachmentsFlag float32
type UpdateMailThreadDetails200DataHasDraftFlag float32
type UpdateMailThreadDetails200DataHasInlineAttachmentsFlag float32
type UpdateMailThreadDetails200DataHasRealAttachmentsFlag float32
type UpdateMailThreadDetails200DataHasSentFlag float32
type UpdateMailThreadDetails200DataMailLinkTrackingEnabledFlag float32
type UpdateMailThreadDetails200DataReadFlag float32
type UpdateMailThreadDetails200DataSharedFlag float32
type UpdateMailThreadDetails200DataSmartBccFlag float32
type UpdateMailThreadDetails200DataSyncedFlag float32

// Status returns HTTPResponse.Status
func (r UpdateMailThreadDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMailThreadDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailThreadMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The array of the mail messages of the mail thread
		Data *[]struct {
			// AccountId The connection account ID
			AccountId *string `json:"account_id,omitempty"`

			// AddTime The time when the mail message was inserted to database
			AddTime *time.Time `json:"add_time,omitempty"`

			// Bcc Participants of the Bcc
			Bcc *[]struct {
				// EmailAddress Email address of the mail thread participant
				EmailAddress *string `json:"email_address,omitempty"`

				// Id ID of the mail thread participant
				Id *int `json:"id,omitempty"`

				// LatestSent Whether the mail thread participant was last to send an email
				LatestSent *bool `json:"latest_sent,omitempty"`

				// LinkedOrganizationId Linked Organization ID
				LinkedOrganizationId *int `json:"linked_organization_id"`

				// LinkedPersonId ID of the linked person
				LinkedPersonId *int `json:"linked_person_id,omitempty"`

				// LinkedPersonName Email of the linked person
				LinkedPersonName *string `json:"linked_person_name,omitempty"`

				// MailMessagePartyId ID of the mail message party
				MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

				// MessageTime Message time
				MessageTime *float32 `json:"message_time,omitempty"`

				// Name Name of the mail thread participant
				Name *string `json:"name,omitempty"`
			} `json:"bcc,omitempty"`

			// BodyUrl A link to the mail thread message
			BodyUrl *string `json:"body_url,omitempty"`

			// Cc Participants of the Cc
			Cc *[]struct {
				// EmailAddress Email address of the mail thread participant
				EmailAddress *string `json:"email_address,omitempty"`

				// Id ID of the mail thread participant
				Id *int `json:"id,omitempty"`

				// LatestSent Whether the mail thread participant was last to send an email
				LatestSent *bool `json:"latest_sent,omitempty"`

				// LinkedOrganizationId Linked Organization ID
				LinkedOrganizationId *int `json:"linked_organization_id"`

				// LinkedPersonId ID of the linked person
				LinkedPersonId *int `json:"linked_person_id,omitempty"`

				// LinkedPersonName Email of the linked person
				LinkedPersonName *string `json:"linked_person_name,omitempty"`

				// MailMessagePartyId ID of the mail message party
				MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

				// MessageTime Message time
				MessageTime *float32 `json:"message_time,omitempty"`

				// Name Name of the mail thread participant
				Name *string `json:"name,omitempty"`
			} `json:"cc,omitempty"`

			// DeletedFlag Whether the mail thread is deleted
			DeletedFlag *GetMailThreadMessages200DataDeletedFlag `json:"deleted_flag,omitempty"`

			// Draft If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
			Draft *string `json:"draft"`

			// From Senders of the mail thread
			From *[]struct {
				// EmailAddress Email address of the mail thread participant
				EmailAddress *string `json:"email_address,omitempty"`

				// Id ID of the mail thread participant
				Id *int `json:"id,omitempty"`

				// LatestSent Whether the mail thread participant was last to send an email
				LatestSent *bool `json:"latest_sent,omitempty"`

				// LinkedOrganizationId Linked Organization ID
				LinkedOrganizationId *int `json:"linked_organization_id"`

				// LinkedPersonId ID of the linked person
				LinkedPersonId *int `json:"linked_person_id,omitempty"`

				// LinkedPersonName Email of the linked person
				LinkedPersonName *string `json:"linked_person_name,omitempty"`

				// MailMessagePartyId ID of the mail message party
				MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

				// MessageTime Message time
				MessageTime *float32 `json:"message_time,omitempty"`

				// Name Name of the mail thread participant
				Name *string `json:"name,omitempty"`
			} `json:"from,omitempty"`

			// HasAttachmentsFlag Whether the mail thread has an attachment
			HasAttachmentsFlag *GetMailThreadMessages200DataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

			// HasBodyFlag Whether the mail thread message has a body
			HasBodyFlag *GetMailThreadMessages200DataHasBodyFlag `json:"has_body_flag,omitempty"`

			// HasInlineAttachmentsFlag Whether the mail thread has inline attachments
			HasInlineAttachmentsFlag *GetMailThreadMessages200DataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

			// HasRealAttachmentsFlag Whether the mail thread has real attachments (which are not inline)
			HasRealAttachmentsFlag *GetMailThreadMessages200DataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

			// Id ID of the mail thread
			Id *int `json:"id,omitempty"`

			// MailLinkTrackingEnabledFlag Whether the link tracking of the mail thread is enabled
			MailLinkTrackingEnabledFlag *GetMailThreadMessages200DataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

			// MailThreadId ID of the mail thread
			MailThreadId *int `json:"mail_thread_id,omitempty"`

			// MailTrackingStatus Mail tracking status
			MailTrackingStatus *string `json:"mail_tracking_status"`

			// MessageTime The time when the mail message was received or created
			MessageTime *time.Time `json:"message_time,omitempty"`

			// ReadFlag Whether the mail thread is read
			ReadFlag *GetMailThreadMessages200DataReadFlag `json:"read_flag,omitempty"`

			// SentFlag Whether the mail thread message is sent
			SentFlag *GetMailThreadMessages200DataSentFlag `json:"sent_flag,omitempty"`

			// SentFromPipedriveFlag Whether the mail thread message is sent from Pipedrive
			SentFromPipedriveFlag *GetMailThreadMessages200DataSentFromPipedriveFlag `json:"sent_from_pipedrive_flag,omitempty"`

			// SmartBccFlag Whether one of the parties of the mail thread is Bcc
			SmartBccFlag *GetMailThreadMessages200DataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

			// Snippet A snippet
			Snippet *string `json:"snippet,omitempty"`

			// Subject The subject
			Subject *string `json:"subject,omitempty"`

			// SyncedFlag Whether the mail thread is synced
			SyncedFlag *GetMailThreadMessages200DataSyncedFlag `json:"synced_flag,omitempty"`

			// To Recipients of the mail thread
			To *[]struct {
				// EmailAddress Email address of the mail thread participant
				EmailAddress *string `json:"email_address,omitempty"`

				// Id ID of the mail thread participant
				Id *int `json:"id,omitempty"`

				// LatestSent Whether the mail thread participant was last to send an email
				LatestSent *bool `json:"latest_sent,omitempty"`

				// LinkedOrganizationId Linked Organization ID
				LinkedOrganizationId *int `json:"linked_organization_id"`

				// LinkedPersonId ID of the linked person
				LinkedPersonId *int `json:"linked_person_id,omitempty"`

				// LinkedPersonName Email of the linked person
				LinkedPersonName *string `json:"linked_person_name,omitempty"`

				// MailMessagePartyId ID of the mail message party
				MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

				// MessageTime Message time
				MessageTime *float32 `json:"message_time,omitempty"`

				// Name Name of the mail thread participant
				Name *string `json:"name,omitempty"`
			} `json:"to,omitempty"`

			// UpdateTime The time when the mail message was updated in database received
			UpdateTime *time.Time `json:"update_time,omitempty"`

			// UserId ID of the user whom mail message will be assigned to
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetMailThreadMessages200DataDeletedFlag float32
type GetMailThreadMessages200DataHasAttachmentsFlag float32
type GetMailThreadMessages200DataHasBodyFlag float32
type GetMailThreadMessages200DataHasInlineAttachmentsFlag float32
type GetMailThreadMessages200DataHasRealAttachmentsFlag float32
type GetMailThreadMessages200DataMailLinkTrackingEnabledFlag float32
type GetMailThreadMessages200DataReadFlag float32
type GetMailThreadMessages200DataSentFlag float32
type GetMailThreadMessages200DataSentFromPipedriveFlag float32
type GetMailThreadMessages200DataSmartBccFlag float32
type GetMailThreadMessages200DataSyncedFlag float32

// Status returns HTTPResponse.Status
func (r GetMailThreadMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailThreadMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveUserProviderLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Message The success message of the request
			Message *string `json:"message,omitempty"`
		} `json:"data,omitempty"`

		// Success Boolean that indicates whether the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *struct {
		// Message The error message of the request
		Message *string `json:"message,omitempty"`

		// Success Boolean that indicates whether the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SaveUserProviderLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveUserProviderLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserProviderLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Message The success message of the request
			Message *string `json:"message,omitempty"`
		} `json:"data,omitempty"`

		// Success Boolean that indicates whether the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *struct {
		// Message The error message of the request
		Message *string `json:"message,omitempty"`

		// Success Boolean that indicates whether the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		// Message The error message of the request
		Message *string `json:"message,omitempty"`

		// Success Boolean that indicates whether the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteUserProviderLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserProviderLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNoteFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// ActiveFlag The active flag of the field
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// BulkEditAllowed Not used
			BulkEditAllowed *bool `json:"bulk_edit_allowed,omitempty"`

			// EditFlag The edit flag of the field
			EditFlag *bool `json:"edit_flag,omitempty"`

			// FieldType List of all possible field types
			FieldType *GetNoteFields200DataFieldType `json:"field_type,omitempty"`

			// Id The ID of the field
			Id *int `json:"id,omitempty"`

			// Key The key of the field
			Key *string `json:"key,omitempty"`

			// MandatoryFlag Whether or not the field is mandatory
			MandatoryFlag *bool `json:"mandatory_flag,omitempty"`

			// Name The name of the field
			Name *string `json:"name,omitempty"`

			// Options The options of the field. When there are no options, `null` is returned.
			Options *[]struct {
				Id    *int    `json:"id,omitempty"`
				Label *string `json:"label,omitempty"`
			} `json:"options,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetNoteFields200DataFieldType string

// Status returns HTTPResponse.Status
func (r GetNoteFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNoteFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// Pagination The pagination details of the list
			Pagination *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// NextStart Next pagination start
				NextStart *int `json:"next_start,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"pagination,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of notes
		Data *[]struct {
			// ActiveFlag Whether the note is active or deleted
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the note
			AddTime *string `json:"add_time,omitempty"`

			// Content The content of the note in HTML format. Subject to sanitization on the back-end.
			Content *string `json:"content,omitempty"`

			// Deal The deal this note is attached to
			Deal *struct {
				// Title The title of the deal this note is attached to
				Title *string `json:"title,omitempty"`
			} `json:"deal,omitempty"`

			// DealId The ID of the deal the note is attached to
			DealId *int `json:"deal_id,omitempty"`

			// Id The ID of the note
			Id *int `json:"id,omitempty"`

			// LastUpdateUserId The ID of the user who last updated the note
			LastUpdateUserId *int `json:"last_update_user_id,omitempty"`

			// LeadId The ID of the lead the note is attached to
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// OrgId The ID of the organization the note is attached to
			OrgId *int `json:"org_id,omitempty"`

			// Organization The organization the note is attached to
			Organization *struct {
				// Name The name of the organization the note is attached to
				Name *string `json:"name,omitempty"`
			} `json:"organization,omitempty"`

			// Person The person the note is attached to
			Person *struct {
				// Name The name of the person the note is attached to
				Name *string `json:"name,omitempty"`
			} `json:"person,omitempty"`

			// PersonId The ID of the person the note is attached to
			PersonId *int `json:"person_id,omitempty"`

			// PinnedToDealFlag If true, the results are filtered by note to deal pinning state
			PinnedToDealFlag *bool `json:"pinned_to_deal_flag,omitempty"`

			// PinnedToOrganizationFlag If true, the results are filtered by note to organization pinning state
			PinnedToOrganizationFlag *bool `json:"pinned_to_organization_flag,omitempty"`

			// PinnedToPersonFlag If true, the results are filtered by note to person pinning state
			PinnedToPersonFlag *bool `json:"pinned_to_person_flag,omitempty"`

			// PinnedToProjectFlag If true, the results are filtered by note to project pinning state
			PinnedToProjectFlag *bool `json:"pinned_to_project_flag,omitempty"`

			// Project The project the note is attached to
			Project *struct {
				// Title The title of the project the note is attached to
				Title *string `json:"title,omitempty"`
			} `json:"project,omitempty"`

			// ProjectId The ID of the project the note is attached to
			ProjectId *int `json:"project_id,omitempty"`

			// UpdateTime The last updated date and time of the note
			UpdateTime *string `json:"update_time,omitempty"`

			// User The user who created the note
			User *struct {
				// Email The email of the note creator
				Email *string `json:"email,omitempty"`

				// IconUrl The URL of the note creator avatar picture
				IconUrl *string `json:"icon_url,omitempty"`

				// IsYou Whether the note is created by you or not
				IsYou *bool `json:"is_you,omitempty"`

				// Name The name of the note creator
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`

			// UserId The ID of the note creator
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetNotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Whether the note is active or deleted
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the note
			AddTime *string `json:"add_time,omitempty"`

			// Content The content of the note in HTML format. Subject to sanitization on the back-end.
			Content *string `json:"content,omitempty"`

			// Deal The deal this note is attached to
			Deal *struct {
				// Title The title of the deal this note is attached to
				Title *string `json:"title,omitempty"`
			} `json:"deal,omitempty"`

			// DealId The ID of the deal the note is attached to
			DealId *int `json:"deal_id,omitempty"`

			// Id The ID of the note
			Id *int `json:"id,omitempty"`

			// LastUpdateUserId The ID of the user who last updated the note
			LastUpdateUserId *int `json:"last_update_user_id,omitempty"`

			// LeadId The ID of the lead the note is attached to
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// OrgId The ID of the organization the note is attached to
			OrgId *int `json:"org_id,omitempty"`

			// Organization The organization the note is attached to
			Organization *struct {
				// Name The name of the organization the note is attached to
				Name *string `json:"name,omitempty"`
			} `json:"organization,omitempty"`

			// Person The person the note is attached to
			Person *struct {
				// Name The name of the person the note is attached to
				Name *string `json:"name,omitempty"`
			} `json:"person,omitempty"`

			// PersonId The ID of the person the note is attached to
			PersonId *int `json:"person_id,omitempty"`

			// PinnedToDealFlag If true, the results are filtered by note to deal pinning state
			PinnedToDealFlag *bool `json:"pinned_to_deal_flag,omitempty"`

			// PinnedToOrganizationFlag If true, the results are filtered by note to organization pinning state
			PinnedToOrganizationFlag *bool `json:"pinned_to_organization_flag,omitempty"`

			// PinnedToPersonFlag If true, the results are filtered by note to person pinning state
			PinnedToPersonFlag *bool `json:"pinned_to_person_flag,omitempty"`

			// PinnedToProjectFlag If true, the results are filtered by note to project pinning state
			PinnedToProjectFlag *bool `json:"pinned_to_project_flag,omitempty"`

			// Project The project the note is attached to
			Project *struct {
				// Title The title of the project the note is attached to
				Title *string `json:"title,omitempty"`
			} `json:"project,omitempty"`

			// ProjectId The ID of the project the note is attached to
			ProjectId *int `json:"project_id,omitempty"`

			// UpdateTime The last updated date and time of the note
			UpdateTime *string `json:"update_time,omitempty"`

			// User The user who created the note
			User *struct {
				// Email The email of the note creator
				Email *string `json:"email,omitempty"`

				// IconUrl The URL of the note creator avatar picture
				IconUrl *string `json:"icon_url,omitempty"`

				// IsYou Whether the note is created by you or not
				IsYou *bool `json:"is_you,omitempty"`

				// Name The name of the note creator
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`

			// UserId The ID of the note creator
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data If the response is successful or not
		Data *bool `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Whether the note is active or deleted
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the note
			AddTime *string `json:"add_time,omitempty"`

			// Content The content of the note in HTML format. Subject to sanitization on the back-end.
			Content *string `json:"content,omitempty"`

			// Deal The deal this note is attached to
			Deal *struct {
				// Title The title of the deal this note is attached to
				Title *string `json:"title,omitempty"`
			} `json:"deal,omitempty"`

			// DealId The ID of the deal the note is attached to
			DealId *int `json:"deal_id,omitempty"`

			// Id The ID of the note
			Id *int `json:"id,omitempty"`

			// LastUpdateUserId The ID of the user who last updated the note
			LastUpdateUserId *int `json:"last_update_user_id,omitempty"`

			// LeadId The ID of the lead the note is attached to
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// OrgId The ID of the organization the note is attached to
			OrgId *int `json:"org_id,omitempty"`

			// Organization The organization the note is attached to
			Organization *struct {
				// Name The name of the organization the note is attached to
				Name *string `json:"name,omitempty"`
			} `json:"organization,omitempty"`

			// Person The person the note is attached to
			Person *struct {
				// Name The name of the person the note is attached to
				Name *string `json:"name,omitempty"`
			} `json:"person,omitempty"`

			// PersonId The ID of the person the note is attached to
			PersonId *int `json:"person_id,omitempty"`

			// PinnedToDealFlag If true, the results are filtered by note to deal pinning state
			PinnedToDealFlag *bool `json:"pinned_to_deal_flag,omitempty"`

			// PinnedToOrganizationFlag If true, the results are filtered by note to organization pinning state
			PinnedToOrganizationFlag *bool `json:"pinned_to_organization_flag,omitempty"`

			// PinnedToPersonFlag If true, the results are filtered by note to person pinning state
			PinnedToPersonFlag *bool `json:"pinned_to_person_flag,omitempty"`

			// PinnedToProjectFlag If true, the results are filtered by note to project pinning state
			PinnedToProjectFlag *bool `json:"pinned_to_project_flag,omitempty"`

			// Project The project the note is attached to
			Project *struct {
				// Title The title of the project the note is attached to
				Title *string `json:"title,omitempty"`
			} `json:"project,omitempty"`

			// ProjectId The ID of the project the note is attached to
			ProjectId *int `json:"project_id,omitempty"`

			// UpdateTime The last updated date and time of the note
			UpdateTime *string `json:"update_time,omitempty"`

			// User The user who created the note
			User *struct {
				// Email The email of the note creator
				Email *string `json:"email,omitempty"`

				// IconUrl The URL of the note creator avatar picture
				IconUrl *string `json:"icon_url,omitempty"`

				// IsYou Whether the note is created by you or not
				IsYou *bool `json:"is_you,omitempty"`

				// Name The name of the note creator
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`

			// UserId The ID of the note creator
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Whether the note is active or deleted
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the note
			AddTime *string `json:"add_time,omitempty"`

			// Content The content of the note in HTML format. Subject to sanitization on the back-end.
			Content *string `json:"content,omitempty"`

			// Deal The deal this note is attached to
			Deal *struct {
				// Title The title of the deal this note is attached to
				Title *string `json:"title,omitempty"`
			} `json:"deal,omitempty"`

			// DealId The ID of the deal the note is attached to
			DealId *int `json:"deal_id,omitempty"`

			// Id The ID of the note
			Id *int `json:"id,omitempty"`

			// LastUpdateUserId The ID of the user who last updated the note
			LastUpdateUserId *int `json:"last_update_user_id,omitempty"`

			// LeadId The ID of the lead the note is attached to
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// OrgId The ID of the organization the note is attached to
			OrgId *int `json:"org_id,omitempty"`

			// Organization The organization the note is attached to
			Organization *struct {
				// Name The name of the organization the note is attached to
				Name *string `json:"name,omitempty"`
			} `json:"organization,omitempty"`

			// Person The person the note is attached to
			Person *struct {
				// Name The name of the person the note is attached to
				Name *string `json:"name,omitempty"`
			} `json:"person,omitempty"`

			// PersonId The ID of the person the note is attached to
			PersonId *int `json:"person_id,omitempty"`

			// PinnedToDealFlag If true, the results are filtered by note to deal pinning state
			PinnedToDealFlag *bool `json:"pinned_to_deal_flag,omitempty"`

			// PinnedToOrganizationFlag If true, the results are filtered by note to organization pinning state
			PinnedToOrganizationFlag *bool `json:"pinned_to_organization_flag,omitempty"`

			// PinnedToPersonFlag If true, the results are filtered by note to person pinning state
			PinnedToPersonFlag *bool `json:"pinned_to_person_flag,omitempty"`

			// PinnedToProjectFlag If true, the results are filtered by note to project pinning state
			PinnedToProjectFlag *bool `json:"pinned_to_project_flag,omitempty"`

			// Project The project the note is attached to
			Project *struct {
				// Title The title of the project the note is attached to
				Title *string `json:"title,omitempty"`
			} `json:"project,omitempty"`

			// ProjectId The ID of the project the note is attached to
			ProjectId *int `json:"project_id,omitempty"`

			// UpdateTime The last updated date and time of the note
			UpdateTime *string `json:"update_time,omitempty"`

			// User The user who created the note
			User *struct {
				// Email The email of the note creator
				Email *string `json:"email,omitempty"`

				// IconUrl The URL of the note creator avatar picture
				IconUrl *string `json:"icon_url,omitempty"`

				// IsYou Whether the note is created by you or not
				IsYou *bool `json:"is_you,omitempty"`

				// Name The name of the note creator
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`

			// UserId The ID of the note creator
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNoteCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// Pagination The pagination details of the list
			Pagination *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// NextStart Next pagination start
				NextStart *int `json:"next_start,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"pagination,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of comments
		Data *[]struct {
			// ActiveFlag Whether the note is active or deleted
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the note
			AddTime *string `json:"add_time,omitempty"`

			// CompanyId The ID of the company
			CompanyId *int `json:"company_id,omitempty"`

			// Content The content of the note in HTML format. Subject to sanitization on the back-end.
			Content *string `json:"content,omitempty"`

			// ObjectId The ID of the object that the comment is attached to, will be the id of the note
			ObjectId *string `json:"object_id,omitempty"`

			// ObjectType The type of object that the comment is attached to, will be "note"
			ObjectType *string `json:"object_type,omitempty"`

			// UpdateTime The creation date and time of the note
			UpdateTime *string `json:"update_time,omitempty"`

			// UpdaterId The ID of the user who last updated the comment
			UpdaterId *int `json:"updater_id,omitempty"`

			// UserId The ID of the user who created the comment
			UserId *int `json:"user_id,omitempty"`

			// Uuid The ID of the note
			Uuid *openapi_types.UUID `json:"uuid,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetNoteCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNoteCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddNoteCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Whether the note is active or deleted
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the note
			AddTime *string `json:"add_time,omitempty"`

			// CompanyId The ID of the company
			CompanyId *int `json:"company_id,omitempty"`

			// Content The content of the note in HTML format. Subject to sanitization on the back-end.
			Content *string `json:"content,omitempty"`

			// ObjectId The ID of the object that the comment is attached to, will be the id of the note
			ObjectId *string `json:"object_id,omitempty"`

			// ObjectType The type of object that the comment is attached to, will be "note"
			ObjectType *string `json:"object_type,omitempty"`

			// UpdateTime The creation date and time of the note
			UpdateTime *string `json:"update_time,omitempty"`

			// UpdaterId The ID of the user who last updated the comment
			UpdaterId *int `json:"updater_id,omitempty"`

			// UserId The ID of the user who created the comment
			UserId *int `json:"user_id,omitempty"`

			// Uuid The ID of the note
			Uuid *openapi_types.UUID `json:"uuid,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddNoteCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddNoteCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data If the response is successful or not
		Data *bool `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Whether the note is active or deleted
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the note
			AddTime *string `json:"add_time,omitempty"`

			// CompanyId The ID of the company
			CompanyId *int `json:"company_id,omitempty"`

			// Content The content of the note in HTML format. Subject to sanitization on the back-end.
			Content *string `json:"content,omitempty"`

			// ObjectId The ID of the object that the comment is attached to, will be the id of the note
			ObjectId *string `json:"object_id,omitempty"`

			// ObjectType The type of object that the comment is attached to, will be "note"
			ObjectType *string `json:"object_type,omitempty"`

			// UpdateTime The creation date and time of the note
			UpdateTime *string `json:"update_time,omitempty"`

			// UpdaterId The ID of the user who last updated the comment
			UpdaterId *int `json:"updater_id,omitempty"`

			// UserId The ID of the user who created the comment
			UserId *int `json:"user_id,omitempty"`

			// Uuid The ID of the note
			Uuid *openapi_types.UUID `json:"uuid,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCommentForNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Whether the note is active or deleted
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the note
			AddTime *string `json:"add_time,omitempty"`

			// CompanyId The ID of the company
			CompanyId *int `json:"company_id,omitempty"`

			// Content The content of the note in HTML format. Subject to sanitization on the back-end.
			Content *string `json:"content,omitempty"`

			// ObjectId The ID of the object that the comment is attached to, will be the id of the note
			ObjectId *string `json:"object_id,omitempty"`

			// ObjectType The type of object that the comment is attached to, will be "note"
			ObjectType *string `json:"object_type,omitempty"`

			// UpdateTime The creation date and time of the note
			UpdateTime *string `json:"update_time,omitempty"`

			// UpdaterId The ID of the user who last updated the comment
			UpdaterId *int `json:"updater_id,omitempty"`

			// UserId The ID of the user who created the comment
			UserId *int `json:"user_id,omitempty"`

			// Uuid The ID of the note
			Uuid *openapi_types.UUID `json:"uuid,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateCommentForNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCommentForNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AccessToken You need to use an `access_token` for accessing the user's data via API. You will need to [refresh the access token](https://pipedrive.readme.io/docs/marketplace-oauth-authorization#step-7-refreshing-the-tokens) if the `access_token` becomes invalid.
		AccessToken *string `json:"access_token,omitempty"`

		// ApiDomain The base URL path, including the company_domain, where the requests can be sent to
		ApiDomain *string `json:"api_domain,omitempty"`

		// ExpiresIn The maximum time in seconds until the `access_token` expires
		ExpiresIn *int `json:"expires_in,omitempty"`

		// RefreshToken A refresh token is needed when you refresh the access token. refresh_token will expire if it isn't used in 60 days. Each time refresh_token is used, its expiry date is reset back to 60 days.
		RefreshToken *string `json:"refresh_token,omitempty"`

		// Scope List of scopes to which users have agreed to grant access within this `access_token`
		Scope *string `json:"scope,omitempty"`

		// TokenType The format of the token. Always "Bearer".
		TokenType *string `json:"token_type,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AccessToken You need to use an `access_token` for accessing the user's data via API. You will need to [refresh the access token](https://pipedrive.readme.io/docs/marketplace-oauth-authorization#step-7-refreshing-the-tokens) if the `access_token` becomes invalid.
		AccessToken *string `json:"access_token,omitempty"`

		// ApiDomain The base URL path, including the company_domain, where the requests can be sent to
		ApiDomain *string `json:"api_domain,omitempty"`

		// ExpiresIn The maximum time in seconds until the `access_token` expires
		ExpiresIn *int `json:"expires_in,omitempty"`

		// RefreshToken A refresh token is needed when you refresh the access token. refresh_token will expire if it isn't used in 60 days. Each time refresh_token is used, its expiry date is reset back to 60 days.
		RefreshToken *string `json:"refresh_token,omitempty"`

		// Scope List of scopes to which users have agreed to grant access within this `access_token`
		Scope *string `json:"scope,omitempty"`

		// TokenType The format of the token. Always "Bearer".
		TokenType *string `json:"token_type,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RefreshTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The list of deleted field IDs
			Id *[]int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationRelationshipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of organization relationships
		Data *[]struct {
			// ActiveFlag Whether the relationship is active or not
			ActiveFlag *string `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the relationship
			AddTime *string `json:"add_time,omitempty"`

			// CalculatedRelatedOrgId The ID of the linked organization
			CalculatedRelatedOrgId *int `json:"calculated_related_org_id,omitempty"`

			// CalculatedType The calculated type of the relationship with the linked organization
			CalculatedType *string `json:"calculated_type,omitempty"`

			// Id The ID of the organization relationship
			Id             *int `json:"id,omitempty"`
			RelLinkedOrgId *struct {
				// Address The address of the organization
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the item
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the item
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the item
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the item
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization
				Value *int `json:"value,omitempty"`
			} `json:"rel_linked_org_id,omitempty"`
			RelOwnerOrgId *struct {
				// Address The address of the organization
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the item
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the item
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the item
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the item
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization
				Value *int `json:"value,omitempty"`
			} `json:"rel_owner_org_id,omitempty"`

			// RelatedOrganizationName The name of the linked organization
			RelatedOrganizationName *string `json:"related_organization_name,omitempty"`

			// Type The type of the relationship
			Type *string `json:"type,omitempty"`

			// UpdateTime The last updated date and time of the relationship
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationRelationshipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationRelationshipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Whether the relationship is active or not
			ActiveFlag *string `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the relationship
			AddTime *string `json:"add_time,omitempty"`

			// Id The ID of the organization relationship
			Id             *int `json:"id,omitempty"`
			RelLinkedOrgId *struct {
				// Address The address of the organization
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the item
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the item
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the item
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the item
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization
				Value *int `json:"value,omitempty"`
			} `json:"rel_linked_org_id,omitempty"`
			RelOwnerOrgId *struct {
				// Address The address of the organization
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the item
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the item
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the item
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the item
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization
				Value *int `json:"value,omitempty"`
			} `json:"rel_owner_org_id,omitempty"`

			// Type The type of the relationship
			Type *string `json:"type,omitempty"`

			// UpdateTime The last updated date and time of the relationship
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddOrganizationRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of the deleted organization relationship
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Whether the relationship is active or not
			ActiveFlag *string `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the relationship
			AddTime *string `json:"add_time,omitempty"`

			// CalculatedRelatedOrgId The ID of the linked organization
			CalculatedRelatedOrgId *int `json:"calculated_related_org_id,omitempty"`

			// CalculatedType The calculated type of the relationship with the linked organization
			CalculatedType *string `json:"calculated_type,omitempty"`

			// Id The ID of the organization relationship
			Id             *int `json:"id,omitempty"`
			RelLinkedOrgId *struct {
				// Address The address of the organization
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the item
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the item
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the item
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the item
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization
				Value *int `json:"value,omitempty"`
			} `json:"rel_linked_org_id,omitempty"`
			RelOwnerOrgId *struct {
				// Address The address of the organization
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the item
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the item
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the item
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the item
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization
				Value *int `json:"value,omitempty"`
			} `json:"rel_owner_org_id,omitempty"`

			// Type The type of the relationship
			Type *string `json:"type,omitempty"`

			// UpdateTime The last updated date and time of the relationship
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrganizationRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Whether the relationship is active or not
			ActiveFlag *string `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the relationship
			AddTime *string `json:"add_time,omitempty"`

			// Id The ID of the organization relationship
			Id             *int `json:"id,omitempty"`
			RelLinkedOrgId *struct {
				// Address The address of the organization
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the item
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the item
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the item
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the item
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization
				Value *int `json:"value,omitempty"`
			} `json:"rel_linked_org_id,omitempty"`
			RelOwnerOrgId *struct {
				// Address The address of the organization
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the item
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the item
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the item
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the item
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization
				Value *int `json:"value,omitempty"`
			} `json:"rel_owner_org_id,omitempty"`

			// Type The type of the relationship
			Type *string `json:"type,omitempty"`

			// UpdateTime The last updated date and time of the relationship
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateOrganizationRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrganizationRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The IDs of the organizations that were deleted
			Id *[]float32 `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationsCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// ActiveFlag Whether the organization is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The date and time when the organization was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// Address The full address of the organization
			Address *string `json:"address,omitempty"`

			// AddressAdminAreaLevel1 The level 1 admin area of the organization location
			AddressAdminAreaLevel1 *string `json:"address_admin_area_level_1,omitempty"`

			// AddressAdminAreaLevel2 The level 2 admin area of the organization location
			AddressAdminAreaLevel2 *string `json:"address_admin_area_level_2,omitempty"`

			// AddressCountry The country of the organization location
			AddressCountry *string `json:"address_country,omitempty"`

			// AddressFormattedAddress The formatted organization location
			AddressFormattedAddress *string `json:"address_formatted_address,omitempty"`

			// AddressLocality The locality of the organization location
			AddressLocality *string `json:"address_locality,omitempty"`

			// AddressPostalCode The postal code of the organization location
			AddressPostalCode *string `json:"address_postal_code,omitempty"`

			// AddressRoute The route of the organization location
			AddressRoute *string `json:"address_route,omitempty"`

			// AddressStreetNumber The street number of the organization location
			AddressStreetNumber *string `json:"address_street_number,omitempty"`

			// AddressSublocality The sub-locality of the organization location
			AddressSublocality *string `json:"address_sublocality,omitempty"`

			// AddressSubpremise The sub-premise of the organization location
			AddressSubpremise *string `json:"address_subpremise,omitempty"`

			// CcEmail The BCC email associated with the organization
			CcEmail *string `json:"cc_email,omitempty"`

			// DeleteTime The date and time this organization was deleted. Format: YYYY-MM-DD HH:MM:SS
			DeleteTime *string `json:"delete_time"`

			// Id The ID of the organization
			Id *int `json:"id,omitempty"`

			// Label The label assigned to the organization. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
			Label *int `json:"label"`

			// LabelIds The IDs of labels assigned to the organization. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
			LabelIds *[]int `json:"label_ids,omitempty"`

			// Name The name of the organization
			Name *string `json:"name,omitempty"`

			// OwnerId The ID of the owner
			OwnerId *int `json:"owner_id,omitempty"`

			// UpdateTime The last updated date and time of the organization. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility group ID of who can see the organization
			VisibleTo *string `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationsCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationsCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// ActivityDistribution The distribution of activities related to the organization grouped by the user ID
			ActivityDistribution *struct {
				// ASSIGNEDTOUSERID The ID of the user
				ASSIGNEDTOUSERID *struct {
					// Activities The count of activities related to the user grouped by activity type
					Activities *struct {
						// ACTIVITYTYPENAME The count of activities related to a specific type
						ACTIVITYTYPENAME *int `json:"ACTIVITY_TYPE_NAME,omitempty"`
					} `json:"activities,omitempty"`

					// ActivityCount The overall count of activities for the user
					ActivityCount *int `json:"activity_count,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// Share The percentage of activities belongs to the user
					Share *int `json:"share,omitempty"`
				} `json:"ASSIGNED_TO_USER_ID,omitempty"`
			} `json:"activity_distribution,omitempty"`

			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of activities
		Data *[]struct {
			// ActiveFlag Whether the activity is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// AssignedToUserId The ID of the user to whom the activity is assigned to. Equal to `user_id`.
			AssignedToUserId *int `json:"assigned_to_user_id,omitempty"`

			// Attendees The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address.
			Attendees *[]map[string]interface{} `json:"attendees"`

			// BusyFlag Marks if the activity is set as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
			BusyFlag *bool `json:"busy_flag,omitempty"`

			// CalendarSyncIncludeContext For activities that sync to an external calendar, this setting indicates if the activity syncs with context (what are the deals, persons, organizations this activity is related to)
			CalendarSyncIncludeContext *string `json:"calendar_sync_include_context,omitempty"`

			// CompanyId The user's company ID
			CompanyId *int `json:"company_id,omitempty"`

			// ConferenceMeetingClient The ID of the Marketplace app, which is connected to this activity
			ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

			// ConferenceMeetingId The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
			ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

			// ConferenceMeetingUrl The link to join the meeting which is associated with this activity
			ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

			// CreatedByUserId The ID of the user who created the activity
			CreatedByUserId *int `json:"created_by_user_id,omitempty"`

			// DealDropboxBcc The BCC email address of the deal
			DealDropboxBcc *string `json:"deal_dropbox_bcc,omitempty"`

			// DealId The ID of the deal this activity is associated with
			DealId *int `json:"deal_id,omitempty"`

			// DealTitle The name of the deal this activity is associated with
			DealTitle *string `json:"deal_title,omitempty"`

			// Done Whether the activity is done or not
			Done *bool `json:"done,omitempty"`

			// DueDate The due date of the activity. Format: YYYY-MM-DD
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// DueTime The due time of the activity in UTC. Format: HH:MM
			DueTime *string `json:"due_time,omitempty"`

			// Duration The duration of the activity. Format: HH:MM
			Duration *string `json:"duration,omitempty"`

			// File The file that is attached to this activity. For example, this can be a reference to an audio note file generated with Pipedrive mobile app.
			File *map[string]interface{} `json:"file,omitempty"`

			// GcalEventId For the activity which syncs to Google calendar, this is the Google event ID. NB! This field is related to old Google calendar sync and will be deprecated soon.
			GcalEventId *string `json:"gcal_event_id,omitempty"`

			// GoogleCalendarEtag The Google calendar API etag (version) that is used for syncing this activity. NB! This field is related to old Google calendar sync and will be deprecated soon.
			GoogleCalendarEtag *string `json:"google_calendar_etag,omitempty"`

			// GoogleCalendarId The Google calendar ID that this activity syncs to. NB! This field is related to old Google calendar sync and will be deprecated soon.
			GoogleCalendarId *string `json:"google_calendar_id,omitempty"`

			// Id The ID of the activity, generated when the activity was created
			Id *int `json:"id,omitempty"`

			// LastNotificationTime The date and time of latest notifications sent about this activity to the participants or the attendees of this activity
			LastNotificationTime *string `json:"last_notification_time,omitempty"`

			// LastNotificationUserId The ID of the user who triggered the sending of the latest notifications about this activity to the participants or the attendees of this activity
			LastNotificationUserId *int `json:"last_notification_user_id,omitempty"`

			// LeadId The ID of the lead in the UUID format this activity is associated with
			LeadId *openapi_types.UUID `json:"lead_id"`

			// Location The address of the activity.
			Location *string `json:"location,omitempty"`

			// LocationAdminAreaLevel1 A subfield of the location field. Indicates state/county.
			LocationAdminAreaLevel1 *string `json:"location_admin_area_level_1,omitempty"`

			// LocationAdminAreaLevel2 A subfield of the location field. Indicates region.
			LocationAdminAreaLevel2 *string `json:"location_admin_area_level_2,omitempty"`

			// LocationCountry A subfield of the location field. Indicates country.
			LocationCountry *string `json:"location_country,omitempty"`

			// LocationFormattedAddress A subfield of the location field. Indicates full/combined address.
			LocationFormattedAddress *string `json:"location_formatted_address,omitempty"`

			// LocationLocality A subfield of the location field. Indicates city/town/village/locality.
			LocationLocality *string `json:"location_locality,omitempty"`

			// LocationPostalCode A subfield of the location field. Indicates ZIP/postal code.
			LocationPostalCode *string `json:"location_postal_code,omitempty"`

			// LocationRoute A subfield of the location field. Indicates street name.
			LocationRoute *string `json:"location_route,omitempty"`

			// LocationStreetNumber A subfield of the location field. Indicates house number.
			LocationStreetNumber *string `json:"location_street_number,omitempty"`

			// LocationSublocality A subfield of the location field. Indicates district/sublocality.
			LocationSublocality *string `json:"location_sublocality,omitempty"`

			// LocationSubpremise A subfield of the location field. Indicates apartment/suite number.
			LocationSubpremise *string `json:"location_subpremise,omitempty"`

			// MarkedAsDoneTime The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// Note The note of the activity (HTML format)
			Note *string `json:"note,omitempty"`

			// NotificationLanguageId The ID of the language the notifications are sent in
			NotificationLanguageId *int `json:"notification_language_id,omitempty"`

			// OrgId The ID of the organization this activity is associated with
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization this activity is associated with
			OrgName *string `json:"org_name,omitempty"`

			// OwnerName The name of the user this activity is owned by
			OwnerName *string `json:"owner_name,omitempty"`

			// Participants List of multiple persons (participants) this activity is associated with
			Participants *[]map[string]interface{} `json:"participants"`

			// PersonDropboxBcc The BCC email address of the person
			PersonDropboxBcc *string `json:"person_dropbox_bcc,omitempty"`

			// PersonId The ID of the person this activity is associated with
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person this activity is associated with
			PersonName *string `json:"person_name,omitempty"`

			// ProjectId The ID of the project this activity is associated with
			ProjectId *int `json:"project_id"`

			// PublicDescription Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
			PublicDescription *string `json:"public_description,omitempty"`

			// RecMasterActivityId The ID of parent activity for a recurrent activity if the current activity is an exception to recurrence rules
			RecMasterActivityId *int `json:"rec_master_activity_id,omitempty"`

			// RecRule The rule for the recurrence of the activity. Is important for activities synced into Pipedrive from an external calendar. Example: "RRULE:FREQ=WEEKLY;BYDAY=WE"
			RecRule *string `json:"rec_rule,omitempty"`

			// RecRuleExtension Additional rules for the recurrence of the activity, extend the `rec_rule`. Is important for activities synced into Pipedrive from an external calendar.
			RecRuleExtension *string `json:"rec_rule_extension,omitempty"`

			// ReferenceId Together with the `reference_type`, gives the ID of the other object
			ReferenceId *int `json:"reference_id,omitempty"`

			// ReferenceType If the activity references some other object, it is indicated here. For example, value `Salesphone` refers to activities created with Caller.
			ReferenceType *string `json:"reference_type,omitempty"`

			// Series The list of recurring activity instances. It is in a structure as follows: `[{due_date: "2020-06-24", due_time: "10:00:00"}]`
			Series *[]map[string]interface{} `json:"series,omitempty"`

			// SourceTimezone The timezone the activity was created in an external calendar
			SourceTimezone *string `json:"source_timezone,omitempty"`

			// Subject The subject of the activity
			Subject *string `json:"subject,omitempty"`

			// Type The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
			Type *string `json:"type,omitempty"`

			// UpdateTime The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`

			// UpdateUserId The ID of the user who was the last to update this activity
			UpdateUserId *int `json:"update_user_id,omitempty"`

			// UserId The ID of the user whom the activity is assigned to
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationChangelogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// ActorUserId The ID of the user who made the change
			ActorUserId *int `json:"actor_user_id,omitempty"`

			// ChangeSource The source of change, for example 'app', 'mobile', 'api', etc.
			ChangeSource *string `json:"change_source"`

			// ChangeSourceUserAgent The user agent from which the change was made
			ChangeSourceUserAgent *string `json:"change_source_user_agent"`

			// FieldKey The key of the field that was changed
			FieldKey *string `json:"field_key,omitempty"`

			// IsBulkUpdateFlag Whether the change was made as part of a bulk update
			IsBulkUpdateFlag *bool `json:"is_bulk_update_flag,omitempty"`

			// NewValue The value of the field after the change
			NewValue *string `json:"new_value"`

			// OldValue The value of the field before the change
			OldValue *string `json:"old_value"`

			// Time The date and time of the change
			Time *string `json:"time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationChangelogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationChangelogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of deals
		Data *[]struct {
			// Active Whether the deal is active or not
			Active *bool `json:"active,omitempty"`

			// ActivitiesCount The number of activities associated with the deal
			ActivitiesCount *int `json:"activities_count,omitempty"`

			// Acv Only available in Growth and above plans
			//
			// The Annual Contract Value of the deal
			//
			// Null if there are no products attached to the deal
			Acv *float32 `json:"acv"`

			// AcvCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Contract Value of the deal
			//
			// If the `acv` is null, this will also be null
			AcvCurrency *string `json:"acv_currency"`

			// AddTime The creation date and time of the deal
			AddTime *string `json:"add_time,omitempty"`

			// Arr Only available in Growth and above plans
			//
			// The Annual Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Arr *float32 `json:"arr"`

			// ArrCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Recurring Revenue of the deal
			//
			// If the `arr` is null, this will also be null
			ArrCurrency *string `json:"arr_currency"`

			// CcEmail The BCC email of the deal
			CcEmail *string `json:"cc_email,omitempty"`

			// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CloseTime The date and time of closing the deal
			CloseTime *string `json:"close_time"`

			// CreatorUserId The creator of the deal
			CreatorUserId *struct {
				// ActiveFlag Whether the creator is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The email of the deal creator
				Email *string `json:"email,omitempty"`

				// HasPic If the creator has a picture or not
				HasPic *bool `json:"has_pic,omitempty"`

				// Id The ID of the deal creator
				Id *int `json:"id,omitempty"`

				// Name The name of the deal creator
				Name *string `json:"name,omitempty"`

				// PicHash The creator picture hash
				PicHash *string `json:"pic_hash"`

				// Value The ID of the deal creator
				Value *int `json:"value,omitempty"`
			} `json:"creator_user_id,omitempty"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// Deleted Whether the deal is deleted or not
			Deleted *bool `json:"deleted,omitempty"`

			// DoneActivitiesCount The number of completed activities associated with the deal
			DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

			// EmailMessagesCount The number of emails associated with the deal
			EmailMessagesCount *int `json:"email_messages_count,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// FilesCount The number of files associated with the deal
			FilesCount *int `json:"files_count,omitempty"`

			// FirstWonTime The date and time of the first time changing the deal status as won
			FirstWonTime *string `json:"first_won_time,omitempty"`

			// FollowersCount The number of followers associated with the deal
			FollowersCount *int `json:"followers_count,omitempty"`

			// FormattedValue The deal value formatted with selected currency. E.g. US$500
			FormattedValue *string `json:"formatted_value,omitempty"`

			// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
			FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// IsArchived Whether the deal is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// Label The label or multiple labels assigned to the deal
			Label *string `json:"label,omitempty"`

			// LastActivityDate The date of the last activity associated with the deal
			LastActivityDate *string `json:"last_activity_date"`

			// LastActivityId The ID of the last activity associated with the deal
			LastActivityId *int `json:"last_activity_id"`

			// LastIncomingMailTime The date and time of the last incoming email associated with the deal
			LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

			// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
			LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status as lost
			LostTime *string `json:"lost_time,omitempty"`

			// Mrr Only available in Growth and above plans
			//
			// The Monthly Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Mrr *float32 `json:"mrr"`

			// MrrCurrency Only available in Growth and above plans
			//
			// The Currency for Monthly Recurring Revenue of the deal
			//
			// If the `mrr` is null, this will also be null
			MrrCurrency *string `json:"mrr_currency"`

			// NextActivityDate The date of the next activity associated with the deal
			NextActivityDate *string `json:"next_activity_date,omitempty"`

			// NextActivityDuration The duration of the next activity associated with the deal
			NextActivityDuration *string `json:"next_activity_duration,omitempty"`

			// NextActivityId The ID of the next activity associated with the deal
			NextActivityId *int `json:"next_activity_id"`

			// NextActivityNote The note of the next activity associated with the deal
			NextActivityNote *string `json:"next_activity_note,omitempty"`

			// NextActivitySubject The subject of the next activity associated with the deal
			NextActivitySubject *string `json:"next_activity_subject,omitempty"`

			// NextActivityTime The time of the next activity associated with the deal
			NextActivityTime *string `json:"next_activity_time,omitempty"`

			// NextActivityType The type of the next activity associated with the deal
			NextActivityType *string `json:"next_activity_type,omitempty"`

			// NotesCount The number of notes associated with the deal
			NotesCount *int `json:"notes_count,omitempty"`

			// OrgHidden If the organization that is associated with the deal is hidden or not
			OrgHidden *bool `json:"org_hidden,omitempty"`
			OrgId     *struct {
				// ActiveFlag Whether the associated organization is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Address The address of the organization that is associated with the deal
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the deal
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the deal
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the deal
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the deal
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization associated with the deal
				Value *int `json:"value,omitempty"`
			} `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the deal
			OrgName *string `json:"org_name,omitempty"`

			// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
			OriginId *string `json:"origin_id"`

			// OwnerName The name of the deal owner
			OwnerName *string `json:"owner_name,omitempty"`

			// ParticipantsCount The number of participants associated with the deal
			ParticipantsCount *int `json:"participants_count,omitempty"`

			// PersonHidden If the person that is associated with the deal is hidden or not
			PersonHidden *bool `json:"person_hidden,omitempty"`
			PersonId     *struct {
				// ActiveFlag Whether the associated person is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The emails of the person associated with the deal
				Email *[]struct {
					// Label The type of the email
					Label *string `json:"label,omitempty"`

					// Primary If this is the primary email or not
					Primary *bool `json:"primary,omitempty"`

					// Value The email of the associated person
					Value *string `json:"value,omitempty"`
				} `json:"email,omitempty"`

				// Name The name of the person associated with the deal
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the person that is associated with the deal
				OwnerId *int `json:"owner_id,omitempty"`

				// Phone The phone numbers of the person associated with the deal
				Phone *[]struct {
					// Label The type of the phone number
					Label *string `json:"label,omitempty"`

					// Primary If this is the primary phone number or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number of the person associated with the deal
					Value *string `json:"value,omitempty"`
				} `json:"phone,omitempty"`

				// Value The ID of the person associated with the deal
				Value *int `json:"value,omitempty"`
			} `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the deal
			PersonName *string `json:"person_name,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// ProductsCount The number of products associated with the deal
			ProductsCount *int `json:"products_count,omitempty"`

			// RottenTime The date and time of changing the deal status as rotten
			RottenTime *string `json:"rotten_time"`

			// StageChangeTime The last updated date and time of the deal stage
			StageChangeTime *string `json:"stage_change_time,omitempty"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// StageOrderNr The order number of the deal stage associated with the deal
			StageOrderNr *int `json:"stage_order_nr,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UndoneActivitiesCount The number of incomplete activities associated with the deal
			UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

			// UpdateTime The last updated date and time of the deal
			UpdateTime *string `json:"update_time,omitempty"`
			UserId     *struct {
				// ActiveFlag Whether the user is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The email of the user
				Email *string `json:"email,omitempty"`

				// HasPic If the user has a picture or not
				HasPic *bool `json:"has_pic,omitempty"`

				// Id The ID of the user
				Id *int `json:"id,omitempty"`

				// Name The name of the user
				Name *string `json:"name,omitempty"`

				// PicHash The user picture hash
				PicHash *string `json:"pic_hash"`

				// Value The ID of the user
				Value *int `json:"value,omitempty"`
			} `json:"user_id,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *string `json:"visible_to,omitempty"`

			// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
			WeightedValue *float32 `json:"weighted_value,omitempty"`

			// WeightedValueCurrency The currency associated with the deal
			WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

			// WonTime The date and time of changing the deal status as won
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
			Person *struct {
				// PERSONID The ID of the person associated with the item
				PERSONID *struct {
					// ActiveFlag Whether the associated person is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The emails of the person associated with the item
					Email *[]struct {
						// Label The type of the email
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary email or not
						Primary *bool `json:"primary,omitempty"`

						// Value The email of the associated person
						Value *string `json:"value,omitempty"`
					} `json:"email,omitempty"`

					// Id The ID of the person associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the person associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the person that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// Phone The phone numbers of the person associated with the item
					Phone *[]struct {
						// Label The type of the phone number
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary phone number or not
						Primary *bool `json:"primary,omitempty"`

						// Value The phone number of the person associated with the item
						Value *string `json:"value,omitempty"`
					} `json:"phone,omitempty"`
				} `json:"PERSON_ID,omitempty"`
			} `json:"person,omitempty"`
			Pipeline *struct {
				// Active Whether this pipeline will be made inactive (hidden) or active
				Active *bool `json:"active,omitempty"`

				// AddTime The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// DealProbability Whether deal probability is disabled or enabled for this pipeline
				DealProbability *bool `json:"deal_probability,omitempty"`

				// Id The ID of the pipeline
				Id *int `json:"id,omitempty"`

				// Name The name of the pipeline
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
				OrderNr *int `json:"order_nr,omitempty"`

				// UpdateTime The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`

				// UrlTitle The pipeline title displayed in the URL
				UrlTitle *string `json:"url_title,omitempty"`
			} `json:"pipeline,omitempty"`
			Stage *struct {
				// ActiveFlag Whether the stage is active or deleted
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The stage creation time. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
				DealProbability *int `json:"deal_probability,omitempty"`

				// Id The ID of the stage
				Id *int `json:"id,omitempty"`

				// Name The name of the stage
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of the stage
				OrderNr *int `json:"order_nr,omitempty"`

				// PipelineId The ID of the pipeline to add the stage to
				PipelineId *int `json:"pipeline_id,omitempty"`

				// RottenDays The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
				RottenDays *int `json:"rotten_days,omitempty"`

				// RottenFlag Whether deals in this stage can become rotten
				RottenFlag *bool `json:"rotten_flag,omitempty"`

				// UpdateTime The stage update time. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"stage,omitempty"`
			User *struct {
				USERID *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`
				} `json:"USER_ID,omitempty"`
			} `json:"user,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of files
		Data *[]struct {
			// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivityId The ID of the activity to associate the file with
			ActivityId *int `json:"activity_id,omitempty"`

			// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// Cid The ID of the inline attachment
			Cid *string `json:"cid,omitempty"`

			// DealId The ID of the deal to associate the file with
			DealId *int `json:"deal_id,omitempty"`

			// DealName The name of the deal associated with the dile
			DealName *string `json:"deal_name,omitempty"`

			// Description The description of the file
			Description *string `json:"description,omitempty"`

			// FileName The original name of the file
			FileName *string `json:"file_name,omitempty"`

			// FileSize The size of the file
			FileSize *int `json:"file_size,omitempty"`

			// Id The ID of the file
			Id *int `json:"id,omitempty"`

			// InlineFlag Whether the file was uploaded as inline or not
			InlineFlag *bool `json:"inline_flag,omitempty"`

			// LeadId The ID of the lead to associate the file with
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// LeadName The name of the lead associated with the file
			LeadName *string `json:"lead_name,omitempty"`

			// MailMessageId The ID of the mail message to associate the file with
			MailMessageId *string `json:"mail_message_id,omitempty"`

			// MailTemplateId The ID of the mail template to associate the file with
			MailTemplateId *string `json:"mail_template_id,omitempty"`

			// Name The visible name of the file
			Name *string `json:"name,omitempty"`

			// OrgId The ID of the organization to associate the file with
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the file
			OrgName *string `json:"org_name,omitempty"`

			// PersonId The ID of the person to associate the file with
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the file
			PersonName *string `json:"person_name,omitempty"`

			// ProductId The ID of the product to associate the file with
			ProductId *int `json:"product_id,omitempty"`

			// ProductName The name of the product associated with the file
			ProductName *string `json:"product_name,omitempty"`

			// RemoteId The ID of the remote item
			RemoteId *string `json:"remote_id,omitempty"`

			// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
			RemoteLocation *string `json:"remote_location,omitempty"`

			// S3Bucket The location of the cloud storage
			S3Bucket *string `json:"s3_bucket,omitempty"`

			// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// Url The URL of the download file
			Url *string `json:"url,omitempty"`

			// UserId The ID of the user to associate the file with
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// Data The data related to the update
			Data *map[string]interface{} `json:"data,omitempty"`

			// Object The type of the person update. (Possible object types - organizationChange, dealChange, file, activity)
			Object *string `json:"object,omitempty"`

			// Timestamp The creation date and time of the update
			Timestamp *string `json:"timestamp,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
			User *struct {
				USERID *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`
				} `json:"USER_ID,omitempty"`
			} `json:"user,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationMailMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of mail messages
		Data *[]struct {
			Data *struct {
				// AccountId The connection account ID
				AccountId *string `json:"account_id,omitempty"`

				// AddTime The insertion into the database time of the mail message
				AddTime *time.Time `json:"add_time,omitempty"`

				// Bcc The array of mail message blind copies (object)
				Bcc *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"bcc,omitempty"`

				// BodyUrl The mail message body URL
				BodyUrl *string `json:"body_url,omitempty"`

				// Cc The array of mail message copies (object)
				Cc *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"cc,omitempty"`

				// CompanyId The ID of the company
				CompanyId *int `json:"company_id,omitempty"`

				// DeletedFlag Whether the mail message is deleted or not
				DeletedFlag *GetOrganizationMailMessages200DataDataDeletedFlag `json:"deleted_flag,omitempty"`

				// Draft If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
				Draft *string `json:"draft,omitempty"`

				// DraftFlag Whether the mail message is a draft or not
				DraftFlag *GetOrganizationMailMessages200DataDataDraftFlag `json:"draft_flag,omitempty"`

				// ExternalDeletedFlag If the Mail Message has been deleted on the provider side or not
				ExternalDeletedFlag *bool `json:"external_deleted_flag,omitempty"`

				// From The array of mail message sender (object)
				From *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"from,omitempty"`

				// HasAttachmentsFlag Whether the mail message has an attachment or not
				HasAttachmentsFlag *GetOrganizationMailMessages200DataDataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

				// HasBodyFlag Whether the mail message has a body or not
				HasBodyFlag *GetOrganizationMailMessages200DataDataHasBodyFlag `json:"has_body_flag,omitempty"`

				// HasInlineAttachmentsFlag Whether the mail message has an inline attachment or not
				HasInlineAttachmentsFlag *GetOrganizationMailMessages200DataDataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

				// HasRealAttachmentsFlag Whether the mail message has an attachment (which is not inline) or not
				HasRealAttachmentsFlag *GetOrganizationMailMessages200DataDataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

				// Id ID of the mail message.
				Id *int `json:"id,omitempty"`

				// ItemType The type of the data item
				ItemType *string `json:"item_type,omitempty"`

				// MailLinkTrackingEnabledFlag Whether the link tracking in mail message body is enabled.
				MailLinkTrackingEnabledFlag *GetOrganizationMailMessages200DataDataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

				// MailThreadId ID of the mail message thread
				MailThreadId *int `json:"mail_thread_id,omitempty"`

				// MailTrackingStatus The status of tracking mail message. Value is `null` if tracking is not enabled.
				MailTrackingStatus *GetOrganizationMailMessages200DataDataMailTrackingStatus `json:"mail_tracking_status"`

				// MessageTime Creation or receival time of the mail message
				MessageTime *time.Time `json:"message_time,omitempty"`

				// MuaMessageId The Mail Message ID assigned by the mail user agent
				MuaMessageId *string `json:"mua_message_id,omitempty"`

				// NylasId The Mail Message ID assigned by the sync provider
				NylasId *string `json:"nylas_id,omitempty"`

				// ReadFlag Whether the mail message is read or not by the user
				ReadFlag *GetOrganizationMailMessages200DataDataReadFlag `json:"read_flag,omitempty"`

				// S3Bucket The name of the S3 bucket
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// S3BucketPath The path of the S3 bucket
				S3BucketPath *string `json:"s3_bucket_path,omitempty"`

				// SentFlag Whether the mail message has been sent or not
				SentFlag *GetOrganizationMailMessages200DataDataSentFlag `json:"sent_flag,omitempty"`

				// SentFromPipedriveFlag Whether the mail message has been sent from Pipedrive app or not
				SentFromPipedriveFlag *GetOrganizationMailMessages200DataDataSentFromPipedriveFlag `json:"sent_from_pipedrive_flag,omitempty"`

				// SmartBccFlag Whether the mail message has been created by Smart Email BCC feature or not
				SmartBccFlag *GetOrganizationMailMessages200DataDataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

				// Snippet The snippet of mail message. Snippet length is up to 225 characters.
				Snippet *string `json:"snippet,omitempty"`

				// Subject The subject of mail message
				Subject *string `json:"subject,omitempty"`

				// SyncedFlag Whether the mail message is synced with the provider or not
				SyncedFlag *GetOrganizationMailMessages200DataDataSyncedFlag `json:"synced_flag,omitempty"`

				// TemplateId The ID of the mail template
				TemplateId *int `json:"template_id,omitempty"`

				// Timestamp The add date and time of the Mail Message
				Timestamp *string `json:"timestamp,omitempty"`

				// To The array of mail message receiver (object)
				To *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"to,omitempty"`

				// UpdateTime The updating time in the database of the mail message
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// UserId ID of the user whom mail message will be assigned to
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Object The type of the data item
			Object *string `json:"object,omitempty"`

			// Timestamp The date and time when the item was created
			Timestamp *string `json:"timestamp,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetOrganizationMailMessages200DataDataDeletedFlag float32
type GetOrganizationMailMessages200DataDataDraftFlag float32
type GetOrganizationMailMessages200DataDataHasAttachmentsFlag float32
type GetOrganizationMailMessages200DataDataHasBodyFlag float32
type GetOrganizationMailMessages200DataDataHasInlineAttachmentsFlag float32
type GetOrganizationMailMessages200DataDataHasRealAttachmentsFlag float32
type GetOrganizationMailMessages200DataDataMailLinkTrackingEnabledFlag float32
type GetOrganizationMailMessages200DataDataMailTrackingStatus string
type GetOrganizationMailMessages200DataDataReadFlag float32
type GetOrganizationMailMessages200DataDataSentFlag float32
type GetOrganizationMailMessages200DataDataSentFromPipedriveFlag float32
type GetOrganizationMailMessages200DataDataSmartBccFlag float32
type GetOrganizationMailMessages200DataDataSyncedFlag float32

// Status returns HTTPResponse.Status
func (r GetOrganizationMailMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationMailMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of the merged organization
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MergeOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The list of permitted user IDs
		Data *[]float32 `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationPersonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of persons
		Data *[]struct {
			// ActiveFlag Whether the person is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivitiesCount The count of activities related to the person
			ActivitiesCount *int `json:"activities_count,omitempty"`

			// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// CcEmail The BCC email associated with the person
			CcEmail *string `json:"cc_email,omitempty"`

			// ClosedDealsCount The count of closed deals related with the item
			ClosedDealsCount *int `json:"closed_deals_count,omitempty"`

			// CompanyId The ID of the company related to the person
			CompanyId *int `json:"company_id,omitempty"`

			// DoneActivitiesCount The count of done activities related to the person
			DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

			// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" } ]`. Please note that only `value` is required.
			Email *[]struct {
				// Label The label that indicates the type of the email. (Possible values - work, home or other)
				Label *string `json:"label,omitempty"`

				// Primary Boolean that indicates if email is primary for the person or not
				Primary *bool `json:"primary,omitempty"`

				// Value Email
				Value *string `json:"value,omitempty"`
			} `json:"email,omitempty"`

			// EmailMessagesCount The count of email messages related to the person
			EmailMessagesCount *int `json:"email_messages_count,omitempty"`

			// FilesCount The count of files related to the person
			FilesCount *int `json:"files_count,omitempty"`

			// FirstChar The first letter of the name of the person
			FirstChar *string `json:"first_char,omitempty"`

			// FirstName The first name of the person
			FirstName *string `json:"first_name,omitempty"`

			// FollowersCount The count of followers related to the person
			FollowersCount *int `json:"followers_count,omitempty"`

			// Id The ID of the person
			Id *int `json:"id,omitempty"`

			// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
			Label *int `json:"label,omitempty"`

			// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LastActivityDate The date of the last activity associated with the deal
			LastActivityDate *string `json:"last_activity_date"`

			// LastActivityId The ID of the last activity associated with the deal
			LastActivityId *int `json:"last_activity_id"`

			// LastIncomingMailTime The date and time of the last incoming email associated with the person
			LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

			// LastName The last name of the person
			LastName *string `json:"last_name,omitempty"`

			// LastOutgoingMailTime The date and time of the last outgoing email associated with the person
			LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

			// LostDealsCount The count of lost deals related with the item
			LostDealsCount *int `json:"lost_deals_count,omitempty"`

			// Name The name of the person
			Name *string `json:"name,omitempty"`

			// NextActivityDate The date of the next activity associated with the deal
			NextActivityDate *string `json:"next_activity_date"`

			// NextActivityId The ID of the next activity associated with the deal
			NextActivityId *int `json:"next_activity_id"`

			// NextActivityTime The time of the next activity associated with the deal
			NextActivityTime *string `json:"next_activity_time"`

			// NotesCount The count of notes related to the person
			NotesCount *int `json:"notes_count,omitempty"`

			// OpenDealsCount The count of open deals related with the item
			OpenDealsCount *int `json:"open_deals_count,omitempty"`
			OrgId          *struct {
				// ActiveFlag Whether the associated organization is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Address The address of the organization
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the item
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the item
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the item
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the item
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization
				Value *int `json:"value,omitempty"`
			} `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the person
			OrgName *string `json:"org_name,omitempty"`
			OwnerId *struct {
				// ActiveFlag Whether the user is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The email of the user
				Email *string `json:"email,omitempty"`

				// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
				HasPic *int `json:"has_pic,omitempty"`

				// Id The ID of the user
				Id *int `json:"id,omitempty"`

				// Name The name of the user
				Name *string `json:"name,omitempty"`

				// PicHash The user picture hash
				PicHash *string `json:"pic_hash"`

				// Value The ID of the owner
				Value *int `json:"value,omitempty"`
			} `json:"owner_id,omitempty"`

			// OwnerName The name of the owner associated with the person
			OwnerName *string `json:"owner_name,omitempty"`

			// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
			Phone *[]struct {
				// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
				Label *string `json:"label,omitempty"`

				// Primary Boolean that indicates if phone number is primary for the person or not
				Primary *bool `json:"primary,omitempty"`

				// Value The phone number
				Value *string `json:"value,omitempty"`
			} `json:"phone,omitempty"`
			PictureId *struct {
				// ActiveFlag Whether the associated picture is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The add time of the picture
				AddTime *string `json:"add_time,omitempty"`

				// AddedByUserId The ID of the user who added the picture
				AddedByUserId *int `json:"added_by_user_id,omitempty"`

				// Id The ID of the picture associated with the item
				Id *int `json:"id,omitempty"`

				// ItemId The ID of related item
				ItemId *int `json:"item_id,omitempty"`

				// ItemType The type of item the picture is related to
				ItemType *string `json:"item_type,omitempty"`
				Pictures *struct {
					// N128 The URL of the 128*128 picture
					N128 *string `json:"128,omitempty"`

					// N512 The URL of the 512*512 picture
					N512 *string `json:"512,omitempty"`
				} `json:"pictures,omitempty"`

				// UpdateTime The update time of the picture
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"picture_id,omitempty"`

			// RelatedClosedDealsCount The count of related closed deals related with the item
			RelatedClosedDealsCount *int `json:"related_closed_deals_count,omitempty"`

			// RelatedLostDealsCount The count of related lost deals related with the item
			RelatedLostDealsCount *int `json:"related_lost_deals_count,omitempty"`

			// RelatedOpenDealsCount The count of related open deals related with the item
			RelatedOpenDealsCount *int `json:"related_open_deals_count,omitempty"`

			// RelatedWonDealsCount The count of related won deals related with the item
			RelatedWonDealsCount *int `json:"related_won_deals_count,omitempty"`

			// UndoneActivitiesCount The count of undone activities related to the person
			UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

			// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility group ID of who can see the person
			VisibleTo *string `json:"visible_to,omitempty"`

			// WonDealsCount The count of won deals related with the item
			WonDealsCount *int `json:"won_deals_count,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
			User *struct {
				USERID *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`
				} `json:"USER_ID,omitempty"`
			} `json:"user,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationPersonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationPersonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionSetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The array of permission set
		Data *[]struct {
			// App The app that permission set belongs to
			App *GetPermissionSets200DataApp `json:"app,omitempty"`

			// AssignmentCount The number of users assigned to this permission set
			AssignmentCount *int `json:"assignment_count,omitempty"`

			// Description The description of the permission set
			Description *string `json:"description,omitempty"`

			// Id The ID of user permission set
			Id *string `json:"id,omitempty"`

			// Name The name of the permission set
			Name *string `json:"name,omitempty"`

			// Type The type of permission set
			Type *GetPermissionSets200DataType `json:"type,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetPermissionSets200DataApp string
type GetPermissionSets200DataType string

// Status returns HTTPResponse.Status
func (r GetPermissionSetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionSetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// App The app that permission set belongs to
		App *GetPermissionSet200App `json:"app,omitempty"`

		// AssignmentCount The number of users assigned to this permission set
		AssignmentCount *int `json:"assignment_count,omitempty"`

		// Contents A permission assigned to this permission set
		Contents *[]string `json:"contents,omitempty"`

		// Description The description of the permission set
		Description *string `json:"description,omitempty"`

		// Id The ID of user permission set
		Id *string `json:"id,omitempty"`

		// Name The name of the permission set
		Name *string `json:"name,omitempty"`

		// Type The type of permission set
		Type *GetPermissionSet200Type `json:"type,omitempty"`
	}
	JSON404 *interface{}
}
type GetPermissionSet200App string
type GetPermissionSet200Type string

// Status returns HTTPResponse.Status
func (r GetPermissionSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionSetAssignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An array of the assignments of the user
		Data *[]struct {
			// Name The name of the permission set
			Name *string `json:"name,omitempty"`

			// PermissionSetId The ID of the permission set
			PermissionSetId *string `json:"permission_set_id,omitempty"`

			// UserId The ID of the user in the permission set
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *interface{}
}

// Status returns HTTPResponse.Status
func (r GetPermissionSetAssignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionSetAssignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersonFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The list of deleted field IDs
			Id *[]int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePersonFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersonFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The list of deleted persons IDs
			Id *[]int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePersonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonsCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// ActiveFlag Whether the person is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// CcEmail The BCC email associated with the person
			CcEmail *string `json:"cc_email,omitempty"`

			// DeleteTime The date and time this person was deleted. Format: YYYY-MM-DD HH:MM:SS
			DeleteTime *string `json:"delete_time"`

			// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" }]`. Please note that only `value` is required.
			Email *[]struct {
				// Label The label that indicates the type of the email. (Possible values - work, home or other)
				Label *string `json:"label,omitempty"`

				// Primary Boolean that indicates if email is primary for the person or not
				Primary *bool `json:"primary,omitempty"`

				// Value The email
				Value *string `json:"value,omitempty"`
			} `json:"email,omitempty"`

			// Id The ID of the person
			Id *int `json:"id,omitempty"`

			// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
			Label *int `json:"label"`

			// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
			LabelIds *[]int `json:"label_ids,omitempty"`

			// Name The name of the person
			Name *string `json:"name,omitempty"`

			// OrgId The ID of the organization related to the person
			OrgId *int `json:"org_id,omitempty"`

			// OwnerId The ID of the owner related to the person
			OwnerId *int `json:"owner_id,omitempty"`

			// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
			Phone *[]struct {
				// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
				Label *string `json:"label,omitempty"`

				// Primary Boolean that indicates if phone number is primary for the person or not
				Primary *bool `json:"primary,omitempty"`

				// Value The phone number
				Value *string `json:"value,omitempty"`
			} `json:"phone,omitempty"`

			// PictureId The ID of the picture associated with the item
			PictureId *int `json:"picture_id"`

			// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility group ID of who can see the person
			VisibleTo *string `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonsCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonsCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// ActivityDistribution The distribution of activities related to the organization grouped by the user ID
			ActivityDistribution *struct {
				// ASSIGNEDTOUSERID The ID of the user
				ASSIGNEDTOUSERID *struct {
					// Activities The count of activities related to the user grouped by activity type
					Activities *struct {
						// ACTIVITYTYPENAME The count of activities related to a specific type
						ACTIVITYTYPENAME *int `json:"ACTIVITY_TYPE_NAME,omitempty"`
					} `json:"activities,omitempty"`

					// ActivityCount The overall count of activities for the user
					ActivityCount *int `json:"activity_count,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// Share The percentage of activities belongs to the user
					Share *int `json:"share,omitempty"`
				} `json:"ASSIGNED_TO_USER_ID,omitempty"`
			} `json:"activity_distribution,omitempty"`

			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of activities
		Data *[]struct {
			// ActiveFlag Whether the activity is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// AssignedToUserId The ID of the user to whom the activity is assigned to. Equal to `user_id`.
			AssignedToUserId *int `json:"assigned_to_user_id,omitempty"`

			// Attendees The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address.
			Attendees *[]map[string]interface{} `json:"attendees"`

			// BusyFlag Marks if the activity is set as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
			BusyFlag *bool `json:"busy_flag,omitempty"`

			// CalendarSyncIncludeContext For activities that sync to an external calendar, this setting indicates if the activity syncs with context (what are the deals, persons, organizations this activity is related to)
			CalendarSyncIncludeContext *string `json:"calendar_sync_include_context,omitempty"`

			// CompanyId The user's company ID
			CompanyId *int `json:"company_id,omitempty"`

			// ConferenceMeetingClient The ID of the Marketplace app, which is connected to this activity
			ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

			// ConferenceMeetingId The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
			ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

			// ConferenceMeetingUrl The link to join the meeting which is associated with this activity
			ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

			// CreatedByUserId The ID of the user who created the activity
			CreatedByUserId *int `json:"created_by_user_id,omitempty"`

			// DealDropboxBcc The BCC email address of the deal
			DealDropboxBcc *string `json:"deal_dropbox_bcc,omitempty"`

			// DealId The ID of the deal this activity is associated with
			DealId *int `json:"deal_id,omitempty"`

			// DealTitle The name of the deal this activity is associated with
			DealTitle *string `json:"deal_title,omitempty"`

			// Done Whether the activity is done or not
			Done *bool `json:"done,omitempty"`

			// DueDate The due date of the activity. Format: YYYY-MM-DD
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// DueTime The due time of the activity in UTC. Format: HH:MM
			DueTime *string `json:"due_time,omitempty"`

			// Duration The duration of the activity. Format: HH:MM
			Duration *string `json:"duration,omitempty"`

			// File The file that is attached to this activity. For example, this can be a reference to an audio note file generated with Pipedrive mobile app.
			File *map[string]interface{} `json:"file,omitempty"`

			// GcalEventId For the activity which syncs to Google calendar, this is the Google event ID. NB! This field is related to old Google calendar sync and will be deprecated soon.
			GcalEventId *string `json:"gcal_event_id,omitempty"`

			// GoogleCalendarEtag The Google calendar API etag (version) that is used for syncing this activity. NB! This field is related to old Google calendar sync and will be deprecated soon.
			GoogleCalendarEtag *string `json:"google_calendar_etag,omitempty"`

			// GoogleCalendarId The Google calendar ID that this activity syncs to. NB! This field is related to old Google calendar sync and will be deprecated soon.
			GoogleCalendarId *string `json:"google_calendar_id,omitempty"`

			// Id The ID of the activity, generated when the activity was created
			Id *int `json:"id,omitempty"`

			// LastNotificationTime The date and time of latest notifications sent about this activity to the participants or the attendees of this activity
			LastNotificationTime *string `json:"last_notification_time,omitempty"`

			// LastNotificationUserId The ID of the user who triggered the sending of the latest notifications about this activity to the participants or the attendees of this activity
			LastNotificationUserId *int `json:"last_notification_user_id,omitempty"`

			// LeadId The ID of the lead in the UUID format this activity is associated with
			LeadId *openapi_types.UUID `json:"lead_id"`

			// Location The address of the activity.
			Location *string `json:"location,omitempty"`

			// LocationAdminAreaLevel1 A subfield of the location field. Indicates state/county.
			LocationAdminAreaLevel1 *string `json:"location_admin_area_level_1,omitempty"`

			// LocationAdminAreaLevel2 A subfield of the location field. Indicates region.
			LocationAdminAreaLevel2 *string `json:"location_admin_area_level_2,omitempty"`

			// LocationCountry A subfield of the location field. Indicates country.
			LocationCountry *string `json:"location_country,omitempty"`

			// LocationFormattedAddress A subfield of the location field. Indicates full/combined address.
			LocationFormattedAddress *string `json:"location_formatted_address,omitempty"`

			// LocationLocality A subfield of the location field. Indicates city/town/village/locality.
			LocationLocality *string `json:"location_locality,omitempty"`

			// LocationPostalCode A subfield of the location field. Indicates ZIP/postal code.
			LocationPostalCode *string `json:"location_postal_code,omitempty"`

			// LocationRoute A subfield of the location field. Indicates street name.
			LocationRoute *string `json:"location_route,omitempty"`

			// LocationStreetNumber A subfield of the location field. Indicates house number.
			LocationStreetNumber *string `json:"location_street_number,omitempty"`

			// LocationSublocality A subfield of the location field. Indicates district/sublocality.
			LocationSublocality *string `json:"location_sublocality,omitempty"`

			// LocationSubpremise A subfield of the location field. Indicates apartment/suite number.
			LocationSubpremise *string `json:"location_subpremise,omitempty"`

			// MarkedAsDoneTime The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// Note The note of the activity (HTML format)
			Note *string `json:"note,omitempty"`

			// NotificationLanguageId The ID of the language the notifications are sent in
			NotificationLanguageId *int `json:"notification_language_id,omitempty"`

			// OrgId The ID of the organization this activity is associated with
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization this activity is associated with
			OrgName *string `json:"org_name,omitempty"`

			// OwnerName The name of the user this activity is owned by
			OwnerName *string `json:"owner_name,omitempty"`

			// Participants List of multiple persons (participants) this activity is associated with
			Participants *[]map[string]interface{} `json:"participants"`

			// PersonDropboxBcc The BCC email address of the person
			PersonDropboxBcc *string `json:"person_dropbox_bcc,omitempty"`

			// PersonId The ID of the person this activity is associated with
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person this activity is associated with
			PersonName *string `json:"person_name,omitempty"`

			// ProjectId The ID of the project this activity is associated with
			ProjectId *int `json:"project_id"`

			// PublicDescription Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
			PublicDescription *string `json:"public_description,omitempty"`

			// RecMasterActivityId The ID of parent activity for a recurrent activity if the current activity is an exception to recurrence rules
			RecMasterActivityId *int `json:"rec_master_activity_id,omitempty"`

			// RecRule The rule for the recurrence of the activity. Is important for activities synced into Pipedrive from an external calendar. Example: "RRULE:FREQ=WEEKLY;BYDAY=WE"
			RecRule *string `json:"rec_rule,omitempty"`

			// RecRuleExtension Additional rules for the recurrence of the activity, extend the `rec_rule`. Is important for activities synced into Pipedrive from an external calendar.
			RecRuleExtension *string `json:"rec_rule_extension,omitempty"`

			// ReferenceId Together with the `reference_type`, gives the ID of the other object
			ReferenceId *int `json:"reference_id,omitempty"`

			// ReferenceType If the activity references some other object, it is indicated here. For example, value `Salesphone` refers to activities created with Caller.
			ReferenceType *string `json:"reference_type,omitempty"`

			// Series The list of recurring activity instances. It is in a structure as follows: `[{due_date: "2020-06-24", due_time: "10:00:00"}]`
			Series *[]map[string]interface{} `json:"series,omitempty"`

			// SourceTimezone The timezone the activity was created in an external calendar
			SourceTimezone *string `json:"source_timezone,omitempty"`

			// Subject The subject of the activity
			Subject *string `json:"subject,omitempty"`

			// Type The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
			Type *string `json:"type,omitempty"`

			// UpdateTime The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`

			// UpdateUserId The ID of the user who was the last to update this activity
			UpdateUserId *int `json:"update_user_id,omitempty"`

			// UserId The ID of the user whom the activity is assigned to
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonChangelogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// ActorUserId The ID of the user who made the change
			ActorUserId *int `json:"actor_user_id,omitempty"`

			// ChangeSource The source of change, for example 'app', 'mobile', 'api', etc.
			ChangeSource *string `json:"change_source"`

			// ChangeSourceUserAgent The user agent from which the change was made
			ChangeSourceUserAgent *string `json:"change_source_user_agent"`

			// FieldKey The key of the field that was changed
			FieldKey *string `json:"field_key,omitempty"`

			// IsBulkUpdateFlag Whether the change was made as part of a bulk update
			IsBulkUpdateFlag *bool `json:"is_bulk_update_flag,omitempty"`

			// NewValue The value of the field after the change
			NewValue *string `json:"new_value"`

			// OldValue The value of the field before the change
			OldValue *string `json:"old_value"`

			// Time The date and time of the change
			Time *string `json:"time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonChangelogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonChangelogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of deals
		Data *[]struct {
			// Active Whether the deal is active or not
			Active *bool `json:"active,omitempty"`

			// ActivitiesCount The number of activities associated with the deal
			ActivitiesCount *int `json:"activities_count,omitempty"`

			// Acv Only available in Growth and above plans
			//
			// The Annual Contract Value of the deal
			//
			// Null if there are no products attached to the deal
			Acv *float32 `json:"acv"`

			// AcvCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Contract Value of the deal
			//
			// If the `acv` is null, this will also be null
			AcvCurrency *string `json:"acv_currency"`

			// AddTime The creation date and time of the deal
			AddTime *string `json:"add_time,omitempty"`

			// Arr Only available in Growth and above plans
			//
			// The Annual Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Arr *float32 `json:"arr"`

			// ArrCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Recurring Revenue of the deal
			//
			// If the `arr` is null, this will also be null
			ArrCurrency *string `json:"arr_currency"`

			// CcEmail The BCC email of the deal
			CcEmail *string `json:"cc_email,omitempty"`

			// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CloseTime The date and time of closing the deal
			CloseTime *string `json:"close_time"`

			// CreatorUserId The creator of the deal
			CreatorUserId *struct {
				// ActiveFlag Whether the creator is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The email of the deal creator
				Email *string `json:"email,omitempty"`

				// HasPic If the creator has a picture or not
				HasPic *bool `json:"has_pic,omitempty"`

				// Id The ID of the deal creator
				Id *int `json:"id,omitempty"`

				// Name The name of the deal creator
				Name *string `json:"name,omitempty"`

				// PicHash The creator picture hash
				PicHash *string `json:"pic_hash"`

				// Value The ID of the deal creator
				Value *int `json:"value,omitempty"`
			} `json:"creator_user_id,omitempty"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// Deleted Whether the deal is deleted or not
			Deleted *bool `json:"deleted,omitempty"`

			// DoneActivitiesCount The number of completed activities associated with the deal
			DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

			// EmailMessagesCount The number of emails associated with the deal
			EmailMessagesCount *int `json:"email_messages_count,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// FilesCount The number of files associated with the deal
			FilesCount *int `json:"files_count,omitempty"`

			// FirstWonTime The date and time of the first time changing the deal status as won
			FirstWonTime *string `json:"first_won_time,omitempty"`

			// FollowersCount The number of followers associated with the deal
			FollowersCount *int `json:"followers_count,omitempty"`

			// FormattedValue The deal value formatted with selected currency. E.g. US$500
			FormattedValue *string `json:"formatted_value,omitempty"`

			// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
			FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// IsArchived Whether the deal is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// Label The label or multiple labels assigned to the deal
			Label *string `json:"label,omitempty"`

			// LastActivityDate The date of the last activity associated with the deal
			LastActivityDate *string `json:"last_activity_date"`

			// LastActivityId The ID of the last activity associated with the deal
			LastActivityId *int `json:"last_activity_id"`

			// LastIncomingMailTime The date and time of the last incoming email associated with the deal
			LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

			// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
			LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status as lost
			LostTime *string `json:"lost_time,omitempty"`

			// Mrr Only available in Growth and above plans
			//
			// The Monthly Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Mrr *float32 `json:"mrr"`

			// MrrCurrency Only available in Growth and above plans
			//
			// The Currency for Monthly Recurring Revenue of the deal
			//
			// If the `mrr` is null, this will also be null
			MrrCurrency *string `json:"mrr_currency"`

			// NextActivityDate The date of the next activity associated with the deal
			NextActivityDate *string `json:"next_activity_date,omitempty"`

			// NextActivityDuration The duration of the next activity associated with the deal
			NextActivityDuration *string `json:"next_activity_duration,omitempty"`

			// NextActivityId The ID of the next activity associated with the deal
			NextActivityId *int `json:"next_activity_id"`

			// NextActivityNote The note of the next activity associated with the deal
			NextActivityNote *string `json:"next_activity_note,omitempty"`

			// NextActivitySubject The subject of the next activity associated with the deal
			NextActivitySubject *string `json:"next_activity_subject,omitempty"`

			// NextActivityTime The time of the next activity associated with the deal
			NextActivityTime *string `json:"next_activity_time,omitempty"`

			// NextActivityType The type of the next activity associated with the deal
			NextActivityType *string `json:"next_activity_type,omitempty"`

			// NotesCount The number of notes associated with the deal
			NotesCount *int `json:"notes_count,omitempty"`

			// OrgHidden If the organization that is associated with the deal is hidden or not
			OrgHidden *bool `json:"org_hidden,omitempty"`
			OrgId     *struct {
				// ActiveFlag Whether the associated organization is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Address The address of the organization that is associated with the deal
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the deal
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the deal
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the deal
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the deal
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization associated with the deal
				Value *int `json:"value,omitempty"`
			} `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the deal
			OrgName *string `json:"org_name,omitempty"`

			// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
			OriginId *string `json:"origin_id"`

			// OwnerName The name of the deal owner
			OwnerName *string `json:"owner_name,omitempty"`

			// ParticipantsCount The number of participants associated with the deal
			ParticipantsCount *int `json:"participants_count,omitempty"`

			// PersonHidden If the person that is associated with the deal is hidden or not
			PersonHidden *bool `json:"person_hidden,omitempty"`
			PersonId     *struct {
				// ActiveFlag Whether the associated person is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The emails of the person associated with the deal
				Email *[]struct {
					// Label The type of the email
					Label *string `json:"label,omitempty"`

					// Primary If this is the primary email or not
					Primary *bool `json:"primary,omitempty"`

					// Value The email of the associated person
					Value *string `json:"value,omitempty"`
				} `json:"email,omitempty"`

				// Name The name of the person associated with the deal
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the person that is associated with the deal
				OwnerId *int `json:"owner_id,omitempty"`

				// Phone The phone numbers of the person associated with the deal
				Phone *[]struct {
					// Label The type of the phone number
					Label *string `json:"label,omitempty"`

					// Primary If this is the primary phone number or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number of the person associated with the deal
					Value *string `json:"value,omitempty"`
				} `json:"phone,omitempty"`

				// Value The ID of the person associated with the deal
				Value *int `json:"value,omitempty"`
			} `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the deal
			PersonName *string `json:"person_name,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// ProductsCount The number of products associated with the deal
			ProductsCount *int `json:"products_count,omitempty"`

			// RottenTime The date and time of changing the deal status as rotten
			RottenTime *string `json:"rotten_time"`

			// StageChangeTime The last updated date and time of the deal stage
			StageChangeTime *string `json:"stage_change_time,omitempty"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// StageOrderNr The order number of the deal stage associated with the deal
			StageOrderNr *int `json:"stage_order_nr,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UndoneActivitiesCount The number of incomplete activities associated with the deal
			UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

			// UpdateTime The last updated date and time of the deal
			UpdateTime *string `json:"update_time,omitempty"`
			UserId     *struct {
				// ActiveFlag Whether the user is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The email of the user
				Email *string `json:"email,omitempty"`

				// HasPic If the user has a picture or not
				HasPic *bool `json:"has_pic,omitempty"`

				// Id The ID of the user
				Id *int `json:"id,omitempty"`

				// Name The name of the user
				Name *string `json:"name,omitempty"`

				// PicHash The user picture hash
				PicHash *string `json:"pic_hash"`

				// Value The ID of the user
				Value *int `json:"value,omitempty"`
			} `json:"user_id,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *string `json:"visible_to,omitempty"`

			// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
			WeightedValue *float32 `json:"weighted_value,omitempty"`

			// WeightedValueCurrency The currency associated with the deal
			WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

			// WonTime The date and time of changing the deal status as won
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
			Person *struct {
				// PERSONID The ID of the person associated with the item
				PERSONID *struct {
					// ActiveFlag Whether the associated person is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The emails of the person associated with the item
					Email *[]struct {
						// Label The type of the email
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary email or not
						Primary *bool `json:"primary,omitempty"`

						// Value The email of the associated person
						Value *string `json:"value,omitempty"`
					} `json:"email,omitempty"`

					// Id The ID of the person associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the person associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the person that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// Phone The phone numbers of the person associated with the item
					Phone *[]struct {
						// Label The type of the phone number
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary phone number or not
						Primary *bool `json:"primary,omitempty"`

						// Value The phone number of the person associated with the item
						Value *string `json:"value,omitempty"`
					} `json:"phone,omitempty"`
				} `json:"PERSON_ID,omitempty"`
			} `json:"person,omitempty"`
			Pipeline *struct {
				// Active Whether this pipeline will be made inactive (hidden) or active
				Active *bool `json:"active,omitempty"`

				// AddTime The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// DealProbability Whether deal probability is disabled or enabled for this pipeline
				DealProbability *bool `json:"deal_probability,omitempty"`

				// Id The ID of the pipeline
				Id *int `json:"id,omitempty"`

				// Name The name of the pipeline
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
				OrderNr *int `json:"order_nr,omitempty"`

				// UpdateTime The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`

				// UrlTitle The pipeline title displayed in the URL
				UrlTitle *string `json:"url_title,omitempty"`
			} `json:"pipeline,omitempty"`
			Stage *struct {
				// ActiveFlag Whether the stage is active or deleted
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The stage creation time. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
				DealProbability *int `json:"deal_probability,omitempty"`

				// Id The ID of the stage
				Id *int `json:"id,omitempty"`

				// Name The name of the stage
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of the stage
				OrderNr *int `json:"order_nr,omitempty"`

				// PipelineId The ID of the pipeline to add the stage to
				PipelineId *int `json:"pipeline_id,omitempty"`

				// RottenDays The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
				RottenDays *int `json:"rotten_days,omitempty"`

				// RottenFlag Whether deals in this stage can become rotten
				RottenFlag *bool `json:"rotten_flag,omitempty"`

				// UpdateTime The stage update time. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"stage,omitempty"`
			User *struct {
				USERID *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`
				} `json:"USER_ID,omitempty"`
			} `json:"user,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of files
		Data *[]struct {
			// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivityId The ID of the activity to associate the file with
			ActivityId *int `json:"activity_id,omitempty"`

			// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// Cid The ID of the inline attachment
			Cid *string `json:"cid,omitempty"`

			// DealId The ID of the deal to associate the file with
			DealId *int `json:"deal_id,omitempty"`

			// DealName The name of the deal associated with the dile
			DealName *string `json:"deal_name,omitempty"`

			// Description The description of the file
			Description *string `json:"description,omitempty"`

			// FileName The original name of the file
			FileName *string `json:"file_name,omitempty"`

			// FileSize The size of the file
			FileSize *int `json:"file_size,omitempty"`

			// Id The ID of the file
			Id *int `json:"id,omitempty"`

			// InlineFlag Whether the file was uploaded as inline or not
			InlineFlag *bool `json:"inline_flag,omitempty"`

			// LeadId The ID of the lead to associate the file with
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// LeadName The name of the lead associated with the file
			LeadName *string `json:"lead_name,omitempty"`

			// MailMessageId The ID of the mail message to associate the file with
			MailMessageId *string `json:"mail_message_id,omitempty"`

			// MailTemplateId The ID of the mail template to associate the file with
			MailTemplateId *string `json:"mail_template_id,omitempty"`

			// Name The visible name of the file
			Name *string `json:"name,omitempty"`

			// OrgId The ID of the organization to associate the file with
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the file
			OrgName *string `json:"org_name,omitempty"`

			// PersonId The ID of the person to associate the file with
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the file
			PersonName *string `json:"person_name,omitempty"`

			// ProductId The ID of the product to associate the file with
			ProductId *int `json:"product_id,omitempty"`

			// ProductName The name of the product associated with the file
			ProductName *string `json:"product_name,omitempty"`

			// RemoteId The ID of the remote item
			RemoteId *string `json:"remote_id,omitempty"`

			// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
			RemoteLocation *string `json:"remote_location,omitempty"`

			// S3Bucket The location of the cloud storage
			S3Bucket *string `json:"s3_bucket,omitempty"`

			// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// Url The URL of the download file
			Url *string `json:"url,omitempty"`

			// UserId The ID of the user to associate the file with
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// Data The data related to the update
			Data *map[string]interface{} `json:"data,omitempty"`

			// Object The type of the person update. (Possible object types - personChange, note, activity, file)
			Object *string `json:"object,omitempty"`

			// Timestamp The creation date and time of the update
			Timestamp *string `json:"timestamp,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Deal *struct {
				// DEALID The ID of the deal which is associated with the item
				DEALID *struct {
					// Currency The currency of the deal value
					Currency *string `json:"currency,omitempty"`

					// Id The ID of the deal associated with the item
					Id *int `json:"id,omitempty"`

					// PipelineId The ID of the pipeline the deal is in
					PipelineId *int `json:"pipeline_id,omitempty"`

					// StageId The ID of the stage the deal is currently at
					StageId *int `json:"stage_id,omitempty"`

					// Status The status of the deal associated with the item
					Status *string `json:"status,omitempty"`

					// Title The title of the deal associated with the item
					Title *string `json:"title,omitempty"`

					// Value The value of the deal that is associated with the item
					Value *float32 `json:"value,omitempty"`
				} `json:"DEAL_ID,omitempty"`
			} `json:"deal,omitempty"`
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
			Person *struct {
				// PERSONID The ID of the person associated with the item
				PERSONID *struct {
					// ActiveFlag Whether the associated person is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The emails of the person associated with the item
					Email *[]struct {
						// Label The type of the email
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary email or not
						Primary *bool `json:"primary,omitempty"`

						// Value The email of the associated person
						Value *string `json:"value,omitempty"`
					} `json:"email,omitempty"`

					// Id The ID of the person associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the person associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the person that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// Phone The phone numbers of the person associated with the item
					Phone *[]struct {
						// Label The type of the phone number
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary phone number or not
						Primary *bool `json:"primary,omitempty"`

						// Value The phone number of the person associated with the item
						Value *string `json:"value,omitempty"`
					} `json:"phone,omitempty"`
				} `json:"PERSON_ID,omitempty"`
			} `json:"person,omitempty"`
			User *struct {
				USERID *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`
				} `json:"USER_ID,omitempty"`
			} `json:"user,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonMailMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of mail messages
		Data *[]struct {
			Data *struct {
				// AccountId The connection account ID
				AccountId *string `json:"account_id,omitempty"`

				// AddTime The insertion into the database time of the mail message
				AddTime *time.Time `json:"add_time,omitempty"`

				// Bcc The array of mail message blind copies (object)
				Bcc *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"bcc,omitempty"`

				// BodyUrl The mail message body URL
				BodyUrl *string `json:"body_url,omitempty"`

				// Cc The array of mail message copies (object)
				Cc *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"cc,omitempty"`

				// CompanyId The ID of the company
				CompanyId *int `json:"company_id,omitempty"`

				// DeletedFlag Whether the mail message is deleted or not
				DeletedFlag *GetPersonMailMessages200DataDataDeletedFlag `json:"deleted_flag,omitempty"`

				// Draft If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
				Draft *string `json:"draft,omitempty"`

				// DraftFlag Whether the mail message is a draft or not
				DraftFlag *GetPersonMailMessages200DataDataDraftFlag `json:"draft_flag,omitempty"`

				// ExternalDeletedFlag If the Mail Message has been deleted on the provider side or not
				ExternalDeletedFlag *bool `json:"external_deleted_flag,omitempty"`

				// From The array of mail message sender (object)
				From *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"from,omitempty"`

				// HasAttachmentsFlag Whether the mail message has an attachment or not
				HasAttachmentsFlag *GetPersonMailMessages200DataDataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

				// HasBodyFlag Whether the mail message has a body or not
				HasBodyFlag *GetPersonMailMessages200DataDataHasBodyFlag `json:"has_body_flag,omitempty"`

				// HasInlineAttachmentsFlag Whether the mail message has an inline attachment or not
				HasInlineAttachmentsFlag *GetPersonMailMessages200DataDataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

				// HasRealAttachmentsFlag Whether the mail message has an attachment (which is not inline) or not
				HasRealAttachmentsFlag *GetPersonMailMessages200DataDataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

				// Id ID of the mail message.
				Id *int `json:"id,omitempty"`

				// ItemType The type of the data item
				ItemType *string `json:"item_type,omitempty"`

				// MailLinkTrackingEnabledFlag Whether the link tracking in mail message body is enabled.
				MailLinkTrackingEnabledFlag *GetPersonMailMessages200DataDataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

				// MailThreadId ID of the mail message thread
				MailThreadId *int `json:"mail_thread_id,omitempty"`

				// MailTrackingStatus The status of tracking mail message. Value is `null` if tracking is not enabled.
				MailTrackingStatus *GetPersonMailMessages200DataDataMailTrackingStatus `json:"mail_tracking_status"`

				// MessageTime Creation or receival time of the mail message
				MessageTime *time.Time `json:"message_time,omitempty"`

				// MuaMessageId The Mail Message ID assigned by the mail user agent
				MuaMessageId *string `json:"mua_message_id,omitempty"`

				// NylasId The Mail Message ID assigned by the sync provider
				NylasId *string `json:"nylas_id,omitempty"`

				// ReadFlag Whether the mail message is read or not by the user
				ReadFlag *GetPersonMailMessages200DataDataReadFlag `json:"read_flag,omitempty"`

				// S3Bucket The name of the S3 bucket
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// S3BucketPath The path of the S3 bucket
				S3BucketPath *string `json:"s3_bucket_path,omitempty"`

				// SentFlag Whether the mail message has been sent or not
				SentFlag *GetPersonMailMessages200DataDataSentFlag `json:"sent_flag,omitempty"`

				// SentFromPipedriveFlag Whether the mail message has been sent from Pipedrive app or not
				SentFromPipedriveFlag *GetPersonMailMessages200DataDataSentFromPipedriveFlag `json:"sent_from_pipedrive_flag,omitempty"`

				// SmartBccFlag Whether the mail message has been created by Smart Email BCC feature or not
				SmartBccFlag *GetPersonMailMessages200DataDataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

				// Snippet The snippet of mail message. Snippet length is up to 225 characters.
				Snippet *string `json:"snippet,omitempty"`

				// Subject The subject of mail message
				Subject *string `json:"subject,omitempty"`

				// SyncedFlag Whether the mail message is synced with the provider or not
				SyncedFlag *GetPersonMailMessages200DataDataSyncedFlag `json:"synced_flag,omitempty"`

				// TemplateId The ID of the mail template
				TemplateId *int `json:"template_id,omitempty"`

				// Timestamp The add date and time of the Mail Message
				Timestamp *string `json:"timestamp,omitempty"`

				// To The array of mail message receiver (object)
				To *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"to,omitempty"`

				// UpdateTime The updating time in the database of the mail message
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// UserId ID of the user whom mail message will be assigned to
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Object The type of the data item
			Object *string `json:"object,omitempty"`

			// Timestamp The date and time when the item was created
			Timestamp *string `json:"timestamp,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetPersonMailMessages200DataDataDeletedFlag float32
type GetPersonMailMessages200DataDataDraftFlag float32
type GetPersonMailMessages200DataDataHasAttachmentsFlag float32
type GetPersonMailMessages200DataDataHasBodyFlag float32
type GetPersonMailMessages200DataDataHasInlineAttachmentsFlag float32
type GetPersonMailMessages200DataDataHasRealAttachmentsFlag float32
type GetPersonMailMessages200DataDataMailLinkTrackingEnabledFlag float32
type GetPersonMailMessages200DataDataMailTrackingStatus string
type GetPersonMailMessages200DataDataReadFlag float32
type GetPersonMailMessages200DataDataSentFlag float32
type GetPersonMailMessages200DataDataSentFromPipedriveFlag float32
type GetPersonMailMessages200DataDataSmartBccFlag float32
type GetPersonMailMessages200DataDataSyncedFlag float32

// Status returns HTTPResponse.Status
func (r GetPersonMailMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonMailMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergePersonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Whether the person is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// ActivitiesCount The count of activities related to the person
			ActivitiesCount *int `json:"activities_count,omitempty"`

			// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// CcEmail The BCC email associated with the person
			CcEmail *string `json:"cc_email,omitempty"`

			// ClosedDealsCount The count of closed deals related with the item
			ClosedDealsCount *int `json:"closed_deals_count,omitempty"`

			// CompanyId The ID of the company related to the person
			CompanyId *int `json:"company_id,omitempty"`

			// DoneActivitiesCount The count of done activities related to the person
			DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

			// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" } ]`. Please note that only `value` is required.
			Email *[]struct {
				// Label The label that indicates the type of the email. (Possible values - work, home or other)
				Label *string `json:"label,omitempty"`

				// Primary Boolean that indicates if email is primary for the person or not
				Primary *bool `json:"primary,omitempty"`

				// Value Email
				Value *string `json:"value,omitempty"`
			} `json:"email,omitempty"`

			// EmailMessagesCount The count of email messages related to the person
			EmailMessagesCount *int `json:"email_messages_count,omitempty"`

			// FilesCount The count of files related to the person
			FilesCount *int `json:"files_count,omitempty"`

			// FirstChar The first letter of the name of the person
			FirstChar *string `json:"first_char,omitempty"`

			// FirstName The first name of the person
			FirstName *string `json:"first_name,omitempty"`

			// FollowersCount The count of followers related to the person
			FollowersCount *int `json:"followers_count,omitempty"`

			// Id The ID of the person
			Id *int `json:"id,omitempty"`

			// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
			Label *int `json:"label,omitempty"`

			// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LastActivityDate The date of the last activity associated with the deal
			LastActivityDate *string `json:"last_activity_date"`

			// LastActivityId The ID of the last activity associated with the deal
			LastActivityId *int `json:"last_activity_id"`

			// LastIncomingMailTime The date and time of the last incoming email associated with the person
			LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

			// LastName The last name of the person
			LastName *string `json:"last_name,omitempty"`

			// LastOutgoingMailTime The date and time of the last outgoing email associated with the person
			LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

			// LostDealsCount The count of lost deals related with the item
			LostDealsCount *int `json:"lost_deals_count,omitempty"`

			// MergeWhatId The ID of the person with what the main person was merged
			MergeWhatId *int `json:"merge_what_id,omitempty"`

			// Name The name of the person
			Name *string `json:"name,omitempty"`

			// NextActivityDate The date of the next activity associated with the deal
			NextActivityDate *string `json:"next_activity_date"`

			// NextActivityId The ID of the next activity associated with the deal
			NextActivityId *int `json:"next_activity_id"`

			// NextActivityTime The time of the next activity associated with the deal
			NextActivityTime *string `json:"next_activity_time"`

			// NotesCount The count of notes related to the person
			NotesCount *int `json:"notes_count,omitempty"`

			// OpenDealsCount The count of open deals related with the item
			OpenDealsCount *int `json:"open_deals_count,omitempty"`

			// OrgId The ID of the organization related to the person
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the person
			OrgName *string `json:"org_name,omitempty"`

			// OwnerId The ID of the owner related to the person
			OwnerId *int `json:"owner_id,omitempty"`

			// OwnerName The name of the owner associated with the person
			OwnerName *string `json:"owner_name,omitempty"`

			// ParticipantClosedDealsCount The count of closed participant deals related with the item
			ParticipantClosedDealsCount *int `json:"participant_closed_deals_count,omitempty"`

			// ParticipantOpenDealsCount The count of open participant deals related with the item
			ParticipantOpenDealsCount *int `json:"participant_open_deals_count,omitempty"`

			// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
			Phone *[]struct {
				// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
				Label *string `json:"label,omitempty"`

				// Primary Boolean that indicates if phone number is primary for the person or not
				Primary *bool `json:"primary,omitempty"`

				// Value The phone number
				Value *string `json:"value,omitempty"`
			} `json:"phone,omitempty"`
			PictureId *struct {
				// ActiveFlag Whether the associated picture is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The add time of the picture
				AddTime *string `json:"add_time,omitempty"`

				// AddedByUserId The ID of the user who added the picture
				AddedByUserId *int `json:"added_by_user_id,omitempty"`

				// Id The ID of the picture associated with the item
				Id *int `json:"id,omitempty"`

				// ItemId The ID of related item
				ItemId *int `json:"item_id,omitempty"`

				// ItemType The type of item the picture is related to
				ItemType *string `json:"item_type,omitempty"`
				Pictures *struct {
					// N128 The URL of the 128*128 picture
					N128 *string `json:"128,omitempty"`

					// N512 The URL of the 512*512 picture
					N512 *string `json:"512,omitempty"`
				} `json:"pictures,omitempty"`

				// UpdateTime The update time of the picture
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"picture_id,omitempty"`

			// RelatedClosedDealsCount The count of related closed deals related with the item
			RelatedClosedDealsCount *int `json:"related_closed_deals_count,omitempty"`

			// RelatedLostDealsCount The count of related lost deals related with the item
			RelatedLostDealsCount *int `json:"related_lost_deals_count,omitempty"`

			// RelatedOpenDealsCount The count of related open deals related with the item
			RelatedOpenDealsCount *int `json:"related_open_deals_count,omitempty"`

			// RelatedWonDealsCount The count of related won deals related with the item
			RelatedWonDealsCount *int `json:"related_won_deals_count,omitempty"`

			// UndoneActivitiesCount The count of undone activities related to the person
			UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

			// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility group ID of who can see the person
			VisibleTo *string `json:"visible_to,omitempty"`

			// WonDealsCount The count of won deals related with the item
			WonDealsCount *int `json:"won_deals_count,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MergePersonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergePersonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The list of permitted user IDs
		Data *[]float32 `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersonPictureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of the deleted person
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePersonPictureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersonPictureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPersonPictureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The picture that is associated with the item
		Data *struct {
			// PICTUREID The ID of the picture
			PICTUREID *struct {
				// ActiveFlag Whether the associated picture is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The add time of the picture
				AddTime *string `json:"add_time,omitempty"`

				// AddedByUserId The ID of the user who added the picture
				AddedByUserId *int `json:"added_by_user_id,omitempty"`

				// Id The ID of the picture associated with the item
				Id *int `json:"id,omitempty"`

				// ItemId The ID of related item
				ItemId *int `json:"item_id,omitempty"`

				// ItemType The type of item the picture is related to
				ItemType *string `json:"item_type,omitempty"`
				Pictures *struct {
					// N128 The URL of the 128*128 picture
					N128 *string `json:"128,omitempty"`

					// N512 The URL of the 512*512 picture
					N512 *string `json:"512,omitempty"`
				} `json:"pictures,omitempty"`

				// UpdateTime The update time of the picture
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"PICTURE_ID,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddPersonPictureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPersonPictureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// Pagination Pagination details of the list
			Pagination *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection Whether there are more list items in the collection than displayed
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// NextStart Next pagination start
				NextStart *int `json:"next_start,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"pagination,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of deal products
		Data *[]struct {
			DEALID *struct {
				Deal *struct {
					// Active Whether the deal is active or not
					Active *bool `json:"active,omitempty"`

					// ActivitiesCount The number of activities associated with the deal
					ActivitiesCount *int `json:"activities_count,omitempty"`

					// AddTime The creation date and time of the deal
					AddTime *string `json:"add_time,omitempty"`

					// CloseTime The date and time of closing the deal
					CloseTime *string `json:"close_time"`

					// CompanyId The ID of the company
					CompanyId *int `json:"company_id,omitempty"`

					// CreatorUserId The ID of the deal creator
					CreatorUserId *int `json:"creator_user_id,omitempty"`

					// Currency The currency associated with the deal
					Currency *string `json:"currency,omitempty"`

					// Deleted Whether the deal is deleted or not
					Deleted *bool `json:"deleted,omitempty"`

					// DoneActivitiesCount The number of completed activities associated with the deal
					DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

					// EmailMessagesCount The number of emails associated with the deal
					EmailMessagesCount *int `json:"email_messages_count,omitempty"`

					// ExpectedCloseDate The expected close date of the deal
					ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

					// FilesCount The number of files associated with the deal
					FilesCount *int `json:"files_count,omitempty"`

					// FirstAddTime The first creation date and time of the deal
					FirstAddTime *string `json:"first_add_time,omitempty"`

					// FirstWonTime The date and time of the first time changing the deal status as won
					FirstWonTime *string `json:"first_won_time,omitempty"`

					// FollowersCount The number of followers associated with the deal
					FollowersCount *int `json:"followers_count,omitempty"`

					// Id The ID of the deal
					Id *int `json:"id,omitempty"`

					// Label The label or multiple labels assigned to the deal
					Label *string `json:"label,omitempty"`

					// LastActivityDate The date of the last activity associated with the deal
					LastActivityDate *string `json:"last_activity_date"`

					// LastActivityId The ID of the last activity associated with the deal
					LastActivityId *int `json:"last_activity_id"`

					// LastIncomingMailTime The date and time of the last incoming email associated with the deal
					LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

					// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
					LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

					// LostReason The reason for losing the deal
					LostReason *string `json:"lost_reason"`

					// LostTime The date and time of changing the deal status as lost
					LostTime *string `json:"lost_time,omitempty"`

					// NextActivityDate The date of the next activity associated with the deal
					NextActivityDate *string `json:"next_activity_date,omitempty"`

					// NextActivityId The ID of the next activity associated with the deal
					NextActivityId *int `json:"next_activity_id"`

					// NextActivityTime The time of the next activity associated with the deal
					NextActivityTime *string `json:"next_activity_time,omitempty"`

					// NotesCount The number of notes associated with the deal
					NotesCount *int `json:"notes_count,omitempty"`

					// OrgId The ID of the organization associated with the deal
					OrgId *int `json:"org_id,omitempty"`

					// ParticipantsCount The number of participants associated with the deal
					ParticipantsCount *int `json:"participants_count,omitempty"`

					// PersonId The ID of the person associated with the deal
					PersonId *int `json:"person_id,omitempty"`

					// PipelineId The ID of the pipeline associated with the deal
					PipelineId *int `json:"pipeline_id,omitempty"`

					// Probability The success probability percentage of the deal
					Probability *float32 `json:"probability"`

					// ProductsCount The number of products associated with the deal
					ProductsCount *int `json:"products_count,omitempty"`

					// StageChangeTime The last updated date and time of the deal stage
					StageChangeTime *string `json:"stage_change_time,omitempty"`

					// StageId The ID of the deal stage
					StageId *int `json:"stage_id,omitempty"`

					// Status The status of the deal
					Status *string `json:"status,omitempty"`

					// Title The title of the deal
					Title *string `json:"title,omitempty"`

					// UndoneActivitiesCount The number of incomplete activities associated with the deal
					UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

					// UpdateTime The last updated date and time of the deal
					UpdateTime *string `json:"update_time,omitempty"`

					// UserId The ID of the user
					UserId *int `json:"user_id,omitempty"`

					// Value The value of the deal
					Value *float32 `json:"value,omitempty"`

					// VisibleTo The visibility of the deal
					VisibleTo *string `json:"visible_to,omitempty"`

					// WonTime The date and time of changing the deal status as won
					WonTime *string `json:"won_time,omitempty"`
				} `json:"deal,omitempty"`
				Product *struct {
					// ActiveFlag Whether this product will be made active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// AddTime The date and time when the product was added to the deal
					AddTime *string `json:"add_time,omitempty"`

					// Category The category of the product
					Category *string `json:"category,omitempty"`

					// Code The product code
					Code *string `json:"code,omitempty"`

					// CompanyId The ID of the company
					CompanyId *int `json:"company_id,omitempty"`

					// DealId The ID of the deal
					DealId *int `json:"deal_id,omitempty"`

					// Description The description of the product
					Description *string `json:"description,omitempty"`

					// FilesCount The count of files
					FilesCount *int `json:"files_count,omitempty"`

					// FirstChar The first letter of the product name
					FirstChar *string `json:"first_char,omitempty"`

					// Id The ID of the product
					Id *int `json:"id,omitempty"`

					// Name The name of the product
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used
					OwnerId *int `json:"owner_id,omitempty"`

					// Selectable Whether this product can be selected in deals or not
					Selectable *bool `json:"selectable,omitempty"`

					// Tax The tax percentage
					Tax *float32 `json:"tax,omitempty"`

					// Unit The unit in which this product is sold
					Unit *string `json:"unit,omitempty"`

					// UpdateTime The date and time when the product was updated to the deal
					UpdateTime *string `json:"update_time,omitempty"`

					// VisibleTo The visibility of the product. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
					VisibleTo *GetPersonProducts200DataDEALIDProductVisibleTo `json:"visible_to,omitempty"`
				} `json:"product,omitempty"`
			} `json:"DEAL_ID,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetPersonProducts200DataDEALIDProductVisibleTo string

// Status returns HTTPResponse.Status
func (r GetPersonProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineConversionStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The pipeline object
		Data *struct {
			// LostConversion The lost conversion
			LostConversion *int `json:"lost_conversion,omitempty"`

			// StageConversions The stage conversions
			StageConversions *[]struct {
				// ConversionRate The conversion rate
				ConversionRate *int `json:"conversion_rate,omitempty"`

				// FromStageId The stage ID from where conversion starts
				FromStageId *int `json:"from_stage_id,omitempty"`

				// ToStageId The stage ID to where conversion ends
				ToStageId *int `json:"to_stage_id,omitempty"`
			} `json:"stage_conversions,omitempty"`

			// WonConversion The won conversion
			WonConversion *int `json:"won_conversion,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPipelineConversionStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineConversionStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of deals
		Data *[]struct {
			// Active Whether the deal is active or not
			Active *bool `json:"active,omitempty"`

			// ActivitiesCount The number of activities associated with the deal
			ActivitiesCount *int `json:"activities_count,omitempty"`

			// Acv Only available in Growth and above plans
			//
			// The Annual Contract Value of the deal
			//
			// Null if there are no products attached to the deal
			Acv *float32 `json:"acv"`

			// AcvCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Contract Value of the deal
			//
			// If the `acv` is null, this will also be null
			AcvCurrency *string `json:"acv_currency"`

			// AddTime The creation date and time of the deal
			AddTime *string `json:"add_time,omitempty"`

			// Arr Only available in Growth and above plans
			//
			// The Annual Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Arr *float32 `json:"arr"`

			// ArrCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Recurring Revenue of the deal
			//
			// If the `arr` is null, this will also be null
			ArrCurrency *string `json:"arr_currency"`

			// CcEmail The BCC email of the deal
			CcEmail *string `json:"cc_email,omitempty"`

			// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CloseTime The date and time of closing the deal
			CloseTime *string `json:"close_time"`

			// CreatorUserId The ID of the deal creator
			CreatorUserId *int `json:"creator_user_id,omitempty"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// Deleted Whether the deal is deleted or not
			Deleted *bool `json:"deleted,omitempty"`

			// DoneActivitiesCount The number of completed activities associated with the deal
			DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

			// EmailMessagesCount The number of emails associated with the deal
			EmailMessagesCount *int `json:"email_messages_count,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// FilesCount The number of files associated with the deal
			FilesCount *int `json:"files_count,omitempty"`

			// FirstWonTime The date and time of the first time changing the deal status as won
			FirstWonTime *string `json:"first_won_time,omitempty"`

			// FollowersCount The number of followers associated with the deal
			FollowersCount *int `json:"followers_count,omitempty"`

			// FormattedValue The deal value formatted with selected currency. E.g. US$500
			FormattedValue *string `json:"formatted_value,omitempty"`

			// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
			FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// IsArchived Whether the deal is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// Label The label or multiple labels assigned to the deal
			Label *string `json:"label,omitempty"`

			// LastActivityDate The date of the last activity associated with the deal
			LastActivityDate *string `json:"last_activity_date"`

			// LastActivityId The ID of the last activity associated with the deal
			LastActivityId *int `json:"last_activity_id"`

			// LastIncomingMailTime The date and time of the last incoming email associated with the deal
			LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

			// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
			LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status as lost
			LostTime *string `json:"lost_time,omitempty"`

			// Mrr Only available in Growth and above plans
			//
			// The Monthly Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Mrr *float32 `json:"mrr"`

			// MrrCurrency Only available in Growth and above plans
			//
			// The Currency for Monthly Recurring Revenue of the deal
			//
			// If the `mrr` is null, this will also be null
			MrrCurrency *string `json:"mrr_currency"`

			// NextActivityDate The date of the next activity associated with the deal
			NextActivityDate *string `json:"next_activity_date,omitempty"`

			// NextActivityDuration The duration of the next activity associated with the deal
			NextActivityDuration *string `json:"next_activity_duration,omitempty"`

			// NextActivityId The ID of the next activity associated with the deal
			NextActivityId *int `json:"next_activity_id"`

			// NextActivityNote The note of the next activity associated with the deal
			NextActivityNote *string `json:"next_activity_note,omitempty"`

			// NextActivitySubject The subject of the next activity associated with the deal
			NextActivitySubject *string `json:"next_activity_subject,omitempty"`

			// NextActivityTime The time of the next activity associated with the deal
			NextActivityTime *string `json:"next_activity_time,omitempty"`

			// NextActivityType The type of the next activity associated with the deal
			NextActivityType *string `json:"next_activity_type,omitempty"`

			// NotesCount The number of notes associated with the deal
			NotesCount *int `json:"notes_count,omitempty"`

			// OrgHidden If the organization that is associated with the deal is hidden or not
			OrgHidden *bool `json:"org_hidden,omitempty"`

			// OrgId The ID of the organization associated with the deal
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the deal
			OrgName *string `json:"org_name,omitempty"`

			// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
			OriginId *string `json:"origin_id"`

			// OwnerName The name of the deal owner
			OwnerName *string `json:"owner_name,omitempty"`

			// ParticipantsCount The number of participants associated with the deal
			ParticipantsCount *int `json:"participants_count,omitempty"`

			// PersonHidden If the person that is associated with the deal is hidden or not
			PersonHidden *bool `json:"person_hidden,omitempty"`

			// PersonId The ID of the person associated with the deal
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the deal
			PersonName *string `json:"person_name,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// ProductsCount The number of products associated with the deal
			ProductsCount *int `json:"products_count,omitempty"`

			// RottenTime The date and time of changing the deal status as rotten
			RottenTime *string `json:"rotten_time"`

			// StageChangeTime The last updated date and time of the deal stage
			StageChangeTime *string `json:"stage_change_time,omitempty"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// StageOrderNr The order number of the deal stage associated with the deal
			StageOrderNr *int `json:"stage_order_nr,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UndoneActivitiesCount The number of incomplete activities associated with the deal
			UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

			// UpdateTime The last updated date and time of the deal
			UpdateTime *string `json:"update_time,omitempty"`

			// UserId The ID of the user
			UserId *int `json:"user_id,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *string `json:"visible_to,omitempty"`

			// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
			WeightedValue *float32 `json:"weighted_value,omitempty"`

			// WeightedValueCurrency The currency associated with the deal
			WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

			// WonTime The date and time of changing the deal status as won
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPipelineDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineMovementStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The pipeline object
		Data *struct {
			// AverageAgeInDays The moved deals average age in days
			AverageAgeInDays *struct {
				// AcrossAllStages The moved deals average age across all stages
				AcrossAllStages *int `json:"across_all_stages,omitempty"`

				// ByStages The moved deals average age by stages
				ByStages *[]struct {
					// StageId The stage ID
					StageId *int `json:"stage_id,omitempty"`

					// Value The average deals age in specific stage
					Value *int `json:"value,omitempty"`
				} `json:"by_stages,omitempty"`
			} `json:"average_age_in_days,omitempty"`

			// DealsLeftOpen Deals summary
			DealsLeftOpen *struct {
				// Count The count of the deals
				Count *int `json:"count,omitempty"`

				// DealsIds The IDs of the deals that have been moved
				DealsIds *[]int `json:"deals_ids,omitempty"`

				// FormattedValues The formatted values of the deals
				FormattedValues *struct {
					// CURRENCYID The formatted values of the deals
					CURRENCYID *string `json:"CURRENCY_ID,omitempty"`
				} `json:"formatted_values,omitempty"`

				// Values The values of the deals
				Values *struct {
					// CURRENCYID The value of the deals
					CURRENCYID *int `json:"CURRENCY_ID,omitempty"`
				} `json:"values,omitempty"`
			} `json:"deals_left_open,omitempty"`

			// LostDeals Deals summary
			LostDeals *struct {
				// Count The count of the deals
				Count *int `json:"count,omitempty"`

				// DealsIds The IDs of the deals that have been moved
				DealsIds *[]int `json:"deals_ids,omitempty"`

				// FormattedValues The formatted values of the deals
				FormattedValues *struct {
					// CURRENCYID The formatted values of the deals
					CURRENCYID *string `json:"CURRENCY_ID,omitempty"`
				} `json:"formatted_values,omitempty"`

				// Values The values of the deals
				Values *struct {
					// CURRENCYID The value of the deals
					CURRENCYID *int `json:"CURRENCY_ID,omitempty"`
				} `json:"values,omitempty"`
			} `json:"lost_deals,omitempty"`

			// MovementsBetweenStages Movements between stages
			MovementsBetweenStages *struct {
				// Count The count of the deals that have been moved between stages
				Count *int `json:"count,omitempty"`
			} `json:"movements_between_stages,omitempty"`

			// NewDeals Deals summary
			NewDeals *struct {
				// Count The count of the deals
				Count *int `json:"count,omitempty"`

				// DealsIds The IDs of the deals that have been moved
				DealsIds *[]int `json:"deals_ids,omitempty"`

				// FormattedValues The formatted values of the deals
				FormattedValues *struct {
					// CURRENCYID The formatted values of the deals
					CURRENCYID *string `json:"CURRENCY_ID,omitempty"`
				} `json:"formatted_values,omitempty"`

				// Values The values of the deals
				Values *struct {
					// CURRENCYID The value of the deals
					CURRENCYID *int `json:"CURRENCY_ID,omitempty"`
				} `json:"values,omitempty"`
			} `json:"new_deals,omitempty"`

			// WonDeals Deals summary
			WonDeals *struct {
				// Count The count of the deals
				Count *int `json:"count,omitempty"`

				// DealsIds The IDs of the deals that have been moved
				DealsIds *[]int `json:"deals_ids,omitempty"`

				// FormattedValues The formatted values of the deals
				FormattedValues *struct {
					// CURRENCYID The formatted values of the deals
					CURRENCYID *string `json:"CURRENCY_ID,omitempty"`
				} `json:"formatted_values,omitempty"`

				// Values The values of the deals
				Values *struct {
					// CURRENCYID The value of the deals
					CURRENCYID *int `json:"CURRENCY_ID,omitempty"`
				} `json:"values,omitempty"`
			} `json:"won_deals,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPipelineMovementStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineMovementStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id Array of all the IDs of the deleted product fields
			Id *[]int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteProductFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of deals
		Data *[]struct {
			// Active Whether the deal is active or not
			Active *bool `json:"active,omitempty"`

			// ActivitiesCount The number of activities associated with the deal
			ActivitiesCount *int `json:"activities_count,omitempty"`

			// Acv Only available in Growth and above plans
			//
			// The Annual Contract Value of the deal
			//
			// Null if there are no products attached to the deal
			Acv *float32 `json:"acv"`

			// AcvCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Contract Value of the deal
			//
			// If the `acv` is null, this will also be null
			AcvCurrency *string `json:"acv_currency"`

			// AddTime The creation date and time of the deal
			AddTime *string `json:"add_time,omitempty"`

			// Arr Only available in Growth and above plans
			//
			// The Annual Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Arr *float32 `json:"arr"`

			// ArrCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Recurring Revenue of the deal
			//
			// If the `arr` is null, this will also be null
			ArrCurrency *string `json:"arr_currency"`

			// CcEmail The BCC email of the deal
			CcEmail *string `json:"cc_email,omitempty"`

			// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CloseTime The date and time of closing the deal
			CloseTime *string `json:"close_time"`

			// CreatorUserId The creator of the deal
			CreatorUserId *struct {
				// ActiveFlag Whether the creator is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The email of the deal creator
				Email *string `json:"email,omitempty"`

				// HasPic If the creator has a picture or not
				HasPic *bool `json:"has_pic,omitempty"`

				// Id The ID of the deal creator
				Id *int `json:"id,omitempty"`

				// Name The name of the deal creator
				Name *string `json:"name,omitempty"`

				// PicHash The creator picture hash
				PicHash *string `json:"pic_hash"`

				// Value The ID of the deal creator
				Value *int `json:"value,omitempty"`
			} `json:"creator_user_id,omitempty"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// Deleted Whether the deal is deleted or not
			Deleted *bool `json:"deleted,omitempty"`

			// DoneActivitiesCount The number of completed activities associated with the deal
			DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

			// EmailMessagesCount The number of emails associated with the deal
			EmailMessagesCount *int `json:"email_messages_count,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// FilesCount The number of files associated with the deal
			FilesCount *int `json:"files_count,omitempty"`

			// FirstWonTime The date and time of the first time changing the deal status as won
			FirstWonTime *string `json:"first_won_time,omitempty"`

			// FollowersCount The number of followers associated with the deal
			FollowersCount *int `json:"followers_count,omitempty"`

			// FormattedValue The deal value formatted with selected currency. E.g. US$500
			FormattedValue *string `json:"formatted_value,omitempty"`

			// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
			FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// IsArchived Whether the deal is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// Label The label or multiple labels assigned to the deal
			Label *string `json:"label,omitempty"`

			// LastActivityDate The date of the last activity associated with the deal
			LastActivityDate *string `json:"last_activity_date"`

			// LastActivityId The ID of the last activity associated with the deal
			LastActivityId *int `json:"last_activity_id"`

			// LastIncomingMailTime The date and time of the last incoming email associated with the deal
			LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

			// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
			LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status as lost
			LostTime *string `json:"lost_time,omitempty"`

			// Mrr Only available in Growth and above plans
			//
			// The Monthly Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Mrr *float32 `json:"mrr"`

			// MrrCurrency Only available in Growth and above plans
			//
			// The Currency for Monthly Recurring Revenue of the deal
			//
			// If the `mrr` is null, this will also be null
			MrrCurrency *string `json:"mrr_currency"`

			// NextActivityDate The date of the next activity associated with the deal
			NextActivityDate *string `json:"next_activity_date,omitempty"`

			// NextActivityDuration The duration of the next activity associated with the deal
			NextActivityDuration *string `json:"next_activity_duration,omitempty"`

			// NextActivityId The ID of the next activity associated with the deal
			NextActivityId *int `json:"next_activity_id"`

			// NextActivityNote The note of the next activity associated with the deal
			NextActivityNote *string `json:"next_activity_note,omitempty"`

			// NextActivitySubject The subject of the next activity associated with the deal
			NextActivitySubject *string `json:"next_activity_subject,omitempty"`

			// NextActivityTime The time of the next activity associated with the deal
			NextActivityTime *string `json:"next_activity_time,omitempty"`

			// NextActivityType The type of the next activity associated with the deal
			NextActivityType *string `json:"next_activity_type,omitempty"`

			// NotesCount The number of notes associated with the deal
			NotesCount *int `json:"notes_count,omitempty"`

			// OrgHidden If the organization that is associated with the deal is hidden or not
			OrgHidden *bool `json:"org_hidden,omitempty"`
			OrgId     *struct {
				// ActiveFlag Whether the associated organization is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Address The address of the organization that is associated with the deal
				Address *string `json:"address,omitempty"`

				// CcEmail The BCC email of the organization associated with the deal
				CcEmail *string `json:"cc_email,omitempty"`

				// Name The name of the organization associated with the deal
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the organization that is associated with the deal
				OwnerId *int `json:"owner_id,omitempty"`

				// PeopleCount The number of people connected with the organization that is associated with the deal
				PeopleCount *int `json:"people_count,omitempty"`

				// Value The ID of the organization associated with the deal
				Value *int `json:"value,omitempty"`
			} `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the deal
			OrgName *string `json:"org_name,omitempty"`

			// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
			OriginId *string `json:"origin_id"`

			// OwnerName The name of the deal owner
			OwnerName *string `json:"owner_name,omitempty"`

			// ParticipantsCount The number of participants associated with the deal
			ParticipantsCount *int `json:"participants_count,omitempty"`

			// PersonHidden If the person that is associated with the deal is hidden or not
			PersonHidden *bool `json:"person_hidden,omitempty"`
			PersonId     *struct {
				// ActiveFlag Whether the associated person is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The emails of the person associated with the deal
				Email *[]struct {
					// Label The type of the email
					Label *string `json:"label,omitempty"`

					// Primary If this is the primary email or not
					Primary *bool `json:"primary,omitempty"`

					// Value The email of the associated person
					Value *string `json:"value,omitempty"`
				} `json:"email,omitempty"`

				// Name The name of the person associated with the deal
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner of the person that is associated with the deal
				OwnerId *int `json:"owner_id,omitempty"`

				// Phone The phone numbers of the person associated with the deal
				Phone *[]struct {
					// Label The type of the phone number
					Label *string `json:"label,omitempty"`

					// Primary If this is the primary phone number or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number of the person associated with the deal
					Value *string `json:"value,omitempty"`
				} `json:"phone,omitempty"`

				// Value The ID of the person associated with the deal
				Value *int `json:"value,omitempty"`
			} `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the deal
			PersonName *string `json:"person_name,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// ProductsCount The number of products associated with the deal
			ProductsCount *int `json:"products_count,omitempty"`

			// RottenTime The date and time of changing the deal status as rotten
			RottenTime *string `json:"rotten_time"`

			// StageChangeTime The last updated date and time of the deal stage
			StageChangeTime *string `json:"stage_change_time,omitempty"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// StageOrderNr The order number of the deal stage associated with the deal
			StageOrderNr *int `json:"stage_order_nr,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UndoneActivitiesCount The number of incomplete activities associated with the deal
			UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

			// UpdateTime The last updated date and time of the deal
			UpdateTime *string `json:"update_time,omitempty"`
			UserId     *struct {
				// ActiveFlag Whether the user is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Email The email of the user
				Email *string `json:"email,omitempty"`

				// HasPic If the user has a picture or not
				HasPic *bool `json:"has_pic,omitempty"`

				// Id The ID of the user
				Id *int `json:"id,omitempty"`

				// Name The name of the user
				Name *string `json:"name,omitempty"`

				// PicHash The user picture hash
				PicHash *string `json:"pic_hash"`

				// Value The ID of the user
				Value *int `json:"value,omitempty"`
			} `json:"user_id,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *string `json:"visible_to,omitempty"`

			// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
			WeightedValue *float32 `json:"weighted_value,omitempty"`

			// WeightedValueCurrency The currency associated with the deal
			WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

			// WonTime The date and time of changing the deal status as won
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`
		RelatedObjects *struct {
			Organization *struct {
				// ORGANIZATIONID The ID of the organization associated with the item
				ORGANIZATIONID *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Id The ID of the organization associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`
				} `json:"ORGANIZATION_ID,omitempty"`
			} `json:"organization,omitempty"`
			Person *struct {
				// PERSONID The ID of the person associated with the item
				PERSONID *struct {
					// ActiveFlag Whether the associated person is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The emails of the person associated with the item
					Email *[]struct {
						// Label The type of the email
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary email or not
						Primary *bool `json:"primary,omitempty"`

						// Value The email of the associated person
						Value *string `json:"value,omitempty"`
					} `json:"email,omitempty"`

					// Id The ID of the person associated with the item
					Id *int `json:"id,omitempty"`

					// Name The name of the person associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the person that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// Phone The phone numbers of the person associated with the item
					Phone *[]struct {
						// Label The type of the phone number
						Label *string `json:"label,omitempty"`

						// Primary Whether this is the primary phone number or not
						Primary *bool `json:"primary,omitempty"`

						// Value The phone number of the person associated with the item
						Value *string `json:"value,omitempty"`
					} `json:"phone,omitempty"`
				} `json:"PERSON_ID,omitempty"`
			} `json:"person,omitempty"`
			Pipeline *struct {
				// Active Whether this pipeline will be made inactive (hidden) or active
				Active *bool `json:"active,omitempty"`

				// AddTime The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// DealProbability Whether deal probability is disabled or enabled for this pipeline
				DealProbability *bool `json:"deal_probability,omitempty"`

				// Id The ID of the pipeline
				Id *int `json:"id,omitempty"`

				// Name The name of the pipeline
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
				OrderNr *int `json:"order_nr,omitempty"`

				// UpdateTime The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`

				// UrlTitle The pipeline title displayed in the URL
				UrlTitle *string `json:"url_title,omitempty"`
			} `json:"pipeline,omitempty"`
			Stage *struct {
				// ActiveFlag Whether the stage is active or deleted
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The stage creation time. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
				DealProbability *int `json:"deal_probability,omitempty"`

				// Id The ID of the stage
				Id *int `json:"id,omitempty"`

				// Name The name of the stage
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of the stage
				OrderNr *int `json:"order_nr,omitempty"`

				// PipelineId The ID of the pipeline to add the stage to
				PipelineId *int `json:"pipeline_id,omitempty"`

				// RottenDays The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
				RottenDays *int `json:"rotten_days,omitempty"`

				// RottenFlag Whether deals in this stage can become rotten
				RottenFlag *bool `json:"rotten_flag,omitempty"`

				// UpdateTime The stage update time. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"stage,omitempty"`
			User *struct {
				USERID *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`
				} `json:"USER_ID,omitempty"`
			} `json:"user,omitempty"`
		} `json:"related_objects,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProductDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of files
		Data *[]struct {
			// ActiveFlag Whether the user is active or not.
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The UTC date time when the file was uploaded. Format: YYYY-MM-DD HH:MM:SS
			AddTime *string `json:"add_time,omitempty"`

			// Description The description of the file
			Description *string `json:"description,omitempty"`

			// FileName The original name of the file
			FileName *string `json:"file_name,omitempty"`

			// FileSize The size of the file in bytes
			FileSize *int `json:"file_size,omitempty"`

			// Id The ID of the file
			Id *int `json:"id,omitempty"`

			// InlineFlag Whether the file was uploaded as inline or not
			InlineFlag *bool `json:"inline_flag,omitempty"`

			// Name The visible name of the file
			Name *string `json:"name,omitempty"`

			// ProductId The ID of the product associated with the file
			ProductId *int `json:"product_id,omitempty"`

			// ProductName The name of the product associated with the file
			ProductName *string `json:"product_name,omitempty"`

			// RemoteId The ID of the remote item
			RemoteId *string `json:"remote_id,omitempty"`

			// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
			RemoteLocation *string `json:"remote_location,omitempty"`

			// S3Bucket The location of the cloud storage
			S3Bucket *string `json:"s3_bucket,omitempty"`

			// UpdateTime The UTC date time when the file was last updated. Format: YYYY-MM-DD HH:MM:SS
			UpdateTime *string `json:"update_time,omitempty"`

			// Url The URL to download the file
			Url *string `json:"url,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProductFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The list of user IDs
		Data *[]int `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProductUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// AddTime The creation date and time of the template in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// Description The description of a template
			Description *string `json:"description,omitempty"`

			// Id The ID of a template
			Id *float32 `json:"id,omitempty"`

			// OwnerId The ID of a template owner
			OwnerId *float32 `json:"owner_id,omitempty"`

			// ProjectsBoardId The ID of the project board this template is associated with
			ProjectsBoardId *float32 `json:"projects_board_id,omitempty"`

			// Title The title of a template
			Title *string `json:"title,omitempty"`

			// UpdateTime The update date and time of the template in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			// AddTime The creation date and time of the template in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// Description The description of a template
			Description *string `json:"description,omitempty"`

			// Id The ID of a template
			Id *float32 `json:"id,omitempty"`

			// OwnerId The ID of a template owner
			OwnerId *float32 `json:"owner_id,omitempty"`

			// ProjectsBoardId The ID of the project board this template is associated with
			ProjectsBoardId *float32 `json:"projects_board_id,omitempty"`

			// Title The title of a template
			Title *string `json:"title,omitempty"`

			// UpdateTime The update date and time of the template in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// AddTime The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// ArchiveTime The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then 'null'.
			ArchiveTime *string `json:"archive_time,omitempty"`

			// BoardId The ID of the board this project is associated with
			BoardId *float32 `json:"board_id,omitempty"`

			// DealIds An array of IDs of the deals this project is associated with
			DealIds *[]int `json:"deal_ids,omitempty"`

			// Description The description of the project
			Description *string `json:"description,omitempty"`

			// EndDate The end date of the project. Format: YYYY-MM-DD.
			EndDate *openapi_types.Date `json:"end_date,omitempty"`

			// Id The ID of the project, generated when the task was created
			Id *int `json:"id,omitempty"`

			// Labels An array of IDs of the labels this project has
			Labels *[]int `json:"labels,omitempty"`

			// OrgId The ID of the organization this project is associated with
			OrgId *float32 `json:"org_id,omitempty"`

			// OwnerId The ID of a project owner
			OwnerId *float32 `json:"owner_id,omitempty"`

			// PersonId The ID of the person this project is associated with
			PersonId *float32 `json:"person_id,omitempty"`

			// PhaseId The ID of the phase this project is associated with
			PhaseId *float32 `json:"phase_id,omitempty"`

			// StartDate The start date of the project. Format: YYYY-MM-DD.
			StartDate *openapi_types.Date `json:"start_date,omitempty"`

			// Status The status of the project
			Status *string `json:"status,omitempty"`

			// StatusChangeTime The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			StatusChangeTime *string `json:"status_change_time,omitempty"`

			// Title The title of the project
			Title *string `json:"title,omitempty"`

			// UpdateTime The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			// AddTime The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// ArchiveTime The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then 'null'.
			ArchiveTime *string `json:"archive_time,omitempty"`

			// BoardId The ID of the board this project is associated with
			BoardId *float32 `json:"board_id,omitempty"`

			// DealIds An array of IDs of the deals this project is associated with
			DealIds *[]int `json:"deal_ids,omitempty"`

			// Description The description of the project
			Description *string `json:"description,omitempty"`

			// EndDate The end date of the project. Format: YYYY-MM-DD.
			EndDate *openapi_types.Date `json:"end_date,omitempty"`

			// Id The ID of the project, generated when the task was created
			Id *int `json:"id,omitempty"`

			// Labels An array of IDs of the labels this project has
			Labels *[]int `json:"labels,omitempty"`

			// OrgId The ID of the organization this project is associated with
			OrgId *float32 `json:"org_id,omitempty"`

			// OwnerId The ID of a project owner
			OwnerId *float32 `json:"owner_id,omitempty"`

			// PersonId The ID of the person this project is associated with
			PersonId *float32 `json:"person_id,omitempty"`

			// PhaseId The ID of the phase this project is associated with
			PhaseId *float32 `json:"phase_id,omitempty"`

			// StartDate The start date of the project. Format: YYYY-MM-DD.
			StartDate *openapi_types.Date `json:"start_date,omitempty"`

			// Status The status of the project
			Status *string `json:"status,omitempty"`

			// StatusChangeTime The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			StatusChangeTime *string `json:"status_change_time,omitempty"`

			// Title The title of the project
			Title *string `json:"title,omitempty"`

			// UpdateTime The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsBoardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// AddTime The creation date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// Id The ID of the project board
			Id *int `json:"id,omitempty"`

			// Name Name of a project board
			Name *string `json:"name,omitempty"`

			// OrderNr The order of a board
			OrderNr *float32 `json:"order_nr,omitempty"`

			// UpdateTime The update date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectsBoardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsBoardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsBoardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			// AddTime The creation date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// Id The ID of the project board
			Id *int `json:"id,omitempty"`

			// Name Name of a project board
			Name *string `json:"name,omitempty"`

			// OrderNr The order of a board
			OrderNr *float32 `json:"order_nr,omitempty"`

			// UpdateTime The update date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectsBoardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsBoardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsPhasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// AddTime The creation date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// BoardId The ID of the project board this phase is linked to
			BoardId *float32 `json:"board_id,omitempty"`

			// Id The ID of the project phase
			Id *int `json:"id,omitempty"`

			// Name Name of a project phase
			Name *string `json:"name,omitempty"`

			// OrderNr The order of a phase
			OrderNr *float32 `json:"order_nr,omitempty"`

			// UpdateTime The update date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectsPhasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsPhasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsPhaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			// AddTime The creation date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// BoardId The ID of the project board this phase is linked to
			BoardId *float32 `json:"board_id,omitempty"`

			// Id The ID of the project phase
			Id *int `json:"id,omitempty"`

			// Name Name of a project phase
			Name *string `json:"name,omitempty"`

			// OrderNr The order of a phase
			OrderNr *float32 `json:"order_nr,omitempty"`

			// UpdateTime The update date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectsPhaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsPhaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			Data *struct {
				// Id The ID of the project that was deleted
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			// AddTime The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// ArchiveTime The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then 'null'.
			ArchiveTime *string `json:"archive_time,omitempty"`

			// BoardId The ID of the board this project is associated with
			BoardId *float32 `json:"board_id,omitempty"`

			// DealIds An array of IDs of the deals this project is associated with
			DealIds *[]int `json:"deal_ids,omitempty"`

			// Description The description of the project
			Description *string `json:"description,omitempty"`

			// EndDate The end date of the project. Format: YYYY-MM-DD.
			EndDate *openapi_types.Date `json:"end_date,omitempty"`

			// Id The ID of the project, generated when the task was created
			Id *int `json:"id,omitempty"`

			// Labels An array of IDs of the labels this project has
			Labels *[]int `json:"labels,omitempty"`

			// OrgId The ID of the organization this project is associated with
			OrgId *float32 `json:"org_id,omitempty"`

			// OwnerId The ID of a project owner
			OwnerId *float32 `json:"owner_id,omitempty"`

			// PersonId The ID of the person this project is associated with
			PersonId *float32 `json:"person_id,omitempty"`

			// PhaseId The ID of the phase this project is associated with
			PhaseId *float32 `json:"phase_id,omitempty"`

			// StartDate The start date of the project. Format: YYYY-MM-DD.
			StartDate *openapi_types.Date `json:"start_date,omitempty"`

			// Status The status of the project
			Status *string `json:"status,omitempty"`

			// StatusChangeTime The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			StatusChangeTime *string `json:"status_change_time,omitempty"`

			// Title The title of the project
			Title *string `json:"title,omitempty"`

			// UpdateTime The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			// AddTime The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// ArchiveTime The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then 'null'.
			ArchiveTime *string `json:"archive_time,omitempty"`

			// BoardId The ID of the board this project is associated with
			BoardId *float32 `json:"board_id,omitempty"`

			// DealIds An array of IDs of the deals this project is associated with
			DealIds *[]int `json:"deal_ids,omitempty"`

			// Description The description of the project
			Description *string `json:"description,omitempty"`

			// EndDate The end date of the project. Format: YYYY-MM-DD.
			EndDate *openapi_types.Date `json:"end_date,omitempty"`

			// Id The ID of the project, generated when the task was created
			Id *int `json:"id,omitempty"`

			// Labels An array of IDs of the labels this project has
			Labels *[]int `json:"labels,omitempty"`

			// OrgId The ID of the organization this project is associated with
			OrgId *float32 `json:"org_id,omitempty"`

			// OwnerId The ID of a project owner
			OwnerId *float32 `json:"owner_id,omitempty"`

			// PersonId The ID of the person this project is associated with
			PersonId *float32 `json:"person_id,omitempty"`

			// PhaseId The ID of the phase this project is associated with
			PhaseId *float32 `json:"phase_id,omitempty"`

			// StartDate The start date of the project. Format: YYYY-MM-DD.
			StartDate *openapi_types.Date `json:"start_date,omitempty"`

			// Status The status of the project
			Status *string `json:"status,omitempty"`

			// StatusChangeTime The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			StatusChangeTime *string `json:"status_change_time,omitempty"`

			// Title The title of the project
			Title *string `json:"title,omitempty"`

			// UpdateTime The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// ActiveFlag Whether the activity is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// BusyFlag Marks if the activity is set as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
			BusyFlag *bool `json:"busy_flag,omitempty"`

			// CompanyId The user's company ID
			CompanyId *int `json:"company_id,omitempty"`

			// ConferenceMeetingClient The ID of the Marketplace app, which is connected to this activity
			ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

			// ConferenceMeetingId The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
			ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

			// ConferenceMeetingUrl The link to join the meeting which is associated with this activity
			ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

			// DealId The ID of the deal this activity is associated with
			DealId *int `json:"deal_id,omitempty"`

			// Done Whether the activity is done or not
			Done *bool `json:"done,omitempty"`

			// DueDate The due date of the activity. Format: YYYY-MM-DD
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// DueTime The due time of the activity in UTC. Format: HH:MM
			DueTime *string `json:"due_time,omitempty"`

			// Duration The duration of the activity. Format: HH:MM
			Duration *string `json:"duration,omitempty"`

			// Id The ID of the activity, generated when the activity was created
			Id *int `json:"id,omitempty"`

			// LeadId The ID of the lead in the UUID format this activity is associated with
			LeadId *openapi_types.UUID `json:"lead_id"`

			// Location The address of the activity.
			Location *string `json:"location,omitempty"`

			// LocationAdminAreaLevel1 A subfield of the location field. Indicates state/county.
			LocationAdminAreaLevel1 *string `json:"location_admin_area_level_1,omitempty"`

			// LocationAdminAreaLevel2 A subfield of the location field. Indicates region.
			LocationAdminAreaLevel2 *string `json:"location_admin_area_level_2,omitempty"`

			// LocationCountry A subfield of the location field. Indicates country.
			LocationCountry *string `json:"location_country,omitempty"`

			// LocationFormattedAddress A subfield of the location field. Indicates full/combined address.
			LocationFormattedAddress *string `json:"location_formatted_address,omitempty"`

			// LocationLocality A subfield of the location field. Indicates city/town/village/locality.
			LocationLocality *string `json:"location_locality,omitempty"`

			// LocationPostalCode A subfield of the location field. Indicates ZIP/postal code.
			LocationPostalCode *string `json:"location_postal_code,omitempty"`

			// LocationRoute A subfield of the location field. Indicates street name.
			LocationRoute *string `json:"location_route,omitempty"`

			// LocationStreetNumber A subfield of the location field. Indicates house number.
			LocationStreetNumber *string `json:"location_street_number,omitempty"`

			// LocationSublocality A subfield of the location field. Indicates district/sublocality.
			LocationSublocality *string `json:"location_sublocality,omitempty"`

			// LocationSubpremise A subfield of the location field. Indicates apartment/suite number.
			LocationSubpremise *string `json:"location_subpremise,omitempty"`

			// MarkedAsDoneTime The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// OrgId The ID of the organization this activity is associated with
			OrgId *int `json:"org_id,omitempty"`

			// PersonId The ID of the person this activity is associated with
			PersonId *int `json:"person_id,omitempty"`

			// ProjectId The ID of the project this activity is associated with
			ProjectId *int `json:"project_id"`

			// PublicDescription Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
			PublicDescription *string `json:"public_description,omitempty"`

			// SourceTimezone The timezone the activity was created in an external calendar
			SourceTimezone *string `json:"source_timezone,omitempty"`

			// Subject The subject of the activity
			Subject *string `json:"subject,omitempty"`

			// Type The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
			Type *string `json:"type,omitempty"`

			// UpdateTime The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`

			// UpdateUserId The ID of the user who was the last to update this activity
			UpdateUserId *int `json:"update_user_id,omitempty"`

			// UserId The ID of the user whom the activity is assigned to
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			// AddTime The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// ArchiveTime The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then 'null'.
			ArchiveTime *string `json:"archive_time,omitempty"`

			// BoardId The ID of the board this project is associated with
			BoardId *float32 `json:"board_id,omitempty"`

			// DealIds An array of IDs of the deals this project is associated with
			DealIds *[]int `json:"deal_ids,omitempty"`

			// Description The description of the project
			Description *string `json:"description,omitempty"`

			// EndDate The end date of the project. Format: YYYY-MM-DD.
			EndDate *openapi_types.Date `json:"end_date,omitempty"`

			// Id The ID of the project, generated when the task was created
			Id *int `json:"id,omitempty"`

			// Labels An array of IDs of the labels this project has
			Labels *[]int `json:"labels,omitempty"`

			// OrgId The ID of the organization this project is associated with
			OrgId *float32 `json:"org_id,omitempty"`

			// OwnerId The ID of a project owner
			OwnerId *float32 `json:"owner_id,omitempty"`

			// PersonId The ID of the person this project is associated with
			PersonId *float32 `json:"person_id,omitempty"`

			// PhaseId The ID of the phase this project is associated with
			PhaseId *float32 `json:"phase_id,omitempty"`

			// StartDate The start date of the project. Format: YYYY-MM-DD.
			StartDate *openapi_types.Date `json:"start_date,omitempty"`

			// Status The status of the project
			Status *string `json:"status,omitempty"`

			// StatusChangeTime The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			StatusChangeTime *string `json:"status_change_time,omitempty"`

			// Title The title of the project
			Title *string `json:"title,omitempty"`

			// UpdateTime The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ArchiveProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id ID of the group
			Id *float32 `json:"id,omitempty"`

			// Name Name of the group
			Name *string `json:"name,omitempty"`

			// OrderNr Order number of the group
			OrderNr *float32 `json:"order_nr,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectPlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// GroupId The ID of the board this project is associated with. If null then plan item is not in any group.
			GroupId *float32 `json:"group_id,omitempty"`

			// ItemId ID of plan item (either activity or task ID)
			ItemId *float32 `json:"item_id,omitempty"`

			// ItemType Type of a plan item (task / activity)
			ItemType *string `json:"item_type,omitempty"`

			// PhaseId The ID of the board this project is associated with. If null then plan item is not in any phase.
			PhaseId *float32 `json:"phase_id,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectPlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectPlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutProjectPlanActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			// GroupId The ID of the board this project is associated with. If null then plan item is not in any group.
			GroupId *float32 `json:"group_id,omitempty"`

			// ItemId ID of plan item (either activity or task ID)
			ItemId *float32 `json:"item_id,omitempty"`

			// ItemType Type of a plan item (task / activity)
			ItemType *string `json:"item_type,omitempty"`

			// PhaseId The ID of the board this project is associated with. If null then plan item is not in any phase.
			PhaseId *float32 `json:"phase_id,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PutProjectPlanActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutProjectPlanActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutProjectPlanTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			// GroupId The ID of the board this project is associated with. If null then plan item is not in any group.
			GroupId *float32 `json:"group_id,omitempty"`

			// ItemId ID of plan item (either activity or task ID)
			ItemId *float32 `json:"item_id,omitempty"`

			// ItemType Type of a plan item (task / activity)
			ItemType *string `json:"item_type,omitempty"`

			// PhaseId The ID of the board this project is associated with. If null then plan item is not in any phase.
			PhaseId *float32 `json:"phase_id,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PutProjectPlanTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutProjectPlanTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// AddTime The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// AssigneeId The ID of the user who will be the assignee of the task
			AssigneeId *float32 `json:"assignee_id,omitempty"`

			// CreatorId The creator of a task
			CreatorId *float32 `json:"creator_id,omitempty"`

			// Description The description of the task
			Description *string `json:"description,omitempty"`

			// Done Whether the task is done or not. 0 = Not done, 1 = Done.
			Done *GetProjectTasks200DataDone `json:"done,omitempty"`

			// DueDate The due date of the task. Format: YYYY-MM-DD.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// Id The ID of the task, generated when the task was created
			Id *int `json:"id,omitempty"`

			// MarkedAsDoneTime The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// ParentTaskId The ID of a parent task. Can not be ID of a task which is already a subtask.
			ParentTaskId *float32 `json:"parent_task_id,omitempty"`

			// ProjectId The ID of the project this task is associated with
			ProjectId *float32 `json:"project_id,omitempty"`

			// Title The title of the task
			Title *string `json:"title,omitempty"`

			// UpdateTime The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}
type GetProjectTasks200DataDone float32

// Status returns HTTPResponse.Status
func (r GetProjectTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// LastTimestampOnPage The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
			LastTimestampOnPage *string `json:"last_timestamp_on_page,omitempty"`

			// Pagination The additional data of the list
			Pagination *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"pagination,omitempty"`

			// SinceTimestamp The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
			SinceTimestamp *string `json:"since_timestamp,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]GetRecents_200_Data_Item `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetRecents200Data0 struct {
	Data *struct {
		// ActiveFlag Whether the activity is active or not
		ActiveFlag *bool `json:"active_flag,omitempty"`

		// AddTime The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
		AddTime *string `json:"add_time,omitempty"`

		// AssignedToUserId The ID of the user to whom the activity is assigned to. Equal to `user_id`.
		AssignedToUserId *int `json:"assigned_to_user_id,omitempty"`

		// Attendees The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address.
		Attendees *[]map[string]interface{} `json:"attendees"`

		// BusyFlag Marks if the activity is set as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
		BusyFlag *bool `json:"busy_flag,omitempty"`

		// CalendarSyncIncludeContext For activities that sync to an external calendar, this setting indicates if the activity syncs with context (what are the deals, persons, organizations this activity is related to)
		CalendarSyncIncludeContext *string `json:"calendar_sync_include_context,omitempty"`

		// CompanyId The user's company ID
		CompanyId *int `json:"company_id,omitempty"`

		// ConferenceMeetingClient The ID of the Marketplace app, which is connected to this activity
		ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

		// ConferenceMeetingId The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
		ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

		// ConferenceMeetingUrl The link to join the meeting which is associated with this activity
		ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

		// CreatedByUserId The ID of the user who created the activity
		CreatedByUserId *int `json:"created_by_user_id,omitempty"`

		// DealDropboxBcc The BCC email address of the deal
		DealDropboxBcc *string `json:"deal_dropbox_bcc,omitempty"`

		// DealId The ID of the deal this activity is associated with
		DealId *int `json:"deal_id,omitempty"`

		// DealTitle The name of the deal this activity is associated with
		DealTitle *string `json:"deal_title,omitempty"`

		// Done Whether the activity is done or not
		Done *bool `json:"done,omitempty"`

		// DueDate The due date of the activity. Format: YYYY-MM-DD
		DueDate *openapi_types.Date `json:"due_date,omitempty"`

		// DueTime The due time of the activity in UTC. Format: HH:MM
		DueTime *string `json:"due_time,omitempty"`

		// Duration The duration of the activity. Format: HH:MM
		Duration *string `json:"duration,omitempty"`

		// File The file that is attached to this activity. For example, this can be a reference to an audio note file generated with Pipedrive mobile app.
		File *map[string]interface{} `json:"file,omitempty"`

		// GcalEventId For the activity which syncs to Google calendar, this is the Google event ID. NB! This field is related to old Google calendar sync and will be deprecated soon.
		GcalEventId *string `json:"gcal_event_id,omitempty"`

		// GoogleCalendarEtag The Google calendar API etag (version) that is used for syncing this activity. NB! This field is related to old Google calendar sync and will be deprecated soon.
		GoogleCalendarEtag *string `json:"google_calendar_etag,omitempty"`

		// GoogleCalendarId The Google calendar ID that this activity syncs to. NB! This field is related to old Google calendar sync and will be deprecated soon.
		GoogleCalendarId *string `json:"google_calendar_id,omitempty"`

		// Id The ID of the activity, generated when the activity was created
		Id *int `json:"id,omitempty"`

		// LastNotificationTime The date and time of latest notifications sent about this activity to the participants or the attendees of this activity
		LastNotificationTime *string `json:"last_notification_time,omitempty"`

		// LastNotificationUserId The ID of the user who triggered the sending of the latest notifications about this activity to the participants or the attendees of this activity
		LastNotificationUserId *int `json:"last_notification_user_id,omitempty"`

		// LeadId The ID of the lead in the UUID format this activity is associated with
		LeadId *openapi_types.UUID `json:"lead_id"`

		// Location The address of the activity.
		Location *string `json:"location,omitempty"`

		// LocationAdminAreaLevel1 A subfield of the location field. Indicates state/county.
		LocationAdminAreaLevel1 *string `json:"location_admin_area_level_1,omitempty"`

		// LocationAdminAreaLevel2 A subfield of the location field. Indicates region.
		LocationAdminAreaLevel2 *string `json:"location_admin_area_level_2,omitempty"`

		// LocationCountry A subfield of the location field. Indicates country.
		LocationCountry *string `json:"location_country,omitempty"`

		// LocationFormattedAddress A subfield of the location field. Indicates full/combined address.
		LocationFormattedAddress *string `json:"location_formatted_address,omitempty"`

		// LocationLocality A subfield of the location field. Indicates city/town/village/locality.
		LocationLocality *string `json:"location_locality,omitempty"`

		// LocationPostalCode A subfield of the location field. Indicates ZIP/postal code.
		LocationPostalCode *string `json:"location_postal_code,omitempty"`

		// LocationRoute A subfield of the location field. Indicates street name.
		LocationRoute *string `json:"location_route,omitempty"`

		// LocationStreetNumber A subfield of the location field. Indicates house number.
		LocationStreetNumber *string `json:"location_street_number,omitempty"`

		// LocationSublocality A subfield of the location field. Indicates district/sublocality.
		LocationSublocality *string `json:"location_sublocality,omitempty"`

		// LocationSubpremise A subfield of the location field. Indicates apartment/suite number.
		LocationSubpremise *string `json:"location_subpremise,omitempty"`

		// MarkedAsDoneTime The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
		MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

		// Note The note of the activity (HTML format)
		Note *string `json:"note,omitempty"`

		// NotificationLanguageId The ID of the language the notifications are sent in
		NotificationLanguageId *int `json:"notification_language_id,omitempty"`

		// OrgId The ID of the organization this activity is associated with
		OrgId *int `json:"org_id,omitempty"`

		// OrgName The name of the organization this activity is associated with
		OrgName *string `json:"org_name,omitempty"`

		// OwnerName The name of the user this activity is owned by
		OwnerName *string `json:"owner_name,omitempty"`

		// Participants List of multiple persons (participants) this activity is associated with
		Participants *[]map[string]interface{} `json:"participants"`

		// PersonDropboxBcc The BCC email address of the person
		PersonDropboxBcc *string `json:"person_dropbox_bcc,omitempty"`

		// PersonId The ID of the person this activity is associated with
		PersonId *int `json:"person_id,omitempty"`

		// PersonName The name of the person this activity is associated with
		PersonName *string `json:"person_name,omitempty"`

		// ProjectId The ID of the project this activity is associated with
		ProjectId *int `json:"project_id"`

		// PublicDescription Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
		PublicDescription *string `json:"public_description,omitempty"`

		// RecMasterActivityId The ID of parent activity for a recurrent activity if the current activity is an exception to recurrence rules
		RecMasterActivityId *int `json:"rec_master_activity_id,omitempty"`

		// RecRule The rule for the recurrence of the activity. Is important for activities synced into Pipedrive from an external calendar. Example: "RRULE:FREQ=WEEKLY;BYDAY=WE"
		RecRule *string `json:"rec_rule,omitempty"`

		// RecRuleExtension Additional rules for the recurrence of the activity, extend the `rec_rule`. Is important for activities synced into Pipedrive from an external calendar.
		RecRuleExtension *string `json:"rec_rule_extension,omitempty"`

		// ReferenceId Together with the `reference_type`, gives the ID of the other object
		ReferenceId *int `json:"reference_id,omitempty"`

		// ReferenceType If the activity references some other object, it is indicated here. For example, value `Salesphone` refers to activities created with Caller.
		ReferenceType *string `json:"reference_type,omitempty"`

		// Series The list of recurring activity instances. It is in a structure as follows: `[{due_date: "2020-06-24", due_time: "10:00:00"}]`
		Series *[]map[string]interface{} `json:"series,omitempty"`

		// SourceTimezone The timezone the activity was created in an external calendar
		SourceTimezone *string `json:"source_timezone,omitempty"`

		// Subject The subject of the activity
		Subject *string `json:"subject,omitempty"`

		// Type The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
		Type *string `json:"type,omitempty"`

		// UpdateTime The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
		UpdateTime *string `json:"update_time,omitempty"`

		// UpdateUserId The ID of the user who was the last to update this activity
		UpdateUserId *int `json:"update_user_id,omitempty"`

		// UserId The ID of the user whom the activity is assigned to
		UserId *int `json:"user_id,omitempty"`
	} `json:"data,omitempty"`
	Id   *int                    `json:"id,omitempty"`
	Item *GetRecents200Data0Item `json:"item,omitempty"`
}
type GetRecents200Data0Item string
type GetRecents200Data1 struct {
	Data *struct {
		// ActiveFlag The active flag of the activity type
		ActiveFlag *bool `json:"active_flag,omitempty"`

		// AddTime The creation time of the activity type
		AddTime *time.Time `json:"add_time,omitempty"`

		// Color A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
		Color *string `json:"color,omitempty"`

		// IconKey Icon graphic to use for representing this activity type
		IconKey *GetRecents200Data1DataIconKey `json:"icon_key,omitempty"`

		// Id The ID of the activity type
		Id *int `json:"id,omitempty"`

		// IsCustomFlag Whether the activity type is a custom one or not
		IsCustomFlag *bool `json:"is_custom_flag,omitempty"`

		// KeyString A string that is generated by the API based on the given name of the activity type upon creation
		KeyString *string `json:"key_string,omitempty"`

		// Name The name of the activity type
		Name *string `json:"name,omitempty"`

		// OrderNr An order number for the activity type. Order numbers should be used to order the types in the activity type selections.
		OrderNr *int `json:"order_nr,omitempty"`

		// UpdateTime The update time of the activity type
		UpdateTime *time.Time `json:"update_time,omitempty"`
	} `json:"data,omitempty"`
	Id   *int                    `json:"id,omitempty"`
	Item *GetRecents200Data1Item `json:"item,omitempty"`
}
type GetRecents200Data1DataIconKey string
type GetRecents200Data1Item string
type GetRecents200Data2 struct {
	Data *struct {
		// Active Whether the deal is active or not
		Active *bool `json:"active,omitempty"`

		// ActivitiesCount The number of activities associated with the deal
		ActivitiesCount *int `json:"activities_count,omitempty"`

		// Acv Only available in Growth and above plans
		//
		// The Annual Contract Value of the deal
		//
		// Null if there are no products attached to the deal
		Acv *float32 `json:"acv"`

		// AcvCurrency Only available in Growth and above plans
		//
		// The Currency for Annual Contract Value of the deal
		//
		// If the `acv` is null, this will also be null
		AcvCurrency *string `json:"acv_currency"`

		// AddTime The creation date and time of the deal
		AddTime *string `json:"add_time,omitempty"`

		// Arr Only available in Growth and above plans
		//
		// The Annual Recurring Revenue of the deal
		//
		// Null if there are no products attached to the deal
		Arr *float32 `json:"arr"`

		// ArrCurrency Only available in Growth and above plans
		//
		// The Currency for Annual Recurring Revenue of the deal
		//
		// If the `arr` is null, this will also be null
		ArrCurrency *string `json:"arr_currency"`

		// CcEmail The BCC email of the deal
		CcEmail *string `json:"cc_email,omitempty"`

		// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
		Channel *int `json:"channel"`

		// ChannelId The optional ID to further distinguish the Marketing channel.
		ChannelId *string `json:"channel_id"`

		// CloseTime The date and time of closing the deal
		CloseTime *string `json:"close_time"`

		// CreatorUserId The ID of the deal creator
		CreatorUserId *int `json:"creator_user_id,omitempty"`

		// Currency The currency associated with the deal
		Currency *string `json:"currency,omitempty"`

		// Deleted Whether the deal is deleted or not
		Deleted *bool `json:"deleted,omitempty"`

		// DoneActivitiesCount The number of completed activities associated with the deal
		DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

		// EmailMessagesCount The number of emails associated with the deal
		EmailMessagesCount *int `json:"email_messages_count,omitempty"`

		// ExpectedCloseDate The expected close date of the deal
		ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

		// FilesCount The number of files associated with the deal
		FilesCount *int `json:"files_count,omitempty"`

		// FirstWonTime The date and time of the first time changing the deal status as won
		FirstWonTime *string `json:"first_won_time,omitempty"`

		// FollowersCount The number of followers associated with the deal
		FollowersCount *int `json:"followers_count,omitempty"`

		// FormattedValue The deal value formatted with selected currency. E.g. US$500
		FormattedValue *string `json:"formatted_value,omitempty"`

		// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
		FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

		// Id The ID of the deal
		Id *int `json:"id,omitempty"`

		// IsArchived Whether the deal is archived or not
		IsArchived *bool `json:"is_archived,omitempty"`

		// Label The label or multiple labels assigned to the deal
		Label *string `json:"label,omitempty"`

		// LastActivityDate The date of the last activity associated with the deal
		LastActivityDate *string `json:"last_activity_date"`

		// LastActivityId The ID of the last activity associated with the deal
		LastActivityId *int `json:"last_activity_id"`

		// LastIncomingMailTime The date and time of the last incoming email associated with the deal
		LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

		// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
		LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

		// LostReason The reason for losing the deal
		LostReason *string `json:"lost_reason"`

		// LostTime The date and time of changing the deal status as lost
		LostTime *string `json:"lost_time,omitempty"`

		// Mrr Only available in Growth and above plans
		//
		// The Monthly Recurring Revenue of the deal
		//
		// Null if there are no products attached to the deal
		Mrr *float32 `json:"mrr"`

		// MrrCurrency Only available in Growth and above plans
		//
		// The Currency for Monthly Recurring Revenue of the deal
		//
		// If the `mrr` is null, this will also be null
		MrrCurrency *string `json:"mrr_currency"`

		// NextActivityDate The date of the next activity associated with the deal
		NextActivityDate *string `json:"next_activity_date,omitempty"`

		// NextActivityDuration The duration of the next activity associated with the deal
		NextActivityDuration *string `json:"next_activity_duration,omitempty"`

		// NextActivityId The ID of the next activity associated with the deal
		NextActivityId *int `json:"next_activity_id"`

		// NextActivityNote The note of the next activity associated with the deal
		NextActivityNote *string `json:"next_activity_note,omitempty"`

		// NextActivitySubject The subject of the next activity associated with the deal
		NextActivitySubject *string `json:"next_activity_subject,omitempty"`

		// NextActivityTime The time of the next activity associated with the deal
		NextActivityTime *string `json:"next_activity_time,omitempty"`

		// NextActivityType The type of the next activity associated with the deal
		NextActivityType *string `json:"next_activity_type,omitempty"`

		// NotesCount The number of notes associated with the deal
		NotesCount *int `json:"notes_count,omitempty"`

		// OrgHidden If the organization that is associated with the deal is hidden or not
		OrgHidden *bool `json:"org_hidden,omitempty"`

		// OrgId The ID of the organization associated with the deal
		OrgId *int `json:"org_id,omitempty"`

		// OrgName The name of the organization associated with the deal
		OrgName *string `json:"org_name,omitempty"`

		// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
		Origin *string `json:"origin,omitempty"`

		// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
		OriginId *string `json:"origin_id"`

		// OwnerName The name of the deal owner
		OwnerName *string `json:"owner_name,omitempty"`

		// ParticipantsCount The number of participants associated with the deal
		ParticipantsCount *int `json:"participants_count,omitempty"`

		// PersonHidden If the person that is associated with the deal is hidden or not
		PersonHidden *bool `json:"person_hidden,omitempty"`

		// PersonId The ID of the person associated with the deal
		PersonId *int `json:"person_id,omitempty"`

		// PersonName The name of the person associated with the deal
		PersonName *string `json:"person_name,omitempty"`

		// PipelineId The ID of the pipeline associated with the deal
		PipelineId *int `json:"pipeline_id,omitempty"`

		// Probability The success probability percentage of the deal
		Probability *float32 `json:"probability"`

		// ProductsCount The number of products associated with the deal
		ProductsCount *int `json:"products_count,omitempty"`

		// RottenTime The date and time of changing the deal status as rotten
		RottenTime *string `json:"rotten_time"`

		// StageChangeTime The last updated date and time of the deal stage
		StageChangeTime *string `json:"stage_change_time,omitempty"`

		// StageId The ID of the deal stage
		StageId *int `json:"stage_id,omitempty"`

		// StageOrderNr The order number of the deal stage associated with the deal
		StageOrderNr *int `json:"stage_order_nr,omitempty"`

		// Status The status of the deal
		Status *string `json:"status,omitempty"`

		// Title The title of the deal
		Title *string `json:"title,omitempty"`

		// UndoneActivitiesCount The number of incomplete activities associated with the deal
		UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

		// UpdateTime The last updated date and time of the deal
		UpdateTime *string `json:"update_time,omitempty"`

		// UserId The ID of the user
		UserId *int `json:"user_id,omitempty"`

		// Value The value of the deal
		Value *float32 `json:"value,omitempty"`

		// VisibleTo The visibility of the deal
		VisibleTo *string `json:"visible_to,omitempty"`

		// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
		WeightedValue *float32 `json:"weighted_value,omitempty"`

		// WeightedValueCurrency The currency associated with the deal
		WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

		// WonTime The date and time of changing the deal status as won
		WonTime *string `json:"won_time,omitempty"`
	} `json:"data,omitempty"`
	Id   *int                    `json:"id,omitempty"`
	Item *GetRecents200Data2Item `json:"item,omitempty"`
}
type GetRecents200Data2Item string
type GetRecents200Data3 struct {
	// Data The file data
	Data *struct {
		// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
		ActiveFlag *bool `json:"active_flag,omitempty"`

		// ActivityId The ID of the activity to associate the file with
		ActivityId *int `json:"activity_id,omitempty"`

		// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
		AddTime *string `json:"add_time,omitempty"`

		// Cid The ID of the inline attachment
		Cid *string `json:"cid,omitempty"`

		// DealId The ID of the deal to associate the file with
		DealId *int `json:"deal_id,omitempty"`

		// DealName The name of the deal associated with the dile
		DealName *string `json:"deal_name,omitempty"`

		// Description The description of the file
		Description *string `json:"description,omitempty"`

		// FileName The original name of the file
		FileName *string `json:"file_name,omitempty"`

		// FileSize The size of the file
		FileSize *int `json:"file_size,omitempty"`

		// Id The ID of the file
		Id *int `json:"id,omitempty"`

		// InlineFlag Whether the file was uploaded as inline or not
		InlineFlag *bool `json:"inline_flag,omitempty"`

		// LeadId The ID of the lead to associate the file with
		LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

		// LeadName The name of the lead associated with the file
		LeadName *string `json:"lead_name,omitempty"`

		// MailMessageId The ID of the mail message to associate the file with
		MailMessageId *string `json:"mail_message_id,omitempty"`

		// MailTemplateId The ID of the mail template to associate the file with
		MailTemplateId *string `json:"mail_template_id,omitempty"`

		// Name The visible name of the file
		Name *string `json:"name,omitempty"`

		// OrgId The ID of the organization to associate the file with
		OrgId *int `json:"org_id,omitempty"`

		// OrgName The name of the organization associated with the file
		OrgName *string `json:"org_name,omitempty"`

		// PersonId The ID of the person to associate the file with
		PersonId *int `json:"person_id,omitempty"`

		// PersonName The name of the person associated with the file
		PersonName *string `json:"person_name,omitempty"`

		// ProductId The ID of the product to associate the file with
		ProductId *int `json:"product_id,omitempty"`

		// ProductName The name of the product associated with the file
		ProductName *string `json:"product_name,omitempty"`

		// RemoteId The ID of the remote item
		RemoteId *string `json:"remote_id,omitempty"`

		// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
		RemoteLocation *string `json:"remote_location,omitempty"`

		// S3Bucket The location of the cloud storage
		S3Bucket *string `json:"s3_bucket,omitempty"`

		// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
		UpdateTime *string `json:"update_time,omitempty"`

		// Url The URL of the download file
		Url *string `json:"url,omitempty"`

		// UserId The ID of the user to associate the file with
		UserId *int `json:"user_id,omitempty"`
	} `json:"data,omitempty"`
	Id   *int                    `json:"id,omitempty"`
	Item *GetRecents200Data3Item `json:"item,omitempty"`
}
type GetRecents200Data3Item string
type GetRecents200Data4 struct {
	// Data The filter object
	Data *struct {
		// ActiveFlag The active flag of the filter
		ActiveFlag *bool `json:"active_flag,omitempty"`

		// AddTime The date and time when the filter was added
		AddTime *string `json:"add_time,omitempty"`

		// CustomViewId Used by Pipedrive webapp
		CustomViewId *int `json:"custom_view_id,omitempty"`

		// Id The ID of the filter
		Id *int `json:"id,omitempty"`

		// Name The name of the filter
		Name *string `json:"name,omitempty"`

		// Type The type of the item
		Type *string `json:"type,omitempty"`

		// UpdateTime The date and time when the filter was updated
		UpdateTime *string `json:"update_time,omitempty"`

		// UserId The owner of the filter
		UserId *int `json:"user_id,omitempty"`

		// VisibleTo The visibility group ID of who can see then filter
		VisibleTo *int `json:"visible_to,omitempty"`
	} `json:"data,omitempty"`
	Id   *int                    `json:"id,omitempty"`
	Item *GetRecents200Data4Item `json:"item,omitempty"`
}
type GetRecents200Data4Item string
type GetRecents200Data5 struct {
	Data *struct {
		// ActiveFlag Whether the note is active or deleted
		ActiveFlag *bool `json:"active_flag,omitempty"`

		// AddTime The creation date and time of the note
		AddTime *string `json:"add_time,omitempty"`

		// Content The content of the note in HTML format. Subject to sanitization on the back-end.
		Content *string `json:"content,omitempty"`

		// Deal The deal this note is attached to
		Deal *struct {
			// Title The title of the deal this note is attached to
			Title *string `json:"title,omitempty"`
		} `json:"deal,omitempty"`

		// DealId The ID of the deal the note is attached to
		DealId *int `json:"deal_id,omitempty"`

		// Id The ID of the note
		Id *int `json:"id,omitempty"`

		// LastUpdateUserId The ID of the user who last updated the note
		LastUpdateUserId *int `json:"last_update_user_id,omitempty"`

		// LeadId The ID of the lead the note is attached to
		LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

		// OrgId The ID of the organization the note is attached to
		OrgId *int `json:"org_id,omitempty"`

		// Organization The organization the note is attached to
		Organization *struct {
			// Name The name of the organization the note is attached to
			Name *string `json:"name,omitempty"`
		} `json:"organization,omitempty"`

		// Person The person the note is attached to
		Person *struct {
			// Name The name of the person the note is attached to
			Name *string `json:"name,omitempty"`
		} `json:"person,omitempty"`

		// PersonId The ID of the person the note is attached to
		PersonId *int `json:"person_id,omitempty"`

		// PinnedToDealFlag If true, the results are filtered by note to deal pinning state
		PinnedToDealFlag *bool `json:"pinned_to_deal_flag,omitempty"`

		// PinnedToOrganizationFlag If true, the results are filtered by note to organization pinning state
		PinnedToOrganizationFlag *bool `json:"pinned_to_organization_flag,omitempty"`

		// PinnedToPersonFlag If true, the results are filtered by note to person pinning state
		PinnedToPersonFlag *bool `json:"pinned_to_person_flag,omitempty"`

		// PinnedToProjectFlag If true, the results are filtered by note to project pinning state
		PinnedToProjectFlag *bool `json:"pinned_to_project_flag,omitempty"`

		// Project The project the note is attached to
		Project *struct {
			// Title The title of the project the note is attached to
			Title *string `json:"title,omitempty"`
		} `json:"project,omitempty"`

		// ProjectId The ID of the project the note is attached to
		ProjectId *int `json:"project_id,omitempty"`

		// UpdateTime The last updated date and time of the note
		UpdateTime *string `json:"update_time,omitempty"`

		// User The user who created the note
		User *struct {
			// Email The email of the note creator
			Email *string `json:"email,omitempty"`

			// IconUrl The URL of the note creator avatar picture
			IconUrl *string `json:"icon_url,omitempty"`

			// IsYou Whether the note is created by you or not
			IsYou *bool `json:"is_you,omitempty"`

			// Name The name of the note creator
			Name *string `json:"name,omitempty"`
		} `json:"user,omitempty"`

		// UserId The ID of the note creator
		UserId *int `json:"user_id,omitempty"`
	} `json:"data,omitempty"`
	Id   *int                    `json:"id,omitempty"`
	Item *GetRecents200Data5Item `json:"item,omitempty"`
}
type GetRecents200Data5Item string
type GetRecents200Data6 struct {
	Data *struct {
		// ActiveFlag Whether the person is active or not
		ActiveFlag *bool `json:"active_flag,omitempty"`

		// ActivitiesCount The count of activities related to the person
		ActivitiesCount *int `json:"activities_count,omitempty"`

		// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
		AddTime *string `json:"add_time,omitempty"`

		// CcEmail The BCC email associated with the person
		CcEmail *string `json:"cc_email,omitempty"`

		// ClosedDealsCount The count of closed deals related with the item
		ClosedDealsCount *int `json:"closed_deals_count,omitempty"`

		// CompanyId The ID of the company related to the person
		CompanyId *int `json:"company_id,omitempty"`

		// DoneActivitiesCount The count of done activities related to the person
		DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

		// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" } ]`. Please note that only `value` is required.
		Email *[]struct {
			// Label The label that indicates the type of the email. (Possible values - work, home or other)
			Label *string `json:"label,omitempty"`

			// Primary Boolean that indicates if email is primary for the person or not
			Primary *bool `json:"primary,omitempty"`

			// Value Email
			Value *string `json:"value,omitempty"`
		} `json:"email,omitempty"`

		// EmailMessagesCount The count of email messages related to the person
		EmailMessagesCount *int `json:"email_messages_count,omitempty"`

		// FilesCount The count of files related to the person
		FilesCount *int `json:"files_count,omitempty"`

		// FirstChar The first letter of the name of the person
		FirstChar *string `json:"first_char,omitempty"`

		// FirstName The first name of the person
		FirstName *string `json:"first_name,omitempty"`

		// FollowersCount The count of followers related to the person
		FollowersCount *int `json:"followers_count,omitempty"`

		// Id The ID of the person
		Id *int `json:"id,omitempty"`

		// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
		Label *int `json:"label,omitempty"`

		// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
		LabelIds *[]int `json:"label_ids,omitempty"`

		// LastActivityDate The date of the last activity associated with the deal
		LastActivityDate *string `json:"last_activity_date"`

		// LastActivityId The ID of the last activity associated with the deal
		LastActivityId *int `json:"last_activity_id"`

		// LastIncomingMailTime The date and time of the last incoming email associated with the person
		LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

		// LastName The last name of the person
		LastName *string `json:"last_name,omitempty"`

		// LastOutgoingMailTime The date and time of the last outgoing email associated with the person
		LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

		// LostDealsCount The count of lost deals related with the item
		LostDealsCount *int `json:"lost_deals_count,omitempty"`

		// MergeWhatId The ID of the person with what the main person was merged
		MergeWhatId *int `json:"merge_what_id,omitempty"`

		// Name The name of the person
		Name *string `json:"name,omitempty"`

		// NextActivityDate The date of the next activity associated with the deal
		NextActivityDate *string `json:"next_activity_date"`

		// NextActivityId The ID of the next activity associated with the deal
		NextActivityId *int `json:"next_activity_id"`

		// NextActivityTime The time of the next activity associated with the deal
		NextActivityTime *string `json:"next_activity_time"`

		// NotesCount The count of notes related to the person
		NotesCount *int `json:"notes_count,omitempty"`

		// OpenDealsCount The count of open deals related with the item
		OpenDealsCount *int `json:"open_deals_count,omitempty"`

		// OrgId The ID of the organization related to the person
		OrgId *int `json:"org_id,omitempty"`

		// OrgName The name of the organization associated with the person
		OrgName *string `json:"org_name,omitempty"`

		// OwnerId The ID of the owner related to the person
		OwnerId *int `json:"owner_id,omitempty"`

		// OwnerName The name of the owner associated with the person
		OwnerName *string `json:"owner_name,omitempty"`

		// ParticipantClosedDealsCount The count of closed participant deals related with the item
		ParticipantClosedDealsCount *int `json:"participant_closed_deals_count,omitempty"`

		// ParticipantOpenDealsCount The count of open participant deals related with the item
		ParticipantOpenDealsCount *int `json:"participant_open_deals_count,omitempty"`

		// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
		Phone *[]struct {
			// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
			Label *string `json:"label,omitempty"`

			// Primary Boolean that indicates if phone number is primary for the person or not
			Primary *bool `json:"primary,omitempty"`

			// Value The phone number
			Value *string `json:"value,omitempty"`
		} `json:"phone,omitempty"`
		PictureId *struct {
			// ActiveFlag Whether the associated picture is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The add time of the picture
			AddTime *string `json:"add_time,omitempty"`

			// AddedByUserId The ID of the user who added the picture
			AddedByUserId *int `json:"added_by_user_id,omitempty"`

			// Id The ID of the picture associated with the item
			Id *int `json:"id,omitempty"`

			// ItemId The ID of related item
			ItemId *int `json:"item_id,omitempty"`

			// ItemType The type of item the picture is related to
			ItemType *string `json:"item_type,omitempty"`
			Pictures *struct {
				// N128 The URL of the 128*128 picture
				N128 *string `json:"128,omitempty"`

				// N512 The URL of the 512*512 picture
				N512 *string `json:"512,omitempty"`
			} `json:"pictures,omitempty"`

			// UpdateTime The update time of the picture
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"picture_id,omitempty"`

		// RelatedClosedDealsCount The count of related closed deals related with the item
		RelatedClosedDealsCount *int `json:"related_closed_deals_count,omitempty"`

		// RelatedLostDealsCount The count of related lost deals related with the item
		RelatedLostDealsCount *int `json:"related_lost_deals_count,omitempty"`

		// RelatedOpenDealsCount The count of related open deals related with the item
		RelatedOpenDealsCount *int `json:"related_open_deals_count,omitempty"`

		// RelatedWonDealsCount The count of related won deals related with the item
		RelatedWonDealsCount *int `json:"related_won_deals_count,omitempty"`

		// UndoneActivitiesCount The count of undone activities related to the person
		UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

		// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
		UpdateTime *string `json:"update_time,omitempty"`

		// VisibleTo The visibility group ID of who can see the person
		VisibleTo *string `json:"visible_to,omitempty"`

		// WonDealsCount The count of won deals related with the item
		WonDealsCount *int `json:"won_deals_count,omitempty"`
	} `json:"data,omitempty"`
	Id   *int                    `json:"id,omitempty"`
	Item *GetRecents200Data6Item `json:"item,omitempty"`
}
type GetRecents200Data6Item string
type GetRecents200Data7 struct {
	Data *struct {
		// ActiveFlag Whether the organization is active or not
		ActiveFlag *bool `json:"active_flag,omitempty"`

		// ActivitiesCount The count of activities related to the organization
		ActivitiesCount *int `json:"activities_count,omitempty"`

		// AddTime The creation date and time of the organization
		AddTime *string `json:"add_time,omitempty"`

		// Address The full address of the organization
		Address *string `json:"address,omitempty"`

		// AddressAdminAreaLevel1 The level 1 admin area of the organization location
		AddressAdminAreaLevel1 *string `json:"address_admin_area_level_1,omitempty"`

		// AddressAdminAreaLevel2 The level 2 admin area of the organization location
		AddressAdminAreaLevel2 *string `json:"address_admin_area_level_2,omitempty"`

		// AddressCountry The country of the organization location
		AddressCountry *string `json:"address_country,omitempty"`

		// AddressFormattedAddress The formatted organization location
		AddressFormattedAddress *string `json:"address_formatted_address,omitempty"`

		// AddressLocality The locality of the organization location
		AddressLocality *string `json:"address_locality,omitempty"`

		// AddressPostalCode The postal code of the organization location
		AddressPostalCode *string `json:"address_postal_code,omitempty"`

		// AddressRoute The route of the organization location
		AddressRoute *string `json:"address_route,omitempty"`

		// AddressStreetNumber The street number of the organization location
		AddressStreetNumber *string `json:"address_street_number,omitempty"`

		// AddressSublocality The sub-locality of the organization location
		AddressSublocality *string `json:"address_sublocality,omitempty"`

		// AddressSubpremise The sub-premise of the organization location
		AddressSubpremise *string `json:"address_subpremise,omitempty"`

		// CcEmail The BCC email associated with the organization
		CcEmail *string `json:"cc_email,omitempty"`

		// ClosedDealsCount The count of closed deals related with the item
		ClosedDealsCount *int `json:"closed_deals_count,omitempty"`

		// CompanyId The ID of the company related to the organization
		CompanyId *int `json:"company_id,omitempty"`

		// CountryCode The country code of the organization
		CountryCode *string `json:"country_code"`

		// DoneActivitiesCount The count of done activities related to the organization
		DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

		// EmailMessagesCount The count of email messages related to the organization
		EmailMessagesCount *int `json:"email_messages_count,omitempty"`

		// FilesCount The count of files related to the organization
		FilesCount *int `json:"files_count,omitempty"`

		// FirstChar The first character of the organization name
		FirstChar *string `json:"first_char,omitempty"`

		// FollowersCount The count of followers related to the organization
		FollowersCount *int `json:"followers_count,omitempty"`

		// Id The ID of the organization
		Id *int `json:"id,omitempty"`

		// Label The label assigned to the organization. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
		Label *int `json:"label,omitempty"`

		// LabelIds The IDs of labels assigned to the organization. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
		LabelIds *[]int `json:"label_ids,omitempty"`

		// LastActivityDate The date of the last activity associated with the deal
		LastActivityDate *string `json:"last_activity_date"`

		// LastActivityId The ID of the last activity associated with the deal
		LastActivityId *int `json:"last_activity_id"`

		// LostDealsCount The count of lost deals related with the item
		LostDealsCount *int `json:"lost_deals_count,omitempty"`

		// Name The name of the organization
		Name *string `json:"name,omitempty"`

		// NextActivityDate The date of the next activity associated with the deal
		NextActivityDate *string `json:"next_activity_date"`

		// NextActivityId The ID of the next activity associated with the deal
		NextActivityId *int `json:"next_activity_id"`

		// NextActivityTime The time of the next activity associated with the deal
		NextActivityTime *string `json:"next_activity_time"`

		// NotesCount The count of notes related to the organization
		NotesCount *int `json:"notes_count,omitempty"`

		// OpenDealsCount The count of open deals related with the item
		OpenDealsCount *int `json:"open_deals_count,omitempty"`
		OwnerId        *struct {
			// ActiveFlag Whether the user is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// Email The email of the user
			Email *string `json:"email,omitempty"`

			// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
			HasPic *int `json:"has_pic,omitempty"`

			// Id The ID of the user
			Id *int `json:"id,omitempty"`

			// Name The name of the user
			Name *string `json:"name,omitempty"`

			// PicHash The user picture hash
			PicHash *string `json:"pic_hash"`

			// Value The ID of the owner
			Value *int `json:"value,omitempty"`
		} `json:"owner_id,omitempty"`

		// OwnerName The name of the organization owner
		OwnerName *string `json:"owner_name,omitempty"`

		// PeopleCount The count of persons related to the organization
		PeopleCount *int `json:"people_count,omitempty"`
		PictureId   *struct {
			// ActiveFlag Whether the associated picture is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddTime The add time of the picture
			AddTime *string `json:"add_time,omitempty"`

			// AddedByUserId The ID of the user who added the picture
			AddedByUserId *int `json:"added_by_user_id,omitempty"`

			// ItemId The ID of related item
			ItemId *int `json:"item_id,omitempty"`

			// ItemType The type of item the picture is related to
			ItemType *string `json:"item_type,omitempty"`
			Pictures *struct {
				// N128 The URL of the 128*128 picture
				N128 *string `json:"128,omitempty"`

				// N512 The URL of the 512*512 picture
				N512 *string `json:"512,omitempty"`
			} `json:"pictures,omitempty"`

			// UpdateTime The update time of the picture
			UpdateTime *string `json:"update_time,omitempty"`

			// Value The ID of the picture associated with the item
			Value *int `json:"value,omitempty"`
		} `json:"picture_id,omitempty"`

		// RelatedClosedDealsCount The count of related closed deals related with the item
		RelatedClosedDealsCount *int `json:"related_closed_deals_count,omitempty"`

		// RelatedLostDealsCount The count of related lost deals related with the item
		RelatedLostDealsCount *int `json:"related_lost_deals_count,omitempty"`

		// RelatedOpenDealsCount The count of related open deals related with the item
		RelatedOpenDealsCount *int `json:"related_open_deals_count,omitempty"`

		// RelatedWonDealsCount The count of related won deals related with the item
		RelatedWonDealsCount *int `json:"related_won_deals_count,omitempty"`

		// UndoneActivitiesCount The count of undone activities related to the organization
		UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

		// UpdateTime The last updated date and time of the organization
		UpdateTime *string `json:"update_time,omitempty"`

		// VisibleTo The visibility group ID of who can see the organization
		VisibleTo *string `json:"visible_to,omitempty"`

		// WonDealsCount The count of won deals related with the item
		WonDealsCount *int `json:"won_deals_count,omitempty"`
	} `json:"data,omitempty"`
	Id   *int                    `json:"id,omitempty"`
	Item *GetRecents200Data7Item `json:"item,omitempty"`
}
type GetRecents200Data7Item string
type GetRecents200Data8 struct {
	Data *struct {
		// Active Whether this pipeline will be made inactive (hidden) or active
		Active *bool `json:"active,omitempty"`

		// AddTime The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
		AddTime *string `json:"add_time,omitempty"`

		// DealProbability Whether deal probability is disabled or enabled for this pipeline
		DealProbability *bool `json:"deal_probability,omitempty"`

		// Id The ID of the pipeline
		Id *int `json:"id,omitempty"`

		// Name The name of the pipeline
		Name *string `json:"name,omitempty"`

		// OrderNr Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
		OrderNr *int `json:"order_nr,omitempty"`

		// UpdateTime The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
		UpdateTime *string `json:"update_time,omitempty"`

		// UrlTitle The pipeline title displayed in the URL
		UrlTitle *string `json:"url_title,omitempty"`
	} `json:"data,omitempty"`
	Id   *int                    `json:"id,omitempty"`
	Item *GetRecents200Data8Item `json:"item,omitempty"`
}
type GetRecents200Data8Item string
type GetRecents200Data9 struct {
	Data *struct {
		// ActiveFlag Whether this product will be made active or not
		ActiveFlag *bool `json:"active_flag,omitempty"`

		// AddTime The date and time when the product was added to the deal
		AddTime *string `json:"add_time,omitempty"`

		// Category The category of the product
		Category *string `json:"category,omitempty"`

		// Code The product code
		Code *string `json:"code,omitempty"`

		// Description The description of the product
		Description *string `json:"description,omitempty"`

		// FilesCount The count of files
		FilesCount *int `json:"files_count,omitempty"`

		// FirstChar The first letter of the product name
		FirstChar *string `json:"first_char,omitempty"`

		// Id The ID of the product
		Id *int `json:"id,omitempty"`

		// Name The name of the product
		Name *string `json:"name,omitempty"`

		// OwnerId The ID of the user who will be marked as the owner of this product. When omitted, authorized user ID will be used.
		OwnerId *int `json:"owner_id,omitempty"`

		// Prices Array of objects, each containing: `currency` (string), `price` (number), `cost` (number, optional), `overhead_cost` (number, optional). Note that there can only be one price per product per currency. When `prices` is omitted altogether, a default price of 0 and a default currency based on the company's currency will be assigned.
		Prices *[]map[string]interface{} `json:"prices,omitempty"`

		// Selectable Whether this product can be selected in deals or not
		Selectable *bool `json:"selectable,omitempty"`

		// Tax The tax percentage
		Tax *float32 `json:"tax,omitempty"`

		// Unit The unit in which this product is sold
		Unit *string `json:"unit,omitempty"`

		// UpdateTime The date and time when the product was updated to the deal
		UpdateTime *string `json:"update_time,omitempty"`

		// VisibleTo The visibility of the product. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.
		VisibleTo *int `json:"visible_to,omitempty"`
	} `json:"data,omitempty"`
	Id   *int                    `json:"id,omitempty"`
	Item *GetRecents200Data9Item `json:"item,omitempty"`
}
type GetRecents200Data9Item string
type GetRecents200Data10 struct {
	Data *struct {
		// ActiveFlag Whether the stage is active or deleted
		ActiveFlag *bool `json:"active_flag,omitempty"`

		// AddTime The stage creation time. Format: YYYY-MM-DD HH:MM:SS.
		AddTime *string `json:"add_time,omitempty"`

		// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
		DealProbability *int `json:"deal_probability,omitempty"`

		// Id The ID of the stage
		Id *int `json:"id,omitempty"`

		// Name The name of the stage
		Name *string `json:"name,omitempty"`

		// OrderNr Defines the order of the stage
		OrderNr *int `json:"order_nr,omitempty"`

		// PipelineId The ID of the pipeline to add the stage to
		PipelineId *int `json:"pipeline_id,omitempty"`

		// RottenDays The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
		RottenDays *int `json:"rotten_days,omitempty"`

		// RottenFlag Whether deals in this stage can become rotten
		RottenFlag *bool `json:"rotten_flag,omitempty"`

		// UpdateTime The stage update time. Format: YYYY-MM-DD HH:MM:SS.
		UpdateTime *string `json:"update_time,omitempty"`
	} `json:"data,omitempty"`
	Id   *int                     `json:"id,omitempty"`
	Item *GetRecents200Data10Item `json:"item,omitempty"`
}
type GetRecents200Data10Item string
type GetRecents200Data11 struct {
	Data *struct {
		Access *[]struct {
			Admin           *bool                             `json:"admin,omitempty"`
			App             *GetRecents200Data11DataAccessApp `json:"app,omitempty"`
			PermissionSetId *string                           `json:"permission_set_id,omitempty"`
		} `json:"access,omitempty"`

		// Activated Boolean that indicates whether the user is activated
		Activated *bool `json:"activated,omitempty"`

		// ActiveFlag Boolean that indicates whether the user is activated
		ActiveFlag *bool `json:"active_flag,omitempty"`

		// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
		Created *string `json:"created,omitempty"`

		// DefaultCurrency The user default currency
		DefaultCurrency *string `json:"default_currency,omitempty"`

		// Email The user email
		Email *string `json:"email,omitempty"`

		// HasCreatedCompany Boolean that indicates whether the user has created a company
		HasCreatedCompany *bool `json:"has_created_company,omitempty"`

		// IconUrl The user icon URL
		IconUrl *string `json:"icon_url"`

		// Id The user ID
		Id *int `json:"id,omitempty"`

		// IsDeleted Boolean that indicates whether the user is deleted from the company
		IsDeleted *bool `json:"is_deleted,omitempty"`

		// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
		IsYou *bool `json:"is_you,omitempty"`

		// Lang The user language ID
		Lang *int `json:"lang,omitempty"`

		// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
		LastLogin *string `json:"last_login,omitempty"`

		// Locale The user locale
		Locale *string `json:"locale,omitempty"`

		// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
		Modified *string `json:"modified"`

		// Name The user name
		Name *string `json:"name,omitempty"`

		// Phone The user phone
		Phone *string `json:"phone"`

		// RoleId The ID of the user role
		RoleId *int `json:"role_id,omitempty"`

		// TimezoneName The user timezone name
		TimezoneName *string `json:"timezone_name,omitempty"`

		// TimezoneOffset The user timezone offset
		TimezoneOffset *string `json:"timezone_offset,omitempty"`
	} `json:"data,omitempty"`
	Id   *int                     `json:"id,omitempty"`
	Item *GetRecents200Data11Item `json:"item,omitempty"`
}
type GetRecents200Data11DataAccessApp string
type GetRecents200Data11Item string
type GetRecents_200_Data_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetRecentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data in the role list
		AdditionalData *struct {
			// Pagination The pagination details in the role list
			Pagination *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection Whether there are more list items in the collection than displayed
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"pagination,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of roles
		Data *[]struct {
			// ActiveFlag Whether the role is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AssignmentCount The number of users assigned to this role
			AssignmentCount *string `json:"assignment_count,omitempty"`

			// Id The ID of the role
			Id *int `json:"id,omitempty"`

			// Level The level of role in the role hierarchy
			Level *int `json:"level,omitempty"`

			// Name The name of the role
			Name *string `json:"name,omitempty"`

			// ParentRoleId The ID of the parent role
			ParentRoleId *int `json:"parent_role_id"`

			// SubRoleCount The number of sub-roles
			SubRoleCount *string `json:"sub_role_count,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The response data
		Data *struct {
			// Id The ID of the created role
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The response data
		Data *struct {
			// Id The ID of the deleted role
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data in the role
		AdditionalData *struct {
			// Settings The settings for the role
			Settings *struct {
				// DealAccessLevel The access level of the deals for the role (only for default role)
				DealAccessLevel *float32 `json:"deal_access_level,omitempty"`

				// DealDefaultVisibility The default visibility level of the deals for the role
				DealDefaultVisibility *float32 `json:"deal_default_visibility,omitempty"`

				// LeadDefaultVisibility The default visibility level of the leads for the role
				LeadDefaultVisibility *float32 `json:"lead_default_visibility,omitempty"`

				// OrgAccessLevel The access level of the organizations for the role (only for default role)
				OrgAccessLevel *float32 `json:"org_access_level,omitempty"`

				// OrgDefaultVisibility The default visibility level of the organizations for the role
				OrgDefaultVisibility *float32 `json:"org_default_visibility,omitempty"`

				// PersonAccessLevel The access level of the people for the role (only for default role)
				PersonAccessLevel *float32 `json:"person_access_level,omitempty"`

				// PersonDefaultVisibility The default visibility level of the people for the role
				PersonDefaultVisibility *float32 `json:"person_default_visibility,omitempty"`

				// ProductAccessLevel The access level of the products for the role (only for default role)
				ProductAccessLevel *float32 `json:"product_access_level,omitempty"`

				// ProductDefaultVisibility The default visibility level of the products for the role
				ProductDefaultVisibility *float32 `json:"product_default_visibility,omitempty"`
			} `json:"settings,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The details of the sub-role
		Data *struct {
			// ActiveFlag Whether the role is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AssignmentCount The number of users assigned to this role
			AssignmentCount *string `json:"assignment_count,omitempty"`

			// Id The ID of the role
			Id *int `json:"id,omitempty"`

			// Name The name of the role
			Name *string `json:"name,omitempty"`

			// ParentRoleId The ID of the parent role
			ParentRoleId *int `json:"parent_role_id"`

			// SubRoleCount The number of sub-roles
			SubRoleCount *string `json:"sub_role_count,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The response data
		Data *struct {
			// Id The ID of the updated role
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The response data
		Data *struct {
			// Id The ID of the role the user was removed from
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRoleAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleAssignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data in the role list
		AdditionalData *struct {
			// Pagination The pagination details in the role list
			Pagination *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection Whether there are more list items in the collection than displayed
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"pagination,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The role assignments
		Data *[]struct {
			// ActiveFlag Whether the role is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// Name The name of the role
			Name *string `json:"name,omitempty"`

			// ParentRoleId The ID of the parent role
			ParentRoleId *int `json:"parent_role_id"`

			// RoleId The role ID
			RoleId *int `json:"role_id,omitempty"`

			// Type The assignment type
			Type *string `json:"type,omitempty"`

			// UserId The user ID
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRoleAssignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleAssignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRoleAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The response data
		Data *struct {
			// RoleId The ID of the role the user was added to
			RoleId *int `json:"role_id,omitempty"`

			// UserId The ID of the user that was added to the role
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddRoleAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRoleAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolePipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The response data
		Data *struct {
			// PipelineIds Either visible or hidden pipeline ids
			PipelineIds *[]float32 `json:"pipeline_ids,omitempty"`

			// Visible Whether visible or hidden pipeline ids were returned
			Visible *bool `json:"visible,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRolePipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolePipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRolePipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The response data
		Data *struct {
			// PipelineIds Either visible or hidden pipeline ids
			PipelineIds *[]float32 `json:"pipeline_ids,omitempty"`

			// Visible Whether visible or hidden pipeline ids were returned
			Visible *bool `json:"visible,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateRolePipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRolePipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The settings for the role
		Data *struct {
			// DealAccessLevel The access level of the deals for the role (only for default role)
			DealAccessLevel *float32 `json:"deal_access_level,omitempty"`

			// DealDefaultVisibility The default visibility level of the deals for the role
			DealDefaultVisibility *float32 `json:"deal_default_visibility,omitempty"`

			// LeadDefaultVisibility The default visibility level of the leads for the role
			LeadDefaultVisibility *float32 `json:"lead_default_visibility,omitempty"`

			// OrgAccessLevel The access level of the organizations for the role (only for default role)
			OrgAccessLevel *float32 `json:"org_access_level,omitempty"`

			// OrgDefaultVisibility The default visibility level of the organizations for the role
			OrgDefaultVisibility *float32 `json:"org_default_visibility,omitempty"`

			// PersonAccessLevel The access level of the people for the role (only for default role)
			PersonAccessLevel *float32 `json:"person_access_level,omitempty"`

			// PersonDefaultVisibility The default visibility level of the people for the role
			PersonDefaultVisibility *float32 `json:"person_default_visibility,omitempty"`

			// ProductAccessLevel The access level of the products for the role (only for default role)
			ProductAccessLevel *float32 `json:"product_access_level,omitempty"`

			// ProductDefaultVisibility The default visibility level of the products for the role
			ProductDefaultVisibility *float32 `json:"product_default_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRoleSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrUpdateRoleSettingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The response data
		Data *struct {
			// DealDefaultVisibility The setting
			DealDefaultVisibility *AddOrUpdateRoleSetting200DataDealDefaultVisibility `json:"deal_default_visibility,omitempty"`

			// Id The ID of the role
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type AddOrUpdateRoleSetting200DataDealDefaultVisibility float32

// Status returns HTTPResponse.Status
func (r AddOrUpdateRoleSettingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrUpdateRoleSettingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The list of deleted stage IDs
			Id *[]int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteStagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStageDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// Limit Items shown per page
			Limit *int `json:"limit,omitempty"`

			// MoreItemsInCollection If there are more list items in the collection than displayed or not
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

			// Start Pagination start
			Start *int `json:"start,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of deals
		Data *[]struct {
			// Active Whether the deal is active or not
			Active *bool `json:"active,omitempty"`

			// ActivitiesCount The number of activities associated with the deal
			ActivitiesCount *int `json:"activities_count,omitempty"`

			// Acv Only available in Growth and above plans
			//
			// The Annual Contract Value of the deal
			//
			// Null if there are no products attached to the deal
			Acv *float32 `json:"acv"`

			// AcvCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Contract Value of the deal
			//
			// If the `acv` is null, this will also be null
			AcvCurrency *string `json:"acv_currency"`

			// AddTime The creation date and time of the deal
			AddTime *string `json:"add_time,omitempty"`

			// Arr Only available in Growth and above plans
			//
			// The Annual Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Arr *float32 `json:"arr"`

			// ArrCurrency Only available in Growth and above plans
			//
			// The Currency for Annual Recurring Revenue of the deal
			//
			// If the `arr` is null, this will also be null
			ArrCurrency *string `json:"arr_currency"`

			// CcEmail The BCC email of the deal
			CcEmail *string `json:"cc_email,omitempty"`

			// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CloseTime The date and time of closing the deal
			CloseTime *string `json:"close_time"`

			// CreatorUserId The ID of the deal creator
			CreatorUserId *int `json:"creator_user_id,omitempty"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// Deleted Whether the deal is deleted or not
			Deleted *bool `json:"deleted,omitempty"`

			// DoneActivitiesCount The number of completed activities associated with the deal
			DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

			// EmailMessagesCount The number of emails associated with the deal
			EmailMessagesCount *int `json:"email_messages_count,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// FilesCount The number of files associated with the deal
			FilesCount *int `json:"files_count,omitempty"`

			// FirstWonTime The date and time of the first time changing the deal status as won
			FirstWonTime *string `json:"first_won_time,omitempty"`

			// FollowersCount The number of followers associated with the deal
			FollowersCount *int `json:"followers_count,omitempty"`

			// FormattedValue The deal value formatted with selected currency. E.g. US$500
			FormattedValue *string `json:"formatted_value,omitempty"`

			// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
			FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// IsArchived Whether the deal is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// Label The label or multiple labels assigned to the deal
			Label *string `json:"label,omitempty"`

			// LastActivityDate The date of the last activity associated with the deal
			LastActivityDate *string `json:"last_activity_date"`

			// LastActivityId The ID of the last activity associated with the deal
			LastActivityId *int `json:"last_activity_id"`

			// LastIncomingMailTime The date and time of the last incoming email associated with the deal
			LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

			// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
			LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status as lost
			LostTime *string `json:"lost_time,omitempty"`

			// Mrr Only available in Growth and above plans
			//
			// The Monthly Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Mrr *float32 `json:"mrr"`

			// MrrCurrency Only available in Growth and above plans
			//
			// The Currency for Monthly Recurring Revenue of the deal
			//
			// If the `mrr` is null, this will also be null
			MrrCurrency *string `json:"mrr_currency"`

			// NextActivityDate The date of the next activity associated with the deal
			NextActivityDate *string `json:"next_activity_date,omitempty"`

			// NextActivityDuration The duration of the next activity associated with the deal
			NextActivityDuration *string `json:"next_activity_duration,omitempty"`

			// NextActivityId The ID of the next activity associated with the deal
			NextActivityId *int `json:"next_activity_id"`

			// NextActivityNote The note of the next activity associated with the deal
			NextActivityNote *string `json:"next_activity_note,omitempty"`

			// NextActivitySubject The subject of the next activity associated with the deal
			NextActivitySubject *string `json:"next_activity_subject,omitempty"`

			// NextActivityTime The time of the next activity associated with the deal
			NextActivityTime *string `json:"next_activity_time,omitempty"`

			// NextActivityType The type of the next activity associated with the deal
			NextActivityType *string `json:"next_activity_type,omitempty"`

			// NotesCount The number of notes associated with the deal
			NotesCount *int `json:"notes_count,omitempty"`

			// OrgHidden If the organization that is associated with the deal is hidden or not
			OrgHidden *bool `json:"org_hidden,omitempty"`

			// OrgId The ID of the organization associated with the deal
			OrgId *int `json:"org_id,omitempty"`

			// OrgName The name of the organization associated with the deal
			OrgName *string `json:"org_name,omitempty"`

			// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
			OriginId *string `json:"origin_id"`

			// OwnerName The name of the deal owner
			OwnerName *string `json:"owner_name,omitempty"`

			// ParticipantsCount The number of participants associated with the deal
			ParticipantsCount *int `json:"participants_count,omitempty"`

			// PersonHidden If the person that is associated with the deal is hidden or not
			PersonHidden *bool `json:"person_hidden,omitempty"`

			// PersonId The ID of the person associated with the deal
			PersonId *int `json:"person_id,omitempty"`

			// PersonName The name of the person associated with the deal
			PersonName *string `json:"person_name,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// ProductsCount The number of products associated with the deal
			ProductsCount *int `json:"products_count,omitempty"`

			// RottenTime The date and time of changing the deal status as rotten
			RottenTime *string `json:"rotten_time"`

			// StageChangeTime The last updated date and time of the deal stage
			StageChangeTime *string `json:"stage_change_time,omitempty"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// StageOrderNr The order number of the deal stage associated with the deal
			StageOrderNr *int `json:"stage_order_nr,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UndoneActivitiesCount The number of incomplete activities associated with the deal
			UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

			// UpdateTime The last updated date and time of the deal
			UpdateTime *string `json:"update_time,omitempty"`

			// UserId The ID of the user
			UserId *int `json:"user_id,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *string `json:"visible_to,omitempty"`

			// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
			WeightedValue *float32 `json:"weighted_value,omitempty"`

			// WeightedValueCurrency The currency associated with the deal
			WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

			// WonTime The date and time of changing the deal status as won
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the request was successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStageDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStageDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// AddTime The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// AssigneeId The ID of the user who will be the assignee of the task
			AssigneeId *float32 `json:"assignee_id,omitempty"`

			// CreatorId The creator of a task
			CreatorId *float32 `json:"creator_id,omitempty"`

			// Description The description of the task
			Description *string `json:"description,omitempty"`

			// Done Whether the task is done or not. 0 = Not done, 1 = Done.
			Done *GetTasks200DataDone `json:"done,omitempty"`

			// DueDate The due date of the task. Format: YYYY-MM-DD.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// Id The ID of the task, generated when the task was created
			Id *int `json:"id,omitempty"`

			// MarkedAsDoneTime The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// ParentTaskId The ID of a parent task. Can not be ID of a task which is already a subtask.
			ParentTaskId *float32 `json:"parent_task_id,omitempty"`

			// ProjectId The ID of the project this task is associated with
			ProjectId *float32 `json:"project_id,omitempty"`

			// Title The title of the task
			Title *string `json:"title,omitempty"`

			// UpdateTime The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}
type GetTasks200DataDone float32

// Status returns HTTPResponse.Status
func (r GetTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			// AddTime The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// AssigneeId The ID of the user who will be the assignee of the task
			AssigneeId *float32 `json:"assignee_id,omitempty"`

			// CreatorId The creator of a task
			CreatorId *float32 `json:"creator_id,omitempty"`

			// Description The description of the task
			Description *string `json:"description,omitempty"`

			// Done Whether the task is done or not. 0 = Not done, 1 = Done.
			Done *AddTask201DataDone `json:"done,omitempty"`

			// DueDate The due date of the task. Format: YYYY-MM-DD.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// Id The ID of the task, generated when the task was created
			Id *int `json:"id,omitempty"`

			// MarkedAsDoneTime The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// ParentTaskId The ID of a parent task. Can not be ID of a task which is already a subtask.
			ParentTaskId *float32 `json:"parent_task_id,omitempty"`

			// ProjectId The ID of the project this task is associated with
			ProjectId *float32 `json:"project_id,omitempty"`

			// Title The title of the task
			Title *string `json:"title,omitempty"`

			// UpdateTime The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}
type AddTask201DataDone float32

// Status returns HTTPResponse.Status
func (r AddTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			Data *struct {
				// Id The ID of the task that was deleted
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			// AddTime The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// AssigneeId The ID of the user who will be the assignee of the task
			AssigneeId *float32 `json:"assignee_id,omitempty"`

			// CreatorId The creator of a task
			CreatorId *float32 `json:"creator_id,omitempty"`

			// Description The description of the task
			Description *string `json:"description,omitempty"`

			// Done Whether the task is done or not. 0 = Not done, 1 = Done.
			Done *GetTask200DataDone `json:"done,omitempty"`

			// DueDate The due date of the task. Format: YYYY-MM-DD.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// Id The ID of the task, generated when the task was created
			Id *int `json:"id,omitempty"`

			// MarkedAsDoneTime The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// ParentTaskId The ID of a parent task. Can not be ID of a task which is already a subtask.
			ParentTaskId *float32 `json:"parent_task_id,omitempty"`

			// ProjectId The ID of the project this task is associated with
			ProjectId *float32 `json:"project_id,omitempty"`

			// Title The title of the task
			Title *string `json:"title,omitempty"`

			// UpdateTime The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}
type GetTask200DataDone float32

// Status returns HTTPResponse.Status
func (r GetTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *struct {
			// AddTime The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			AddTime *string `json:"add_time,omitempty"`

			// AssigneeId The ID of the user who will be the assignee of the task
			AssigneeId *float32 `json:"assignee_id,omitempty"`

			// CreatorId The creator of a task
			CreatorId *float32 `json:"creator_id,omitempty"`

			// Description The description of the task
			Description *string `json:"description,omitempty"`

			// Done Whether the task is done or not. 0 = Not done, 1 = Done.
			Done *UpdateTask200DataDone `json:"done,omitempty"`

			// DueDate The due date of the task. Format: YYYY-MM-DD.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// Id The ID of the task, generated when the task was created
			Id *int `json:"id,omitempty"`

			// MarkedAsDoneTime The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// ParentTaskId The ID of a parent task. Can not be ID of a task which is already a subtask.
			ParentTaskId *float32 `json:"parent_task_id,omitempty"`

			// ProjectId The ID of the project this task is associated with
			ProjectId *float32 `json:"project_id,omitempty"`

			// Title The title of the task
			Title *string `json:"title,omitempty"`

			// UpdateTime The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}
type UpdateTask200DataDone float32

// Status returns HTTPResponse.Status
func (r UpdateTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The object of UserConnections
		Data *struct {
			// Google The third party ID or false in case the ID is not found
			Google *string `json:"google,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// ErrorCode The response error code
		ErrorCode *int `json:"errorCode,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// AutofillDealExpectedCloseDate Whether the expected close date of the deal is filled automatically or not
			AutofillDealExpectedCloseDate *bool `json:"autofill_deal_expected_close_date,omitempty"`

			// BetaApp Whether beta app is enabled
			BetaApp *bool `json:"beta_app,omitempty"`

			// CalltoLinkSyntax The call to link syntax
			CalltoLinkSyntax *string `json:"callto_link_syntax,omitempty"`

			// FileUploadDestination The destination of file upload
			FileUploadDestination *string `json:"file_upload_destination,omitempty"`

			// ListLimit The number of results shown in list by default
			ListLimit *float32 `json:"list_limit,omitempty"`

			// MarketplaceTeam If the vendors are allowed to be part of the Marketplace team or not
			MarketplaceTeam *bool `json:"marketplace_team,omitempty"`

			// PersonDuplicateCondition Allow the vendors to duplicate a person
			PersonDuplicateCondition *string `json:"person_duplicate_condition,omitempty"`

			// PreventSalesphoneCalltoOverride Prevent salesphone call to override
			PreventSalesphoneCalltoOverride *bool `json:"prevent_salesphone_callto_override,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// ErrorCode The response error code
		ErrorCode *int `json:"errorCode,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			Access *[]struct {
				Admin           *bool                     `json:"admin,omitempty"`
				App             *GetUsers200DataAccessApp `json:"app,omitempty"`
				PermissionSetId *string                   `json:"permission_set_id,omitempty"`
			} `json:"access,omitempty"`

			// Activated Boolean that indicates whether the user is activated
			Activated *bool `json:"activated,omitempty"`

			// ActiveFlag Boolean that indicates whether the user is activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			Created *string `json:"created,omitempty"`

			// DefaultCurrency The user default currency
			DefaultCurrency *string `json:"default_currency,omitempty"`

			// Email The user email
			Email *string `json:"email,omitempty"`

			// HasCreatedCompany Boolean that indicates whether the user has created a company
			HasCreatedCompany *bool `json:"has_created_company,omitempty"`

			// IconUrl The user icon URL
			IconUrl *string `json:"icon_url"`

			// Id The user ID
			Id *int `json:"id,omitempty"`

			// IsDeleted Boolean that indicates whether the user is deleted from the company
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
			IsYou *bool `json:"is_you,omitempty"`

			// Lang The user language ID
			Lang *int `json:"lang,omitempty"`

			// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			LastLogin *string `json:"last_login,omitempty"`

			// Locale The user locale
			Locale *string `json:"locale,omitempty"`

			// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			Modified *string `json:"modified"`

			// Name The user name
			Name *string `json:"name,omitempty"`

			// Phone The user phone
			Phone *string `json:"phone"`

			// RoleId The ID of the user role
			RoleId *int `json:"role_id,omitempty"`

			// TimezoneName The user timezone name
			TimezoneName *string `json:"timezone_name,omitempty"`

			// TimezoneOffset The user timezone offset
			TimezoneOffset *string `json:"timezone_offset,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetUsers200DataAccessApp string

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Access *[]struct {
				Admin           *bool                    `json:"admin,omitempty"`
				App             *AddUser200DataAccessApp `json:"app,omitempty"`
				PermissionSetId *string                  `json:"permission_set_id,omitempty"`
			} `json:"access,omitempty"`

			// Activated Boolean that indicates whether the user is activated
			Activated *bool `json:"activated,omitempty"`

			// ActiveFlag Boolean that indicates whether the user is activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			Created *string `json:"created,omitempty"`

			// DefaultCurrency The user default currency
			DefaultCurrency *string `json:"default_currency,omitempty"`

			// Email The user email
			Email *string `json:"email,omitempty"`

			// HasCreatedCompany Boolean that indicates whether the user has created a company
			HasCreatedCompany *bool `json:"has_created_company,omitempty"`

			// IconUrl The user icon URL
			IconUrl *string `json:"icon_url"`

			// Id The user ID
			Id *int `json:"id,omitempty"`

			// IsDeleted Boolean that indicates whether the user is deleted from the company
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
			IsYou *bool `json:"is_you,omitempty"`

			// Lang The user language ID
			Lang *int `json:"lang,omitempty"`

			// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			LastLogin *string `json:"last_login,omitempty"`

			// Locale The user locale
			Locale *string `json:"locale,omitempty"`

			// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			Modified *string `json:"modified"`

			// Name The user name
			Name *string `json:"name,omitempty"`

			// Phone The user phone
			Phone *string `json:"phone"`

			// RoleId The ID of the user role
			RoleId *int `json:"role_id,omitempty"`

			// TimezoneName The user timezone name
			TimezoneName *string `json:"timezone_name,omitempty"`

			// TimezoneOffset The user timezone offset
			TimezoneOffset *string `json:"timezone_offset,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type AddUser200DataAccessApp string

// Status returns HTTPResponse.Status
func (r AddUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindUsersByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			Access *[]struct {
				Admin           *bool                            `json:"admin,omitempty"`
				App             *FindUsersByName200DataAccessApp `json:"app,omitempty"`
				PermissionSetId *string                          `json:"permission_set_id,omitempty"`
			} `json:"access,omitempty"`

			// Activated Boolean that indicates whether the user is activated
			Activated *bool `json:"activated,omitempty"`

			// ActiveFlag Boolean that indicates whether the user is activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			Created *string `json:"created,omitempty"`

			// DefaultCurrency The user default currency
			DefaultCurrency *string `json:"default_currency,omitempty"`

			// Email The user email
			Email *string `json:"email,omitempty"`

			// HasCreatedCompany Boolean that indicates whether the user has created a company
			HasCreatedCompany *bool `json:"has_created_company,omitempty"`

			// IconUrl The user icon URL
			IconUrl *string `json:"icon_url"`

			// Id The user ID
			Id *int `json:"id,omitempty"`

			// IsDeleted Boolean that indicates whether the user is deleted from the company
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
			IsYou *bool `json:"is_you,omitempty"`

			// Lang The user language ID
			Lang *int `json:"lang,omitempty"`

			// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			LastLogin *string `json:"last_login,omitempty"`

			// Locale The user locale
			Locale *string `json:"locale,omitempty"`

			// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			Modified *string `json:"modified"`

			// Name The user name
			Name *string `json:"name,omitempty"`

			// Phone The user phone
			Phone *string `json:"phone"`

			// RoleId The ID of the user role
			RoleId *int `json:"role_id,omitempty"`

			// TimezoneName The user timezone name
			TimezoneName *string `json:"timezone_name,omitempty"`

			// TimezoneOffset The user timezone offset
			TimezoneOffset *string `json:"timezone_offset,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type FindUsersByName200DataAccessApp string

// Status returns HTTPResponse.Status
func (r FindUsersByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindUsersByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Access *[]struct {
				Admin           *bool                           `json:"admin,omitempty"`
				App             *GetCurrentUser200DataAccessApp `json:"app,omitempty"`
				PermissionSetId *string                         `json:"permission_set_id,omitempty"`
			} `json:"access,omitempty"`

			// Activated Boolean that indicates whether the user is activated
			Activated *bool `json:"activated,omitempty"`

			// ActiveFlag Boolean that indicates whether the user is activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// CompanyCountry The user company country
			CompanyCountry *string `json:"company_country,omitempty"`

			// CompanyDomain The user company domain
			CompanyDomain *string `json:"company_domain,omitempty"`

			// CompanyId The user company ID
			CompanyId *int `json:"company_id,omitempty"`

			// CompanyIndustry The user company industry
			CompanyIndustry *string `json:"company_industry,omitempty"`

			// CompanyName The user company name
			CompanyName *string `json:"company_name,omitempty"`

			// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			Created *string `json:"created,omitempty"`

			// DefaultCurrency The user default currency
			DefaultCurrency *string `json:"default_currency,omitempty"`

			// Email The user email
			Email *string `json:"email,omitempty"`

			// HasCreatedCompany Boolean that indicates whether the user has created a company
			HasCreatedCompany *bool `json:"has_created_company,omitempty"`

			// IconUrl The user icon URL
			IconUrl *string `json:"icon_url"`

			// Id The user ID
			Id *int `json:"id,omitempty"`

			// IsDeleted Boolean that indicates whether the user is deleted from the company
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
			IsYou *bool `json:"is_you,omitempty"`

			// Lang The user language ID
			Lang *int `json:"lang,omitempty"`

			// Language The user language details
			Language *struct {
				// CountryCode The country code. E.g. US
				CountryCode *string `json:"country_code,omitempty"`

				// LanguageCode The language code. E.g. en
				LanguageCode *string `json:"language_code,omitempty"`
			} `json:"language,omitempty"`

			// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			LastLogin *string `json:"last_login,omitempty"`

			// Locale The user locale
			Locale *string `json:"locale,omitempty"`

			// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			Modified *string `json:"modified"`

			// Name The user name
			Name *string `json:"name,omitempty"`

			// Phone The user phone
			Phone *string `json:"phone"`

			// RoleId The ID of the user role
			RoleId *int `json:"role_id,omitempty"`

			// TimezoneName The user timezone name
			TimezoneName *string `json:"timezone_name,omitempty"`

			// TimezoneOffset The user timezone offset
			TimezoneOffset *string `json:"timezone_offset,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// ErrorCode The response error code
		ErrorCode *int `json:"errorCode,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetCurrentUser200DataAccessApp string

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Access *[]struct {
				Admin           *bool                    `json:"admin,omitempty"`
				App             *GetUser200DataAccessApp `json:"app,omitempty"`
				PermissionSetId *string                  `json:"permission_set_id,omitempty"`
			} `json:"access,omitempty"`

			// Activated Boolean that indicates whether the user is activated
			Activated *bool `json:"activated,omitempty"`

			// ActiveFlag Boolean that indicates whether the user is activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			Created *string `json:"created,omitempty"`

			// DefaultCurrency The user default currency
			DefaultCurrency *string `json:"default_currency,omitempty"`

			// Email The user email
			Email *string `json:"email,omitempty"`

			// HasCreatedCompany Boolean that indicates whether the user has created a company
			HasCreatedCompany *bool `json:"has_created_company,omitempty"`

			// IconUrl The user icon URL
			IconUrl *string `json:"icon_url"`

			// Id The user ID
			Id *int `json:"id,omitempty"`

			// IsDeleted Boolean that indicates whether the user is deleted from the company
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
			IsYou *bool `json:"is_you,omitempty"`

			// Lang The user language ID
			Lang *int `json:"lang,omitempty"`

			// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			LastLogin *string `json:"last_login,omitempty"`

			// Locale The user locale
			Locale *string `json:"locale,omitempty"`

			// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			Modified *string `json:"modified"`

			// Name The user name
			Name *string `json:"name,omitempty"`

			// Phone The user phone
			Phone *string `json:"phone"`

			// RoleId The ID of the user role
			RoleId *int `json:"role_id,omitempty"`

			// TimezoneName The user timezone name
			TimezoneName *string `json:"timezone_name,omitempty"`

			// TimezoneOffset The user timezone offset
			TimezoneOffset *string `json:"timezone_offset,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetUser200DataAccessApp string

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Access *[]struct {
				Admin           *bool                       `json:"admin,omitempty"`
				App             *UpdateUser200DataAccessApp `json:"app,omitempty"`
				PermissionSetId *string                     `json:"permission_set_id,omitempty"`
			} `json:"access,omitempty"`

			// Activated Boolean that indicates whether the user is activated
			Activated *bool `json:"activated,omitempty"`

			// ActiveFlag Boolean that indicates whether the user is activated
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			Created *string `json:"created,omitempty"`

			// DefaultCurrency The user default currency
			DefaultCurrency *string `json:"default_currency,omitempty"`

			// Email The user email
			Email *string `json:"email,omitempty"`

			// HasCreatedCompany Boolean that indicates whether the user has created a company
			HasCreatedCompany *bool `json:"has_created_company,omitempty"`

			// IconUrl The user icon URL
			IconUrl *string `json:"icon_url"`

			// Id The user ID
			Id *int `json:"id,omitempty"`

			// IsDeleted Boolean that indicates whether the user is deleted from the company
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
			IsYou *bool `json:"is_you,omitempty"`

			// Lang The user language ID
			Lang *int `json:"lang,omitempty"`

			// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			LastLogin *string `json:"last_login,omitempty"`

			// Locale The user locale
			Locale *string `json:"locale,omitempty"`

			// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
			Modified *string `json:"modified"`

			// Name The user name
			Name *string `json:"name,omitempty"`

			// Phone The user phone
			Phone *string `json:"phone"`

			// RoleId The ID of the user role
			RoleId *int `json:"role_id,omitempty"`

			// TimezoneName The user timezone name
			TimezoneName *string `json:"timezone_name,omitempty"`

			// TimezoneOffset The user timezone offset
			TimezoneOffset *string `json:"timezone_offset,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type UpdateUser200DataAccessApp string

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// CanAddCustomFields If the user can add custom fields
			CanAddCustomFields *bool `json:"can_add_custom_fields,omitempty"`

			// CanAddProducts If the user can add products
			CanAddProducts *bool `json:"can_add_products,omitempty"`

			// CanAddProspectsAsLeads If the user can add prospects as leads
			CanAddProspectsAsLeads *bool `json:"can_add_prospects_as_leads,omitempty"`

			// CanBulkEditItems If the user can bulk edit items
			CanBulkEditItems *bool `json:"can_bulk_edit_items,omitempty"`

			// CanChangeVisibilityOfItems If the user can change visibility of items
			CanChangeVisibilityOfItems *bool `json:"can_change_visibility_of_items,omitempty"`

			// CanConvertDealsToLeads If the user can convert deals to leads
			CanConvertDealsToLeads *bool `json:"can_convert_deals_to_leads,omitempty"`

			// CanCreateOwnWorkflow If the user can create workflows
			CanCreateOwnWorkflow *bool `json:"can_create_own_workflow,omitempty"`

			// CanDeleteActivities If the user can delete activities
			CanDeleteActivities *bool `json:"can_delete_activities,omitempty"`

			// CanDeleteCustomFields If the user can delete custom fields
			CanDeleteCustomFields *bool `json:"can_delete_custom_fields,omitempty"`

			// CanDeleteDeals If the user can delete deals
			CanDeleteDeals *bool `json:"can_delete_deals,omitempty"`

			// CanEditCustomFields If the user can edit custom fields
			CanEditCustomFields *bool `json:"can_edit_custom_fields,omitempty"`

			// CanEditDealsClosedDate If the user can edit deals' closed date
			CanEditDealsClosedDate *bool `json:"can_edit_deals_closed_date,omitempty"`

			// CanEditProducts If the user can edit products
			CanEditProducts *bool `json:"can_edit_products,omitempty"`

			// CanEditSharedFilters If the user can edit shared filters
			CanEditSharedFilters *bool `json:"can_edit_shared_filters,omitempty"`

			// CanExportDataFromLists If the user can export data from item lists
			CanExportDataFromLists *bool `json:"can_export_data_from_lists,omitempty"`

			// CanFollowOtherUsers If the user can follow other users
			CanFollowOtherUsers *bool `json:"can_follow_other_users,omitempty"`

			// CanMergeDeals If the user can merge deals
			CanMergeDeals *bool `json:"can_merge_deals,omitempty"`

			// CanMergeOrganizations If the user can merge organizations
			CanMergeOrganizations *bool `json:"can_merge_organizations,omitempty"`

			// CanMergePeople If the user can merge people
			CanMergePeople *bool `json:"can_merge_people,omitempty"`

			// CanModifyLabels If the user can modify labels
			CanModifyLabels *bool `json:"can_modify_labels,omitempty"`

			// CanSeeCompanyWideStatistics If the user can see company-wide statistics
			CanSeeCompanyWideStatistics *bool `json:"can_see_company_wide_statistics,omitempty"`

			// CanSeeDealsListSummary If the user can see the summary on the deals page
			CanSeeDealsListSummary *bool `json:"can_see_deals_list_summary,omitempty"`

			// CanSeeHiddenItemsNames If the user can see the names of hidden items
			CanSeeHiddenItemsNames *bool `json:"can_see_hidden_items_names,omitempty"`

			// CanSeeOtherUsers If the user can see other users
			CanSeeOtherUsers *bool `json:"can_see_other_users,omitempty"`

			// CanSeeOtherUsersStatistics If the user can see other users' statistics
			CanSeeOtherUsersStatistics *bool `json:"can_see_other_users_statistics,omitempty"`

			// CanSeeSecurityDashboard If the user can see security dashboard
			CanSeeSecurityDashboard *bool `json:"can_see_security_dashboard,omitempty"`

			// CanShareFilters If the user can share filters
			CanShareFilters *bool `json:"can_share_filters,omitempty"`

			// CanShareInsights If the user can share insights
			CanShareInsights *bool `json:"can_share_insights,omitempty"`

			// CanUseApi If the user can use API
			CanUseApi *bool `json:"can_use_api,omitempty"`

			// CanUseEmailTracking If the user can use email tracking
			CanUseEmailTracking *bool `json:"can_use_email_tracking,omitempty"`

			// CanUseImport If the user can use import
			CanUseImport *bool `json:"can_use_import,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserRoleAssignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data in the role list
		AdditionalData *struct {
			// Pagination The pagination details in the role list
			Pagination *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection Whether there are more list items in the collection than displayed
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"pagination,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The role assignments
		Data *[]struct {
			// ActiveFlag Whether the role is active or not
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// Name The name of the role
			Name *string `json:"name,omitempty"`

			// ParentRoleId The ID of the parent role
			ParentRoleId *int `json:"parent_role_id"`

			// RoleId The role ID
			RoleId *int `json:"role_id,omitempty"`

			// Type The assignment type
			Type *string `json:"type,omitempty"`

			// UserId The user ID
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserRoleAssignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserRoleAssignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserRoleSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The settings for the role
		Data *struct {
			// DealAccessLevel The access level of the deals for the role (only for default role)
			DealAccessLevel *float32 `json:"deal_access_level,omitempty"`

			// DealDefaultVisibility The default visibility level of the deals for the role
			DealDefaultVisibility *float32 `json:"deal_default_visibility,omitempty"`

			// LeadDefaultVisibility The default visibility level of the leads for the role
			LeadDefaultVisibility *float32 `json:"lead_default_visibility,omitempty"`

			// OrgAccessLevel The access level of the organizations for the role (only for default role)
			OrgAccessLevel *float32 `json:"org_access_level,omitempty"`

			// OrgDefaultVisibility The default visibility level of the organizations for the role
			OrgDefaultVisibility *float32 `json:"org_default_visibility,omitempty"`

			// PersonAccessLevel The access level of the people for the role (only for default role)
			PersonAccessLevel *float32 `json:"person_access_level,omitempty"`

			// PersonDefaultVisibility The default visibility level of the people for the role
			PersonDefaultVisibility *float32 `json:"person_default_visibility,omitempty"`

			// ProductAccessLevel The access level of the products for the role (only for default role)
			ProductAccessLevel *float32 `json:"product_access_level,omitempty"`

			// ProductDefaultVisibility The default visibility level of the products for the role
			ProductDefaultVisibility *float32 `json:"product_default_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserRoleSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserRoleSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The array of Webhooks
		Data *[]struct {
			// AddTime The date when the Webhook was added
			AddTime *time.Time `json:"add_time,omitempty"`

			// AdminId The ID of the admin of the Webhook
			AdminId *int `json:"admin_id,omitempty"`

			// CompanyId The ID of the company related to the Webhook
			CompanyId *int `json:"company_id,omitempty"`

			// EventAction The Webhook action
			EventAction *string `json:"event_action,omitempty"`

			// EventObject The Webhook object
			EventObject *string `json:"event_object,omitempty"`

			// HttpAuthPassword The password of the `subscription_url` of the Webhook
			HttpAuthPassword *string `json:"http_auth_password"`

			// HttpAuthUser The username of the `subscription_url` of the Webhook
			HttpAuthUser *string `json:"http_auth_user"`

			// Id The ID of the Webhook
			Id *int `json:"id,omitempty"`

			// IsActive The Webhook's status
			IsActive *GetWebhooks200DataIsActive `json:"is_active,omitempty"`

			// LastDeliveryTime The last delivery time of the Webhook
			LastDeliveryTime *time.Time `json:"last_delivery_time"`

			// LastHttpStatus The last delivery HTTP status of the Webhook
			LastHttpStatus *int `json:"last_http_status"`

			// Name The Webhook name
			Name *string `json:"name,omitempty"`

			// OwnerId The ID of the user who owns the Webhook
			OwnerId *int `json:"owner_id,omitempty"`

			// RemoveReason The removal reason of the Webhook (if removed)
			RemoveReason *string `json:"remove_reason"`

			// RemoveTime The date when the Webhook was removed (if removed)
			RemoveTime *time.Time `json:"remove_time"`

			// SubscriptionUrl The subscription URL of the Webhook
			SubscriptionUrl *string `json:"subscription_url,omitempty"`

			// Type The type of the Webhook
			Type *GetWebhooks200DataType `json:"type,omitempty"`

			// UserId The ID of the user related to the Webhook
			UserId *int `json:"user_id,omitempty"`

			// Version The Webhook version
			Version *string `json:"version,omitempty"`
		} `json:"data,omitempty"`

		// Status The status of the response
		Status *string `json:"status,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// ErrorCode The response error code
		ErrorCode *int `json:"errorCode,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetWebhooks200DataIsActive float32
type GetWebhooks200DataType string

// Status returns HTTPResponse.Status
func (r GetWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// AddTime The date when the Webhook was added
			AddTime *time.Time `json:"add_time,omitempty"`

			// AdminId The ID of the admin of the Webhook
			AdminId *int `json:"admin_id,omitempty"`

			// CompanyId The ID of the company related to the Webhook
			CompanyId *int `json:"company_id,omitempty"`

			// EventAction The Webhook action
			EventAction *string `json:"event_action,omitempty"`

			// EventObject The Webhook object
			EventObject *string `json:"event_object,omitempty"`

			// HttpAuthPassword The password of the `subscription_url` of the Webhook
			HttpAuthPassword *string `json:"http_auth_password"`

			// HttpAuthUser The username of the `subscription_url` of the Webhook
			HttpAuthUser *string `json:"http_auth_user"`

			// Id The ID of the Webhook
			Id *int `json:"id,omitempty"`

			// IsActive The Webhook's status
			IsActive *AddWebhook201DataIsActive `json:"is_active,omitempty"`

			// LastDeliveryTime The last delivery time of the Webhook
			LastDeliveryTime *time.Time `json:"last_delivery_time"`

			// LastHttpStatus The last delivery HTTP status of the Webhook
			LastHttpStatus *int `json:"last_http_status"`

			// Name The Webhook name
			Name *string `json:"name,omitempty"`

			// OwnerId The ID of the user who owns the Webhook
			OwnerId *int `json:"owner_id,omitempty"`

			// RemoveReason The removal reason of the Webhook (if removed)
			RemoveReason *string `json:"remove_reason"`

			// RemoveTime The date when the Webhook was removed (if removed)
			RemoveTime *time.Time `json:"remove_time"`

			// SubscriptionUrl The subscription URL of the Webhook
			SubscriptionUrl *string `json:"subscription_url,omitempty"`

			// Type The type of the Webhook
			Type *AddWebhook201DataType `json:"type,omitempty"`

			// UserId The ID of the user related to the Webhook
			UserId *int `json:"user_id,omitempty"`

			// Version The Webhook version
			Version *string `json:"version,omitempty"`
		} `json:"data,omitempty"`

		// Status The status of the response
		Status *string `json:"status,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON400 *struct {
		// Errors List of errors
		Errors *map[string]interface{} `json:"errors,omitempty"`

		// Status The status of the response
		Status *string `json:"status,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// ErrorCode The response error code
		ErrorCode *int `json:"errorCode,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type AddWebhook201DataIsActive float32
type AddWebhook201DataType string

// Status returns HTTPResponse.Status
func (r AddWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Status The status of the response
		Status *string `json:"status,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *struct {
		// Error The error message
		Error *string `json:"error,omitempty"`

		// ErrorCode The response error code
		ErrorCode *int `json:"errorCode,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON403 *struct {
		// Message The error message
		Message *string `json:"message,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		// Errors List of errors
		Errors *map[string]interface{} `json:"errors,omitempty"`

		// Status The status of the response
		Status *string `json:"status,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteActivitiesWithResponse request returning *DeleteActivitiesResponse
func (c *ClientWithResponses) DeleteActivitiesWithResponse(ctx context.Context, params *DeleteActivitiesParams, reqEditors ...RequestEditorFn) (*DeleteActivitiesResponse, error) {
	rsp, err := c.DeleteActivities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteActivitiesResponse(rsp)
}

// GetActivitiesCollectionWithResponse request returning *GetActivitiesCollectionResponse
func (c *ClientWithResponses) GetActivitiesCollectionWithResponse(ctx context.Context, params *GetActivitiesCollectionParams, reqEditors ...RequestEditorFn) (*GetActivitiesCollectionResponse, error) {
	rsp, err := c.GetActivitiesCollection(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivitiesCollectionResponse(rsp)
}

// DeleteActivityTypesWithResponse request returning *DeleteActivityTypesResponse
func (c *ClientWithResponses) DeleteActivityTypesWithResponse(ctx context.Context, params *DeleteActivityTypesParams, reqEditors ...RequestEditorFn) (*DeleteActivityTypesResponse, error) {
	rsp, err := c.DeleteActivityTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteActivityTypesResponse(rsp)
}

// GetActivityTypesWithResponse request returning *GetActivityTypesResponse
func (c *ClientWithResponses) GetActivityTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetActivityTypesResponse, error) {
	rsp, err := c.GetActivityTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityTypesResponse(rsp)
}

// AddActivityTypeWithBodyWithResponse request with arbitrary body returning *AddActivityTypeResponse
func (c *ClientWithResponses) AddActivityTypeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddActivityTypeResponse, error) {
	rsp, err := c.AddActivityTypeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddActivityTypeResponse(rsp)
}

func (c *ClientWithResponses) AddActivityTypeWithResponse(ctx context.Context, body AddActivityTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*AddActivityTypeResponse, error) {
	rsp, err := c.AddActivityType(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddActivityTypeResponse(rsp)
}

// DeleteActivityTypeWithResponse request returning *DeleteActivityTypeResponse
func (c *ClientWithResponses) DeleteActivityTypeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteActivityTypeResponse, error) {
	rsp, err := c.DeleteActivityType(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteActivityTypeResponse(rsp)
}

// UpdateActivityTypeWithBodyWithResponse request with arbitrary body returning *UpdateActivityTypeResponse
func (c *ClientWithResponses) UpdateActivityTypeWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateActivityTypeResponse, error) {
	rsp, err := c.UpdateActivityTypeWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateActivityTypeResponse(rsp)
}

func (c *ClientWithResponses) UpdateActivityTypeWithResponse(ctx context.Context, id int, body UpdateActivityTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateActivityTypeResponse, error) {
	rsp, err := c.UpdateActivityType(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateActivityTypeResponse(rsp)
}

// GetCompanyAddonsWithResponse request returning *GetCompanyAddonsResponse
func (c *ClientWithResponses) GetCompanyAddonsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCompanyAddonsResponse, error) {
	rsp, err := c.GetCompanyAddons(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompanyAddonsResponse(rsp)
}

// GetUserCallLogsWithResponse request returning *GetUserCallLogsResponse
func (c *ClientWithResponses) GetUserCallLogsWithResponse(ctx context.Context, params *GetUserCallLogsParams, reqEditors ...RequestEditorFn) (*GetUserCallLogsResponse, error) {
	rsp, err := c.GetUserCallLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserCallLogsResponse(rsp)
}

// AddCallLogWithBodyWithResponse request with arbitrary body returning *AddCallLogResponse
func (c *ClientWithResponses) AddCallLogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCallLogResponse, error) {
	rsp, err := c.AddCallLogWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCallLogResponse(rsp)
}

func (c *ClientWithResponses) AddCallLogWithResponse(ctx context.Context, body AddCallLogJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCallLogResponse, error) {
	rsp, err := c.AddCallLog(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCallLogResponse(rsp)
}

// DeleteCallLogWithResponse request returning *DeleteCallLogResponse
func (c *ClientWithResponses) DeleteCallLogWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCallLogResponse, error) {
	rsp, err := c.DeleteCallLog(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCallLogResponse(rsp)
}

// GetCallLogWithResponse request returning *GetCallLogResponse
func (c *ClientWithResponses) GetCallLogWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCallLogResponse, error) {
	rsp, err := c.GetCallLog(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCallLogResponse(rsp)
}

// AddCallLogAudioFileWithBodyWithResponse request with arbitrary body returning *AddCallLogAudioFileResponse
func (c *ClientWithResponses) AddCallLogAudioFileWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCallLogAudioFileResponse, error) {
	rsp, err := c.AddCallLogAudioFileWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCallLogAudioFileResponse(rsp)
}

// AddChannelWithBodyWithResponse request with arbitrary body returning *AddChannelResponse
func (c *ClientWithResponses) AddChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddChannelResponse, error) {
	rsp, err := c.AddChannelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddChannelResponse(rsp)
}

func (c *ClientWithResponses) AddChannelWithResponse(ctx context.Context, body AddChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*AddChannelResponse, error) {
	rsp, err := c.AddChannel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddChannelResponse(rsp)
}

// ReceiveMessageWithBodyWithResponse request with arbitrary body returning *ReceiveMessageResponse
func (c *ClientWithResponses) ReceiveMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveMessageResponse, error) {
	rsp, err := c.ReceiveMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReceiveMessageResponse(rsp)
}

func (c *ClientWithResponses) ReceiveMessageWithResponse(ctx context.Context, body ReceiveMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*ReceiveMessageResponse, error) {
	rsp, err := c.ReceiveMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReceiveMessageResponse(rsp)
}

// DeleteConversationWithResponse request returning *DeleteConversationResponse
func (c *ClientWithResponses) DeleteConversationWithResponse(ctx context.Context, channelId string, conversationId string, reqEditors ...RequestEditorFn) (*DeleteConversationResponse, error) {
	rsp, err := c.DeleteConversation(ctx, channelId, conversationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConversationResponse(rsp)
}

// DeleteChannelWithResponse request returning *DeleteChannelResponse
func (c *ClientWithResponses) DeleteChannelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteChannelResponse, error) {
	rsp, err := c.DeleteChannel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteChannelResponse(rsp)
}

// GetCurrenciesWithResponse request returning *GetCurrenciesResponse
func (c *ClientWithResponses) GetCurrenciesWithResponse(ctx context.Context, params *GetCurrenciesParams, reqEditors ...RequestEditorFn) (*GetCurrenciesResponse, error) {
	rsp, err := c.GetCurrencies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrenciesResponse(rsp)
}

// DeleteDealFieldsWithResponse request returning *DeleteDealFieldsResponse
func (c *ClientWithResponses) DeleteDealFieldsWithResponse(ctx context.Context, params *DeleteDealFieldsParams, reqEditors ...RequestEditorFn) (*DeleteDealFieldsResponse, error) {
	rsp, err := c.DeleteDealFields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDealFieldsResponse(rsp)
}

// DeleteDealsWithResponse request returning *DeleteDealsResponse
func (c *ClientWithResponses) DeleteDealsWithResponse(ctx context.Context, params *DeleteDealsParams, reqEditors ...RequestEditorFn) (*DeleteDealsResponse, error) {
	rsp, err := c.DeleteDeals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDealsResponse(rsp)
}

// GetDealsCollectionWithResponse request returning *GetDealsCollectionResponse
func (c *ClientWithResponses) GetDealsCollectionWithResponse(ctx context.Context, params *GetDealsCollectionParams, reqEditors ...RequestEditorFn) (*GetDealsCollectionResponse, error) {
	rsp, err := c.GetDealsCollection(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealsCollectionResponse(rsp)
}

// GetDealsSummaryWithResponse request returning *GetDealsSummaryResponse
func (c *ClientWithResponses) GetDealsSummaryWithResponse(ctx context.Context, params *GetDealsSummaryParams, reqEditors ...RequestEditorFn) (*GetDealsSummaryResponse, error) {
	rsp, err := c.GetDealsSummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealsSummaryResponse(rsp)
}

// GetArchivedDealsSummaryWithResponse request returning *GetArchivedDealsSummaryResponse
func (c *ClientWithResponses) GetArchivedDealsSummaryWithResponse(ctx context.Context, params *GetArchivedDealsSummaryParams, reqEditors ...RequestEditorFn) (*GetArchivedDealsSummaryResponse, error) {
	rsp, err := c.GetArchivedDealsSummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArchivedDealsSummaryResponse(rsp)
}

// GetDealsTimelineWithResponse request returning *GetDealsTimelineResponse
func (c *ClientWithResponses) GetDealsTimelineWithResponse(ctx context.Context, params *GetDealsTimelineParams, reqEditors ...RequestEditorFn) (*GetDealsTimelineResponse, error) {
	rsp, err := c.GetDealsTimeline(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealsTimelineResponse(rsp)
}

// GetArchivedDealsTimelineWithResponse request returning *GetArchivedDealsTimelineResponse
func (c *ClientWithResponses) GetArchivedDealsTimelineWithResponse(ctx context.Context, params *GetArchivedDealsTimelineParams, reqEditors ...RequestEditorFn) (*GetArchivedDealsTimelineResponse, error) {
	rsp, err := c.GetArchivedDealsTimeline(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArchivedDealsTimelineResponse(rsp)
}

// GetDealActivitiesWithResponse request returning *GetDealActivitiesResponse
func (c *ClientWithResponses) GetDealActivitiesWithResponse(ctx context.Context, id int, params *GetDealActivitiesParams, reqEditors ...RequestEditorFn) (*GetDealActivitiesResponse, error) {
	rsp, err := c.GetDealActivities(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealActivitiesResponse(rsp)
}

// GetDealChangelogWithResponse request returning *GetDealChangelogResponse
func (c *ClientWithResponses) GetDealChangelogWithResponse(ctx context.Context, id int, params *GetDealChangelogParams, reqEditors ...RequestEditorFn) (*GetDealChangelogResponse, error) {
	rsp, err := c.GetDealChangelog(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealChangelogResponse(rsp)
}

// DuplicateDealWithResponse request returning *DuplicateDealResponse
func (c *ClientWithResponses) DuplicateDealWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DuplicateDealResponse, error) {
	rsp, err := c.DuplicateDeal(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuplicateDealResponse(rsp)
}

// GetDealFilesWithResponse request returning *GetDealFilesResponse
func (c *ClientWithResponses) GetDealFilesWithResponse(ctx context.Context, id int, params *GetDealFilesParams, reqEditors ...RequestEditorFn) (*GetDealFilesResponse, error) {
	rsp, err := c.GetDealFiles(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealFilesResponse(rsp)
}

// GetDealUpdatesWithResponse request returning *GetDealUpdatesResponse
func (c *ClientWithResponses) GetDealUpdatesWithResponse(ctx context.Context, id int, params *GetDealUpdatesParams, reqEditors ...RequestEditorFn) (*GetDealUpdatesResponse, error) {
	rsp, err := c.GetDealUpdates(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealUpdatesResponse(rsp)
}

// GetDealMailMessagesWithResponse request returning *GetDealMailMessagesResponse
func (c *ClientWithResponses) GetDealMailMessagesWithResponse(ctx context.Context, id int, params *GetDealMailMessagesParams, reqEditors ...RequestEditorFn) (*GetDealMailMessagesResponse, error) {
	rsp, err := c.GetDealMailMessages(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealMailMessagesResponse(rsp)
}

// MergeDealsWithBodyWithResponse request with arbitrary body returning *MergeDealsResponse
func (c *ClientWithResponses) MergeDealsWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeDealsResponse, error) {
	rsp, err := c.MergeDealsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeDealsResponse(rsp)
}

func (c *ClientWithResponses) MergeDealsWithResponse(ctx context.Context, id int, body MergeDealsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeDealsResponse, error) {
	rsp, err := c.MergeDeals(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeDealsResponse(rsp)
}

// GetDealParticipantsWithResponse request returning *GetDealParticipantsResponse
func (c *ClientWithResponses) GetDealParticipantsWithResponse(ctx context.Context, id int, params *GetDealParticipantsParams, reqEditors ...RequestEditorFn) (*GetDealParticipantsResponse, error) {
	rsp, err := c.GetDealParticipants(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealParticipantsResponse(rsp)
}

// AddDealParticipantWithBodyWithResponse request with arbitrary body returning *AddDealParticipantResponse
func (c *ClientWithResponses) AddDealParticipantWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDealParticipantResponse, error) {
	rsp, err := c.AddDealParticipantWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDealParticipantResponse(rsp)
}

func (c *ClientWithResponses) AddDealParticipantWithResponse(ctx context.Context, id int, body AddDealParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDealParticipantResponse, error) {
	rsp, err := c.AddDealParticipant(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDealParticipantResponse(rsp)
}

// DeleteDealParticipantWithResponse request returning *DeleteDealParticipantResponse
func (c *ClientWithResponses) DeleteDealParticipantWithResponse(ctx context.Context, id int, dealParticipantId int, reqEditors ...RequestEditorFn) (*DeleteDealParticipantResponse, error) {
	rsp, err := c.DeleteDealParticipant(ctx, id, dealParticipantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDealParticipantResponse(rsp)
}

// GetDealParticipantsChangelogWithResponse request returning *GetDealParticipantsChangelogResponse
func (c *ClientWithResponses) GetDealParticipantsChangelogWithResponse(ctx context.Context, id int, params *GetDealParticipantsChangelogParams, reqEditors ...RequestEditorFn) (*GetDealParticipantsChangelogResponse, error) {
	rsp, err := c.GetDealParticipantsChangelog(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealParticipantsChangelogResponse(rsp)
}

// GetDealUsersWithResponse request returning *GetDealUsersResponse
func (c *ClientWithResponses) GetDealUsersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetDealUsersResponse, error) {
	rsp, err := c.GetDealUsers(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealUsersResponse(rsp)
}

// GetDealPersonsWithResponse request returning *GetDealPersonsResponse
func (c *ClientWithResponses) GetDealPersonsWithResponse(ctx context.Context, id int, params *GetDealPersonsParams, reqEditors ...RequestEditorFn) (*GetDealPersonsResponse, error) {
	rsp, err := c.GetDealPersons(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealPersonsResponse(rsp)
}

// GetFilesWithResponse request returning *GetFilesResponse
func (c *ClientWithResponses) GetFilesWithResponse(ctx context.Context, params *GetFilesParams, reqEditors ...RequestEditorFn) (*GetFilesResponse, error) {
	rsp, err := c.GetFiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilesResponse(rsp)
}

// AddFileWithBodyWithResponse request with arbitrary body returning *AddFileResponse
func (c *ClientWithResponses) AddFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddFileResponse, error) {
	rsp, err := c.AddFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddFileResponse(rsp)
}

// AddFileAndLinkItWithBodyWithResponse request with arbitrary body returning *AddFileAndLinkItResponse
func (c *ClientWithResponses) AddFileAndLinkItWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddFileAndLinkItResponse, error) {
	rsp, err := c.AddFileAndLinkItWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddFileAndLinkItResponse(rsp)
}

func (c *ClientWithResponses) AddFileAndLinkItWithFormdataBodyWithResponse(ctx context.Context, body AddFileAndLinkItFormdataRequestBody, reqEditors ...RequestEditorFn) (*AddFileAndLinkItResponse, error) {
	rsp, err := c.AddFileAndLinkItWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddFileAndLinkItResponse(rsp)
}

// LinkFileToItemWithBodyWithResponse request with arbitrary body returning *LinkFileToItemResponse
func (c *ClientWithResponses) LinkFileToItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkFileToItemResponse, error) {
	rsp, err := c.LinkFileToItemWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkFileToItemResponse(rsp)
}

func (c *ClientWithResponses) LinkFileToItemWithFormdataBodyWithResponse(ctx context.Context, body LinkFileToItemFormdataRequestBody, reqEditors ...RequestEditorFn) (*LinkFileToItemResponse, error) {
	rsp, err := c.LinkFileToItemWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkFileToItemResponse(rsp)
}

// DeleteFileWithResponse request returning *DeleteFileResponse
func (c *ClientWithResponses) DeleteFileWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteFileResponse, error) {
	rsp, err := c.DeleteFile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFileResponse(rsp)
}

// GetFileWithResponse request returning *GetFileResponse
func (c *ClientWithResponses) GetFileWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetFileResponse, error) {
	rsp, err := c.GetFile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileResponse(rsp)
}

// UpdateFileWithBodyWithResponse request with arbitrary body returning *UpdateFileResponse
func (c *ClientWithResponses) UpdateFileWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFileResponse, error) {
	rsp, err := c.UpdateFileWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFileResponse(rsp)
}

func (c *ClientWithResponses) UpdateFileWithFormdataBodyWithResponse(ctx context.Context, id int, body UpdateFileFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateFileResponse, error) {
	rsp, err := c.UpdateFileWithFormdataBody(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFileResponse(rsp)
}

// DownloadFileWithResponse request returning *DownloadFileResponse
func (c *ClientWithResponses) DownloadFileWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DownloadFileResponse, error) {
	rsp, err := c.DownloadFile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadFileResponse(rsp)
}

// DeleteFiltersWithResponse request returning *DeleteFiltersResponse
func (c *ClientWithResponses) DeleteFiltersWithResponse(ctx context.Context, params *DeleteFiltersParams, reqEditors ...RequestEditorFn) (*DeleteFiltersResponse, error) {
	rsp, err := c.DeleteFilters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFiltersResponse(rsp)
}

// GetFiltersWithResponse request returning *GetFiltersResponse
func (c *ClientWithResponses) GetFiltersWithResponse(ctx context.Context, params *GetFiltersParams, reqEditors ...RequestEditorFn) (*GetFiltersResponse, error) {
	rsp, err := c.GetFilters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFiltersResponse(rsp)
}

// AddFilterWithBodyWithResponse request with arbitrary body returning *AddFilterResponse
func (c *ClientWithResponses) AddFilterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddFilterResponse, error) {
	rsp, err := c.AddFilterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddFilterResponse(rsp)
}

func (c *ClientWithResponses) AddFilterWithResponse(ctx context.Context, body AddFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*AddFilterResponse, error) {
	rsp, err := c.AddFilter(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddFilterResponse(rsp)
}

// GetFilterHelpersWithResponse request returning *GetFilterHelpersResponse
func (c *ClientWithResponses) GetFilterHelpersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFilterHelpersResponse, error) {
	rsp, err := c.GetFilterHelpers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterHelpersResponse(rsp)
}

// DeleteFilterWithResponse request returning *DeleteFilterResponse
func (c *ClientWithResponses) DeleteFilterWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteFilterResponse, error) {
	rsp, err := c.DeleteFilter(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFilterResponse(rsp)
}

// GetFilterWithResponse request returning *GetFilterResponse
func (c *ClientWithResponses) GetFilterWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetFilterResponse, error) {
	rsp, err := c.GetFilter(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterResponse(rsp)
}

// UpdateFilterWithBodyWithResponse request with arbitrary body returning *UpdateFilterResponse
func (c *ClientWithResponses) UpdateFilterWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFilterResponse, error) {
	rsp, err := c.UpdateFilterWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFilterResponse(rsp)
}

func (c *ClientWithResponses) UpdateFilterWithResponse(ctx context.Context, id int, body UpdateFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFilterResponse, error) {
	rsp, err := c.UpdateFilter(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFilterResponse(rsp)
}

// AddGoalWithBodyWithResponse request with arbitrary body returning *AddGoalResponse
func (c *ClientWithResponses) AddGoalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGoalResponse, error) {
	rsp, err := c.AddGoalWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGoalResponse(rsp)
}

func (c *ClientWithResponses) AddGoalWithResponse(ctx context.Context, body AddGoalJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGoalResponse, error) {
	rsp, err := c.AddGoal(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGoalResponse(rsp)
}

// GetGoalsWithResponse request returning *GetGoalsResponse
func (c *ClientWithResponses) GetGoalsWithResponse(ctx context.Context, params *GetGoalsParams, reqEditors ...RequestEditorFn) (*GetGoalsResponse, error) {
	rsp, err := c.GetGoals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGoalsResponse(rsp)
}

// DeleteGoalWithResponse request returning *DeleteGoalResponse
func (c *ClientWithResponses) DeleteGoalWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteGoalResponse, error) {
	rsp, err := c.DeleteGoal(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGoalResponse(rsp)
}

// UpdateGoalWithBodyWithResponse request with arbitrary body returning *UpdateGoalResponse
func (c *ClientWithResponses) UpdateGoalWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGoalResponse, error) {
	rsp, err := c.UpdateGoalWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGoalResponse(rsp)
}

func (c *ClientWithResponses) UpdateGoalWithResponse(ctx context.Context, id string, body UpdateGoalJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGoalResponse, error) {
	rsp, err := c.UpdateGoal(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGoalResponse(rsp)
}

// GetGoalResultWithResponse request returning *GetGoalResultResponse
func (c *ClientWithResponses) GetGoalResultWithResponse(ctx context.Context, id string, params *GetGoalResultParams, reqEditors ...RequestEditorFn) (*GetGoalResultResponse, error) {
	rsp, err := c.GetGoalResult(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGoalResultResponse(rsp)
}

// GetLeadFieldsWithResponse request returning *GetLeadFieldsResponse
func (c *ClientWithResponses) GetLeadFieldsWithResponse(ctx context.Context, params *GetLeadFieldsParams, reqEditors ...RequestEditorFn) (*GetLeadFieldsResponse, error) {
	rsp, err := c.GetLeadFields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeadFieldsResponse(rsp)
}

// GetLeadLabelsWithResponse request returning *GetLeadLabelsResponse
func (c *ClientWithResponses) GetLeadLabelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLeadLabelsResponse, error) {
	rsp, err := c.GetLeadLabels(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeadLabelsResponse(rsp)
}

// AddLeadLabelWithBodyWithResponse request with arbitrary body returning *AddLeadLabelResponse
func (c *ClientWithResponses) AddLeadLabelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddLeadLabelResponse, error) {
	rsp, err := c.AddLeadLabelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddLeadLabelResponse(rsp)
}

func (c *ClientWithResponses) AddLeadLabelWithResponse(ctx context.Context, body AddLeadLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*AddLeadLabelResponse, error) {
	rsp, err := c.AddLeadLabel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddLeadLabelResponse(rsp)
}

// DeleteLeadLabelWithResponse request returning *DeleteLeadLabelResponse
func (c *ClientWithResponses) DeleteLeadLabelWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteLeadLabelResponse, error) {
	rsp, err := c.DeleteLeadLabel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLeadLabelResponse(rsp)
}

// UpdateLeadLabelWithBodyWithResponse request with arbitrary body returning *UpdateLeadLabelResponse
func (c *ClientWithResponses) UpdateLeadLabelWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLeadLabelResponse, error) {
	rsp, err := c.UpdateLeadLabelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLeadLabelResponse(rsp)
}

func (c *ClientWithResponses) UpdateLeadLabelWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateLeadLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLeadLabelResponse, error) {
	rsp, err := c.UpdateLeadLabel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLeadLabelResponse(rsp)
}

// GetLeadSourcesWithResponse request returning *GetLeadSourcesResponse
func (c *ClientWithResponses) GetLeadSourcesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLeadSourcesResponse, error) {
	rsp, err := c.GetLeadSources(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeadSourcesResponse(rsp)
}

// GetLeadsWithResponse request returning *GetLeadsResponse
func (c *ClientWithResponses) GetLeadsWithResponse(ctx context.Context, params *GetLeadsParams, reqEditors ...RequestEditorFn) (*GetLeadsResponse, error) {
	rsp, err := c.GetLeads(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeadsResponse(rsp)
}

// AddLeadWithBodyWithResponse request with arbitrary body returning *AddLeadResponse
func (c *ClientWithResponses) AddLeadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddLeadResponse, error) {
	rsp, err := c.AddLeadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddLeadResponse(rsp)
}

func (c *ClientWithResponses) AddLeadWithResponse(ctx context.Context, body AddLeadJSONRequestBody, reqEditors ...RequestEditorFn) (*AddLeadResponse, error) {
	rsp, err := c.AddLead(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddLeadResponse(rsp)
}

// GetArchivedLeadsWithResponse request returning *GetArchivedLeadsResponse
func (c *ClientWithResponses) GetArchivedLeadsWithResponse(ctx context.Context, params *GetArchivedLeadsParams, reqEditors ...RequestEditorFn) (*GetArchivedLeadsResponse, error) {
	rsp, err := c.GetArchivedLeads(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArchivedLeadsResponse(rsp)
}

// DeleteLeadWithResponse request returning *DeleteLeadResponse
func (c *ClientWithResponses) DeleteLeadWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteLeadResponse, error) {
	rsp, err := c.DeleteLead(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLeadResponse(rsp)
}

// GetLeadWithResponse request returning *GetLeadResponse
func (c *ClientWithResponses) GetLeadWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetLeadResponse, error) {
	rsp, err := c.GetLead(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeadResponse(rsp)
}

// UpdateLeadWithBodyWithResponse request with arbitrary body returning *UpdateLeadResponse
func (c *ClientWithResponses) UpdateLeadWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLeadResponse, error) {
	rsp, err := c.UpdateLeadWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLeadResponse(rsp)
}

func (c *ClientWithResponses) UpdateLeadWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateLeadJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLeadResponse, error) {
	rsp, err := c.UpdateLead(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLeadResponse(rsp)
}

// GetLeadUsersWithResponse request returning *GetLeadUsersResponse
func (c *ClientWithResponses) GetLeadUsersWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLeadUsersResponse, error) {
	rsp, err := c.GetLeadUsers(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeadUsersResponse(rsp)
}

// GetTeamsWithResponse request returning *GetTeamsResponse
func (c *ClientWithResponses) GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error) {
	rsp, err := c.GetTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsResponse(rsp)
}

// AddTeamWithBodyWithResponse request with arbitrary body returning *AddTeamResponse
func (c *ClientWithResponses) AddTeamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTeamResponse, error) {
	rsp, err := c.AddTeamWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamResponse(rsp)
}

func (c *ClientWithResponses) AddTeamWithResponse(ctx context.Context, body AddTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTeamResponse, error) {
	rsp, err := c.AddTeam(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamResponse(rsp)
}

// GetUserTeamsWithResponse request returning *GetUserTeamsResponse
func (c *ClientWithResponses) GetUserTeamsWithResponse(ctx context.Context, id int, params *GetUserTeamsParams, reqEditors ...RequestEditorFn) (*GetUserTeamsResponse, error) {
	rsp, err := c.GetUserTeams(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserTeamsResponse(rsp)
}

// GetTeamWithResponse request returning *GetTeamResponse
func (c *ClientWithResponses) GetTeamWithResponse(ctx context.Context, id int, params *GetTeamParams, reqEditors ...RequestEditorFn) (*GetTeamResponse, error) {
	rsp, err := c.GetTeam(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamResponse(rsp)
}

// UpdateTeamWithBodyWithResponse request with arbitrary body returning *UpdateTeamResponse
func (c *ClientWithResponses) UpdateTeamWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error) {
	rsp, err := c.UpdateTeamWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamResponse(rsp)
}

func (c *ClientWithResponses) UpdateTeamWithResponse(ctx context.Context, id int, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error) {
	rsp, err := c.UpdateTeam(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamResponse(rsp)
}

// DeleteTeamUserWithBodyWithResponse request with arbitrary body returning *DeleteTeamUserResponse
func (c *ClientWithResponses) DeleteTeamUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTeamUserResponse, error) {
	rsp, err := c.DeleteTeamUserWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamUserResponse(rsp)
}

func (c *ClientWithResponses) DeleteTeamUserWithResponse(ctx context.Context, id int, body DeleteTeamUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTeamUserResponse, error) {
	rsp, err := c.DeleteTeamUser(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamUserResponse(rsp)
}

// GetTeamUsersWithResponse request returning *GetTeamUsersResponse
func (c *ClientWithResponses) GetTeamUsersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTeamUsersResponse, error) {
	rsp, err := c.GetTeamUsers(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamUsersResponse(rsp)
}

// AddTeamUserWithBodyWithResponse request with arbitrary body returning *AddTeamUserResponse
func (c *ClientWithResponses) AddTeamUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTeamUserResponse, error) {
	rsp, err := c.AddTeamUserWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamUserResponse(rsp)
}

func (c *ClientWithResponses) AddTeamUserWithResponse(ctx context.Context, id int, body AddTeamUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTeamUserResponse, error) {
	rsp, err := c.AddTeamUser(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamUserResponse(rsp)
}

// GetMailMessageWithResponse request returning *GetMailMessageResponse
func (c *ClientWithResponses) GetMailMessageWithResponse(ctx context.Context, id int, params *GetMailMessageParams, reqEditors ...RequestEditorFn) (*GetMailMessageResponse, error) {
	rsp, err := c.GetMailMessage(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailMessageResponse(rsp)
}

// GetMailThreadsWithResponse request returning *GetMailThreadsResponse
func (c *ClientWithResponses) GetMailThreadsWithResponse(ctx context.Context, params *GetMailThreadsParams, reqEditors ...RequestEditorFn) (*GetMailThreadsResponse, error) {
	rsp, err := c.GetMailThreads(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailThreadsResponse(rsp)
}

// DeleteMailThreadWithResponse request returning *DeleteMailThreadResponse
func (c *ClientWithResponses) DeleteMailThreadWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteMailThreadResponse, error) {
	rsp, err := c.DeleteMailThread(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMailThreadResponse(rsp)
}

// GetMailThreadWithResponse request returning *GetMailThreadResponse
func (c *ClientWithResponses) GetMailThreadWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMailThreadResponse, error) {
	rsp, err := c.GetMailThread(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailThreadResponse(rsp)
}

// UpdateMailThreadDetailsWithBodyWithResponse request with arbitrary body returning *UpdateMailThreadDetailsResponse
func (c *ClientWithResponses) UpdateMailThreadDetailsWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMailThreadDetailsResponse, error) {
	rsp, err := c.UpdateMailThreadDetailsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMailThreadDetailsResponse(rsp)
}

func (c *ClientWithResponses) UpdateMailThreadDetailsWithFormdataBodyWithResponse(ctx context.Context, id int, body UpdateMailThreadDetailsFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateMailThreadDetailsResponse, error) {
	rsp, err := c.UpdateMailThreadDetailsWithFormdataBody(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMailThreadDetailsResponse(rsp)
}

// GetMailThreadMessagesWithResponse request returning *GetMailThreadMessagesResponse
func (c *ClientWithResponses) GetMailThreadMessagesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMailThreadMessagesResponse, error) {
	rsp, err := c.GetMailThreadMessages(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailThreadMessagesResponse(rsp)
}

// SaveUserProviderLinkWithBodyWithResponse request with arbitrary body returning *SaveUserProviderLinkResponse
func (c *ClientWithResponses) SaveUserProviderLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserProviderLinkResponse, error) {
	rsp, err := c.SaveUserProviderLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserProviderLinkResponse(rsp)
}

func (c *ClientWithResponses) SaveUserProviderLinkWithResponse(ctx context.Context, body SaveUserProviderLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveUserProviderLinkResponse, error) {
	rsp, err := c.SaveUserProviderLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserProviderLinkResponse(rsp)
}

// DeleteUserProviderLinkWithResponse request returning *DeleteUserProviderLinkResponse
func (c *ClientWithResponses) DeleteUserProviderLinkWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteUserProviderLinkResponse, error) {
	rsp, err := c.DeleteUserProviderLink(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserProviderLinkResponse(rsp)
}

// GetNoteFieldsWithResponse request returning *GetNoteFieldsResponse
func (c *ClientWithResponses) GetNoteFieldsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNoteFieldsResponse, error) {
	rsp, err := c.GetNoteFields(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNoteFieldsResponse(rsp)
}

// GetNotesWithResponse request returning *GetNotesResponse
func (c *ClientWithResponses) GetNotesWithResponse(ctx context.Context, params *GetNotesParams, reqEditors ...RequestEditorFn) (*GetNotesResponse, error) {
	rsp, err := c.GetNotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotesResponse(rsp)
}

// AddNoteWithBodyWithResponse request with arbitrary body returning *AddNoteResponse
func (c *ClientWithResponses) AddNoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddNoteResponse, error) {
	rsp, err := c.AddNoteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddNoteResponse(rsp)
}

func (c *ClientWithResponses) AddNoteWithResponse(ctx context.Context, body AddNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*AddNoteResponse, error) {
	rsp, err := c.AddNote(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddNoteResponse(rsp)
}

// DeleteNoteWithResponse request returning *DeleteNoteResponse
func (c *ClientWithResponses) DeleteNoteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteNoteResponse, error) {
	rsp, err := c.DeleteNote(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNoteResponse(rsp)
}

// GetNoteWithResponse request returning *GetNoteResponse
func (c *ClientWithResponses) GetNoteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetNoteResponse, error) {
	rsp, err := c.GetNote(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNoteResponse(rsp)
}

// UpdateNoteWithBodyWithResponse request with arbitrary body returning *UpdateNoteResponse
func (c *ClientWithResponses) UpdateNoteWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNoteResponse, error) {
	rsp, err := c.UpdateNoteWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNoteResponse(rsp)
}

func (c *ClientWithResponses) UpdateNoteWithResponse(ctx context.Context, id int, body UpdateNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNoteResponse, error) {
	rsp, err := c.UpdateNote(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNoteResponse(rsp)
}

// GetNoteCommentsWithResponse request returning *GetNoteCommentsResponse
func (c *ClientWithResponses) GetNoteCommentsWithResponse(ctx context.Context, id int, params *GetNoteCommentsParams, reqEditors ...RequestEditorFn) (*GetNoteCommentsResponse, error) {
	rsp, err := c.GetNoteComments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNoteCommentsResponse(rsp)
}

// AddNoteCommentWithBodyWithResponse request with arbitrary body returning *AddNoteCommentResponse
func (c *ClientWithResponses) AddNoteCommentWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddNoteCommentResponse, error) {
	rsp, err := c.AddNoteCommentWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddNoteCommentResponse(rsp)
}

func (c *ClientWithResponses) AddNoteCommentWithResponse(ctx context.Context, id int, body AddNoteCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*AddNoteCommentResponse, error) {
	rsp, err := c.AddNoteComment(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddNoteCommentResponse(rsp)
}

// DeleteCommentWithResponse request returning *DeleteCommentResponse
func (c *ClientWithResponses) DeleteCommentWithResponse(ctx context.Context, id int, commentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteCommentResponse, error) {
	rsp, err := c.DeleteComment(ctx, id, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommentResponse(rsp)
}

// GetCommentWithResponse request returning *GetCommentResponse
func (c *ClientWithResponses) GetCommentWithResponse(ctx context.Context, id int, commentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetCommentResponse, error) {
	rsp, err := c.GetComment(ctx, id, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommentResponse(rsp)
}

// UpdateCommentForNoteWithBodyWithResponse request with arbitrary body returning *UpdateCommentForNoteResponse
func (c *ClientWithResponses) UpdateCommentForNoteWithBodyWithResponse(ctx context.Context, id int, commentId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCommentForNoteResponse, error) {
	rsp, err := c.UpdateCommentForNoteWithBody(ctx, id, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommentForNoteResponse(rsp)
}

func (c *ClientWithResponses) UpdateCommentForNoteWithResponse(ctx context.Context, id int, commentId openapi_types.UUID, body UpdateCommentForNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCommentForNoteResponse, error) {
	rsp, err := c.UpdateCommentForNote(ctx, id, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommentForNoteResponse(rsp)
}

// AuthorizeWithResponse request returning *AuthorizeResponse
func (c *ClientWithResponses) AuthorizeWithResponse(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*AuthorizeResponse, error) {
	rsp, err := c.Authorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeResponse(rsp)
}

// GetTokensWithBodyWithResponse request with arbitrary body returning *GetTokensResponse
func (c *ClientWithResponses) GetTokensWithBodyWithResponse(ctx context.Context, params *GetTokensParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTokensResponse, error) {
	rsp, err := c.GetTokensWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokensResponse(rsp)
}

func (c *ClientWithResponses) GetTokensWithFormdataBodyWithResponse(ctx context.Context, params *GetTokensParams, body GetTokensFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetTokensResponse, error) {
	rsp, err := c.GetTokensWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokensResponse(rsp)
}

// RefreshTokensWithBodyWithResponse request with arbitrary body returning *RefreshTokensResponse
func (c *ClientWithResponses) RefreshTokensWithBodyWithResponse(ctx context.Context, params *RefreshTokensParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokensResponse, error) {
	rsp, err := c.RefreshTokensWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokensResponse(rsp)
}

func (c *ClientWithResponses) RefreshTokensWithFormdataBodyWithResponse(ctx context.Context, params *RefreshTokensParams, body RefreshTokensFormdataRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokensResponse, error) {
	rsp, err := c.RefreshTokensWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokensResponse(rsp)
}

// DeleteOrganizationFieldsWithResponse request returning *DeleteOrganizationFieldsResponse
func (c *ClientWithResponses) DeleteOrganizationFieldsWithResponse(ctx context.Context, params *DeleteOrganizationFieldsParams, reqEditors ...RequestEditorFn) (*DeleteOrganizationFieldsResponse, error) {
	rsp, err := c.DeleteOrganizationFields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationFieldsResponse(rsp)
}

// GetOrganizationRelationshipsWithResponse request returning *GetOrganizationRelationshipsResponse
func (c *ClientWithResponses) GetOrganizationRelationshipsWithResponse(ctx context.Context, params *GetOrganizationRelationshipsParams, reqEditors ...RequestEditorFn) (*GetOrganizationRelationshipsResponse, error) {
	rsp, err := c.GetOrganizationRelationships(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationRelationshipsResponse(rsp)
}

// AddOrganizationRelationshipWithBodyWithResponse request with arbitrary body returning *AddOrganizationRelationshipResponse
func (c *ClientWithResponses) AddOrganizationRelationshipWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationRelationshipResponse, error) {
	rsp, err := c.AddOrganizationRelationshipWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationRelationshipResponse(rsp)
}

func (c *ClientWithResponses) AddOrganizationRelationshipWithResponse(ctx context.Context, body AddOrganizationRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationRelationshipResponse, error) {
	rsp, err := c.AddOrganizationRelationship(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationRelationshipResponse(rsp)
}

// DeleteOrganizationRelationshipWithResponse request returning *DeleteOrganizationRelationshipResponse
func (c *ClientWithResponses) DeleteOrganizationRelationshipWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteOrganizationRelationshipResponse, error) {
	rsp, err := c.DeleteOrganizationRelationship(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationRelationshipResponse(rsp)
}

// GetOrganizationRelationshipWithResponse request returning *GetOrganizationRelationshipResponse
func (c *ClientWithResponses) GetOrganizationRelationshipWithResponse(ctx context.Context, id int, params *GetOrganizationRelationshipParams, reqEditors ...RequestEditorFn) (*GetOrganizationRelationshipResponse, error) {
	rsp, err := c.GetOrganizationRelationship(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationRelationshipResponse(rsp)
}

// UpdateOrganizationRelationshipWithBodyWithResponse request with arbitrary body returning *UpdateOrganizationRelationshipResponse
func (c *ClientWithResponses) UpdateOrganizationRelationshipWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationRelationshipResponse, error) {
	rsp, err := c.UpdateOrganizationRelationshipWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationRelationshipResponse(rsp)
}

func (c *ClientWithResponses) UpdateOrganizationRelationshipWithResponse(ctx context.Context, id int, body UpdateOrganizationRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationRelationshipResponse, error) {
	rsp, err := c.UpdateOrganizationRelationship(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationRelationshipResponse(rsp)
}

// DeleteOrganizationsWithResponse request returning *DeleteOrganizationsResponse
func (c *ClientWithResponses) DeleteOrganizationsWithResponse(ctx context.Context, params *DeleteOrganizationsParams, reqEditors ...RequestEditorFn) (*DeleteOrganizationsResponse, error) {
	rsp, err := c.DeleteOrganizations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationsResponse(rsp)
}

// GetOrganizationsCollectionWithResponse request returning *GetOrganizationsCollectionResponse
func (c *ClientWithResponses) GetOrganizationsCollectionWithResponse(ctx context.Context, params *GetOrganizationsCollectionParams, reqEditors ...RequestEditorFn) (*GetOrganizationsCollectionResponse, error) {
	rsp, err := c.GetOrganizationsCollection(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationsCollectionResponse(rsp)
}

// GetOrganizationActivitiesWithResponse request returning *GetOrganizationActivitiesResponse
func (c *ClientWithResponses) GetOrganizationActivitiesWithResponse(ctx context.Context, id int, params *GetOrganizationActivitiesParams, reqEditors ...RequestEditorFn) (*GetOrganizationActivitiesResponse, error) {
	rsp, err := c.GetOrganizationActivities(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationActivitiesResponse(rsp)
}

// GetOrganizationChangelogWithResponse request returning *GetOrganizationChangelogResponse
func (c *ClientWithResponses) GetOrganizationChangelogWithResponse(ctx context.Context, id int, params *GetOrganizationChangelogParams, reqEditors ...RequestEditorFn) (*GetOrganizationChangelogResponse, error) {
	rsp, err := c.GetOrganizationChangelog(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationChangelogResponse(rsp)
}

// GetOrganizationDealsWithResponse request returning *GetOrganizationDealsResponse
func (c *ClientWithResponses) GetOrganizationDealsWithResponse(ctx context.Context, id int, params *GetOrganizationDealsParams, reqEditors ...RequestEditorFn) (*GetOrganizationDealsResponse, error) {
	rsp, err := c.GetOrganizationDeals(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationDealsResponse(rsp)
}

// GetOrganizationFilesWithResponse request returning *GetOrganizationFilesResponse
func (c *ClientWithResponses) GetOrganizationFilesWithResponse(ctx context.Context, id int, params *GetOrganizationFilesParams, reqEditors ...RequestEditorFn) (*GetOrganizationFilesResponse, error) {
	rsp, err := c.GetOrganizationFiles(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationFilesResponse(rsp)
}

// GetOrganizationUpdatesWithResponse request returning *GetOrganizationUpdatesResponse
func (c *ClientWithResponses) GetOrganizationUpdatesWithResponse(ctx context.Context, id int, params *GetOrganizationUpdatesParams, reqEditors ...RequestEditorFn) (*GetOrganizationUpdatesResponse, error) {
	rsp, err := c.GetOrganizationUpdates(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationUpdatesResponse(rsp)
}

// GetOrganizationMailMessagesWithResponse request returning *GetOrganizationMailMessagesResponse
func (c *ClientWithResponses) GetOrganizationMailMessagesWithResponse(ctx context.Context, id int, params *GetOrganizationMailMessagesParams, reqEditors ...RequestEditorFn) (*GetOrganizationMailMessagesResponse, error) {
	rsp, err := c.GetOrganizationMailMessages(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationMailMessagesResponse(rsp)
}

// MergeOrganizationsWithBodyWithResponse request with arbitrary body returning *MergeOrganizationsResponse
func (c *ClientWithResponses) MergeOrganizationsWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeOrganizationsResponse, error) {
	rsp, err := c.MergeOrganizationsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeOrganizationsResponse(rsp)
}

func (c *ClientWithResponses) MergeOrganizationsWithResponse(ctx context.Context, id int, body MergeOrganizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeOrganizationsResponse, error) {
	rsp, err := c.MergeOrganizations(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeOrganizationsResponse(rsp)
}

// GetOrganizationUsersWithResponse request returning *GetOrganizationUsersResponse
func (c *ClientWithResponses) GetOrganizationUsersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetOrganizationUsersResponse, error) {
	rsp, err := c.GetOrganizationUsers(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationUsersResponse(rsp)
}

// GetOrganizationPersonsWithResponse request returning *GetOrganizationPersonsResponse
func (c *ClientWithResponses) GetOrganizationPersonsWithResponse(ctx context.Context, id int, params *GetOrganizationPersonsParams, reqEditors ...RequestEditorFn) (*GetOrganizationPersonsResponse, error) {
	rsp, err := c.GetOrganizationPersons(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationPersonsResponse(rsp)
}

// GetPermissionSetsWithResponse request returning *GetPermissionSetsResponse
func (c *ClientWithResponses) GetPermissionSetsWithResponse(ctx context.Context, params *GetPermissionSetsParams, reqEditors ...RequestEditorFn) (*GetPermissionSetsResponse, error) {
	rsp, err := c.GetPermissionSets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionSetsResponse(rsp)
}

// GetPermissionSetWithResponse request returning *GetPermissionSetResponse
func (c *ClientWithResponses) GetPermissionSetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPermissionSetResponse, error) {
	rsp, err := c.GetPermissionSet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionSetResponse(rsp)
}

// GetPermissionSetAssignmentsWithResponse request returning *GetPermissionSetAssignmentsResponse
func (c *ClientWithResponses) GetPermissionSetAssignmentsWithResponse(ctx context.Context, id string, params *GetPermissionSetAssignmentsParams, reqEditors ...RequestEditorFn) (*GetPermissionSetAssignmentsResponse, error) {
	rsp, err := c.GetPermissionSetAssignments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionSetAssignmentsResponse(rsp)
}

// DeletePersonFieldsWithResponse request returning *DeletePersonFieldsResponse
func (c *ClientWithResponses) DeletePersonFieldsWithResponse(ctx context.Context, params *DeletePersonFieldsParams, reqEditors ...RequestEditorFn) (*DeletePersonFieldsResponse, error) {
	rsp, err := c.DeletePersonFields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersonFieldsResponse(rsp)
}

// DeletePersonsWithResponse request returning *DeletePersonsResponse
func (c *ClientWithResponses) DeletePersonsWithResponse(ctx context.Context, params *DeletePersonsParams, reqEditors ...RequestEditorFn) (*DeletePersonsResponse, error) {
	rsp, err := c.DeletePersons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersonsResponse(rsp)
}

// GetPersonsCollectionWithResponse request returning *GetPersonsCollectionResponse
func (c *ClientWithResponses) GetPersonsCollectionWithResponse(ctx context.Context, params *GetPersonsCollectionParams, reqEditors ...RequestEditorFn) (*GetPersonsCollectionResponse, error) {
	rsp, err := c.GetPersonsCollection(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonsCollectionResponse(rsp)
}

// GetPersonActivitiesWithResponse request returning *GetPersonActivitiesResponse
func (c *ClientWithResponses) GetPersonActivitiesWithResponse(ctx context.Context, id int, params *GetPersonActivitiesParams, reqEditors ...RequestEditorFn) (*GetPersonActivitiesResponse, error) {
	rsp, err := c.GetPersonActivities(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonActivitiesResponse(rsp)
}

// GetPersonChangelogWithResponse request returning *GetPersonChangelogResponse
func (c *ClientWithResponses) GetPersonChangelogWithResponse(ctx context.Context, id int, params *GetPersonChangelogParams, reqEditors ...RequestEditorFn) (*GetPersonChangelogResponse, error) {
	rsp, err := c.GetPersonChangelog(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonChangelogResponse(rsp)
}

// GetPersonDealsWithResponse request returning *GetPersonDealsResponse
func (c *ClientWithResponses) GetPersonDealsWithResponse(ctx context.Context, id int, params *GetPersonDealsParams, reqEditors ...RequestEditorFn) (*GetPersonDealsResponse, error) {
	rsp, err := c.GetPersonDeals(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonDealsResponse(rsp)
}

// GetPersonFilesWithResponse request returning *GetPersonFilesResponse
func (c *ClientWithResponses) GetPersonFilesWithResponse(ctx context.Context, id int, params *GetPersonFilesParams, reqEditors ...RequestEditorFn) (*GetPersonFilesResponse, error) {
	rsp, err := c.GetPersonFiles(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonFilesResponse(rsp)
}

// GetPersonUpdatesWithResponse request returning *GetPersonUpdatesResponse
func (c *ClientWithResponses) GetPersonUpdatesWithResponse(ctx context.Context, id int, params *GetPersonUpdatesParams, reqEditors ...RequestEditorFn) (*GetPersonUpdatesResponse, error) {
	rsp, err := c.GetPersonUpdates(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonUpdatesResponse(rsp)
}

// GetPersonMailMessagesWithResponse request returning *GetPersonMailMessagesResponse
func (c *ClientWithResponses) GetPersonMailMessagesWithResponse(ctx context.Context, id int, params *GetPersonMailMessagesParams, reqEditors ...RequestEditorFn) (*GetPersonMailMessagesResponse, error) {
	rsp, err := c.GetPersonMailMessages(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonMailMessagesResponse(rsp)
}

// MergePersonsWithBodyWithResponse request with arbitrary body returning *MergePersonsResponse
func (c *ClientWithResponses) MergePersonsWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergePersonsResponse, error) {
	rsp, err := c.MergePersonsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergePersonsResponse(rsp)
}

func (c *ClientWithResponses) MergePersonsWithResponse(ctx context.Context, id int, body MergePersonsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergePersonsResponse, error) {
	rsp, err := c.MergePersons(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergePersonsResponse(rsp)
}

// GetPersonUsersWithResponse request returning *GetPersonUsersResponse
func (c *ClientWithResponses) GetPersonUsersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonUsersResponse, error) {
	rsp, err := c.GetPersonUsers(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonUsersResponse(rsp)
}

// DeletePersonPictureWithResponse request returning *DeletePersonPictureResponse
func (c *ClientWithResponses) DeletePersonPictureWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeletePersonPictureResponse, error) {
	rsp, err := c.DeletePersonPicture(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersonPictureResponse(rsp)
}

// AddPersonPictureWithBodyWithResponse request with arbitrary body returning *AddPersonPictureResponse
func (c *ClientWithResponses) AddPersonPictureWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPersonPictureResponse, error) {
	rsp, err := c.AddPersonPictureWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPersonPictureResponse(rsp)
}

// GetPersonProductsWithResponse request returning *GetPersonProductsResponse
func (c *ClientWithResponses) GetPersonProductsWithResponse(ctx context.Context, id int, params *GetPersonProductsParams, reqEditors ...RequestEditorFn) (*GetPersonProductsResponse, error) {
	rsp, err := c.GetPersonProducts(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonProductsResponse(rsp)
}

// GetPipelineConversionStatisticsWithResponse request returning *GetPipelineConversionStatisticsResponse
func (c *ClientWithResponses) GetPipelineConversionStatisticsWithResponse(ctx context.Context, id int, params *GetPipelineConversionStatisticsParams, reqEditors ...RequestEditorFn) (*GetPipelineConversionStatisticsResponse, error) {
	rsp, err := c.GetPipelineConversionStatistics(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineConversionStatisticsResponse(rsp)
}

// GetPipelineDealsWithResponse request returning *GetPipelineDealsResponse
func (c *ClientWithResponses) GetPipelineDealsWithResponse(ctx context.Context, id int, params *GetPipelineDealsParams, reqEditors ...RequestEditorFn) (*GetPipelineDealsResponse, error) {
	rsp, err := c.GetPipelineDeals(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineDealsResponse(rsp)
}

// GetPipelineMovementStatisticsWithResponse request returning *GetPipelineMovementStatisticsResponse
func (c *ClientWithResponses) GetPipelineMovementStatisticsWithResponse(ctx context.Context, id int, params *GetPipelineMovementStatisticsParams, reqEditors ...RequestEditorFn) (*GetPipelineMovementStatisticsResponse, error) {
	rsp, err := c.GetPipelineMovementStatistics(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineMovementStatisticsResponse(rsp)
}

// DeleteProductFieldsWithResponse request returning *DeleteProductFieldsResponse
func (c *ClientWithResponses) DeleteProductFieldsWithResponse(ctx context.Context, params *DeleteProductFieldsParams, reqEditors ...RequestEditorFn) (*DeleteProductFieldsResponse, error) {
	rsp, err := c.DeleteProductFields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductFieldsResponse(rsp)
}

// GetProductDealsWithResponse request returning *GetProductDealsResponse
func (c *ClientWithResponses) GetProductDealsWithResponse(ctx context.Context, id int, params *GetProductDealsParams, reqEditors ...RequestEditorFn) (*GetProductDealsResponse, error) {
	rsp, err := c.GetProductDeals(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductDealsResponse(rsp)
}

// GetProductFilesWithResponse request returning *GetProductFilesResponse
func (c *ClientWithResponses) GetProductFilesWithResponse(ctx context.Context, id int, params *GetProductFilesParams, reqEditors ...RequestEditorFn) (*GetProductFilesResponse, error) {
	rsp, err := c.GetProductFiles(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductFilesResponse(rsp)
}

// GetProductUsersWithResponse request returning *GetProductUsersResponse
func (c *ClientWithResponses) GetProductUsersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProductUsersResponse, error) {
	rsp, err := c.GetProductUsers(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductUsersResponse(rsp)
}

// GetProjectTemplatesWithResponse request returning *GetProjectTemplatesResponse
func (c *ClientWithResponses) GetProjectTemplatesWithResponse(ctx context.Context, params *GetProjectTemplatesParams, reqEditors ...RequestEditorFn) (*GetProjectTemplatesResponse, error) {
	rsp, err := c.GetProjectTemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectTemplatesResponse(rsp)
}

// GetProjectTemplateWithResponse request returning *GetProjectTemplateResponse
func (c *ClientWithResponses) GetProjectTemplateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectTemplateResponse, error) {
	rsp, err := c.GetProjectTemplate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectTemplateResponse(rsp)
}

// GetProjectsWithResponse request returning *GetProjectsResponse
func (c *ClientWithResponses) GetProjectsWithResponse(ctx context.Context, params *GetProjectsParams, reqEditors ...RequestEditorFn) (*GetProjectsResponse, error) {
	rsp, err := c.GetProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsResponse(rsp)
}

// AddProjectWithBodyWithResponse request with arbitrary body returning *AddProjectResponse
func (c *ClientWithResponses) AddProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProjectResponse, error) {
	rsp, err := c.AddProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProjectResponse(rsp)
}

func (c *ClientWithResponses) AddProjectWithResponse(ctx context.Context, body AddProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProjectResponse, error) {
	rsp, err := c.AddProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProjectResponse(rsp)
}

// GetProjectsBoardsWithResponse request returning *GetProjectsBoardsResponse
func (c *ClientWithResponses) GetProjectsBoardsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProjectsBoardsResponse, error) {
	rsp, err := c.GetProjectsBoards(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsBoardsResponse(rsp)
}

// GetProjectsBoardWithResponse request returning *GetProjectsBoardResponse
func (c *ClientWithResponses) GetProjectsBoardWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectsBoardResponse, error) {
	rsp, err := c.GetProjectsBoard(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsBoardResponse(rsp)
}

// GetProjectsPhasesWithResponse request returning *GetProjectsPhasesResponse
func (c *ClientWithResponses) GetProjectsPhasesWithResponse(ctx context.Context, params *GetProjectsPhasesParams, reqEditors ...RequestEditorFn) (*GetProjectsPhasesResponse, error) {
	rsp, err := c.GetProjectsPhases(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsPhasesResponse(rsp)
}

// GetProjectsPhaseWithResponse request returning *GetProjectsPhaseResponse
func (c *ClientWithResponses) GetProjectsPhaseWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectsPhaseResponse, error) {
	rsp, err := c.GetProjectsPhase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsPhaseResponse(rsp)
}

// DeleteProjectWithResponse request returning *DeleteProjectResponse
func (c *ClientWithResponses) DeleteProjectWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error) {
	rsp, err := c.DeleteProject(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectResponse(rsp)
}

// GetProjectWithResponse request returning *GetProjectResponse
func (c *ClientWithResponses) GetProjectWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectResponse, error) {
	rsp, err := c.GetProject(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectResponse(rsp)
}

// UpdateProjectWithBodyWithResponse request with arbitrary body returning *UpdateProjectResponse
func (c *ClientWithResponses) UpdateProjectWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProjectWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectWithResponse(ctx context.Context, id int, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProject(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

// GetProjectActivitiesWithResponse request returning *GetProjectActivitiesResponse
func (c *ClientWithResponses) GetProjectActivitiesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectActivitiesResponse, error) {
	rsp, err := c.GetProjectActivities(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectActivitiesResponse(rsp)
}

// ArchiveProjectWithResponse request returning *ArchiveProjectResponse
func (c *ClientWithResponses) ArchiveProjectWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ArchiveProjectResponse, error) {
	rsp, err := c.ArchiveProject(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveProjectResponse(rsp)
}

// GetProjectGroupsWithResponse request returning *GetProjectGroupsResponse
func (c *ClientWithResponses) GetProjectGroupsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectGroupsResponse, error) {
	rsp, err := c.GetProjectGroups(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectGroupsResponse(rsp)
}

// GetProjectPlanWithResponse request returning *GetProjectPlanResponse
func (c *ClientWithResponses) GetProjectPlanWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectPlanResponse, error) {
	rsp, err := c.GetProjectPlan(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectPlanResponse(rsp)
}

// PutProjectPlanActivityWithBodyWithResponse request with arbitrary body returning *PutProjectPlanActivityResponse
func (c *ClientWithResponses) PutProjectPlanActivityWithBodyWithResponse(ctx context.Context, id int, activityId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutProjectPlanActivityResponse, error) {
	rsp, err := c.PutProjectPlanActivityWithBody(ctx, id, activityId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutProjectPlanActivityResponse(rsp)
}

func (c *ClientWithResponses) PutProjectPlanActivityWithResponse(ctx context.Context, id int, activityId int, body PutProjectPlanActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*PutProjectPlanActivityResponse, error) {
	rsp, err := c.PutProjectPlanActivity(ctx, id, activityId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutProjectPlanActivityResponse(rsp)
}

// PutProjectPlanTaskWithBodyWithResponse request with arbitrary body returning *PutProjectPlanTaskResponse
func (c *ClientWithResponses) PutProjectPlanTaskWithBodyWithResponse(ctx context.Context, id int, taskId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutProjectPlanTaskResponse, error) {
	rsp, err := c.PutProjectPlanTaskWithBody(ctx, id, taskId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutProjectPlanTaskResponse(rsp)
}

func (c *ClientWithResponses) PutProjectPlanTaskWithResponse(ctx context.Context, id int, taskId int, body PutProjectPlanTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*PutProjectPlanTaskResponse, error) {
	rsp, err := c.PutProjectPlanTask(ctx, id, taskId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutProjectPlanTaskResponse(rsp)
}

// GetProjectTasksWithResponse request returning *GetProjectTasksResponse
func (c *ClientWithResponses) GetProjectTasksWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProjectTasksResponse, error) {
	rsp, err := c.GetProjectTasks(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectTasksResponse(rsp)
}

// GetRecentsWithResponse request returning *GetRecentsResponse
func (c *ClientWithResponses) GetRecentsWithResponse(ctx context.Context, params *GetRecentsParams, reqEditors ...RequestEditorFn) (*GetRecentsResponse, error) {
	rsp, err := c.GetRecents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecentsResponse(rsp)
}

// GetRolesWithResponse request returning *GetRolesResponse
func (c *ClientWithResponses) GetRolesWithResponse(ctx context.Context, params *GetRolesParams, reqEditors ...RequestEditorFn) (*GetRolesResponse, error) {
	rsp, err := c.GetRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolesResponse(rsp)
}

// AddRoleWithBodyWithResponse request with arbitrary body returning *AddRoleResponse
func (c *ClientWithResponses) AddRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRoleResponse, error) {
	rsp, err := c.AddRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRoleResponse(rsp)
}

func (c *ClientWithResponses) AddRoleWithResponse(ctx context.Context, body AddRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRoleResponse, error) {
	rsp, err := c.AddRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRoleResponse(rsp)
}

// DeleteRoleWithResponse request returning *DeleteRoleResponse
func (c *ClientWithResponses) DeleteRoleWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error) {
	rsp, err := c.DeleteRole(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// UpdateRoleWithBodyWithResponse request with arbitrary body returning *UpdateRoleResponse
func (c *ClientWithResponses) UpdateRoleWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRoleWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleWithResponse(ctx context.Context, id int, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRole(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

// DeleteRoleAssignmentWithBodyWithResponse request with arbitrary body returning *DeleteRoleAssignmentResponse
func (c *ClientWithResponses) DeleteRoleAssignmentWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRoleAssignmentResponse, error) {
	rsp, err := c.DeleteRoleAssignmentWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleAssignmentResponse(rsp)
}

func (c *ClientWithResponses) DeleteRoleAssignmentWithResponse(ctx context.Context, id int, body DeleteRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRoleAssignmentResponse, error) {
	rsp, err := c.DeleteRoleAssignment(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleAssignmentResponse(rsp)
}

// GetRoleAssignmentsWithResponse request returning *GetRoleAssignmentsResponse
func (c *ClientWithResponses) GetRoleAssignmentsWithResponse(ctx context.Context, id int, params *GetRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*GetRoleAssignmentsResponse, error) {
	rsp, err := c.GetRoleAssignments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleAssignmentsResponse(rsp)
}

// AddRoleAssignmentWithBodyWithResponse request with arbitrary body returning *AddRoleAssignmentResponse
func (c *ClientWithResponses) AddRoleAssignmentWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRoleAssignmentResponse, error) {
	rsp, err := c.AddRoleAssignmentWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRoleAssignmentResponse(rsp)
}

func (c *ClientWithResponses) AddRoleAssignmentWithResponse(ctx context.Context, id int, body AddRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRoleAssignmentResponse, error) {
	rsp, err := c.AddRoleAssignment(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRoleAssignmentResponse(rsp)
}

// GetRolePipelinesWithResponse request returning *GetRolePipelinesResponse
func (c *ClientWithResponses) GetRolePipelinesWithResponse(ctx context.Context, id int, params *GetRolePipelinesParams, reqEditors ...RequestEditorFn) (*GetRolePipelinesResponse, error) {
	rsp, err := c.GetRolePipelines(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolePipelinesResponse(rsp)
}

// UpdateRolePipelinesWithBodyWithResponse request with arbitrary body returning *UpdateRolePipelinesResponse
func (c *ClientWithResponses) UpdateRolePipelinesWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRolePipelinesResponse, error) {
	rsp, err := c.UpdateRolePipelinesWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRolePipelinesResponse(rsp)
}

func (c *ClientWithResponses) UpdateRolePipelinesWithResponse(ctx context.Context, id int, body UpdateRolePipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRolePipelinesResponse, error) {
	rsp, err := c.UpdateRolePipelines(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRolePipelinesResponse(rsp)
}

// GetRoleSettingsWithResponse request returning *GetRoleSettingsResponse
func (c *ClientWithResponses) GetRoleSettingsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetRoleSettingsResponse, error) {
	rsp, err := c.GetRoleSettings(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleSettingsResponse(rsp)
}

// AddOrUpdateRoleSettingWithBodyWithResponse request with arbitrary body returning *AddOrUpdateRoleSettingResponse
func (c *ClientWithResponses) AddOrUpdateRoleSettingWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateRoleSettingResponse, error) {
	rsp, err := c.AddOrUpdateRoleSettingWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateRoleSettingResponse(rsp)
}

func (c *ClientWithResponses) AddOrUpdateRoleSettingWithResponse(ctx context.Context, id int, body AddOrUpdateRoleSettingJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateRoleSettingResponse, error) {
	rsp, err := c.AddOrUpdateRoleSetting(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateRoleSettingResponse(rsp)
}

// DeleteStagesWithResponse request returning *DeleteStagesResponse
func (c *ClientWithResponses) DeleteStagesWithResponse(ctx context.Context, params *DeleteStagesParams, reqEditors ...RequestEditorFn) (*DeleteStagesResponse, error) {
	rsp, err := c.DeleteStages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStagesResponse(rsp)
}

// GetStageDealsWithResponse request returning *GetStageDealsResponse
func (c *ClientWithResponses) GetStageDealsWithResponse(ctx context.Context, id int, params *GetStageDealsParams, reqEditors ...RequestEditorFn) (*GetStageDealsResponse, error) {
	rsp, err := c.GetStageDeals(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStageDealsResponse(rsp)
}

// GetTasksWithResponse request returning *GetTasksResponse
func (c *ClientWithResponses) GetTasksWithResponse(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*GetTasksResponse, error) {
	rsp, err := c.GetTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTasksResponse(rsp)
}

// AddTaskWithBodyWithResponse request with arbitrary body returning *AddTaskResponse
func (c *ClientWithResponses) AddTaskWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTaskResponse, error) {
	rsp, err := c.AddTaskWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTaskResponse(rsp)
}

func (c *ClientWithResponses) AddTaskWithResponse(ctx context.Context, body AddTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTaskResponse, error) {
	rsp, err := c.AddTask(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTaskResponse(rsp)
}

// DeleteTaskWithResponse request returning *DeleteTaskResponse
func (c *ClientWithResponses) DeleteTaskWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteTaskResponse, error) {
	rsp, err := c.DeleteTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaskResponse(rsp)
}

// GetTaskWithResponse request returning *GetTaskResponse
func (c *ClientWithResponses) GetTaskWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTaskResponse, error) {
	rsp, err := c.GetTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaskResponse(rsp)
}

// UpdateTaskWithBodyWithResponse request with arbitrary body returning *UpdateTaskResponse
func (c *ClientWithResponses) UpdateTaskWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error) {
	rsp, err := c.UpdateTaskWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTaskResponse(rsp)
}

func (c *ClientWithResponses) UpdateTaskWithResponse(ctx context.Context, id int, body UpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error) {
	rsp, err := c.UpdateTask(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTaskResponse(rsp)
}

// GetUserConnectionsWithResponse request returning *GetUserConnectionsResponse
func (c *ClientWithResponses) GetUserConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserConnectionsResponse, error) {
	rsp, err := c.GetUserConnections(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserConnectionsResponse(rsp)
}

// GetUserSettingsWithResponse request returning *GetUserSettingsResponse
func (c *ClientWithResponses) GetUserSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserSettingsResponse, error) {
	rsp, err := c.GetUserSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserSettingsResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// AddUserWithBodyWithResponse request with arbitrary body returning *AddUserResponse
func (c *ClientWithResponses) AddUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserResponse, error) {
	rsp, err := c.AddUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserResponse(rsp)
}

func (c *ClientWithResponses) AddUserWithResponse(ctx context.Context, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserResponse, error) {
	rsp, err := c.AddUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserResponse(rsp)
}

// FindUsersByNameWithResponse request returning *FindUsersByNameResponse
func (c *ClientWithResponses) FindUsersByNameWithResponse(ctx context.Context, params *FindUsersByNameParams, reqEditors ...RequestEditorFn) (*FindUsersByNameResponse, error) {
	rsp, err := c.FindUsersByName(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindUsersByNameResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// GetUserPermissionsWithResponse request returning *GetUserPermissionsResponse
func (c *ClientWithResponses) GetUserPermissionsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUserPermissionsResponse, error) {
	rsp, err := c.GetUserPermissions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserPermissionsResponse(rsp)
}

// GetUserRoleAssignmentsWithResponse request returning *GetUserRoleAssignmentsResponse
func (c *ClientWithResponses) GetUserRoleAssignmentsWithResponse(ctx context.Context, id int, params *GetUserRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*GetUserRoleAssignmentsResponse, error) {
	rsp, err := c.GetUserRoleAssignments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserRoleAssignmentsResponse(rsp)
}

// GetUserRoleSettingsWithResponse request returning *GetUserRoleSettingsResponse
func (c *ClientWithResponses) GetUserRoleSettingsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUserRoleSettingsResponse, error) {
	rsp, err := c.GetUserRoleSettings(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserRoleSettingsResponse(rsp)
}

// GetWebhooksWithResponse request returning *GetWebhooksResponse
func (c *ClientWithResponses) GetWebhooksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebhooksResponse, error) {
	rsp, err := c.GetWebhooks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhooksResponse(rsp)
}

// AddWebhookWithBodyWithResponse request with arbitrary body returning *AddWebhookResponse
func (c *ClientWithResponses) AddWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddWebhookResponse, error) {
	rsp, err := c.AddWebhookWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddWebhookResponse(rsp)
}

func (c *ClientWithResponses) AddWebhookWithResponse(ctx context.Context, body AddWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*AddWebhookResponse, error) {
	rsp, err := c.AddWebhook(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddWebhookResponse(rsp)
}

// DeleteWebhookWithResponse request returning *DeleteWebhookResponse
func (c *ClientWithResponses) DeleteWebhookWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error) {
	rsp, err := c.DeleteWebhook(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookResponse(rsp)
}

// ParseDeleteActivitiesResponse parses an HTTP response from a DeleteActivitiesWithResponse call
func ParseDeleteActivitiesResponse(rsp *http.Response) (*DeleteActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id An array of the IDs of activities that were deleted
				Id *[]int `json:"id,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetActivitiesCollectionResponse parses an HTTP response from a GetActivitiesCollectionWithResponse call
func ParseGetActivitiesCollectionResponse(rsp *http.Response) (*GetActivitiesCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivitiesCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// ActiveFlag Whether the activity is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// BusyFlag Marks if the activity is set as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
				BusyFlag *bool `json:"busy_flag,omitempty"`

				// CompanyId The user's company ID
				CompanyId *int `json:"company_id,omitempty"`

				// ConferenceMeetingClient The ID of the Marketplace app, which is connected to this activity
				ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

				// ConferenceMeetingId The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
				ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

				// ConferenceMeetingUrl The link to join the meeting which is associated with this activity
				ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

				// DealId The ID of the deal this activity is associated with
				DealId *int `json:"deal_id,omitempty"`

				// Done Whether the activity is done or not
				Done *bool `json:"done,omitempty"`

				// DueDate The due date of the activity. Format: YYYY-MM-DD
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// DueTime The due time of the activity in UTC. Format: HH:MM
				DueTime *string `json:"due_time,omitempty"`

				// Duration The duration of the activity. Format: HH:MM
				Duration *string `json:"duration,omitempty"`

				// Id The ID of the activity, generated when the activity was created
				Id *int `json:"id,omitempty"`

				// LeadId The ID of the lead in the UUID format this activity is associated with
				LeadId *openapi_types.UUID `json:"lead_id"`

				// Location The address of the activity.
				Location *string `json:"location,omitempty"`

				// LocationAdminAreaLevel1 A subfield of the location field. Indicates state/county.
				LocationAdminAreaLevel1 *string `json:"location_admin_area_level_1,omitempty"`

				// LocationAdminAreaLevel2 A subfield of the location field. Indicates region.
				LocationAdminAreaLevel2 *string `json:"location_admin_area_level_2,omitempty"`

				// LocationCountry A subfield of the location field. Indicates country.
				LocationCountry *string `json:"location_country,omitempty"`

				// LocationFormattedAddress A subfield of the location field. Indicates full/combined address.
				LocationFormattedAddress *string `json:"location_formatted_address,omitempty"`

				// LocationLocality A subfield of the location field. Indicates city/town/village/locality.
				LocationLocality *string `json:"location_locality,omitempty"`

				// LocationPostalCode A subfield of the location field. Indicates ZIP/postal code.
				LocationPostalCode *string `json:"location_postal_code,omitempty"`

				// LocationRoute A subfield of the location field. Indicates street name.
				LocationRoute *string `json:"location_route,omitempty"`

				// LocationStreetNumber A subfield of the location field. Indicates house number.
				LocationStreetNumber *string `json:"location_street_number,omitempty"`

				// LocationSublocality A subfield of the location field. Indicates district/sublocality.
				LocationSublocality *string `json:"location_sublocality,omitempty"`

				// LocationSubpremise A subfield of the location field. Indicates apartment/suite number.
				LocationSubpremise *string `json:"location_subpremise,omitempty"`

				// MarkedAsDoneTime The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// OrgId The ID of the organization this activity is associated with
				OrgId *int `json:"org_id,omitempty"`

				// PersonId The ID of the person this activity is associated with
				PersonId *int `json:"person_id,omitempty"`

				// ProjectId The ID of the project this activity is associated with
				ProjectId *int `json:"project_id"`

				// PublicDescription Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
				PublicDescription *string `json:"public_description,omitempty"`

				// SourceTimezone The timezone the activity was created in an external calendar
				SourceTimezone *string `json:"source_timezone,omitempty"`

				// Subject The subject of the activity
				Subject *string `json:"subject,omitempty"`

				// Type The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
				Type *string `json:"type,omitempty"`

				// UpdateTime The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`

				// UpdateUserId The ID of the user who was the last to update this activity
				UpdateUserId *int `json:"update_user_id,omitempty"`

				// UserId The ID of the user whom the activity is assigned to
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteActivityTypesResponse parses an HTTP response from a DeleteActivityTypesWithResponse call
func ParseDeleteActivityTypesResponse(rsp *http.Response) (*DeleteActivityTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteActivityTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The IDs of the deleted activity types
				Id *[]int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetActivityTypesResponse parses an HTTP response from a GetActivityTypesWithResponse call
func ParseGetActivityTypesResponse(rsp *http.Response) (*GetActivityTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The array of activity types
			Data *[]struct {
				// ActiveFlag The active flag of the activity type
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation time of the activity type
				AddTime *time.Time `json:"add_time,omitempty"`

				// Color A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
				Color *string `json:"color,omitempty"`

				// IconKey Icon graphic to use for representing this activity type
				IconKey *GetActivityTypes200DataIconKey `json:"icon_key,omitempty"`

				// Id The ID of the activity type
				Id *int `json:"id,omitempty"`

				// IsCustomFlag Whether the activity type is a custom one or not
				IsCustomFlag *bool `json:"is_custom_flag,omitempty"`

				// KeyString A string that is generated by the API based on the given name of the activity type upon creation
				KeyString *string `json:"key_string,omitempty"`

				// Name The name of the activity type
				Name *string `json:"name,omitempty"`

				// OrderNr An order number for the activity type. Order numbers should be used to order the types in the activity type selections.
				OrderNr *int `json:"order_nr,omitempty"`

				// UpdateTime The update time of the activity type
				UpdateTime *time.Time `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddActivityTypeResponse parses an HTTP response from a AddActivityTypeWithResponse call
func ParseAddActivityTypeResponse(rsp *http.Response) (*AddActivityTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddActivityTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag The active flag of the activity type
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation time of the activity type
				AddTime *time.Time `json:"add_time,omitempty"`

				// Color A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
				Color *string `json:"color,omitempty"`

				// IconKey Icon graphic to use for representing this activity type
				IconKey *AddActivityType200DataIconKey `json:"icon_key,omitempty"`

				// Id The ID of the activity type
				Id *int `json:"id,omitempty"`

				// IsCustomFlag Whether the activity type is a custom one or not
				IsCustomFlag *bool `json:"is_custom_flag,omitempty"`

				// KeyString A string that is generated by the API based on the given name of the activity type upon creation
				KeyString *string `json:"key_string,omitempty"`

				// Name The name of the activity type
				Name *string `json:"name,omitempty"`

				// OrderNr An order number for the activity type. Order numbers should be used to order the types in the activity type selections.
				OrderNr *int `json:"order_nr,omitempty"`

				// UpdateTime The update time of the activity type
				UpdateTime *time.Time `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteActivityTypeResponse parses an HTTP response from a DeleteActivityTypeWithResponse call
func ParseDeleteActivityTypeResponse(rsp *http.Response) (*DeleteActivityTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteActivityTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag The active flag of the activity type
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation time of the activity type
				AddTime *time.Time `json:"add_time,omitempty"`

				// Color A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
				Color *string `json:"color,omitempty"`

				// IconKey Icon graphic to use for representing this activity type
				IconKey *DeleteActivityType200DataIconKey `json:"icon_key,omitempty"`

				// Id The ID of the activity type
				Id *int `json:"id,omitempty"`

				// IsCustomFlag Whether the activity type is a custom one or not
				IsCustomFlag *bool `json:"is_custom_flag,omitempty"`

				// KeyString A string that is generated by the API based on the given name of the activity type upon creation
				KeyString *string `json:"key_string,omitempty"`

				// Name The name of the activity type
				Name *string `json:"name,omitempty"`

				// OrderNr An order number for the activity type. Order numbers should be used to order the types in the activity type selections.
				OrderNr *int `json:"order_nr,omitempty"`

				// UpdateTime The update time of the activity type
				UpdateTime *time.Time `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateActivityTypeResponse parses an HTTP response from a UpdateActivityTypeWithResponse call
func ParseUpdateActivityTypeResponse(rsp *http.Response) (*UpdateActivityTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateActivityTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag The active flag of the activity type
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation time of the activity type
				AddTime *time.Time `json:"add_time,omitempty"`

				// Color A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
				Color *string `json:"color,omitempty"`

				// IconKey Icon graphic to use for representing this activity type
				IconKey *UpdateActivityType200DataIconKey `json:"icon_key,omitempty"`

				// Id The ID of the activity type
				Id *int `json:"id,omitempty"`

				// IsCustomFlag Whether the activity type is a custom one or not
				IsCustomFlag *bool `json:"is_custom_flag,omitempty"`

				// KeyString A string that is generated by the API based on the given name of the activity type upon creation
				KeyString *string `json:"key_string,omitempty"`

				// Name The name of the activity type
				Name *string `json:"name,omitempty"`

				// OrderNr An order number for the activity type. Order numbers should be used to order the types in the activity type selections.
				OrderNr *int `json:"order_nr,omitempty"`

				// UpdateTime The update time of the activity type
				UpdateTime *time.Time `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompanyAddonsResponse parses an HTTP response from a GetCompanyAddonsWithResponse call
func ParseGetCompanyAddonsResponse(rsp *http.Response) (*GetCompanyAddonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompanyAddonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An array of add-ons that the company has.
			Data *[]map[string]interface{} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserCallLogsResponse parses an HTTP response from a GetUserCallLogsWithResponse call
func ParseGetUserCallLogsResponse(rsp *http.Response) (*GetUserCallLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserCallLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// Pagination The additional data of the list
				Pagination *struct {
					// Limit Items shown per page
					Limit *int `json:"limit,omitempty"`

					// MoreItemsInCollection If there are more list items in the collection than displayed or not
					MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

					// Start Pagination start
					Start *int `json:"start,omitempty"`
				} `json:"pagination,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// ActivityId If specified, this activity will be converted into a call log, with the information provided. When this field is used, you don't need to specify `deal_id`, `person_id` or `org_id`, as they will be ignored in favor of the values already available in the activity. The `activity_id` must refer to a `call` type activity.
				ActivityId *int `json:"activity_id,omitempty"`

				// CompanyId The company ID of the owner of the call log
				CompanyId *int `json:"company_id,omitempty"`

				// DealId The ID of the deal this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
				DealId *int `json:"deal_id,omitempty"`

				// Duration The duration of the call in seconds
				Duration *string `json:"duration,omitempty"`

				// EndTime The date and time of the end of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
				EndTime time.Time `json:"end_time"`

				// FromPhoneNumber The number that made the call
				FromPhoneNumber *string `json:"from_phone_number,omitempty"`

				// HasRecording If the call log has an audio recording attached, the value should be true
				HasRecording *bool `json:"has_recording,omitempty"`

				// Id The call log ID, generated when the call log was created
				Id *string `json:"id,omitempty"`

				// LeadId The ID of the lead in the UUID format this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// Note The note for the call log in HTML format
				Note *string `json:"note,omitempty"`

				// OrgId The ID of the organization this call is associated with
				OrgId *int `json:"org_id,omitempty"`

				// Outcome Describes the outcome of the call
				Outcome GetUserCallLogs200DataOutcome `json:"outcome"`

				// PersonId The ID of the person this call is associated with
				PersonId *int `json:"person_id,omitempty"`

				// StartTime The date and time of the start of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
				StartTime time.Time `json:"start_time"`

				// Subject The name of the activity this call is attached to
				Subject *string `json:"subject,omitempty"`

				// ToPhoneNumber The number called
				ToPhoneNumber string `json:"to_phone_number"`

				// UserId The ID of the owner of the call log. Please note that a user without account settings access cannot create call logs for other users.
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddCallLogResponse parses an HTTP response from a AddCallLogWithResponse call
func ParseAddCallLogResponse(rsp *http.Response) (*AddCallLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddCallLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActivityId If specified, this activity will be converted into a call log, with the information provided. When this field is used, you don't need to specify `deal_id`, `person_id` or `org_id`, as they will be ignored in favor of the values already available in the activity. The `activity_id` must refer to a `call` type activity.
				ActivityId *int `json:"activity_id,omitempty"`

				// CompanyId The company ID of the owner of the call log
				CompanyId *int `json:"company_id,omitempty"`

				// DealId The ID of the deal this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
				DealId *int `json:"deal_id,omitempty"`

				// Duration The duration of the call in seconds
				Duration *string `json:"duration,omitempty"`

				// EndTime The date and time of the end of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
				EndTime time.Time `json:"end_time"`

				// FromPhoneNumber The number that made the call
				FromPhoneNumber *string `json:"from_phone_number,omitempty"`

				// HasRecording If the call log has an audio recording attached, the value should be true
				HasRecording *bool `json:"has_recording,omitempty"`

				// Id The call log ID, generated when the call log was created
				Id *string `json:"id,omitempty"`

				// LeadId The ID of the lead in the UUID format this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// Note The note for the call log in HTML format
				Note *string `json:"note,omitempty"`

				// OrgId The ID of the organization this call is associated with
				OrgId *int `json:"org_id,omitempty"`

				// Outcome Describes the outcome of the call
				Outcome AddCallLog200DataOutcome `json:"outcome"`

				// PersonId The ID of the person this call is associated with
				PersonId *int `json:"person_id,omitempty"`

				// StartTime The date and time of the start of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
				StartTime time.Time `json:"start_time"`

				// Subject The name of the activity this call is attached to
				Subject *string `json:"subject,omitempty"`

				// ToPhoneNumber The number called
				ToPhoneNumber string `json:"to_phone_number"`

				// UserId The ID of the owner of the call log. Please note that a user without account settings access cannot create call logs for other users.
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCallLogResponse parses an HTTP response from a DeleteCallLogWithResponse call
func ParseDeleteCallLogResponse(rsp *http.Response) (*DeleteCallLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCallLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCallLogResponse parses an HTTP response from a GetCallLogWithResponse call
func ParseGetCallLogResponse(rsp *http.Response) (*GetCallLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCallLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActivityId If specified, this activity will be converted into a call log, with the information provided. When this field is used, you don't need to specify `deal_id`, `person_id` or `org_id`, as they will be ignored in favor of the values already available in the activity. The `activity_id` must refer to a `call` type activity.
				ActivityId *int `json:"activity_id,omitempty"`

				// CompanyId The company ID of the owner of the call log
				CompanyId *int `json:"company_id,omitempty"`

				// DealId The ID of the deal this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
				DealId *int `json:"deal_id,omitempty"`

				// Duration The duration of the call in seconds
				Duration *string `json:"duration,omitempty"`

				// EndTime The date and time of the end of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
				EndTime time.Time `json:"end_time"`

				// FromPhoneNumber The number that made the call
				FromPhoneNumber *string `json:"from_phone_number,omitempty"`

				// HasRecording If the call log has an audio recording attached, the value should be true
				HasRecording *bool `json:"has_recording,omitempty"`

				// Id The call log ID, generated when the call log was created
				Id *string `json:"id,omitempty"`

				// LeadId The ID of the lead in the UUID format this call is associated with. A call log can be associated with either a deal or a lead, but not both at once.
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// Note The note for the call log in HTML format
				Note *string `json:"note,omitempty"`

				// OrgId The ID of the organization this call is associated with
				OrgId *int `json:"org_id,omitempty"`

				// Outcome Describes the outcome of the call
				Outcome GetCallLog200DataOutcome `json:"outcome"`

				// PersonId The ID of the person this call is associated with
				PersonId *int `json:"person_id,omitempty"`

				// StartTime The date and time of the start of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
				StartTime time.Time `json:"start_time"`

				// Subject The name of the activity this call is attached to
				Subject *string `json:"subject,omitempty"`

				// ToPhoneNumber The number called
				ToPhoneNumber string `json:"to_phone_number"`

				// UserId The ID of the owner of the call log. Please note that a user without account settings access cannot create call logs for other users.
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddCallLogAudioFileResponse parses an HTTP response from a AddCallLogAudioFileWithResponse call
func ParseAddCallLogAudioFileResponse(rsp *http.Response) (*AddCallLogAudioFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddCallLogAudioFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddChannelResponse parses an HTTP response from a AddChannelWithResponse call
func ParseAddChannelResponse(rsp *http.Response) (*AddChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// AvatarUrl The URL for an icon that represents your channel
				AvatarUrl *string `json:"avatar_url,omitempty"`

				// CreatedAt The date and time when your channel was created in the API
				CreatedAt *time.Time `json:"created_at,omitempty"`

				// Id The unique channel ID used internally in omnichannel-api and the frontend of the extension
				Id *string `json:"id,omitempty"`

				// MarketplaceClientId The client_id of your app in Pipedrive marketplace
				MarketplaceClientId *string `json:"marketplace_client_id,omitempty"`

				// Name The name of the channel
				Name *string `json:"name,omitempty"`

				// PdCompanyId The ID of the user's company in Pipedrive
				PdCompanyId *int `json:"pd_company_id,omitempty"`

				// PdUserId The ID of the user in Pipedrive
				PdUserId *int `json:"pd_user_id,omitempty"`

				// ProviderChannelId The channel ID you specified while creating the channel
				ProviderChannelId *string `json:"provider_channel_id,omitempty"`

				// ProviderType Value of the provider_type sent to this endpoint
				ProviderType *AddChannel200DataProviderType `json:"provider_type,omitempty"`

				// TemplateSupport Value of the template_support sent to this endpoint
				TemplateSupport *bool `json:"template_support,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			AdditionalData *struct {
				// Code An error code sent by the API
				Code *string `json:"code,omitempty"`
			} `json:"additional_data,omitempty"`

			// Error The error description
			Error     *string `json:"error,omitempty"`
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			AdditionalData *struct {
				// Code An error code sent by the API
				Code *string `json:"code,omitempty"`
			} `json:"additional_data,omitempty"`

			// Error The error description
			Error     *string `json:"error,omitempty"`
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseReceiveMessageResponse parses an HTTP response from a ReceiveMessageWithResponse call
func ParseReceiveMessageResponse(rsp *http.Response) (*ReceiveMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiveMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Attachments The list of attachments available in the message
				Attachments *[]struct {
					// Id The ID of the attachment
					Id string `json:"id"`

					// LinkExpires If true, it will use the getMessageById endpoint for fetching updated attachment's urls. Find out more [here](https://pipedrive.readme.io/docs/implementing-messaging-app-extension)
					LinkExpires *bool `json:"link_expires,omitempty"`

					// Name The name of the attachment
					Name *string `json:"name,omitempty"`

					// PreviewUrl A URL to a preview picture of the file
					PreviewUrl *string `json:"preview_url,omitempty"`

					// Size The size of the attachment
					Size *float32 `json:"size,omitempty"`

					// Type The mime-type of the attachment
					Type string `json:"type"`

					// Url A URL to the file
					Url string `json:"url"`
				} `json:"attachments,omitempty"`

				// ChannelId The channel ID as in the provider
				ChannelId string `json:"channel_id"`

				// ConversationId The ID of the conversation
				ConversationId string `json:"conversation_id"`

				// ConversationLink A URL that can open the conversation in the provider's side
				ConversationLink *string `json:"conversation_link,omitempty"`

				// CreatedAt The date and time when the message was created in the provider, in UTC. Format: YYYY-MM-DD HH:MM
				CreatedAt time.Time `json:"created_at"`

				// Id The ID of the message
				Id string `json:"id"`

				// Message The body of the message
				Message string `json:"message"`

				// ReplyBy The date and time when the message can no longer receive a reply, in UTC. Format: YYYY-MM-DD HH:MM
				ReplyBy *time.Time `json:"reply_by,omitempty"`

				// SenderId The ID of the provider's user that sent the message
				SenderId string `json:"sender_id"`

				// Status The status of the message
				Status ReceiveMessage200DataStatus `json:"status"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			AdditionalData *struct {
				// Code An error code sent by the API
				Code *string `json:"code,omitempty"`
			} `json:"additional_data,omitempty"`

			// Error The error description
			Error     *string `json:"error,omitempty"`
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteConversationResponse parses an HTTP response from a DeleteConversationWithResponse call
func ParseDeleteConversationResponse(rsp *http.Response) (*DeleteConversationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			AdditionalData *struct {
				// Code An error code sent by the API
				Code *string `json:"code,omitempty"`
			} `json:"additional_data,omitempty"`

			// Error The error description
			Error     *string `json:"error,omitempty"`
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *struct {
				// Code An error code sent by the API
				Code *string `json:"code,omitempty"`
			} `json:"additional_data,omitempty"`

			// Error The error description
			Error     *string `json:"error,omitempty"`
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteChannelResponse parses an HTTP response from a DeleteChannelWithResponse call
func ParseDeleteChannelResponse(rsp *http.Response) (*DeleteChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			AdditionalData *struct {
				// Code An error code sent by the API
				Code *string `json:"code,omitempty"`
			} `json:"additional_data,omitempty"`

			// Error The error description
			Error     *string `json:"error,omitempty"`
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetCurrenciesResponse parses an HTTP response from a GetCurrenciesWithResponse call
func ParseGetCurrenciesResponse(rsp *http.Response) (*GetCurrenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The array of currencies
			Data *[]struct {
				// ActiveFlag Whether the currency is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Code The code of the currency
				Code *string `json:"code,omitempty"`

				// DecimalPoints The amount of decimal points of the currency
				DecimalPoints *int `json:"decimal_points,omitempty"`

				// Id The ID of the currency
				Id *int `json:"id,omitempty"`

				// IsCustomFlag Whether the currency is a custom one or not
				IsCustomFlag *bool `json:"is_custom_flag,omitempty"`

				// Name The name of the currency
				Name *string `json:"name,omitempty"`

				// Symbol The symbol of the currency
				Symbol *string `json:"symbol,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDealFieldsResponse parses an HTTP response from a DeleteDealFieldsWithResponse call
func ParseDeleteDealFieldsResponse(rsp *http.Response) (*DeleteDealFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDealFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The list of deleted field IDs
				Id *[]int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDealsResponse parses an HTTP response from a DeleteDealsWithResponse call
func ParseDeleteDealsResponse(rsp *http.Response) (*DeleteDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The list of deleted deals IDs
				Id *[]int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealsCollectionResponse parses an HTTP response from a GetDealsCollectionWithResponse call
func ParseGetDealsCollectionResponse(rsp *http.Response) (*GetDealsCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealsCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// AddTime The creation date and time of the deal in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// CloseTime The date and time of closing the deal in UTC. Format: YYYY-MM-DD HH:MM:SS.
				CloseTime *string `json:"close_time"`

				// CreatorUserId The ID of the deal creator
				CreatorUserId *int `json:"creator_user_id,omitempty"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// Label The label or multiple labels assigned to the deal
				Label *string `json:"label,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status to lost in UTC. Format: YYYY-MM-DD HH:MM:SS.
				LostTime *string `json:"lost_time,omitempty"`

				// OrgId The ID of the organization associated with the deal
				OrgId *int `json:"org_id,omitempty"`

				// PersonId The ID of the person associated with the deal
				PersonId *int `json:"person_id,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UpdateTime The last update date and time of the deal in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`

				// UserId The ID of the user
				UserId *int `json:"user_id,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *string `json:"visible_to,omitempty"`

				// WonTime The date and time of changing the deal status to won in UTC. Format: YYYY-MM-DD HH:MM:SS.
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetDealsSummaryResponse parses an HTTP response from a GetDealsSummaryWithResponse call
func ParseGetDealsSummaryResponse(rsp *http.Response) (*GetDealsSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealsSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The summary of deals
			Data *struct {
				// TotalCount The total number of deals
				TotalCount *int `json:"total_count,omitempty"`

				// TotalCurrencyConvertedValue The total value of deals converted into the company default currency
				TotalCurrencyConvertedValue *float32 `json:"total_currency_converted_value,omitempty"`

				// TotalCurrencyConvertedValueFormatted The total converted value of deals formatted with the company default currency. E.g. US$5,100.96
				TotalCurrencyConvertedValueFormatted *string `json:"total_currency_converted_value_formatted,omitempty"`

				// TotalWeightedCurrencyConvertedValue The total weighted value of deals converted into the company default currency
				TotalWeightedCurrencyConvertedValue *float32 `json:"total_weighted_currency_converted_value,omitempty"`

				// TotalWeightedCurrencyConvertedValueFormatted The total weighted value of deals formatted with the company default currency. E.g. US$5,100.96
				TotalWeightedCurrencyConvertedValueFormatted *string `json:"total_weighted_currency_converted_value_formatted,omitempty"`

				// ValuesTotal The total values of the deals grouped by deal currency
				ValuesTotal *struct {
					// Count The number of deals in the deal currency group
					Count *int `json:"count,omitempty"`

					// Value The total value of deals in the deal currency group
					Value *float32 `json:"value,omitempty"`

					// ValueConverted The total value of deals converted into the company default currency
					ValueConverted *float32 `json:"value_converted,omitempty"`

					// ValueConvertedFormatted The value_converted formatted with deal currency. E.g. US$50.10
					ValueConvertedFormatted *string `json:"value_converted_formatted,omitempty"`

					// ValueFormatted The total value of deals formatted with deal currency. E.g. 50
					ValueFormatted *string `json:"value_formatted,omitempty"`
				} `json:"values_total,omitempty"`

				// WeightedValuesTotal The total weighted values of the deals grouped by deal currency. The weighted value is calculated as probability times deal value.
				WeightedValuesTotal *struct {
					// Count The number of deals in the deal currency group
					Count *int `json:"count,omitempty"`

					// Value The total weighted value of the deals in the deal currency group
					Value *float32 `json:"value,omitempty"`

					// ValueFormatted The total weighted value of the deals formatted with deal currency. E.g. 50
					ValueFormatted *string `json:"value_formatted,omitempty"`
				} `json:"weighted_values_total,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetArchivedDealsSummaryResponse parses an HTTP response from a GetArchivedDealsSummaryWithResponse call
func ParseGetArchivedDealsSummaryResponse(rsp *http.Response) (*GetArchivedDealsSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArchivedDealsSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The summary of deals
			Data *struct {
				// TotalCount The total number of deals
				TotalCount *int `json:"total_count,omitempty"`

				// TotalCurrencyConvertedValue The total value of deals converted into the company default currency
				TotalCurrencyConvertedValue *float32 `json:"total_currency_converted_value,omitempty"`

				// TotalCurrencyConvertedValueFormatted The total converted value of deals formatted with the company default currency. E.g. US$5,100.96
				TotalCurrencyConvertedValueFormatted *string `json:"total_currency_converted_value_formatted,omitempty"`

				// TotalWeightedCurrencyConvertedValue The total weighted value of deals converted into the company default currency
				TotalWeightedCurrencyConvertedValue *float32 `json:"total_weighted_currency_converted_value,omitempty"`

				// TotalWeightedCurrencyConvertedValueFormatted The total weighted value of deals formatted with the company default currency. E.g. US$5,100.96
				TotalWeightedCurrencyConvertedValueFormatted *string `json:"total_weighted_currency_converted_value_formatted,omitempty"`

				// ValuesTotal The total values of the deals grouped by deal currency
				ValuesTotal *struct {
					// Count The number of deals in the deal currency group
					Count *int `json:"count,omitempty"`

					// Value The total value of deals in the deal currency group
					Value *float32 `json:"value,omitempty"`

					// ValueConverted The total value of deals converted into the company default currency
					ValueConverted *float32 `json:"value_converted,omitempty"`

					// ValueConvertedFormatted The value_converted formatted with deal currency. E.g. US$50.10
					ValueConvertedFormatted *string `json:"value_converted_formatted,omitempty"`

					// ValueFormatted The total value of deals formatted with deal currency. E.g. 50
					ValueFormatted *string `json:"value_formatted,omitempty"`
				} `json:"values_total,omitempty"`

				// WeightedValuesTotal The total weighted values of the deals grouped by deal currency. The weighted value is calculated as probability times deal value.
				WeightedValuesTotal *struct {
					// Count The number of deals in the deal currency group
					Count *int `json:"count,omitempty"`

					// Value The total weighted value of the deals in the deal currency group
					Value *float32 `json:"value,omitempty"`

					// ValueFormatted The total weighted value of the deals formatted with deal currency. E.g. 50
					ValueFormatted *string `json:"value_formatted,omitempty"`
				} `json:"weighted_values_total,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealsTimelineResponse parses an HTTP response from a GetDealsTimelineWithResponse call
func ParseGetDealsTimelineResponse(rsp *http.Response) (*GetDealsTimelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealsTimelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Open and won deals grouped into periods by defined interval, amount and date-type dealField (`field_key`)
			Data *struct {
				Deals *[]struct {
					// Active Whether the deal is active or not
					Active *bool `json:"active,omitempty"`

					// ActivitiesCount The number of activities associated with the deal
					ActivitiesCount *int `json:"activities_count,omitempty"`

					// Acv Only available in Growth and above plans
					//
					// The Annual Contract Value of the deal
					//
					// Null if there are no products attached to the deal
					Acv *float32 `json:"acv"`

					// AcvCurrency Only available in Growth and above plans
					//
					// The Currency for Annual Contract Value of the deal
					//
					// If the `acv` is null, this will also be null
					AcvCurrency *string `json:"acv_currency"`

					// AddTime The creation date and time of the deal
					AddTime *string `json:"add_time,omitempty"`

					// Arr Only available in Growth and above plans
					//
					// The Annual Recurring Revenue of the deal
					//
					// Null if there are no products attached to the deal
					Arr *float32 `json:"arr"`

					// ArrCurrency Only available in Growth and above plans
					//
					// The Currency for Annual Recurring Revenue of the deal
					//
					// If the `arr` is null, this will also be null
					ArrCurrency *string `json:"arr_currency"`

					// CcEmail The BCC email of the deal
					CcEmail *string `json:"cc_email,omitempty"`

					// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
					Channel *int `json:"channel"`

					// ChannelId The optional ID to further distinguish the Marketing channel.
					ChannelId *string `json:"channel_id"`

					// CloseTime The date and time of closing the deal
					CloseTime *string `json:"close_time"`

					// CreatorUserId The ID of the deal creator
					CreatorUserId *int `json:"creator_user_id,omitempty"`

					// Currency The currency associated with the deal
					Currency *string `json:"currency,omitempty"`

					// Deleted Whether the deal is deleted or not
					Deleted *bool `json:"deleted,omitempty"`

					// DoneActivitiesCount The number of completed activities associated with the deal
					DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

					// EmailMessagesCount The number of emails associated with the deal
					EmailMessagesCount *int `json:"email_messages_count,omitempty"`

					// ExpectedCloseDate The expected close date of the deal
					ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

					// FilesCount The number of files associated with the deal
					FilesCount *int `json:"files_count,omitempty"`

					// FirstWonTime The date and time of the first time changing the deal status as won
					FirstWonTime *string `json:"first_won_time,omitempty"`

					// FollowersCount The number of followers associated with the deal
					FollowersCount *int `json:"followers_count,omitempty"`

					// FormattedValue The deal value formatted with selected currency. E.g. US$500
					FormattedValue *string `json:"formatted_value,omitempty"`

					// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
					FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

					// Id The ID of the deal
					Id *int `json:"id,omitempty"`

					// IsArchived Whether the deal is archived or not
					IsArchived *bool `json:"is_archived,omitempty"`

					// Label The label or multiple labels assigned to the deal
					Label *string `json:"label,omitempty"`

					// LastActivityDate The date of the last activity associated with the deal
					LastActivityDate *string `json:"last_activity_date"`

					// LastActivityId The ID of the last activity associated with the deal
					LastActivityId *int `json:"last_activity_id"`

					// LastIncomingMailTime The date and time of the last incoming email associated with the deal
					LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

					// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
					LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

					// LostReason The reason for losing the deal
					LostReason *string `json:"lost_reason"`

					// LostTime The date and time of changing the deal status as lost
					LostTime *string `json:"lost_time,omitempty"`

					// Mrr Only available in Growth and above plans
					//
					// The Monthly Recurring Revenue of the deal
					//
					// Null if there are no products attached to the deal
					Mrr *float32 `json:"mrr"`

					// MrrCurrency Only available in Growth and above plans
					//
					// The Currency for Monthly Recurring Revenue of the deal
					//
					// If the `mrr` is null, this will also be null
					MrrCurrency *string `json:"mrr_currency"`

					// NextActivityDate The date of the next activity associated with the deal
					NextActivityDate *string `json:"next_activity_date,omitempty"`

					// NextActivityDuration The duration of the next activity associated with the deal
					NextActivityDuration *string `json:"next_activity_duration,omitempty"`

					// NextActivityId The ID of the next activity associated with the deal
					NextActivityId *int `json:"next_activity_id"`

					// NextActivityNote The note of the next activity associated with the deal
					NextActivityNote *string `json:"next_activity_note,omitempty"`

					// NextActivitySubject The subject of the next activity associated with the deal
					NextActivitySubject *string `json:"next_activity_subject,omitempty"`

					// NextActivityTime The time of the next activity associated with the deal
					NextActivityTime *string `json:"next_activity_time,omitempty"`

					// NextActivityType The type of the next activity associated with the deal
					NextActivityType *string `json:"next_activity_type,omitempty"`

					// NotesCount The number of notes associated with the deal
					NotesCount *int `json:"notes_count,omitempty"`

					// OrgHidden If the organization that is associated with the deal is hidden or not
					OrgHidden *bool `json:"org_hidden,omitempty"`

					// OrgId The ID of the organization associated with the deal
					OrgId *int `json:"org_id,omitempty"`

					// OrgName The name of the organization associated with the deal
					OrgName *string `json:"org_name,omitempty"`

					// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
					Origin *string `json:"origin,omitempty"`

					// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
					OriginId *string `json:"origin_id"`

					// OwnerName The name of the deal owner
					OwnerName *string `json:"owner_name,omitempty"`

					// ParticipantsCount The number of participants associated with the deal
					ParticipantsCount *int `json:"participants_count,omitempty"`

					// PersonHidden If the person that is associated with the deal is hidden or not
					PersonHidden *bool `json:"person_hidden,omitempty"`

					// PersonId The ID of the person associated with the deal
					PersonId *int `json:"person_id,omitempty"`

					// PersonName The name of the person associated with the deal
					PersonName *string `json:"person_name,omitempty"`

					// PipelineId The ID of the pipeline associated with the deal
					PipelineId *int `json:"pipeline_id,omitempty"`

					// Probability The success probability percentage of the deal
					Probability *float32 `json:"probability"`

					// ProductsCount The number of products associated with the deal
					ProductsCount *int `json:"products_count,omitempty"`

					// RottenTime The date and time of changing the deal status as rotten
					RottenTime *string `json:"rotten_time"`

					// StageChangeTime The last updated date and time of the deal stage
					StageChangeTime *string `json:"stage_change_time,omitempty"`

					// StageId The ID of the deal stage
					StageId *int `json:"stage_id,omitempty"`

					// StageOrderNr The order number of the deal stage associated with the deal
					StageOrderNr *int `json:"stage_order_nr,omitempty"`

					// Status The status of the deal
					Status *string `json:"status,omitempty"`

					// Title The title of the deal
					Title *string `json:"title,omitempty"`

					// UndoneActivitiesCount The number of incomplete activities associated with the deal
					UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

					// UpdateTime The last updated date and time of the deal
					UpdateTime *string `json:"update_time,omitempty"`

					// UserId The ID of the user
					UserId *int `json:"user_id,omitempty"`

					// Value The value of the deal
					Value *float32 `json:"value,omitempty"`

					// VisibleTo The visibility of the deal
					VisibleTo *string `json:"visible_to,omitempty"`

					// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
					WeightedValue *float32 `json:"weighted_value,omitempty"`

					// WeightedValueCurrency The currency associated with the deal
					WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

					// WonTime The date and time of changing the deal status as won
					WonTime *string `json:"won_time,omitempty"`
				} `json:"deals,omitempty"`

				// PeriodEnd The end date and time of the period
				PeriodEnd *string `json:"period_end,omitempty"`

				// PeriodStart The start date and time of the period
				PeriodStart *string `json:"period_start,omitempty"`

				// Totals The total values of deals for the given period
				Totals *struct {
					// Count The number of deals for the given period
					Count *int `json:"count,omitempty"`

					// OpenCount The number of open deals for the given period
					OpenCount *int `json:"open_count,omitempty"`

					// OpenValues The total values of open deals for the given period grouped by deal currency
					OpenValues *map[string]interface{} `json:"open_values,omitempty"`

					// Values The total values of deals grouped by deal currency
					Values *map[string]interface{} `json:"values,omitempty"`

					// WeightedOpenValues The total weighted values of open deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value.
					WeightedOpenValues *map[string]interface{} `json:"weighted_open_values,omitempty"`

					// WeightedValues The total weighted values of deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value.
					WeightedValues *map[string]interface{} `json:"weighted_values,omitempty"`

					// WonCount The number of won deals for the given period
					WonCount *int `json:"won_count,omitempty"`

					// WonValues The total values of won deals for the given period grouped by deal currency
					WonValues *map[string]interface{} `json:"won_values,omitempty"`
				} `json:"totals,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetArchivedDealsTimelineResponse parses an HTTP response from a GetArchivedDealsTimelineWithResponse call
func ParseGetArchivedDealsTimelineResponse(rsp *http.Response) (*GetArchivedDealsTimelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArchivedDealsTimelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Open and won deals grouped into periods by defined interval, amount and date-type dealField (`field_key`)
			Data *struct {
				Deals *[]struct {
					// Active Whether the deal is active or not
					Active *bool `json:"active,omitempty"`

					// ActivitiesCount The number of activities associated with the deal
					ActivitiesCount *int `json:"activities_count,omitempty"`

					// Acv Only available in Growth and above plans
					//
					// The Annual Contract Value of the deal
					//
					// Null if there are no products attached to the deal
					Acv *float32 `json:"acv"`

					// AcvCurrency Only available in Growth and above plans
					//
					// The Currency for Annual Contract Value of the deal
					//
					// If the `acv` is null, this will also be null
					AcvCurrency *string `json:"acv_currency"`

					// AddTime The creation date and time of the deal
					AddTime *string `json:"add_time,omitempty"`

					// Arr Only available in Growth and above plans
					//
					// The Annual Recurring Revenue of the deal
					//
					// Null if there are no products attached to the deal
					Arr *float32 `json:"arr"`

					// ArrCurrency Only available in Growth and above plans
					//
					// The Currency for Annual Recurring Revenue of the deal
					//
					// If the `arr` is null, this will also be null
					ArrCurrency *string `json:"arr_currency"`

					// CcEmail The BCC email of the deal
					CcEmail *string `json:"cc_email,omitempty"`

					// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
					Channel *int `json:"channel"`

					// ChannelId The optional ID to further distinguish the Marketing channel.
					ChannelId *string `json:"channel_id"`

					// CloseTime The date and time of closing the deal
					CloseTime *string `json:"close_time"`

					// CreatorUserId The ID of the deal creator
					CreatorUserId *int `json:"creator_user_id,omitempty"`

					// Currency The currency associated with the deal
					Currency *string `json:"currency,omitempty"`

					// Deleted Whether the deal is deleted or not
					Deleted *bool `json:"deleted,omitempty"`

					// DoneActivitiesCount The number of completed activities associated with the deal
					DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

					// EmailMessagesCount The number of emails associated with the deal
					EmailMessagesCount *int `json:"email_messages_count,omitempty"`

					// ExpectedCloseDate The expected close date of the deal
					ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

					// FilesCount The number of files associated with the deal
					FilesCount *int `json:"files_count,omitempty"`

					// FirstWonTime The date and time of the first time changing the deal status as won
					FirstWonTime *string `json:"first_won_time,omitempty"`

					// FollowersCount The number of followers associated with the deal
					FollowersCount *int `json:"followers_count,omitempty"`

					// FormattedValue The deal value formatted with selected currency. E.g. US$500
					FormattedValue *string `json:"formatted_value,omitempty"`

					// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
					FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

					// Id The ID of the deal
					Id *int `json:"id,omitempty"`

					// IsArchived Whether the deal is archived or not
					IsArchived *bool `json:"is_archived,omitempty"`

					// Label The label or multiple labels assigned to the deal
					Label *string `json:"label,omitempty"`

					// LastActivityDate The date of the last activity associated with the deal
					LastActivityDate *string `json:"last_activity_date"`

					// LastActivityId The ID of the last activity associated with the deal
					LastActivityId *int `json:"last_activity_id"`

					// LastIncomingMailTime The date and time of the last incoming email associated with the deal
					LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

					// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
					LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

					// LostReason The reason for losing the deal
					LostReason *string `json:"lost_reason"`

					// LostTime The date and time of changing the deal status as lost
					LostTime *string `json:"lost_time,omitempty"`

					// Mrr Only available in Growth and above plans
					//
					// The Monthly Recurring Revenue of the deal
					//
					// Null if there are no products attached to the deal
					Mrr *float32 `json:"mrr"`

					// MrrCurrency Only available in Growth and above plans
					//
					// The Currency for Monthly Recurring Revenue of the deal
					//
					// If the `mrr` is null, this will also be null
					MrrCurrency *string `json:"mrr_currency"`

					// NextActivityDate The date of the next activity associated with the deal
					NextActivityDate *string `json:"next_activity_date,omitempty"`

					// NextActivityDuration The duration of the next activity associated with the deal
					NextActivityDuration *string `json:"next_activity_duration,omitempty"`

					// NextActivityId The ID of the next activity associated with the deal
					NextActivityId *int `json:"next_activity_id"`

					// NextActivityNote The note of the next activity associated with the deal
					NextActivityNote *string `json:"next_activity_note,omitempty"`

					// NextActivitySubject The subject of the next activity associated with the deal
					NextActivitySubject *string `json:"next_activity_subject,omitempty"`

					// NextActivityTime The time of the next activity associated with the deal
					NextActivityTime *string `json:"next_activity_time,omitempty"`

					// NextActivityType The type of the next activity associated with the deal
					NextActivityType *string `json:"next_activity_type,omitempty"`

					// NotesCount The number of notes associated with the deal
					NotesCount *int `json:"notes_count,omitempty"`

					// OrgHidden If the organization that is associated with the deal is hidden or not
					OrgHidden *bool `json:"org_hidden,omitempty"`

					// OrgId The ID of the organization associated with the deal
					OrgId *int `json:"org_id,omitempty"`

					// OrgName The name of the organization associated with the deal
					OrgName *string `json:"org_name,omitempty"`

					// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
					Origin *string `json:"origin,omitempty"`

					// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
					OriginId *string `json:"origin_id"`

					// OwnerName The name of the deal owner
					OwnerName *string `json:"owner_name,omitempty"`

					// ParticipantsCount The number of participants associated with the deal
					ParticipantsCount *int `json:"participants_count,omitempty"`

					// PersonHidden If the person that is associated with the deal is hidden or not
					PersonHidden *bool `json:"person_hidden,omitempty"`

					// PersonId The ID of the person associated with the deal
					PersonId *int `json:"person_id,omitempty"`

					// PersonName The name of the person associated with the deal
					PersonName *string `json:"person_name,omitempty"`

					// PipelineId The ID of the pipeline associated with the deal
					PipelineId *int `json:"pipeline_id,omitempty"`

					// Probability The success probability percentage of the deal
					Probability *float32 `json:"probability"`

					// ProductsCount The number of products associated with the deal
					ProductsCount *int `json:"products_count,omitempty"`

					// RottenTime The date and time of changing the deal status as rotten
					RottenTime *string `json:"rotten_time"`

					// StageChangeTime The last updated date and time of the deal stage
					StageChangeTime *string `json:"stage_change_time,omitempty"`

					// StageId The ID of the deal stage
					StageId *int `json:"stage_id,omitempty"`

					// StageOrderNr The order number of the deal stage associated with the deal
					StageOrderNr *int `json:"stage_order_nr,omitempty"`

					// Status The status of the deal
					Status *string `json:"status,omitempty"`

					// Title The title of the deal
					Title *string `json:"title,omitempty"`

					// UndoneActivitiesCount The number of incomplete activities associated with the deal
					UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

					// UpdateTime The last updated date and time of the deal
					UpdateTime *string `json:"update_time,omitempty"`

					// UserId The ID of the user
					UserId *int `json:"user_id,omitempty"`

					// Value The value of the deal
					Value *float32 `json:"value,omitempty"`

					// VisibleTo The visibility of the deal
					VisibleTo *string `json:"visible_to,omitempty"`

					// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
					WeightedValue *float32 `json:"weighted_value,omitempty"`

					// WeightedValueCurrency The currency associated with the deal
					WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

					// WonTime The date and time of changing the deal status as won
					WonTime *string `json:"won_time,omitempty"`
				} `json:"deals,omitempty"`

				// PeriodEnd The end date and time of the period
				PeriodEnd *string `json:"period_end,omitempty"`

				// PeriodStart The start date and time of the period
				PeriodStart *string `json:"period_start,omitempty"`

				// Totals The total values of deals for the given period
				Totals *struct {
					// Count The number of deals for the given period
					Count *int `json:"count,omitempty"`

					// OpenCount The number of open deals for the given period
					OpenCount *int `json:"open_count,omitempty"`

					// OpenValues The total values of open deals for the given period grouped by deal currency
					OpenValues *map[string]interface{} `json:"open_values,omitempty"`

					// Values The total values of deals grouped by deal currency
					Values *map[string]interface{} `json:"values,omitempty"`

					// WeightedOpenValues The total weighted values of open deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value.
					WeightedOpenValues *map[string]interface{} `json:"weighted_open_values,omitempty"`

					// WeightedValues The total weighted values of deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value.
					WeightedValues *map[string]interface{} `json:"weighted_values,omitempty"`

					// WonCount The number of won deals for the given period
					WonCount *int `json:"won_count,omitempty"`

					// WonValues The total values of won deals for the given period grouped by deal currency
					WonValues *map[string]interface{} `json:"won_values,omitempty"`
				} `json:"totals,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealActivitiesResponse parses an HTTP response from a GetDealActivitiesWithResponse call
func ParseGetDealActivitiesResponse(rsp *http.Response) (*GetDealActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// ActivityDistribution The distribution of activities related to the organization grouped by the user ID
				ActivityDistribution *struct {
					// ASSIGNEDTOUSERID The ID of the user
					ASSIGNEDTOUSERID *struct {
						// Activities The count of activities related to the user grouped by activity type
						Activities *struct {
							// ACTIVITYTYPENAME The count of activities related to a specific type
							ACTIVITYTYPENAME *int `json:"ACTIVITY_TYPE_NAME,omitempty"`
						} `json:"activities,omitempty"`

						// ActivityCount The overall count of activities for the user
						ActivityCount *int `json:"activity_count,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// Share The percentage of activities belongs to the user
						Share *int `json:"share,omitempty"`
					} `json:"ASSIGNED_TO_USER_ID,omitempty"`
				} `json:"activity_distribution,omitempty"`

				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of activities
			Data *[]struct {
				// ActiveFlag Whether the activity is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// AssignedToUserId The ID of the user to whom the activity is assigned to. Equal to `user_id`.
				AssignedToUserId *int `json:"assigned_to_user_id,omitempty"`

				// Attendees The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address.
				Attendees *[]map[string]interface{} `json:"attendees"`

				// BusyFlag Marks if the activity is set as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
				BusyFlag *bool `json:"busy_flag,omitempty"`

				// CalendarSyncIncludeContext For activities that sync to an external calendar, this setting indicates if the activity syncs with context (what are the deals, persons, organizations this activity is related to)
				CalendarSyncIncludeContext *string `json:"calendar_sync_include_context,omitempty"`

				// CompanyId The user's company ID
				CompanyId *int `json:"company_id,omitempty"`

				// ConferenceMeetingClient The ID of the Marketplace app, which is connected to this activity
				ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

				// ConferenceMeetingId The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
				ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

				// ConferenceMeetingUrl The link to join the meeting which is associated with this activity
				ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

				// CreatedByUserId The ID of the user who created the activity
				CreatedByUserId *int `json:"created_by_user_id,omitempty"`

				// DealDropboxBcc The BCC email address of the deal
				DealDropboxBcc *string `json:"deal_dropbox_bcc,omitempty"`

				// DealId The ID of the deal this activity is associated with
				DealId *int `json:"deal_id,omitempty"`

				// DealTitle The name of the deal this activity is associated with
				DealTitle *string `json:"deal_title,omitempty"`

				// Done Whether the activity is done or not
				Done *bool `json:"done,omitempty"`

				// DueDate The due date of the activity. Format: YYYY-MM-DD
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// DueTime The due time of the activity in UTC. Format: HH:MM
				DueTime *string `json:"due_time,omitempty"`

				// Duration The duration of the activity. Format: HH:MM
				Duration *string `json:"duration,omitempty"`

				// File The file that is attached to this activity. For example, this can be a reference to an audio note file generated with Pipedrive mobile app.
				File *map[string]interface{} `json:"file,omitempty"`

				// GcalEventId For the activity which syncs to Google calendar, this is the Google event ID. NB! This field is related to old Google calendar sync and will be deprecated soon.
				GcalEventId *string `json:"gcal_event_id,omitempty"`

				// GoogleCalendarEtag The Google calendar API etag (version) that is used for syncing this activity. NB! This field is related to old Google calendar sync and will be deprecated soon.
				GoogleCalendarEtag *string `json:"google_calendar_etag,omitempty"`

				// GoogleCalendarId The Google calendar ID that this activity syncs to. NB! This field is related to old Google calendar sync and will be deprecated soon.
				GoogleCalendarId *string `json:"google_calendar_id,omitempty"`

				// Id The ID of the activity, generated when the activity was created
				Id *int `json:"id,omitempty"`

				// LastNotificationTime The date and time of latest notifications sent about this activity to the participants or the attendees of this activity
				LastNotificationTime *string `json:"last_notification_time,omitempty"`

				// LastNotificationUserId The ID of the user who triggered the sending of the latest notifications about this activity to the participants or the attendees of this activity
				LastNotificationUserId *int `json:"last_notification_user_id,omitempty"`

				// LeadId The ID of the lead in the UUID format this activity is associated with
				LeadId *openapi_types.UUID `json:"lead_id"`

				// Location The address of the activity.
				Location *string `json:"location,omitempty"`

				// LocationAdminAreaLevel1 A subfield of the location field. Indicates state/county.
				LocationAdminAreaLevel1 *string `json:"location_admin_area_level_1,omitempty"`

				// LocationAdminAreaLevel2 A subfield of the location field. Indicates region.
				LocationAdminAreaLevel2 *string `json:"location_admin_area_level_2,omitempty"`

				// LocationCountry A subfield of the location field. Indicates country.
				LocationCountry *string `json:"location_country,omitempty"`

				// LocationFormattedAddress A subfield of the location field. Indicates full/combined address.
				LocationFormattedAddress *string `json:"location_formatted_address,omitempty"`

				// LocationLocality A subfield of the location field. Indicates city/town/village/locality.
				LocationLocality *string `json:"location_locality,omitempty"`

				// LocationPostalCode A subfield of the location field. Indicates ZIP/postal code.
				LocationPostalCode *string `json:"location_postal_code,omitempty"`

				// LocationRoute A subfield of the location field. Indicates street name.
				LocationRoute *string `json:"location_route,omitempty"`

				// LocationStreetNumber A subfield of the location field. Indicates house number.
				LocationStreetNumber *string `json:"location_street_number,omitempty"`

				// LocationSublocality A subfield of the location field. Indicates district/sublocality.
				LocationSublocality *string `json:"location_sublocality,omitempty"`

				// LocationSubpremise A subfield of the location field. Indicates apartment/suite number.
				LocationSubpremise *string `json:"location_subpremise,omitempty"`

				// MarkedAsDoneTime The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// Note The note of the activity (HTML format)
				Note *string `json:"note,omitempty"`

				// NotificationLanguageId The ID of the language the notifications are sent in
				NotificationLanguageId *int `json:"notification_language_id,omitempty"`

				// OrgId The ID of the organization this activity is associated with
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization this activity is associated with
				OrgName *string `json:"org_name,omitempty"`

				// OwnerName The name of the user this activity is owned by
				OwnerName *string `json:"owner_name,omitempty"`

				// Participants List of multiple persons (participants) this activity is associated with
				Participants *[]map[string]interface{} `json:"participants"`

				// PersonDropboxBcc The BCC email address of the person
				PersonDropboxBcc *string `json:"person_dropbox_bcc,omitempty"`

				// PersonId The ID of the person this activity is associated with
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person this activity is associated with
				PersonName *string `json:"person_name,omitempty"`

				// ProjectId The ID of the project this activity is associated with
				ProjectId *int `json:"project_id"`

				// PublicDescription Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
				PublicDescription *string `json:"public_description,omitempty"`

				// RecMasterActivityId The ID of parent activity for a recurrent activity if the current activity is an exception to recurrence rules
				RecMasterActivityId *int `json:"rec_master_activity_id,omitempty"`

				// RecRule The rule for the recurrence of the activity. Is important for activities synced into Pipedrive from an external calendar. Example: "RRULE:FREQ=WEEKLY;BYDAY=WE"
				RecRule *string `json:"rec_rule,omitempty"`

				// RecRuleExtension Additional rules for the recurrence of the activity, extend the `rec_rule`. Is important for activities synced into Pipedrive from an external calendar.
				RecRuleExtension *string `json:"rec_rule_extension,omitempty"`

				// ReferenceId Together with the `reference_type`, gives the ID of the other object
				ReferenceId *int `json:"reference_id,omitempty"`

				// ReferenceType If the activity references some other object, it is indicated here. For example, value `Salesphone` refers to activities created with Caller.
				ReferenceType *string `json:"reference_type,omitempty"`

				// Series The list of recurring activity instances. It is in a structure as follows: `[{due_date: "2020-06-24", due_time: "10:00:00"}]`
				Series *[]map[string]interface{} `json:"series,omitempty"`

				// SourceTimezone The timezone the activity was created in an external calendar
				SourceTimezone *string `json:"source_timezone,omitempty"`

				// Subject The subject of the activity
				Subject *string `json:"subject,omitempty"`

				// Type The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
				Type *string `json:"type,omitempty"`

				// UpdateTime The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`

				// UpdateUserId The ID of the user who was the last to update this activity
				UpdateUserId *int `json:"update_user_id,omitempty"`

				// UserId The ID of the user whom the activity is assigned to
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Deal *struct {
					// DEALID The ID of the deal which is associated with the item
					DEALID *struct {
						// Currency The currency of the deal value
						Currency *string `json:"currency,omitempty"`

						// Id The ID of the deal associated with the item
						Id *int `json:"id,omitempty"`

						// PipelineId The ID of the pipeline the deal is in
						PipelineId *int `json:"pipeline_id,omitempty"`

						// StageId The ID of the stage the deal is currently at
						StageId *int `json:"stage_id,omitempty"`

						// Status The status of the deal associated with the item
						Status *string `json:"status,omitempty"`

						// Title The title of the deal associated with the item
						Title *string `json:"title,omitempty"`

						// Value The value of the deal that is associated with the item
						Value *float32 `json:"value,omitempty"`
					} `json:"DEAL_ID,omitempty"`
				} `json:"deal,omitempty"`
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// ActiveFlag Whether the associated organization is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
				Person *struct {
					// PERSONID The ID of the person associated with the item
					PERSONID *struct {
						// ActiveFlag Whether the associated person is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The emails of the person associated with the item
						Email *[]struct {
							// Label The type of the email
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary email or not
							Primary *bool `json:"primary,omitempty"`

							// Value The email of the associated person
							Value *string `json:"value,omitempty"`
						} `json:"email,omitempty"`

						// Id The ID of the person associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the person associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the person that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// Phone The phone numbers of the person associated with the item
						Phone *[]struct {
							// Label The type of the phone number
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary phone number or not
							Primary *bool `json:"primary,omitempty"`

							// Value The phone number of the person associated with the item
							Value *string `json:"value,omitempty"`
						} `json:"phone,omitempty"`
					} `json:"PERSON_ID,omitempty"`
				} `json:"person,omitempty"`
				User *struct {
					USERID *struct {
						// ActiveFlag Whether the user is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The email of the user
						Email *string `json:"email,omitempty"`

						// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
						HasPic *int `json:"has_pic,omitempty"`

						// Id The ID of the user
						Id *int `json:"id,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// PicHash The user picture hash
						PicHash *string `json:"pic_hash"`
					} `json:"USER_ID,omitempty"`
				} `json:"user,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealChangelogResponse parses an HTTP response from a GetDealChangelogWithResponse call
func ParseGetDealChangelogResponse(rsp *http.Response) (*GetDealChangelogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealChangelogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// ActorUserId The ID of the user who made the change
				ActorUserId *int `json:"actor_user_id,omitempty"`

				// ChangeSource The source of change, for example 'app', 'mobile', 'api', etc.
				ChangeSource *string `json:"change_source"`

				// ChangeSourceUserAgent The user agent from which the change was made
				ChangeSourceUserAgent *string `json:"change_source_user_agent"`

				// FieldKey The key of the field that was changed
				FieldKey *string `json:"field_key,omitempty"`

				// IsBulkUpdateFlag Whether the change was made as part of a bulk update
				IsBulkUpdateFlag *bool `json:"is_bulk_update_flag,omitempty"`

				// NewValue The value of the field after the change
				NewValue *string `json:"new_value"`

				// OldValue The value of the field before the change
				OldValue *string `json:"old_value"`

				// Time The date and time of the change
				Time *string `json:"time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDuplicateDealResponse parses an HTTP response from a DuplicateDealWithResponse call
func ParseDuplicateDealResponse(rsp *http.Response) (*DuplicateDealResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DuplicateDealResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Active Whether the deal is active or not
				Active *bool `json:"active,omitempty"`

				// ActivitiesCount The number of activities associated with the deal
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AcvCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Contract Value of the deal
				//
				// If the `acv` is null, this will also be null
				AcvCurrency *string `json:"acv_currency"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// ArrCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Recurring Revenue of the deal
				//
				// If the `arr` is null, this will also be null
				ArrCurrency *string `json:"arr_currency"`

				// CcEmail The BCC email of the deal
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// CreatorUserId The ID of the deal creator
				CreatorUserId *int `json:"creator_user_id,omitempty"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// Deleted Whether the deal is deleted or not
				Deleted *bool `json:"deleted,omitempty"`

				// DoneActivitiesCount The number of completed activities associated with the deal
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// EmailMessagesCount The number of emails associated with the deal
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// FilesCount The number of files associated with the deal
				FilesCount *int `json:"files_count,omitempty"`

				// FirstWonTime The date and time of the first time changing the deal status as won
				FirstWonTime *string `json:"first_won_time,omitempty"`

				// FollowersCount The number of followers associated with the deal
				FollowersCount *int `json:"followers_count,omitempty"`

				// FormattedValue The deal value formatted with selected currency. E.g. US$500
				FormattedValue *string `json:"formatted_value,omitempty"`

				// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
				FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// Label The label or multiple labels assigned to the deal
				Label *string `json:"label,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the deal
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// MrrCurrency Only available in Growth and above plans
				//
				// The Currency for Monthly Recurring Revenue of the deal
				//
				// If the `mrr` is null, this will also be null
				MrrCurrency *string `json:"mrr_currency"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date,omitempty"`

				// NextActivityDuration The duration of the next activity associated with the deal
				NextActivityDuration *string `json:"next_activity_duration,omitempty"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityNote The note of the next activity associated with the deal
				NextActivityNote *string `json:"next_activity_note,omitempty"`

				// NextActivitySubject The subject of the next activity associated with the deal
				NextActivitySubject *string `json:"next_activity_subject,omitempty"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time,omitempty"`

				// NextActivityType The type of the next activity associated with the deal
				NextActivityType *string `json:"next_activity_type,omitempty"`

				// NotesCount The number of notes associated with the deal
				NotesCount *int `json:"notes_count,omitempty"`

				// OrgHidden If the organization that is associated with the deal is hidden or not
				OrgHidden *bool `json:"org_hidden,omitempty"`

				// OrgId The ID of the organization associated with the deal
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the deal
				OrgName *string `json:"org_name,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerName The name of the deal owner
				OwnerName *string `json:"owner_name,omitempty"`

				// ParticipantsCount The number of participants associated with the deal
				ParticipantsCount *int `json:"participants_count,omitempty"`

				// PersonHidden If the person that is associated with the deal is hidden or not
				PersonHidden *bool `json:"person_hidden,omitempty"`

				// PersonId The ID of the person associated with the deal
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the deal
				PersonName *string `json:"person_name,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// ProductsCount The number of products associated with the deal
				ProductsCount *int `json:"products_count,omitempty"`

				// RottenTime The date and time of changing the deal status as rotten
				RottenTime *string `json:"rotten_time"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// StageOrderNr The order number of the deal stage associated with the deal
				StageOrderNr *int `json:"stage_order_nr,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UndoneActivitiesCount The number of incomplete activities associated with the deal
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`

				// UserId The ID of the user
				UserId *int `json:"user_id,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *string `json:"visible_to,omitempty"`

				// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
				WeightedValue *float32 `json:"weighted_value,omitempty"`

				// WeightedValueCurrency The currency associated with the deal
				WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealFilesResponse parses an HTTP response from a GetDealFilesWithResponse call
func ParseGetDealFilesResponse(rsp *http.Response) (*GetDealFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of files
			Data *[]struct {
				// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivityId The ID of the activity to associate the file with
				ActivityId *int `json:"activity_id,omitempty"`

				// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// Cid The ID of the inline attachment
				Cid *string `json:"cid,omitempty"`

				// DealId The ID of the deal to associate the file with
				DealId *int `json:"deal_id,omitempty"`

				// DealName The name of the deal associated with the dile
				DealName *string `json:"deal_name,omitempty"`

				// Description The description of the file
				Description *string `json:"description,omitempty"`

				// FileName The original name of the file
				FileName *string `json:"file_name,omitempty"`

				// FileSize The size of the file
				FileSize *int `json:"file_size,omitempty"`

				// Id The ID of the file
				Id *int `json:"id,omitempty"`

				// InlineFlag Whether the file was uploaded as inline or not
				InlineFlag *bool `json:"inline_flag,omitempty"`

				// LeadId The ID of the lead to associate the file with
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// LeadName The name of the lead associated with the file
				LeadName *string `json:"lead_name,omitempty"`

				// MailMessageId The ID of the mail message to associate the file with
				MailMessageId *string `json:"mail_message_id,omitempty"`

				// MailTemplateId The ID of the mail template to associate the file with
				MailTemplateId *string `json:"mail_template_id,omitempty"`

				// Name The visible name of the file
				Name *string `json:"name,omitempty"`

				// OrgId The ID of the organization to associate the file with
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the file
				OrgName *string `json:"org_name,omitempty"`

				// PersonId The ID of the person to associate the file with
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the file
				PersonName *string `json:"person_name,omitempty"`

				// ProductId The ID of the product to associate the file with
				ProductId *int `json:"product_id,omitempty"`

				// ProductName The name of the product associated with the file
				ProductName *string `json:"product_name,omitempty"`

				// RemoteId The ID of the remote item
				RemoteId *string `json:"remote_id,omitempty"`

				// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
				RemoteLocation *string `json:"remote_location,omitempty"`

				// S3Bucket The location of the cloud storage
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// Url The URL of the download file
				Url *string `json:"url,omitempty"`

				// UserId The ID of the user to associate the file with
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealUpdatesResponse parses an HTTP response from a GetDealUpdatesWithResponse call
func ParseGetDealUpdatesResponse(rsp *http.Response) (*GetDealUpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// Data The data related to the update
				Data *map[string]interface{} `json:"data,omitempty"`

				// Object The type of the deal update. (Possible object types - dealChange, note, activity, mailMessage, invoice, document, file)
				Object *string `json:"object,omitempty"`

				// Timestamp The creation date and time of the update
				Timestamp *string `json:"timestamp,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Deal *struct {
					// DEALID The ID of the deal which is associated with the item
					DEALID *struct {
						// Currency The currency of the deal value
						Currency *string `json:"currency,omitempty"`

						// Id The ID of the deal associated with the item
						Id *int `json:"id,omitempty"`

						// PipelineId The ID of the pipeline the deal is in
						PipelineId *int `json:"pipeline_id,omitempty"`

						// StageId The ID of the stage the deal is currently at
						StageId *int `json:"stage_id,omitempty"`

						// Status The status of the deal associated with the item
						Status *string `json:"status,omitempty"`

						// Title The title of the deal associated with the item
						Title *string `json:"title,omitempty"`

						// Value The value of the deal that is associated with the item
						Value *float32 `json:"value,omitempty"`
					} `json:"DEAL_ID,omitempty"`
				} `json:"deal,omitempty"`
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
				Person *struct {
					// PERSONID The ID of the person associated with the item
					PERSONID *struct {
						// ActiveFlag Whether the associated person is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The emails of the person associated with the item
						Email *[]struct {
							// Label The type of the email
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary email or not
							Primary *bool `json:"primary,omitempty"`

							// Value The email of the associated person
							Value *string `json:"value,omitempty"`
						} `json:"email,omitempty"`

						// Id The ID of the person associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the person associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the person that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// Phone The phone numbers of the person associated with the item
						Phone *[]struct {
							// Label The type of the phone number
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary phone number or not
							Primary *bool `json:"primary,omitempty"`

							// Value The phone number of the person associated with the item
							Value *string `json:"value,omitempty"`
						} `json:"phone,omitempty"`
					} `json:"PERSON_ID,omitempty"`
				} `json:"person,omitempty"`
				User *struct {
					USERID *struct {
						// ActiveFlag Whether the user is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The email of the user
						Email *string `json:"email,omitempty"`

						// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
						HasPic *int `json:"has_pic,omitempty"`

						// Id The ID of the user
						Id *int `json:"id,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// PicHash The user picture hash
						PicHash *string `json:"pic_hash"`
					} `json:"USER_ID,omitempty"`
				} `json:"user,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealMailMessagesResponse parses an HTTP response from a GetDealMailMessagesWithResponse call
func ParseGetDealMailMessagesResponse(rsp *http.Response) (*GetDealMailMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealMailMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of mail messages
			Data *[]struct {
				Data *struct {
					// AccountId The connection account ID
					AccountId *string `json:"account_id,omitempty"`

					// AddTime The insertion into the database time of the mail message
					AddTime *time.Time `json:"add_time,omitempty"`

					// Bcc The array of mail message blind copies (object)
					Bcc *[]struct {
						// EmailAddress Mail address of the mail participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail participant
						Id *int `json:"id,omitempty"`

						// LinkedPersonId ID of the linked person to the mail message
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Name of the linked person to the mail message
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message participant
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// Name Name of the mail participant
						Name *string `json:"name,omitempty"`
					} `json:"bcc,omitempty"`

					// BodyUrl The mail message body URL
					BodyUrl *string `json:"body_url,omitempty"`

					// Cc The array of mail message copies (object)
					Cc *[]struct {
						// EmailAddress Mail address of the mail participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail participant
						Id *int `json:"id,omitempty"`

						// LinkedPersonId ID of the linked person to the mail message
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Name of the linked person to the mail message
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message participant
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// Name Name of the mail participant
						Name *string `json:"name,omitempty"`
					} `json:"cc,omitempty"`

					// CompanyId The ID of the company
					CompanyId *int `json:"company_id,omitempty"`

					// DeletedFlag Whether the mail message is deleted or not
					DeletedFlag *GetDealMailMessages200DataDataDeletedFlag `json:"deleted_flag,omitempty"`

					// Draft If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
					Draft *string `json:"draft,omitempty"`

					// DraftFlag Whether the mail message is a draft or not
					DraftFlag *GetDealMailMessages200DataDataDraftFlag `json:"draft_flag,omitempty"`

					// ExternalDeletedFlag If the Mail Message has been deleted on the provider side or not
					ExternalDeletedFlag *bool `json:"external_deleted_flag,omitempty"`

					// From The array of mail message sender (object)
					From *[]struct {
						// EmailAddress Mail address of the mail participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail participant
						Id *int `json:"id,omitempty"`

						// LinkedPersonId ID of the linked person to the mail message
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Name of the linked person to the mail message
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message participant
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// Name Name of the mail participant
						Name *string `json:"name,omitempty"`
					} `json:"from,omitempty"`

					// HasAttachmentsFlag Whether the mail message has an attachment or not
					HasAttachmentsFlag *GetDealMailMessages200DataDataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

					// HasBodyFlag Whether the mail message has a body or not
					HasBodyFlag *GetDealMailMessages200DataDataHasBodyFlag `json:"has_body_flag,omitempty"`

					// HasInlineAttachmentsFlag Whether the mail message has an inline attachment or not
					HasInlineAttachmentsFlag *GetDealMailMessages200DataDataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

					// HasRealAttachmentsFlag Whether the mail message has an attachment (which is not inline) or not
					HasRealAttachmentsFlag *GetDealMailMessages200DataDataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

					// Id ID of the mail message.
					Id *int `json:"id,omitempty"`

					// ItemType The type of the data item
					ItemType *string `json:"item_type,omitempty"`

					// MailLinkTrackingEnabledFlag Whether the link tracking in mail message body is enabled.
					MailLinkTrackingEnabledFlag *GetDealMailMessages200DataDataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

					// MailThreadId ID of the mail message thread
					MailThreadId *int `json:"mail_thread_id,omitempty"`

					// MailTrackingStatus The status of tracking mail message. Value is `null` if tracking is not enabled.
					MailTrackingStatus *GetDealMailMessages200DataDataMailTrackingStatus `json:"mail_tracking_status"`

					// MessageTime Creation or receival time of the mail message
					MessageTime *time.Time `json:"message_time,omitempty"`

					// MuaMessageId The Mail Message ID assigned by the mail user agent
					MuaMessageId *string `json:"mua_message_id,omitempty"`

					// NylasId The Mail Message ID assigned by the sync provider
					NylasId *string `json:"nylas_id,omitempty"`

					// ReadFlag Whether the mail message is read or not by the user
					ReadFlag *GetDealMailMessages200DataDataReadFlag `json:"read_flag,omitempty"`

					// S3Bucket The name of the S3 bucket
					S3Bucket *string `json:"s3_bucket,omitempty"`

					// S3BucketPath The path of the S3 bucket
					S3BucketPath *string `json:"s3_bucket_path,omitempty"`

					// SentFlag Whether the mail message has been sent or not
					SentFlag *GetDealMailMessages200DataDataSentFlag `json:"sent_flag,omitempty"`

					// SentFromPipedriveFlag Whether the mail message has been sent from Pipedrive app or not
					SentFromPipedriveFlag *GetDealMailMessages200DataDataSentFromPipedriveFlag `json:"sent_from_pipedrive_flag,omitempty"`

					// SmartBccFlag Whether the mail message has been created by Smart Email BCC feature or not
					SmartBccFlag *GetDealMailMessages200DataDataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

					// Snippet The snippet of mail message. Snippet length is up to 225 characters.
					Snippet *string `json:"snippet,omitempty"`

					// Subject The subject of mail message
					Subject *string `json:"subject,omitempty"`

					// SyncedFlag Whether the mail message is synced with the provider or not
					SyncedFlag *GetDealMailMessages200DataDataSyncedFlag `json:"synced_flag,omitempty"`

					// TemplateId The ID of the mail template
					TemplateId *int `json:"template_id,omitempty"`

					// Timestamp The add date and time of the Mail Message
					Timestamp *string `json:"timestamp,omitempty"`

					// To The array of mail message receiver (object)
					To *[]struct {
						// EmailAddress Mail address of the mail participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail participant
						Id *int `json:"id,omitempty"`

						// LinkedPersonId ID of the linked person to the mail message
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Name of the linked person to the mail message
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message participant
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// Name Name of the mail participant
						Name *string `json:"name,omitempty"`
					} `json:"to,omitempty"`

					// UpdateTime The updating time in the database of the mail message
					UpdateTime *time.Time `json:"update_time,omitempty"`

					// UserId ID of the user whom mail message will be assigned to
					UserId *int `json:"user_id,omitempty"`
				} `json:"data,omitempty"`

				// Object The type of the data item
				Object *string `json:"object,omitempty"`

				// Timestamp The date and time when the item was created
				Timestamp *string `json:"timestamp,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMergeDealsResponse parses an HTTP response from a MergeDealsWithResponse call
func ParseMergeDealsResponse(rsp *http.Response) (*MergeDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Active Whether the deal is active or not
				Active *bool `json:"active,omitempty"`

				// ActivitiesCount The number of activities associated with the deal
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AcvCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Contract Value of the deal
				//
				// If the `acv` is null, this will also be null
				AcvCurrency *string `json:"acv_currency"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// ArrCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Recurring Revenue of the deal
				//
				// If the `arr` is null, this will also be null
				ArrCurrency *string `json:"arr_currency"`

				// CcEmail The BCC email of the deal
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// CreatorUserId The ID of the deal creator
				CreatorUserId *int `json:"creator_user_id,omitempty"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// Deleted Whether the deal is deleted or not
				Deleted *bool `json:"deleted,omitempty"`

				// DoneActivitiesCount The number of completed activities associated with the deal
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// EmailMessagesCount The number of emails associated with the deal
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// FilesCount The number of files associated with the deal
				FilesCount *int `json:"files_count,omitempty"`

				// FirstWonTime The date and time of the first time changing the deal status as won
				FirstWonTime *string `json:"first_won_time,omitempty"`

				// FollowersCount The number of followers associated with the deal
				FollowersCount *int `json:"followers_count,omitempty"`

				// FormattedValue The deal value formatted with selected currency. E.g. US$500
				FormattedValue *string `json:"formatted_value,omitempty"`

				// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
				FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// Label The label or multiple labels assigned to the deal
				Label *string `json:"label,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the deal
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// MergeWhatId The deal ID of the deal which the original deal was merged with
				MergeWhatId *int `json:"merge_what_id,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// MrrCurrency Only available in Growth and above plans
				//
				// The Currency for Monthly Recurring Revenue of the deal
				//
				// If the `mrr` is null, this will also be null
				MrrCurrency *string `json:"mrr_currency"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date,omitempty"`

				// NextActivityDuration The duration of the next activity associated with the deal
				NextActivityDuration *string `json:"next_activity_duration,omitempty"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityNote The note of the next activity associated with the deal
				NextActivityNote *string `json:"next_activity_note,omitempty"`

				// NextActivitySubject The subject of the next activity associated with the deal
				NextActivitySubject *string `json:"next_activity_subject,omitempty"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time,omitempty"`

				// NextActivityType The type of the next activity associated with the deal
				NextActivityType *string `json:"next_activity_type,omitempty"`

				// NotesCount The number of notes associated with the deal
				NotesCount *int `json:"notes_count,omitempty"`

				// OrgHidden If the organization that is associated with the deal is hidden or not
				OrgHidden *bool `json:"org_hidden,omitempty"`

				// OrgId The ID of the organization associated with the deal
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the deal
				OrgName *string `json:"org_name,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerName The name of the deal owner
				OwnerName *string `json:"owner_name,omitempty"`

				// ParticipantsCount The number of participants associated with the deal
				ParticipantsCount *int `json:"participants_count,omitempty"`

				// PersonHidden If the person that is associated with the deal is hidden or not
				PersonHidden *bool `json:"person_hidden,omitempty"`

				// PersonId The ID of the person associated with the deal
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the deal
				PersonName *string `json:"person_name,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// ProductsCount The number of products associated with the deal
				ProductsCount *int `json:"products_count,omitempty"`

				// RottenTime The date and time of changing the deal status as rotten
				RottenTime *string `json:"rotten_time"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// StageOrderNr The order number of the deal stage associated with the deal
				StageOrderNr *int `json:"stage_order_nr,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UndoneActivitiesCount The number of incomplete activities associated with the deal
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`

				// UserId The ID of the user
				UserId *int `json:"user_id,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *string `json:"visible_to,omitempty"`

				// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
				WeightedValue *float32 `json:"weighted_value,omitempty"`

				// WeightedValueCurrency The currency associated with the deal
				WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealParticipantsResponse parses an HTTP response from a GetDealParticipantsWithResponse call
func ParseGetDealParticipantsResponse(rsp *http.Response) (*GetDealParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of participants
			Data *[]struct {
				// ActiveFlag Whether the person is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivitiesCount The count of activities related to the person
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// CcEmail The BCC email associated with the person
				CcEmail *string `json:"cc_email,omitempty"`

				// ClosedDealsCount The count of closed deals related with the item
				ClosedDealsCount *int `json:"closed_deals_count,omitempty"`

				// CompanyId The ID of the company related to the person
				CompanyId *int `json:"company_id,omitempty"`

				// DoneActivitiesCount The count of done activities related to the person
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" } ]`. Please note that only `value` is required.
				Email *[]struct {
					// Label The label that indicates the type of the email. (Possible values - work, home or other)
					Label *string `json:"label,omitempty"`

					// Primary Boolean that indicates if email is primary for the person or not
					Primary *bool `json:"primary,omitempty"`

					// Value Email
					Value *string `json:"value,omitempty"`
				} `json:"email,omitempty"`

				// EmailMessagesCount The count of email messages related to the person
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// FilesCount The count of files related to the person
				FilesCount *int `json:"files_count,omitempty"`

				// FirstChar The first letter of the name of the person
				FirstChar *string `json:"first_char,omitempty"`

				// FirstName The first name of the person
				FirstName *string `json:"first_name,omitempty"`

				// FollowersCount The count of followers related to the person
				FollowersCount *int `json:"followers_count,omitempty"`

				// Id The ID of the person
				Id *int `json:"id,omitempty"`

				// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
				Label *int `json:"label,omitempty"`

				// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the person
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastName The last name of the person
				LastName *string `json:"last_name,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the person
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostDealsCount The count of lost deals related with the item
				LostDealsCount *int `json:"lost_deals_count,omitempty"`

				// Name The name of the person
				Name *string `json:"name,omitempty"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time"`

				// NotesCount The count of notes related to the person
				NotesCount *int `json:"notes_count,omitempty"`

				// OpenDealsCount The count of open deals related with the item
				OpenDealsCount *int `json:"open_deals_count,omitempty"`
				OrgId          *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization
					Value *int `json:"value,omitempty"`
				} `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the person
				OrgName *string `json:"org_name,omitempty"`
				OwnerId *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`

					// Value The ID of the owner
					Value *int `json:"value,omitempty"`
				} `json:"owner_id,omitempty"`

				// OwnerName The name of the owner associated with the person
				OwnerName *string `json:"owner_name,omitempty"`

				// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
				Phone *[]struct {
					// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
					Label *string `json:"label,omitempty"`

					// Primary Boolean that indicates if phone number is primary for the person or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number
					Value *string `json:"value,omitempty"`
				} `json:"phone,omitempty"`
				PictureId *struct {
					// ActiveFlag Whether the associated picture is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// AddTime The add time of the picture
					AddTime *string `json:"add_time,omitempty"`

					// AddedByUserId The ID of the user who added the picture
					AddedByUserId *int `json:"added_by_user_id,omitempty"`

					// Id The ID of the picture associated with the item
					Id *int `json:"id,omitempty"`

					// ItemId The ID of related item
					ItemId *int `json:"item_id,omitempty"`

					// ItemType The type of item the picture is related to
					ItemType *string `json:"item_type,omitempty"`
					Pictures *struct {
						// N128 The URL of the 128*128 picture
						N128 *string `json:"128,omitempty"`

						// N512 The URL of the 512*512 picture
						N512 *string `json:"512,omitempty"`
					} `json:"pictures,omitempty"`

					// UpdateTime The update time of the picture
					UpdateTime *string `json:"update_time,omitempty"`
				} `json:"picture_id,omitempty"`

				// RelatedClosedDealsCount The count of related closed deals related with the item
				RelatedClosedDealsCount *int `json:"related_closed_deals_count,omitempty"`

				// RelatedLostDealsCount The count of related lost deals related with the item
				RelatedLostDealsCount *int `json:"related_lost_deals_count,omitempty"`

				// RelatedOpenDealsCount The count of related open deals related with the item
				RelatedOpenDealsCount *int `json:"related_open_deals_count,omitempty"`

				// RelatedWonDealsCount The count of related won deals related with the item
				RelatedWonDealsCount *int `json:"related_won_deals_count,omitempty"`

				// UndoneActivitiesCount The count of undone activities related to the person
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility group ID of who can see the person
				VisibleTo *string `json:"visible_to,omitempty"`

				// WonDealsCount The count of won deals related with the item
				WonDealsCount *int `json:"won_deals_count,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// ActiveFlag Whether the associated organization is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
				Person *struct {
					// PERSONID The ID of the person associated with the item
					PERSONID *struct {
						// ActiveFlag Whether the associated person is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The emails of the person associated with the item
						Email *[]struct {
							// Label The type of the email
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary email or not
							Primary *bool `json:"primary,omitempty"`

							// Value The email of the associated person
							Value *string `json:"value,omitempty"`
						} `json:"email,omitempty"`

						// Id The ID of the person associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the person associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the person that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// Phone The phone numbers of the person associated with the item
						Phone *[]struct {
							// Label The type of the phone number
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary phone number or not
							Primary *bool `json:"primary,omitempty"`

							// Value The phone number of the person associated with the item
							Value *string `json:"value,omitempty"`
						} `json:"phone,omitempty"`
					} `json:"PERSON_ID,omitempty"`
				} `json:"person,omitempty"`
				User *struct {
					USERID *struct {
						// ActiveFlag Whether the user is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The email of the user
						Email *string `json:"email,omitempty"`

						// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
						HasPic *int `json:"has_pic,omitempty"`

						// Id The ID of the user
						Id *int `json:"id,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// PicHash The user picture hash
						PicHash *string `json:"pic_hash"`
					} `json:"USER_ID,omitempty"`
				} `json:"user,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddDealParticipantResponse parses an HTTP response from a AddDealParticipantWithResponse call
func ParseAddDealParticipantResponse(rsp *http.Response) (*AddDealParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDealParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The object of participant
			Data *struct {
				// ActiveFlag Whether the person is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivitiesCount The count of activities related to the person
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// CcEmail The BCC email associated with the person
				CcEmail *string `json:"cc_email,omitempty"`

				// ClosedDealsCount The count of closed deals related with the item
				ClosedDealsCount *int `json:"closed_deals_count,omitempty"`

				// CompanyId The ID of the company related to the person
				CompanyId *int `json:"company_id,omitempty"`

				// DoneActivitiesCount The count of done activities related to the person
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" } ]`. Please note that only `value` is required.
				Email *[]struct {
					// Label The label that indicates the type of the email. (Possible values - work, home or other)
					Label *string `json:"label,omitempty"`

					// Primary Boolean that indicates if email is primary for the person or not
					Primary *bool `json:"primary,omitempty"`

					// Value Email
					Value *string `json:"value,omitempty"`
				} `json:"email,omitempty"`

				// EmailMessagesCount The count of email messages related to the person
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// FilesCount The count of files related to the person
				FilesCount *int `json:"files_count,omitempty"`

				// FirstChar The first letter of the name of the person
				FirstChar *string `json:"first_char,omitempty"`

				// FirstName The first name of the person
				FirstName *string `json:"first_name,omitempty"`

				// FollowersCount The count of followers related to the person
				FollowersCount *int `json:"followers_count,omitempty"`

				// Id The ID of the person
				Id *int `json:"id,omitempty"`

				// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
				Label *int `json:"label,omitempty"`

				// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the person
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastName The last name of the person
				LastName *string `json:"last_name,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the person
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostDealsCount The count of lost deals related with the item
				LostDealsCount *int `json:"lost_deals_count,omitempty"`

				// Name The name of the person
				Name *string `json:"name,omitempty"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time"`

				// NotesCount The count of notes related to the person
				NotesCount *int `json:"notes_count,omitempty"`

				// OpenDealsCount The count of open deals related with the item
				OpenDealsCount *int `json:"open_deals_count,omitempty"`
				OrgId          *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization
					Value *int `json:"value,omitempty"`
				} `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the person
				OrgName *string `json:"org_name,omitempty"`
				OwnerId *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`

					// Value The ID of the owner
					Value *int `json:"value,omitempty"`
				} `json:"owner_id,omitempty"`

				// OwnerName The name of the owner associated with the person
				OwnerName *string `json:"owner_name,omitempty"`

				// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
				Phone *[]struct {
					// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
					Label *string `json:"label,omitempty"`

					// Primary Boolean that indicates if phone number is primary for the person or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number
					Value *string `json:"value,omitempty"`
				} `json:"phone,omitempty"`
				PictureId *struct {
					// ActiveFlag Whether the associated picture is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// AddTime The add time of the picture
					AddTime *string `json:"add_time,omitempty"`

					// AddedByUserId The ID of the user who added the picture
					AddedByUserId *int `json:"added_by_user_id,omitempty"`

					// Id The ID of the picture associated with the item
					Id *int `json:"id,omitempty"`

					// ItemId The ID of related item
					ItemId *int `json:"item_id,omitempty"`

					// ItemType The type of item the picture is related to
					ItemType *string `json:"item_type,omitempty"`
					Pictures *struct {
						// N128 The URL of the 128*128 picture
						N128 *string `json:"128,omitempty"`

						// N512 The URL of the 512*512 picture
						N512 *string `json:"512,omitempty"`
					} `json:"pictures,omitempty"`

					// UpdateTime The update time of the picture
					UpdateTime *string `json:"update_time,omitempty"`
				} `json:"picture_id,omitempty"`

				// RelatedClosedDealsCount The count of related closed deals related with the item
				RelatedClosedDealsCount *int `json:"related_closed_deals_count,omitempty"`

				// RelatedLostDealsCount The count of related lost deals related with the item
				RelatedLostDealsCount *int `json:"related_lost_deals_count,omitempty"`

				// RelatedOpenDealsCount The count of related open deals related with the item
				RelatedOpenDealsCount *int `json:"related_open_deals_count,omitempty"`

				// RelatedWonDealsCount The count of related won deals related with the item
				RelatedWonDealsCount *int `json:"related_won_deals_count,omitempty"`

				// UndoneActivitiesCount The count of undone activities related to the person
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility group ID of who can see the person
				VisibleTo *string `json:"visible_to,omitempty"`

				// WonDealsCount The count of won deals related with the item
				WonDealsCount *int `json:"won_deals_count,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Person *struct {
					// PERSONID The ID of the person associated with the item
					PERSONID *struct {
						// ActiveFlag Whether the associated person is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The emails of the person associated with the item
						Email *[]struct {
							// Label The type of the email
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary email or not
							Primary *bool `json:"primary,omitempty"`

							// Value The email of the associated person
							Value *string `json:"value,omitempty"`
						} `json:"email,omitempty"`

						// Id The ID of the person associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the person associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the person that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// Phone The phone numbers of the person associated with the item
						Phone *[]struct {
							// Label The type of the phone number
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary phone number or not
							Primary *bool `json:"primary,omitempty"`

							// Value The phone number of the person associated with the item
							Value *string `json:"value,omitempty"`
						} `json:"phone,omitempty"`
					} `json:"PERSON_ID,omitempty"`
				} `json:"person,omitempty"`
				User *struct {
					USERID *struct {
						// ActiveFlag Whether the user is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The email of the user
						Email *string `json:"email,omitempty"`

						// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
						HasPic *int `json:"has_pic,omitempty"`

						// Id The ID of the user
						Id *int `json:"id,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// PicHash The user picture hash
						PicHash *string `json:"pic_hash"`
					} `json:"USER_ID,omitempty"`
				} `json:"user,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDealParticipantResponse parses an HTTP response from a DeleteDealParticipantWithResponse call
func ParseDeleteDealParticipantResponse(rsp *http.Response) (*DeleteDealParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDealParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of the deal participant that was deleted
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealParticipantsChangelogResponse parses an HTTP response from a GetDealParticipantsChangelogWithResponse call
func ParseGetDealParticipantsChangelogResponse(rsp *http.Response) (*GetDealParticipantsChangelogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealParticipantsChangelogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of participant changelog
			Data *[]struct {
				// Action Deal participant action type
				Action *string `json:"action,omitempty"`

				// ActorUserId The ID of the user
				ActorUserId *int `json:"actor_user_id,omitempty"`

				// PersonId The ID of the person
				PersonId *int `json:"person_id,omitempty"`

				// Time The deal participant action log time
				Time *string `json:"time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealUsersResponse parses an HTTP response from a GetDealUsersWithResponse call
func ParseGetDealUsersResponse(rsp *http.Response) (*GetDealUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealPersonsResponse parses an HTTP response from a GetDealPersonsWithResponse call
func ParseGetDealPersonsResponse(rsp *http.Response) (*GetDealPersonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealPersonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of persons
			Data *[]struct {
				// ActiveFlag Whether the person is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivitiesCount The count of activities related to the person
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// CcEmail The BCC email associated with the person
				CcEmail *string `json:"cc_email,omitempty"`

				// ClosedDealsCount The count of closed deals related with the item
				ClosedDealsCount *int `json:"closed_deals_count,omitempty"`

				// CompanyId The ID of the company related to the person
				CompanyId *int `json:"company_id,omitempty"`

				// DoneActivitiesCount The count of done activities related to the person
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" } ]`. Please note that only `value` is required.
				Email *[]struct {
					// Label The label that indicates the type of the email. (Possible values - work, home or other)
					Label *string `json:"label,omitempty"`

					// Primary Boolean that indicates if email is primary for the person or not
					Primary *bool `json:"primary,omitempty"`

					// Value Email
					Value *string `json:"value,omitempty"`
				} `json:"email,omitempty"`

				// EmailMessagesCount The count of email messages related to the person
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// FilesCount The count of files related to the person
				FilesCount *int `json:"files_count,omitempty"`

				// FirstChar The first letter of the name of the person
				FirstChar *string `json:"first_char,omitempty"`

				// FirstName The first name of the person
				FirstName *string `json:"first_name,omitempty"`

				// FollowersCount The count of followers related to the person
				FollowersCount *int `json:"followers_count,omitempty"`

				// Id The ID of the person
				Id *int `json:"id,omitempty"`

				// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
				Label *int `json:"label,omitempty"`

				// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the person
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastName The last name of the person
				LastName *string `json:"last_name,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the person
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostDealsCount The count of lost deals related with the item
				LostDealsCount *int `json:"lost_deals_count,omitempty"`

				// Name The name of the person
				Name *string `json:"name,omitempty"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time"`

				// NotesCount The count of notes related to the person
				NotesCount *int `json:"notes_count,omitempty"`

				// OpenDealsCount The count of open deals related with the item
				OpenDealsCount *int `json:"open_deals_count,omitempty"`
				OrgId          *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization
					Value *int `json:"value,omitempty"`
				} `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the person
				OrgName *string `json:"org_name,omitempty"`
				OwnerId *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`

					// Value The ID of the owner
					Value *int `json:"value,omitempty"`
				} `json:"owner_id,omitempty"`

				// OwnerName The name of the owner associated with the person
				OwnerName *string `json:"owner_name,omitempty"`

				// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
				Phone *[]struct {
					// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
					Label *string `json:"label,omitempty"`

					// Primary Boolean that indicates if phone number is primary for the person or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number
					Value *string `json:"value,omitempty"`
				} `json:"phone,omitempty"`
				PictureId *struct {
					// ActiveFlag Whether the associated picture is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// AddTime The add time of the picture
					AddTime *string `json:"add_time,omitempty"`

					// AddedByUserId The ID of the user who added the picture
					AddedByUserId *int `json:"added_by_user_id,omitempty"`

					// Id The ID of the picture associated with the item
					Id *int `json:"id,omitempty"`

					// ItemId The ID of related item
					ItemId *int `json:"item_id,omitempty"`

					// ItemType The type of item the picture is related to
					ItemType *string `json:"item_type,omitempty"`
					Pictures *struct {
						// N128 The URL of the 128*128 picture
						N128 *string `json:"128,omitempty"`

						// N512 The URL of the 512*512 picture
						N512 *string `json:"512,omitempty"`
					} `json:"pictures,omitempty"`

					// UpdateTime The update time of the picture
					UpdateTime *string `json:"update_time,omitempty"`
				} `json:"picture_id,omitempty"`

				// RelatedClosedDealsCount The count of related closed deals related with the item
				RelatedClosedDealsCount *int `json:"related_closed_deals_count,omitempty"`

				// RelatedLostDealsCount The count of related lost deals related with the item
				RelatedLostDealsCount *int `json:"related_lost_deals_count,omitempty"`

				// RelatedOpenDealsCount The count of related open deals related with the item
				RelatedOpenDealsCount *int `json:"related_open_deals_count,omitempty"`

				// RelatedWonDealsCount The count of related won deals related with the item
				RelatedWonDealsCount *int `json:"related_won_deals_count,omitempty"`

				// UndoneActivitiesCount The count of undone activities related to the person
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility group ID of who can see the person
				VisibleTo *string `json:"visible_to,omitempty"`

				// WonDealsCount The count of won deals related with the item
				WonDealsCount *int `json:"won_deals_count,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// ActiveFlag Whether the associated organization is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
				User *struct {
					USERID *struct {
						// ActiveFlag Whether the user is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The email of the user
						Email *string `json:"email,omitempty"`

						// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
						HasPic *int `json:"has_pic,omitempty"`

						// Id The ID of the user
						Id *int `json:"id,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// PicHash The user picture hash
						PicHash *string `json:"pic_hash"`
					} `json:"USER_ID,omitempty"`
				} `json:"user,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFilesResponse parses an HTTP response from a GetFilesWithResponse call
func ParseGetFilesResponse(rsp *http.Response) (*GetFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// Pagination Pagination details of the list
				Pagination *struct {
					// Limit Items shown per page
					Limit *int `json:"limit,omitempty"`

					// MoreItemsInCollection If there are more list items in the collection than displayed or not
					MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

					// NextStart Next pagination start
					NextStart *int `json:"next_start,omitempty"`

					// Start Pagination start
					Start *int `json:"start,omitempty"`
				} `json:"pagination,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of all uploaded files
			Data *[]struct {
				// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivityId The ID of the activity to associate the file with
				ActivityId *int `json:"activity_id,omitempty"`

				// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// Cid The ID of the inline attachment
				Cid *string `json:"cid,omitempty"`

				// DealId The ID of the deal to associate the file with
				DealId *int `json:"deal_id,omitempty"`

				// DealName The name of the deal associated with the file
				DealName *string `json:"deal_name,omitempty"`

				// Description The description of the file
				Description *string `json:"description,omitempty"`

				// FileName The original name of the file
				FileName *string `json:"file_name,omitempty"`

				// FileSize The size of the file
				FileSize *int `json:"file_size,omitempty"`

				// Id The ID of the file
				Id *int `json:"id,omitempty"`

				// InlineFlag Whether the file was uploaded as inline or not
				InlineFlag *bool `json:"inline_flag,omitempty"`

				// LeadId The ID of the lead to associate the file with
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// LeadName The name of the lead associated with the file
				LeadName *string `json:"lead_name,omitempty"`

				// MailMessageId The ID of the mail message to associate the file with
				MailMessageId *string `json:"mail_message_id,omitempty"`

				// MailTemplateId The ID of the mail template to associate the file with
				MailTemplateId *string `json:"mail_template_id,omitempty"`

				// Name The visible name of the file
				Name *string `json:"name,omitempty"`

				// OrgId The ID of the organization to associate the file with
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the file
				OrgName *string `json:"org_name,omitempty"`

				// PersonId The ID of the person to associate the file with
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the file
				PersonName *string `json:"person_name,omitempty"`

				// ProductId The ID of the product to associate the file with
				ProductId *int `json:"product_id,omitempty"`

				// ProductName The name of the product associated with the file
				ProductName *string `json:"product_name,omitempty"`

				// RemoteId The ID of the remote item
				RemoteId *string `json:"remote_id,omitempty"`

				// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
				RemoteLocation *string `json:"remote_location,omitempty"`

				// S3Bucket The location of the cloud storage
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// Url The URL of the download file
				Url *string `json:"url,omitempty"`

				// UserId The ID of the user to associate the file with
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddFileResponse parses an HTTP response from a AddFileWithResponse call
func ParseAddFileResponse(rsp *http.Response) (*AddFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The file data
			Data *struct {
				// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivityId The ID of the activity to associate the file with
				ActivityId *int `json:"activity_id,omitempty"`

				// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// Cid The ID of the inline attachment
				Cid *string `json:"cid,omitempty"`

				// DealId The ID of the deal to associate the file with
				DealId *int `json:"deal_id,omitempty"`

				// DealName The name of the deal associated with the file
				DealName *string `json:"deal_name,omitempty"`

				// Description The description of the file
				Description *string `json:"description,omitempty"`

				// FileName The original name of the file
				FileName *string `json:"file_name,omitempty"`

				// FileSize The size of the file
				FileSize *int `json:"file_size,omitempty"`

				// Id The ID of the file
				Id *int `json:"id,omitempty"`

				// InlineFlag Whether the file was uploaded as inline or not
				InlineFlag *bool `json:"inline_flag,omitempty"`

				// LeadId The ID of the lead to associate the file with
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// LeadName The name of the lead associated with the file
				LeadName *string `json:"lead_name,omitempty"`

				// MailMessageId The ID of the mail message to associate the file with
				MailMessageId *string `json:"mail_message_id,omitempty"`

				// MailTemplateId The ID of the mail template to associate the file with
				MailTemplateId *string `json:"mail_template_id,omitempty"`

				// Name The visible name of the file
				Name *string `json:"name,omitempty"`

				// OrgId The ID of the organization to associate the file with
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the file
				OrgName *string `json:"org_name,omitempty"`

				// PersonId The ID of the person to associate the file with
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the file
				PersonName *string `json:"person_name,omitempty"`

				// ProductId The ID of the product to associate the file with
				ProductId *int `json:"product_id,omitempty"`

				// ProductName The name of the product associated with the file
				ProductName *string `json:"product_name,omitempty"`

				// RemoteId The ID of the remote item
				RemoteId *string `json:"remote_id,omitempty"`

				// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
				RemoteLocation *string `json:"remote_location,omitempty"`

				// S3Bucket The location of the cloud storage
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// Url The URL of the download file
				Url *string `json:"url,omitempty"`

				// UserId The ID of the user to associate the file with
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddFileAndLinkItResponse parses an HTTP response from a AddFileAndLinkItWithResponse call
func ParseAddFileAndLinkItResponse(rsp *http.Response) (*AddFileAndLinkItResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddFileAndLinkItResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The file data
			Data *struct {
				// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivityId The ID of the activity to associate the file with
				ActivityId *int `json:"activity_id,omitempty"`

				// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// Cid The ID of the inline attachment
				Cid *string `json:"cid,omitempty"`

				// DealId The ID of the deal to associate the file with
				DealId *int `json:"deal_id,omitempty"`

				// DealName The name of the deal associated with the file
				DealName *string `json:"deal_name,omitempty"`

				// Description The description of the file
				Description *string `json:"description,omitempty"`

				// FileName The original name of the file
				FileName *string `json:"file_name,omitempty"`

				// FileSize The size of the file
				FileSize *int `json:"file_size,omitempty"`

				// Id The ID of the file
				Id *int `json:"id,omitempty"`

				// InlineFlag Whether the file was uploaded as inline or not
				InlineFlag *bool `json:"inline_flag,omitempty"`

				// LeadId The ID of the lead to associate the file with
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// LeadName The name of the lead associated with the file
				LeadName *string `json:"lead_name,omitempty"`

				// MailMessageId The ID of the mail message to associate the file with
				MailMessageId *string `json:"mail_message_id,omitempty"`

				// MailTemplateId The ID of the mail template to associate the file with
				MailTemplateId *string `json:"mail_template_id,omitempty"`

				// Name The visible name of the file
				Name *string `json:"name,omitempty"`

				// OrgId The ID of the organization to associate the file with
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the file
				OrgName *string `json:"org_name,omitempty"`

				// PersonId The ID of the person to associate the file with
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the file
				PersonName *string `json:"person_name,omitempty"`

				// ProductId The ID of the product to associate the file with
				ProductId *int `json:"product_id,omitempty"`

				// ProductName The name of the product associated with the file
				ProductName *string `json:"product_name,omitempty"`

				// RemoteId The ID of the remote item
				RemoteId *string `json:"remote_id,omitempty"`

				// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
				RemoteLocation *string `json:"remote_location,omitempty"`

				// S3Bucket The location of the cloud storage
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// Url The URL of the download file
				Url *string `json:"url,omitempty"`

				// UserId The ID of the user to associate the file with
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLinkFileToItemResponse parses an HTTP response from a LinkFileToItemWithResponse call
func ParseLinkFileToItemResponse(rsp *http.Response) (*LinkFileToItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkFileToItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The file data
			Data *struct {
				// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivityId The ID of the activity to associate the file with
				ActivityId *int `json:"activity_id,omitempty"`

				// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// Cid The ID of the inline attachment
				Cid *string `json:"cid,omitempty"`

				// DealId The ID of the deal to associate the file with
				DealId *int `json:"deal_id,omitempty"`

				// DealName The name of the deal associated with the file
				DealName *string `json:"deal_name,omitempty"`

				// Description The description of the file
				Description *string `json:"description,omitempty"`

				// FileName The original name of the file
				FileName *string `json:"file_name,omitempty"`

				// FileSize The size of the file
				FileSize *int `json:"file_size,omitempty"`

				// Id The ID of the file
				Id *int `json:"id,omitempty"`

				// InlineFlag Whether the file was uploaded as inline or not
				InlineFlag *bool `json:"inline_flag,omitempty"`

				// LeadId The ID of the lead to associate the file with
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// LeadName The name of the lead associated with the file
				LeadName *string `json:"lead_name,omitempty"`

				// MailMessageId The ID of the mail message to associate the file with
				MailMessageId *string `json:"mail_message_id,omitempty"`

				// MailTemplateId The ID of the mail template to associate the file with
				MailTemplateId *string `json:"mail_template_id,omitempty"`

				// Name The visible name of the file
				Name *string `json:"name,omitempty"`

				// OrgId The ID of the organization to associate the file with
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the file
				OrgName *string `json:"org_name,omitempty"`

				// PersonId The ID of the person to associate the file with
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the file
				PersonName *string `json:"person_name,omitempty"`

				// ProductId The ID of the product to associate the file with
				ProductId *int `json:"product_id,omitempty"`

				// ProductName The name of the product associated with the file
				ProductName *string `json:"product_name,omitempty"`

				// RemoteId The ID of the remote item
				RemoteId *string `json:"remote_id,omitempty"`

				// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
				RemoteLocation *string `json:"remote_location,omitempty"`

				// S3Bucket The location of the cloud storage
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// Url The URL of the download file
				Url *string `json:"url,omitempty"`

				// UserId The ID of the user to associate the file with
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFileResponse parses an HTTP response from a DeleteFileWithResponse call
func ParseDeleteFileResponse(rsp *http.Response) (*DeleteFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of the file
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFileResponse parses an HTTP response from a GetFileWithResponse call
func ParseGetFileResponse(rsp *http.Response) (*GetFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The file data
			Data *struct {
				// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivityId The ID of the activity to associate the file with
				ActivityId *int `json:"activity_id,omitempty"`

				// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// Cid The ID of the inline attachment
				Cid *string `json:"cid,omitempty"`

				// DealId The ID of the deal to associate the file with
				DealId *int `json:"deal_id,omitempty"`

				// DealName The name of the deal associated with the file
				DealName *string `json:"deal_name,omitempty"`

				// Description The description of the file
				Description *string `json:"description,omitempty"`

				// FileName The original name of the file
				FileName *string `json:"file_name,omitempty"`

				// FileSize The size of the file
				FileSize *int `json:"file_size,omitempty"`

				// Id The ID of the file
				Id *int `json:"id,omitempty"`

				// InlineFlag Whether the file was uploaded as inline or not
				InlineFlag *bool `json:"inline_flag,omitempty"`

				// LeadId The ID of the lead to associate the file with
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// LeadName The name of the lead associated with the file
				LeadName *string `json:"lead_name,omitempty"`

				// MailMessageId The ID of the mail message to associate the file with
				MailMessageId *string `json:"mail_message_id,omitempty"`

				// MailTemplateId The ID of the mail template to associate the file with
				MailTemplateId *string `json:"mail_template_id,omitempty"`

				// Name The visible name of the file
				Name *string `json:"name,omitempty"`

				// OrgId The ID of the organization to associate the file with
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the file
				OrgName *string `json:"org_name,omitempty"`

				// PersonId The ID of the person to associate the file with
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the file
				PersonName *string `json:"person_name,omitempty"`

				// ProductId The ID of the product to associate the file with
				ProductId *int `json:"product_id,omitempty"`

				// ProductName The name of the product associated with the file
				ProductName *string `json:"product_name,omitempty"`

				// RemoteId The ID of the remote item
				RemoteId *string `json:"remote_id,omitempty"`

				// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
				RemoteLocation *string `json:"remote_location,omitempty"`

				// S3Bucket The location of the cloud storage
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// Url The URL of the download file
				Url *string `json:"url,omitempty"`

				// UserId The ID of the user to associate the file with
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateFileResponse parses an HTTP response from a UpdateFileWithResponse call
func ParseUpdateFileResponse(rsp *http.Response) (*UpdateFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The file data
			Data *struct {
				// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivityId The ID of the activity to associate the file with
				ActivityId *int `json:"activity_id,omitempty"`

				// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// Cid The ID of the inline attachment
				Cid *string `json:"cid,omitempty"`

				// DealId The ID of the deal to associate the file with
				DealId *int `json:"deal_id,omitempty"`

				// DealName The name of the deal associated with the file
				DealName *string `json:"deal_name,omitempty"`

				// Description The description of the file
				Description *string `json:"description,omitempty"`

				// FileName The original name of the file
				FileName *string `json:"file_name,omitempty"`

				// FileSize The size of the file
				FileSize *int `json:"file_size,omitempty"`

				// Id The ID of the file
				Id *int `json:"id,omitempty"`

				// InlineFlag Whether the file was uploaded as inline or not
				InlineFlag *bool `json:"inline_flag,omitempty"`

				// LeadId The ID of the lead to associate the file with
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// LeadName The name of the lead associated with the file
				LeadName *string `json:"lead_name,omitempty"`

				// MailMessageId The ID of the mail message to associate the file with
				MailMessageId *string `json:"mail_message_id,omitempty"`

				// MailTemplateId The ID of the mail template to associate the file with
				MailTemplateId *string `json:"mail_template_id,omitempty"`

				// Name The visible name of the file
				Name *string `json:"name,omitempty"`

				// OrgId The ID of the organization to associate the file with
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the file
				OrgName *string `json:"org_name,omitempty"`

				// PersonId The ID of the person to associate the file with
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the file
				PersonName *string `json:"person_name,omitempty"`

				// ProductId The ID of the product to associate the file with
				ProductId *int `json:"product_id,omitempty"`

				// ProductName The name of the product associated with the file
				ProductName *string `json:"product_name,omitempty"`

				// RemoteId The ID of the remote item
				RemoteId *string `json:"remote_id,omitempty"`

				// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
				RemoteLocation *string `json:"remote_location,omitempty"`

				// S3Bucket The location of the cloud storage
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// Url The URL of the download file
				Url *string `json:"url,omitempty"`

				// UserId The ID of the user to associate the file with
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadFileResponse parses an HTTP response from a DownloadFileWithResponse call
func ParseDownloadFileResponse(rsp *http.Response) (*DownloadFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFiltersResponse parses an HTTP response from a DeleteFiltersWithResponse call
func ParseDeleteFiltersResponse(rsp *http.Response) (*DeleteFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The array of the IDs of the deleted filter
				Id *[]int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFiltersResponse parses an HTTP response from a GetFiltersWithResponse call
func ParseGetFiltersResponse(rsp *http.Response) (*GetFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The array of filters
			Data *[]struct {
				// ActiveFlag The active flag of the filter
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The date and time when the filter was added
				AddTime *string `json:"add_time,omitempty"`

				// CustomViewId Used by Pipedrive webapp
				CustomViewId *int `json:"custom_view_id,omitempty"`

				// Id The ID of the filter
				Id *int `json:"id,omitempty"`

				// Name The name of the filter
				Name *string `json:"name,omitempty"`

				// Type The type of the item
				Type *string `json:"type,omitempty"`

				// UpdateTime The date and time when the filter was updated
				UpdateTime *string `json:"update_time,omitempty"`

				// UserId The owner of the filter
				UserId *int `json:"user_id,omitempty"`

				// VisibleTo The visibility group ID of who can see then filter
				VisibleTo *int `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddFilterResponse parses an HTTP response from a AddFilterWithResponse call
func ParseAddFilterResponse(rsp *http.Response) (*AddFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag The activity flag of the created filter
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The add time of the created filter
				AddTime *string `json:"add_time,omitempty"`

				// Conditions The created filter conditions object
				Conditions *map[string]interface{} `json:"conditions,omitempty"`

				// CustomViewId The custom view ID of the created filter
				CustomViewId *int `json:"custom_view_id,omitempty"`

				// Id The ID of the created filter
				Id *int `json:"id,omitempty"`

				// Name The name of the created filter
				Name *string `json:"name,omitempty"`

				// TemporaryFlag If the created filter is temporary or not
				TemporaryFlag *bool                 `json:"temporary_flag,omitempty"`
				Type          *AddFilter200DataType `json:"type,omitempty"`

				// UpdateTime The update time of the created filter
				UpdateTime *string `json:"update_time,omitempty"`

				// UserId The user ID of the created filter
				UserId *int `json:"user_id,omitempty"`

				// VisibleTo The visibility group ID of the created filter
				VisibleTo *int `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFilterHelpersResponse parses an HTTP response from a GetFilterHelpersWithResponse call
func ParseGetFilterHelpersResponse(rsp *http.Response) (*GetFilterHelpersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilterHelpersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFilterResponse parses an HTTP response from a DeleteFilterWithResponse call
func ParseDeleteFilterResponse(rsp *http.Response) (*DeleteFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of the deleted filter
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFilterResponse parses an HTTP response from a GetFilterWithResponse call
func ParseGetFilterResponse(rsp *http.Response) (*GetFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The filter object
			Data *struct {
				// ActiveFlag The active flag of the filter
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The date and time when the filter was added
				AddTime *string `json:"add_time,omitempty"`

				// CustomViewId Used by Pipedrive webapp
				CustomViewId *int `json:"custom_view_id,omitempty"`

				// Id The ID of the filter
				Id *int `json:"id,omitempty"`

				// Name The name of the filter
				Name *string `json:"name,omitempty"`

				// Type The type of the item
				Type *string `json:"type,omitempty"`

				// UpdateTime The date and time when the filter was updated
				UpdateTime *string `json:"update_time,omitempty"`

				// UserId The owner of the filter
				UserId *int `json:"user_id,omitempty"`

				// VisibleTo The visibility group ID of who can see then filter
				VisibleTo *int `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateFilterResponse parses an HTTP response from a UpdateFilterWithResponse call
func ParseUpdateFilterResponse(rsp *http.Response) (*UpdateFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag The activity flag of the created filter
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The add time of the created filter
				AddTime *string `json:"add_time,omitempty"`

				// Conditions The created filter conditions object
				Conditions *map[string]interface{} `json:"conditions,omitempty"`

				// CustomViewId The custom view ID of the created filter
				CustomViewId *int `json:"custom_view_id,omitempty"`

				// Id The ID of the created filter
				Id *int `json:"id,omitempty"`

				// Name The name of the created filter
				Name *string `json:"name,omitempty"`

				// TemporaryFlag If the created filter is temporary or not
				TemporaryFlag *bool                    `json:"temporary_flag,omitempty"`
				Type          *UpdateFilter200DataType `json:"type,omitempty"`

				// UpdateTime The update time of the created filter
				UpdateTime *string `json:"update_time,omitempty"`

				// UserId The user ID of the created filter
				UserId *int `json:"user_id,omitempty"`

				// VisibleTo The visibility group ID of the created filter
				VisibleTo *int `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddGoalResponse parses an HTTP response from a AddGoalWithResponse call
func ParseAddGoalResponse(rsp *http.Response) (*AddGoalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddGoalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Goal *struct {
					// Assignee Who the goal is assigned to
					Assignee *struct {
						// Id The ID of the goal assignee
						Id *int `json:"id,omitempty"`

						// Type The type of the assignee
						Type *string `json:"type,omitempty"`
					} `json:"assignee,omitempty"`

					// Duration The duration of the goal
					Duration *struct {
						// End The end date of the goal
						End *string `json:"end,omitempty"`

						// Start The start date of the goal
						Start *string `json:"start,omitempty"`
					} `json:"duration,omitempty"`

					// ExpectedOutcome The expected outcome of the goal
					ExpectedOutcome *struct {
						// Target The numeric target of the goal
						Target *int `json:"target,omitempty"`

						// TrackingMetric The tracking metric of the goal
						TrackingMetric *string `json:"tracking_metric,omitempty"`
					} `json:"expected_outcome,omitempty"`

					// Id The ID of the goal
					Id *string `json:"id,omitempty"`

					// Interval The interval of the goal
					Interval *string `json:"interval,omitempty"`

					// IsActive Whether the goal is currently active or not
					IsActive *bool `json:"is_active,omitempty"`

					// OwnerId The ID of the creator of the goal
					OwnerId *int `json:"owner_id,omitempty"`

					// ReportIds The IDs of the reports that belong to the goal
					ReportIds *[]string `json:"report_ids,omitempty"`

					// Title The title of the goal
					Title *string `json:"title,omitempty"`

					// Type The type of the goal
					Type *struct {
						// Name The name of the goal type
						Name *string `json:"name,omitempty"`

						// Params The parameters that accompany the goal type
						Params *struct {
							// ActivityTypeId The IDs of activity types of the goal
							ActivityTypeId *[]int `json:"activity_type_id,omitempty"`

							// PipelineId The IDs of pipelines of the goal
							PipelineId *[]int `json:"pipeline_id,omitempty"`
						} `json:"params,omitempty"`
					} `json:"type,omitempty"`
				} `json:"goal,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGoalsResponse parses an HTTP response from a GetGoalsWithResponse call
func ParseGetGoalsResponse(rsp *http.Response) (*GetGoalsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGoalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Goals *[]struct {
					// Assignee Who the goal is assigned to
					Assignee *struct {
						// Id The ID of the goal assignee
						Id *int `json:"id,omitempty"`

						// Type The type of the assignee
						Type *string `json:"type,omitempty"`
					} `json:"assignee,omitempty"`

					// Duration The duration of the goal
					Duration *struct {
						// End The end date of the goal
						End *string `json:"end,omitempty"`

						// Start The start date of the goal
						Start *string `json:"start,omitempty"`
					} `json:"duration,omitempty"`

					// ExpectedOutcome The expected outcome of the goal
					ExpectedOutcome *struct {
						// Target The numeric target of the goal
						Target *int `json:"target,omitempty"`

						// TrackingMetric The tracking metric of the goal
						TrackingMetric *string `json:"tracking_metric,omitempty"`
					} `json:"expected_outcome,omitempty"`

					// Id The ID of the goal
					Id *string `json:"id,omitempty"`

					// Interval The interval of the goal
					Interval *string `json:"interval,omitempty"`

					// IsActive Whether the goal is currently active or not
					IsActive *bool `json:"is_active,omitempty"`

					// OwnerId The ID of the creator of the goal
					OwnerId *int `json:"owner_id,omitempty"`

					// ReportIds The IDs of the reports that belong to the goal
					ReportIds *[]string `json:"report_ids,omitempty"`

					// Title The title of the goal
					Title *string `json:"title,omitempty"`

					// Type The type of the goal
					Type *struct {
						// Name The name of the goal type
						Name *string `json:"name,omitempty"`

						// Params The parameters that accompany the goal type
						Params *struct {
							// ActivityTypeId The IDs of activity types of the goal
							ActivityTypeId *[]int `json:"activity_type_id,omitempty"`

							// PipelineId The IDs of pipelines of the goal
							PipelineId *[]int `json:"pipeline_id,omitempty"`
						} `json:"params,omitempty"`
					} `json:"type,omitempty"`
				} `json:"goals,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteGoalResponse parses an HTTP response from a DeleteGoalWithResponse call
func ParseDeleteGoalResponse(rsp *http.Response) (*DeleteGoalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGoalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateGoalResponse parses an HTTP response from a UpdateGoalWithResponse call
func ParseUpdateGoalResponse(rsp *http.Response) (*UpdateGoalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGoalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Goal *struct {
					// Assignee Who the goal is assigned to
					Assignee *struct {
						// Id The ID of the goal assignee
						Id *int `json:"id,omitempty"`

						// Type The type of the assignee
						Type *string `json:"type,omitempty"`
					} `json:"assignee,omitempty"`

					// Duration The duration of the goal
					Duration *struct {
						// End The end date of the goal
						End *string `json:"end,omitempty"`

						// Start The start date of the goal
						Start *string `json:"start,omitempty"`
					} `json:"duration,omitempty"`

					// ExpectedOutcome The expected outcome of the goal
					ExpectedOutcome *struct {
						// Target The numeric target of the goal
						Target *int `json:"target,omitempty"`

						// TrackingMetric The tracking metric of the goal
						TrackingMetric *string `json:"tracking_metric,omitempty"`
					} `json:"expected_outcome,omitempty"`

					// Id The ID of the goal
					Id *string `json:"id,omitempty"`

					// Interval The interval of the goal
					Interval *string `json:"interval,omitempty"`

					// IsActive Whether the goal is currently active or not
					IsActive *bool `json:"is_active,omitempty"`

					// OwnerId The ID of the creator of the goal
					OwnerId *int `json:"owner_id,omitempty"`

					// ReportIds The IDs of the reports that belong to the goal
					ReportIds *[]string `json:"report_ids,omitempty"`

					// Title The title of the goal
					Title *string `json:"title,omitempty"`

					// Type The type of the goal
					Type *struct {
						// Name The name of the goal type
						Name *string `json:"name,omitempty"`

						// Params The parameters that accompany the goal type
						Params *struct {
							// ActivityTypeId The IDs of activity types of the goal
							ActivityTypeId *[]int `json:"activity_type_id,omitempty"`

							// PipelineId The IDs of pipelines of the goal
							PipelineId *[]int `json:"pipeline_id,omitempty"`
						} `json:"params,omitempty"`
					} `json:"type,omitempty"`
				} `json:"goal,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGoalResultResponse parses an HTTP response from a GetGoalResultWithResponse call
func ParseGetGoalResultResponse(rsp *http.Response) (*GetGoalResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGoalResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Goal *struct {
					// Assignee Who the goal is assigned to
					Assignee *struct {
						// Id The ID of the goal assignee
						Id *int `json:"id,omitempty"`

						// Type The type of the assignee
						Type *string `json:"type,omitempty"`
					} `json:"assignee,omitempty"`

					// Duration The duration of the goal
					Duration *struct {
						// End The end date of the goal
						End *string `json:"end,omitempty"`

						// Start The start date of the goal
						Start *string `json:"start,omitempty"`
					} `json:"duration,omitempty"`

					// ExpectedOutcome The expected outcome of the goal
					ExpectedOutcome *struct {
						// Target The numeric target of the goal
						Target *int `json:"target,omitempty"`

						// TrackingMetric The tracking metric of the goal
						TrackingMetric *string `json:"tracking_metric,omitempty"`
					} `json:"expected_outcome,omitempty"`

					// Id The ID of the goal
					Id *string `json:"id,omitempty"`

					// Interval The interval of the goal
					Interval *string `json:"interval,omitempty"`

					// IsActive Whether the goal is currently active or not
					IsActive *bool `json:"is_active,omitempty"`

					// OwnerId The ID of the creator of the goal
					OwnerId *int `json:"owner_id,omitempty"`

					// ReportIds The IDs of the reports that belong to the goal
					ReportIds *[]string `json:"report_ids,omitempty"`

					// Title The title of the goal
					Title *string `json:"title,omitempty"`

					// Type The type of the goal
					Type *struct {
						// Name The name of the goal type
						Name *string `json:"name,omitempty"`

						// Params The parameters that accompany the goal type
						Params *struct {
							// ActivityTypeId The IDs of activity types of the goal
							ActivityTypeId *[]int `json:"activity_type_id,omitempty"`

							// PipelineId The IDs of pipelines of the goal
							PipelineId *[]int `json:"pipeline_id,omitempty"`
						} `json:"params,omitempty"`
					} `json:"type,omitempty"`
				} `json:"goal,omitempty"`

				// Progress The numeric progress of the goal
				Progress *int `json:"progress,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLeadFieldsResponse parses an HTTP response from a GetLeadFieldsWithResponse call
func ParseGetLeadFieldsResponse(rsp *http.Response) (*GetLeadFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeadFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// ActiveFlag The active flag of the field
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation time of the field
				AddTime *time.Time `json:"add_time,omitempty"`

				// AddVisibleFlag Not used
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// BulkEditAllowed Whether or not the field of an item can be edited in bulk
				BulkEditAllowed *bool `json:"bulk_edit_allowed,omitempty"`

				// CreatedByUserId The ID of the user who created the field
				CreatedByUserId *int `json:"created_by_user_id"`

				// DetailsVisibleFlag Not used
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// EditFlag The edit flag of the field
				EditFlag *bool `json:"edit_flag,omitempty"`

				// FieldType List of all possible field types
				FieldType *GetLeadFields200DataFieldType `json:"field_type,omitempty"`

				// FilteringAllowed Whether or not items can be filtered by this field
				FilteringAllowed *bool `json:"filtering_allowed,omitempty"`

				// Id The ID of the field. Value is `null` in case of subfields.
				Id *int `json:"id"`

				// ImportantFlag Not used
				ImportantFlag *bool `json:"important_flag,omitempty"`

				// IndexVisibleFlag Not used
				IndexVisibleFlag *bool `json:"index_visible_flag,omitempty"`

				// IsSubfield Whether or not the field is a subfield of another field. Only present if field is subfield.
				IsSubfield *bool `json:"is_subfield,omitempty"`

				// Key The key of the field. For custom fields this is generated upon creation.
				Key *string `json:"key,omitempty"`

				// LastUpdatedByUserId The ID of the user who created or most recently updated the field, only applicable for custom fields
				LastUpdatedByUserId *int `json:"last_updated_by_user_id"`

				// MandatoryFlag Whether or not the field is mandatory
				MandatoryFlag *bool `json:"mandatory_flag,omitempty"`

				// Name The name of the field
				Name *string `json:"name,omitempty"`

				// Options The options of the field. When there are no options, `null` is returned.
				Options *[]map[string]interface{} `json:"options"`

				// OptionsDeleted The deleted options of the field. Only present when there is at least 1 deleted option.
				OptionsDeleted *[]map[string]interface{} `json:"options_deleted,omitempty"`

				// OrderNr The order number of the field
				OrderNr *int `json:"order_nr,omitempty"`

				// SearchableFlag Whether or not items can be searched by this field
				SearchableFlag *bool `json:"searchable_flag,omitempty"`

				// SortableFlag Whether or not items can be sorted by this field
				SortableFlag *bool `json:"sortable_flag,omitempty"`

				// Subfields The subfields of the field. Only present when the field has subfields.
				Subfields *[]map[string]interface{} `json:"subfields,omitempty"`

				// UpdateTime The update time of the field
				UpdateTime *time.Time `json:"update_time"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLeadLabelsResponse parses an HTTP response from a GetLeadLabelsWithResponse call
func ParseGetLeadLabelsResponse(rsp *http.Response) (*GetLeadLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeadLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				// AddTime The date and time of when the lead label was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				AddTime *time.Time `json:"add_time,omitempty"`

				// Color The color of the label. Only a subset of colors can be used.
				Color *GetLeadLabels200DataColor `json:"color,omitempty"`

				// Id The unique ID of the lead label
				Id *openapi_types.UUID `json:"id,omitempty"`

				// Name The name of the lead label
				Name *string `json:"name,omitempty"`

				// UpdateTime The date and time of when the lead label was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				UpdateTime *time.Time `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddLeadLabelResponse parses an HTTP response from a AddLeadLabelWithResponse call
func ParseAddLeadLabelResponse(rsp *http.Response) (*AddLeadLabelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddLeadLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// AddTime The date and time of when the lead label was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				AddTime *time.Time `json:"add_time,omitempty"`

				// Color The color of the label. Only a subset of colors can be used.
				Color *AddLeadLabel200DataColor `json:"color,omitempty"`

				// Id The unique ID of the lead label
				Id *openapi_types.UUID `json:"id,omitempty"`

				// Name The name of the lead label
				Name *string `json:"name,omitempty"`

				// UpdateTime The date and time of when the lead label was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				UpdateTime *time.Time `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteLeadLabelResponse parses an HTTP response from a DeleteLeadLabelWithResponse call
func ParseDeleteLeadLabelResponse(rsp *http.Response) (*DeleteLeadLabelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLeadLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateLeadLabelResponse parses an HTTP response from a UpdateLeadLabelWithResponse call
func ParseUpdateLeadLabelResponse(rsp *http.Response) (*UpdateLeadLabelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLeadLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// AddTime The date and time of when the lead label was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				AddTime *time.Time `json:"add_time,omitempty"`

				// Color The color of the label. Only a subset of colors can be used.
				Color *UpdateLeadLabel200DataColor `json:"color,omitempty"`

				// Id The unique ID of the lead label
				Id *openapi_types.UUID `json:"id,omitempty"`

				// Name The name of the lead label
				Name *string `json:"name,omitempty"`

				// UpdateTime The date and time of when the lead label was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				UpdateTime *time.Time `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLeadSourcesResponse parses an HTTP response from a GetLeadSourcesWithResponse call
func ParseGetLeadSourcesResponse(rsp *http.Response) (*GetLeadSourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeadSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				// Name The unique name of a lead source
				Name *string `json:"name,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLeadsResponse parses an HTTP response from a GetLeadsWithResponse call
func ParseGetLeadsResponse(rsp *http.Response) (*GetLeadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// AddTime The date and time of when the lead was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				AddTime *time.Time `json:"add_time,omitempty"`

				// CcEmail The BCC email of the lead
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Lead was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CreatorId The ID of the user who created the lead
				CreatorId *int `json:"creator_id,omitempty"`

				// ExpectedCloseDate The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date"`

				// Id The unique ID of the lead in the UUID format
				Id *openapi_types.UUID `json:"id,omitempty"`

				// IsArchived A flag indicating whether the lead is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// LabelIds The IDs of the lead labels which are associated with the lead
				LabelIds *[]openapi_types.UUID `json:"label_ids,omitempty"`

				// NextActivityId The ID of the next activity associated with the lead
				NextActivityId *int `json:"next_activity_id"`

				// OrganizationId The ID of an organization which this lead is linked to
				OrganizationId *int `json:"organization_id"`

				// Origin The way this Lead was created. `origin` field is set by Pipedrive when Lead is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the lead - e.g. Which API integration created this Lead.
				OriginId *string `json:"origin_id"`

				// OwnerId The ID of the user who owns the lead
				OwnerId *int `json:"owner_id,omitempty"`

				// PersonId The ID of a person which this lead is linked to
				PersonId *int `json:"person_id"`

				// SourceName Defines where the lead comes from. Will be `API` if the lead was created through the Public API and will be `Manually created` if the lead was created manually through the UI.
				SourceName *string `json:"source_name,omitempty"`

				// Title The title of the lead
				Title *string `json:"title,omitempty"`

				// UpdateTime The date and time of when the lead was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// Value The potential value of the lead represented by a JSON object: `{ "amount": 200, "currency": "EUR" }`. Both amount and currency are required.
				Value *struct {
					Amount   float32 `json:"amount"`
					Currency string  `json:"currency"`
				} `json:"value"`

				// VisibleTo The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
				VisibleTo *GetLeads200DataVisibleTo `json:"visible_to,omitempty"`

				// WasSeen A flag indicating whether the lead was seen by someone in the Pipedrive UI
				WasSeen *bool `json:"was_seen,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddLeadResponse parses an HTTP response from a AddLeadWithResponse call
func ParseAddLeadResponse(rsp *http.Response) (*AddLeadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddLeadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// AddTime The date and time of when the lead was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				AddTime *time.Time `json:"add_time,omitempty"`

				// CcEmail The BCC email of the lead
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Lead was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CreatorId The ID of the user who created the lead
				CreatorId *int `json:"creator_id,omitempty"`

				// ExpectedCloseDate The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date"`

				// Id The unique ID of the lead in the UUID format
				Id *openapi_types.UUID `json:"id,omitempty"`

				// IsArchived A flag indicating whether the lead is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// LabelIds The IDs of the lead labels which are associated with the lead
				LabelIds *[]openapi_types.UUID `json:"label_ids,omitempty"`

				// NextActivityId The ID of the next activity associated with the lead
				NextActivityId *int `json:"next_activity_id"`

				// OrganizationId The ID of an organization which this lead is linked to
				OrganizationId *int `json:"organization_id"`

				// Origin The way this Lead was created. `origin` field is set by Pipedrive when Lead is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the lead - e.g. Which API integration created this Lead.
				OriginId *string `json:"origin_id"`

				// OwnerId The ID of the user who owns the lead
				OwnerId *int `json:"owner_id,omitempty"`

				// PersonId The ID of a person which this lead is linked to
				PersonId *int `json:"person_id"`

				// SourceName Defines where the lead comes from. Will be `API` if the lead was created through the Public API and will be `Manually created` if the lead was created manually through the UI.
				SourceName *string `json:"source_name,omitempty"`

				// Title The title of the lead
				Title *string `json:"title,omitempty"`

				// UpdateTime The date and time of when the lead was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// Value The potential value of the lead represented by a JSON object: `{ "amount": 200, "currency": "EUR" }`. Both amount and currency are required.
				Value *struct {
					Amount   float32 `json:"amount"`
					Currency string  `json:"currency"`
				} `json:"value"`

				// VisibleTo The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
				VisibleTo *AddLead201DataVisibleTo `json:"visible_to,omitempty"`

				// WasSeen A flag indicating whether the lead was seen by someone in the Pipedrive UI
				WasSeen *bool `json:"was_seen,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetArchivedLeadsResponse parses an HTTP response from a GetArchivedLeadsWithResponse call
func ParseGetArchivedLeadsResponse(rsp *http.Response) (*GetArchivedLeadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArchivedLeadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// AddTime The date and time of when the lead was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				AddTime *time.Time `json:"add_time,omitempty"`

				// CcEmail The BCC email of the lead
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Lead was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CreatorId The ID of the user who created the lead
				CreatorId *int `json:"creator_id,omitempty"`

				// ExpectedCloseDate The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date"`

				// Id The unique ID of the lead in the UUID format
				Id *openapi_types.UUID `json:"id,omitempty"`

				// IsArchived A flag indicating whether the lead is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// LabelIds The IDs of the lead labels which are associated with the lead
				LabelIds *[]openapi_types.UUID `json:"label_ids,omitempty"`

				// NextActivityId The ID of the next activity associated with the lead
				NextActivityId *int `json:"next_activity_id"`

				// OrganizationId The ID of an organization which this lead is linked to
				OrganizationId *int `json:"organization_id"`

				// Origin The way this Lead was created. `origin` field is set by Pipedrive when Lead is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the lead - e.g. Which API integration created this Lead.
				OriginId *string `json:"origin_id"`

				// OwnerId The ID of the user who owns the lead
				OwnerId *int `json:"owner_id,omitempty"`

				// PersonId The ID of a person which this lead is linked to
				PersonId *int `json:"person_id"`

				// SourceName Defines where the lead comes from. Will be `API` if the lead was created through the Public API and will be `Manually created` if the lead was created manually through the UI.
				SourceName *string `json:"source_name,omitempty"`

				// Title The title of the lead
				Title *string `json:"title,omitempty"`

				// UpdateTime The date and time of when the lead was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// Value The potential value of the lead represented by a JSON object: `{ "amount": 200, "currency": "EUR" }`. Both amount and currency are required.
				Value *struct {
					Amount   float32 `json:"amount"`
					Currency string  `json:"currency"`
				} `json:"value"`

				// VisibleTo The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
				VisibleTo *GetArchivedLeads200DataVisibleTo `json:"visible_to,omitempty"`

				// WasSeen A flag indicating whether the lead was seen by someone in the Pipedrive UI
				WasSeen *bool `json:"was_seen,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteLeadResponse parses an HTTP response from a DeleteLeadWithResponse call
func ParseDeleteLeadResponse(rsp *http.Response) (*DeleteLeadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLeadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLeadResponse parses an HTTP response from a GetLeadWithResponse call
func ParseGetLeadResponse(rsp *http.Response) (*GetLeadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// AddTime The date and time of when the lead was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				AddTime *time.Time `json:"add_time,omitempty"`

				// CcEmail The BCC email of the lead
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Lead was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CreatorId The ID of the user who created the lead
				CreatorId *int `json:"creator_id,omitempty"`

				// ExpectedCloseDate The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date"`

				// Id The unique ID of the lead in the UUID format
				Id *openapi_types.UUID `json:"id,omitempty"`

				// IsArchived A flag indicating whether the lead is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// LabelIds The IDs of the lead labels which are associated with the lead
				LabelIds *[]openapi_types.UUID `json:"label_ids,omitempty"`

				// NextActivityId The ID of the next activity associated with the lead
				NextActivityId *int `json:"next_activity_id"`

				// OrganizationId The ID of an organization which this lead is linked to
				OrganizationId *int `json:"organization_id"`

				// Origin The way this Lead was created. `origin` field is set by Pipedrive when Lead is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the lead - e.g. Which API integration created this Lead.
				OriginId *string `json:"origin_id"`

				// OwnerId The ID of the user who owns the lead
				OwnerId *int `json:"owner_id,omitempty"`

				// PersonId The ID of a person which this lead is linked to
				PersonId *int `json:"person_id"`

				// SourceName Defines where the lead comes from. Will be `API` if the lead was created through the Public API and will be `Manually created` if the lead was created manually through the UI.
				SourceName *string `json:"source_name,omitempty"`

				// Title The title of the lead
				Title *string `json:"title,omitempty"`

				// UpdateTime The date and time of when the lead was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// Value The potential value of the lead represented by a JSON object: `{ "amount": 200, "currency": "EUR" }`. Both amount and currency are required.
				Value *struct {
					Amount   float32 `json:"amount"`
					Currency string  `json:"currency"`
				} `json:"value"`

				// VisibleTo The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
				VisibleTo *GetLead200DataVisibleTo `json:"visible_to,omitempty"`

				// WasSeen A flag indicating whether the lead was seen by someone in the Pipedrive UI
				WasSeen *bool `json:"was_seen,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateLeadResponse parses an HTTP response from a UpdateLeadWithResponse call
func ParseUpdateLeadResponse(rsp *http.Response) (*UpdateLeadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLeadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// AddTime The date and time of when the lead was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				AddTime *time.Time `json:"add_time,omitempty"`

				// CcEmail The BCC email of the lead
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Lead was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CreatorId The ID of the user who created the lead
				CreatorId *int `json:"creator_id,omitempty"`

				// ExpectedCloseDate The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date"`

				// Id The unique ID of the lead in the UUID format
				Id *openapi_types.UUID `json:"id,omitempty"`

				// IsArchived A flag indicating whether the lead is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// LabelIds The IDs of the lead labels which are associated with the lead
				LabelIds *[]openapi_types.UUID `json:"label_ids,omitempty"`

				// NextActivityId The ID of the next activity associated with the lead
				NextActivityId *int `json:"next_activity_id"`

				// OrganizationId The ID of an organization which this lead is linked to
				OrganizationId *int `json:"organization_id"`

				// Origin The way this Lead was created. `origin` field is set by Pipedrive when Lead is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the lead - e.g. Which API integration created this Lead.
				OriginId *string `json:"origin_id"`

				// OwnerId The ID of the user who owns the lead
				OwnerId *int `json:"owner_id,omitempty"`

				// PersonId The ID of a person which this lead is linked to
				PersonId *int `json:"person_id"`

				// SourceName Defines where the lead comes from. Will be `API` if the lead was created through the Public API and will be `Manually created` if the lead was created manually through the UI.
				SourceName *string `json:"source_name,omitempty"`

				// Title The title of the lead
				Title *string `json:"title,omitempty"`

				// UpdateTime The date and time of when the lead was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// Value The potential value of the lead represented by a JSON object: `{ "amount": 200, "currency": "EUR" }`. Both amount and currency are required.
				Value *struct {
					Amount   float32 `json:"amount"`
					Currency string  `json:"currency"`
				} `json:"value"`

				// VisibleTo The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
				VisibleTo *UpdateLead200DataVisibleTo `json:"visible_to,omitempty"`

				// WasSeen A flag indicating whether the lead was seen by someone in the Pipedrive UI
				WasSeen *bool `json:"was_seen,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLeadUsersResponse parses an HTTP response from a GetLeadUsersWithResponse call
func ParseGetLeadUsersResponse(rsp *http.Response) (*GetLeadUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeadUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The list of user IDs
			Data *[]int `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTeamsResponse parses an HTTP response from a GetTeamsWithResponse call
func ParseGetTeamsResponse(rsp *http.Response) (*GetTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				// ActiveFlag Flag that indicates whether the team is active
				ActiveFlag *GetTeams200DataActiveFlag `json:"active_flag,omitempty"`

				// AddTime The team creation time. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// CreatedByUserId The ID of the user who created the team
				CreatedByUserId *int `json:"created_by_user_id,omitempty"`

				// DeletedFlag Flag that indicates whether the team is deleted
				DeletedFlag *GetTeams200DataDeletedFlag `json:"deleted_flag,omitempty"`

				// Description The team description
				Description *string `json:"description,omitempty"`

				// Id The team ID
				Id *int `json:"id,omitempty"`

				// ManagerId The team manager ID
				ManagerId *int `json:"manager_id,omitempty"`

				// Name The team name
				Name *string `json:"name,omitempty"`

				// Users The list of user IDs
				Users *[]int `json:"users,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddTeamResponse parses an HTTP response from a AddTeamWithResponse call
func ParseAddTeamResponse(rsp *http.Response) (*AddTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Flag that indicates whether the team is active
				ActiveFlag *AddTeam200DataActiveFlag `json:"active_flag,omitempty"`

				// AddTime The team creation time. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// CreatedByUserId The ID of the user who created the team
				CreatedByUserId *int `json:"created_by_user_id,omitempty"`

				// DeletedFlag Flag that indicates whether the team is deleted
				DeletedFlag *AddTeam200DataDeletedFlag `json:"deleted_flag,omitempty"`

				// Description The team description
				Description *string `json:"description,omitempty"`

				// Id The team ID
				Id *int `json:"id,omitempty"`

				// ManagerId The team manager ID
				ManagerId *int `json:"manager_id,omitempty"`

				// Name The team name
				Name *string `json:"name,omitempty"`

				// Users The list of user IDs
				Users *[]int `json:"users,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetUserTeamsResponse parses an HTTP response from a GetUserTeamsWithResponse call
func ParseGetUserTeamsResponse(rsp *http.Response) (*GetUserTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				// ActiveFlag Flag that indicates whether the team is active
				ActiveFlag *GetUserTeams200DataActiveFlag `json:"active_flag,omitempty"`

				// AddTime The team creation time. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// CreatedByUserId The ID of the user who created the team
				CreatedByUserId *int `json:"created_by_user_id,omitempty"`

				// DeletedFlag Flag that indicates whether the team is deleted
				DeletedFlag *GetUserTeams200DataDeletedFlag `json:"deleted_flag,omitempty"`

				// Description The team description
				Description *string `json:"description,omitempty"`

				// Id The team ID
				Id *int `json:"id,omitempty"`

				// ManagerId The team manager ID
				ManagerId *int `json:"manager_id,omitempty"`

				// Name The team name
				Name *string `json:"name,omitempty"`

				// Users The list of user IDs
				Users *[]int `json:"users,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTeamResponse parses an HTTP response from a GetTeamWithResponse call
func ParseGetTeamResponse(rsp *http.Response) (*GetTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Flag that indicates whether the team is active
				ActiveFlag *GetTeam200DataActiveFlag `json:"active_flag,omitempty"`

				// AddTime The team creation time. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// CreatedByUserId The ID of the user who created the team
				CreatedByUserId *int `json:"created_by_user_id,omitempty"`

				// DeletedFlag Flag that indicates whether the team is deleted
				DeletedFlag *GetTeam200DataDeletedFlag `json:"deleted_flag,omitempty"`

				// Description The team description
				Description *string `json:"description,omitempty"`

				// Id The team ID
				Id *int `json:"id,omitempty"`

				// ManagerId The team manager ID
				ManagerId *int `json:"manager_id,omitempty"`

				// Name The team name
				Name *string `json:"name,omitempty"`

				// Users The list of user IDs
				Users *[]int `json:"users,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateTeamResponse parses an HTTP response from a UpdateTeamWithResponse call
func ParseUpdateTeamResponse(rsp *http.Response) (*UpdateTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Flag that indicates whether the team is active
				ActiveFlag *UpdateTeam200DataActiveFlag `json:"active_flag,omitempty"`

				// AddTime The team creation time. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// CreatedByUserId The ID of the user who created the team
				CreatedByUserId *int `json:"created_by_user_id,omitempty"`

				// DeletedFlag Flag that indicates whether the team is deleted
				DeletedFlag *UpdateTeam200DataDeletedFlag `json:"deleted_flag,omitempty"`

				// Description The team description
				Description *string `json:"description,omitempty"`

				// Id The team ID
				Id *int `json:"id,omitempty"`

				// ManagerId The team manager ID
				ManagerId *int `json:"manager_id,omitempty"`

				// Name The team name
				Name *string `json:"name,omitempty"`

				// Users The list of user IDs
				Users *[]int `json:"users,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteTeamUserResponse parses an HTTP response from a DeleteTeamUserWithResponse call
func ParseDeleteTeamUserResponse(rsp *http.Response) (*DeleteTeamUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The list of user IDs
			Data *[]int `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTeamUsersResponse parses an HTTP response from a GetTeamUsersWithResponse call
func ParseGetTeamUsersResponse(rsp *http.Response) (*GetTeamUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The list of user IDs
			Data *[]int `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddTeamUserResponse parses an HTTP response from a AddTeamUserWithResponse call
func ParseAddTeamUserResponse(rsp *http.Response) (*AddTeamUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTeamUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The list of user IDs
			Data *[]int `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMailMessageResponse parses an HTTP response from a GetMailMessageWithResponse call
func ParseGetMailMessageResponse(rsp *http.Response) (*GetMailMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// AccountId The connection account ID
				AccountId *string `json:"account_id,omitempty"`

				// AddTime The insertion into the database time of the mail message
				AddTime *time.Time `json:"add_time,omitempty"`

				// Bcc The array of mail message blind copies (object)
				Bcc *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"bcc,omitempty"`

				// BodyUrl The mail message body URL
				BodyUrl *string `json:"body_url,omitempty"`

				// Cc The array of mail message copies (object)
				Cc *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"cc,omitempty"`

				// DeletedFlag Whether the mail message is deleted or not
				DeletedFlag *GetMailMessage200DataDeletedFlag `json:"deleted_flag,omitempty"`

				// Draft If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
				Draft *string `json:"draft,omitempty"`

				// DraftFlag Whether the mail message is a draft or not
				DraftFlag *GetMailMessage200DataDraftFlag `json:"draft_flag,omitempty"`

				// From The array of mail message sender (object)
				From *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"from,omitempty"`

				// HasAttachmentsFlag Whether the mail message has an attachment or not
				HasAttachmentsFlag *GetMailMessage200DataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

				// HasBodyFlag Whether the mail message has a body or not
				HasBodyFlag *GetMailMessage200DataHasBodyFlag `json:"has_body_flag,omitempty"`

				// HasInlineAttachmentsFlag Whether the mail message has an inline attachment or not
				HasInlineAttachmentsFlag *GetMailMessage200DataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

				// HasRealAttachmentsFlag Whether the mail message has an attachment (which is not inline) or not
				HasRealAttachmentsFlag *GetMailMessage200DataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

				// Id ID of the mail message.
				Id *int `json:"id,omitempty"`

				// MailLinkTrackingEnabledFlag Whether the link tracking in mail message body is enabled.
				MailLinkTrackingEnabledFlag *GetMailMessage200DataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

				// MailThreadId ID of the mail message thread
				MailThreadId *int `json:"mail_thread_id,omitempty"`

				// MailTrackingStatus The status of tracking mail message. Value is `null` if tracking is not enabled.
				MailTrackingStatus *GetMailMessage200DataMailTrackingStatus `json:"mail_tracking_status"`

				// MessageTime Creation or receival time of the mail message
				MessageTime *time.Time `json:"message_time,omitempty"`

				// ReadFlag Whether the mail message is read or not by the user
				ReadFlag *GetMailMessage200DataReadFlag `json:"read_flag,omitempty"`

				// SentFlag Whether the mail message has been sent or not
				SentFlag *GetMailMessage200DataSentFlag `json:"sent_flag,omitempty"`

				// SentFromPipedriveFlag Whether the mail message has been sent from Pipedrive app or not
				SentFromPipedriveFlag *GetMailMessage200DataSentFromPipedriveFlag `json:"sent_from_pipedrive_flag,omitempty"`

				// SmartBccFlag Whether the mail message has been created by Smart Email BCC feature or not
				SmartBccFlag *GetMailMessage200DataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

				// Snippet The snippet of mail message. Snippet length is up to 225 characters.
				Snippet *string `json:"snippet,omitempty"`

				// Subject The subject of mail message
				Subject *string `json:"subject,omitempty"`

				// SyncedFlag Whether the mail message is synced with the provider or not
				SyncedFlag *GetMailMessage200DataSyncedFlag `json:"synced_flag,omitempty"`

				// To The array of mail message receiver (object)
				To *[]struct {
					// EmailAddress Mail address of the mail participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail participant
					Id *int `json:"id,omitempty"`

					// LinkedPersonId ID of the linked person to the mail message
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Name of the linked person to the mail message
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message participant
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// Name Name of the mail participant
					Name *string `json:"name,omitempty"`
				} `json:"to,omitempty"`

				// UpdateTime The updating time in the database of the mail message
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// UserId ID of the user whom mail message will be assigned to
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Service The service name of the response.
			Service *string `json:"service,omitempty"`

			// StatusCode The email service specific status code and it is returned through the response body.
			StatusCode *int `json:"statusCode,omitempty"`

			// StatusText The status text of the response.
			StatusText *string `json:"statusText,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMailThreadsResponse parses an HTTP response from a GetMailThreadsWithResponse call
func ParseGetMailThreadsResponse(rsp *http.Response) (*GetMailThreadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailThreadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The array of mail threads
			Data *[]struct {
				// AccountId The connection account ID
				AccountId *string `json:"account_id,omitempty"`

				// AddTime The time when the mail thread was inserted to database
				AddTime *time.Time `json:"add_time,omitempty"`

				// AllMessagesSentFlag Whether all the mail thread messages have been sent
				AllMessagesSentFlag *GetMailThreads200DataAllMessagesSentFlag `json:"all_messages_sent_flag,omitempty"`

				// ArchivedFlag Whether the mail thread is archived
				ArchivedFlag *GetMailThreads200DataArchivedFlag `json:"archived_flag,omitempty"`

				// DealId The ID of the deal
				DealId *int `json:"deal_id"`

				// DealStatus Status of the deal
				DealStatus *string `json:"deal_status"`

				// DeletedFlag Whether the mail thread is deleted
				DeletedFlag *GetMailThreads200DataDeletedFlag `json:"deleted_flag,omitempty"`

				// DraftsParties Parties of the drafted mail thread
				DraftsParties *[]map[string]interface{} `json:"drafts_parties,omitempty"`

				// ExternalDeletedFlag Whether the mail thread has been deleted externally
				ExternalDeletedFlag *GetMailThreads200DataExternalDeletedFlag `json:"external_deleted_flag,omitempty"`

				// FirstMessageTimestamp The time when the mail thread has had the first message received or created
				FirstMessageTimestamp *time.Time `json:"first_message_timestamp,omitempty"`

				// FirstMessageToMeFlag Whether the mail thread was initialized by others
				FirstMessageToMeFlag *GetMailThreads200DataFirstMessageToMeFlag `json:"first_message_to_me_flag,omitempty"`

				// Folders Folders in which messages from thread are being stored
				Folders *[]string `json:"folders,omitempty"`

				// HasAttachmentsFlag Whether the mail thread has an attachment
				HasAttachmentsFlag *GetMailThreads200DataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

				// HasDraftFlag Whether the mail thread has any drafts
				HasDraftFlag *GetMailThreads200DataHasDraftFlag `json:"has_draft_flag,omitempty"`

				// HasInlineAttachmentsFlag Whether the mail thread has inline attachments
				HasInlineAttachmentsFlag *GetMailThreads200DataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

				// HasRealAttachmentsFlag Whether the mail thread has real attachments (which are not inline)
				HasRealAttachmentsFlag *GetMailThreads200DataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

				// HasSentFlag Whether the mail thread has messages sent
				HasSentFlag *GetMailThreads200DataHasSentFlag `json:"has_sent_flag,omitempty"`

				// Id ID of the mail thread
				Id *int `json:"id,omitempty"`

				// LastMessageReceivedTimestamp The last time when the mail thread has had a message received
				LastMessageReceivedTimestamp *time.Time `json:"last_message_received_timestamp,omitempty"`

				// LastMessageSentTimestamp The last time when the mail thread has had a message sent
				LastMessageSentTimestamp *time.Time `json:"last_message_sent_timestamp"`

				// LastMessageTimestamp Last message timestamp
				LastMessageTimestamp *time.Time `json:"last_message_timestamp,omitempty"`

				// LeadId The ID of the lead
				LeadId *openapi_types.UUID `json:"lead_id"`

				// MailLinkTrackingEnabledFlag Whether the link tracking of the mail thread is enabled
				MailLinkTrackingEnabledFlag *GetMailThreads200DataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

				// MailTrackingStatus Mail tracking status
				MailTrackingStatus *string `json:"mail_tracking_status"`

				// MessageCount An amount of messages
				MessageCount *int `json:"message_count,omitempty"`

				// Parties Parties of the mail thread
				Parties *struct {
					// From Senders of the mail thread
					From *[]struct {
						// EmailAddress Email address of the mail thread participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail thread participant
						Id *int `json:"id,omitempty"`

						// LatestSent Whether the mail thread participant was last to send an email
						LatestSent *bool `json:"latest_sent,omitempty"`

						// LinkedOrganizationId Linked Organization ID
						LinkedOrganizationId *int `json:"linked_organization_id"`

						// LinkedPersonId ID of the linked person
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Email of the linked person
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message party
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// MessageTime Message time
						MessageTime *float32 `json:"message_time,omitempty"`

						// Name Name of the mail thread participant
						Name *string `json:"name,omitempty"`
					} `json:"from,omitempty"`

					// To Recipients of the mail thread
					To *[]struct {
						// EmailAddress Email address of the mail thread participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail thread participant
						Id *int `json:"id,omitempty"`

						// LatestSent Whether the mail thread participant was last to send an email
						LatestSent *bool `json:"latest_sent,omitempty"`

						// LinkedOrganizationId Linked Organization ID
						LinkedOrganizationId *int `json:"linked_organization_id"`

						// LinkedPersonId ID of the linked person
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Email of the linked person
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message party
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// MessageTime Message time
						MessageTime *float32 `json:"message_time,omitempty"`

						// Name Name of the mail thread participant
						Name *string `json:"name,omitempty"`
					} `json:"to,omitempty"`
				} `json:"parties,omitempty"`

				// ReadFlag Whether the mail thread is read
				ReadFlag *GetMailThreads200DataReadFlag `json:"read_flag,omitempty"`

				// SharedFlag Whether the mail thread is shared
				SharedFlag *GetMailThreads200DataSharedFlag `json:"shared_flag,omitempty"`

				// SmartBccFlag Whether one of the parties of the mail thread is Bcc
				SmartBccFlag *GetMailThreads200DataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

				// Snippet A snippet
				Snippet *string `json:"snippet,omitempty"`

				// SnippetDraft A snippet from a draft
				SnippetDraft *string `json:"snippet_draft"`

				// SnippetSent A snippet from a message sent
				SnippetSent *string `json:"snippet_sent,omitempty"`

				// Subject The subject
				Subject *string `json:"subject,omitempty"`

				// SyncedFlag Whether the mail thread is synced
				SyncedFlag *GetMailThreads200DataSyncedFlag `json:"synced_flag,omitempty"`

				// UpdateTime The time when the mail thread was updated in database received
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// UserId ID of the user whom mail message will be assigned to
				UserId *int `json:"user_id,omitempty"`

				// Version Version
				Version *float32 `json:"version,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteMailThreadResponse parses an HTTP response from a DeleteMailThreadWithResponse call
func ParseDeleteMailThreadResponse(rsp *http.Response) (*DeleteMailThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMailThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of the deleted mail thread
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMailThreadResponse parses an HTTP response from a GetMailThreadWithResponse call
func ParseGetMailThreadResponse(rsp *http.Response) (*GetMailThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The mail thread object
			Data *struct {
				// AccountId The connection account ID
				AccountId *string `json:"account_id,omitempty"`

				// AddTime The time when the mail thread was inserted to database
				AddTime *time.Time `json:"add_time,omitempty"`

				// AllMessagesSentFlag Whether all the mail thread messages have been sent
				AllMessagesSentFlag *GetMailThread200DataAllMessagesSentFlag `json:"all_messages_sent_flag,omitempty"`

				// ArchivedFlag Whether the mail thread is archived
				ArchivedFlag *GetMailThread200DataArchivedFlag `json:"archived_flag,omitempty"`

				// DealId The ID of the deal
				DealId *int `json:"deal_id"`

				// DealStatus Status of the deal
				DealStatus *string `json:"deal_status"`

				// DeletedFlag Whether the mail thread is deleted
				DeletedFlag *GetMailThread200DataDeletedFlag `json:"deleted_flag,omitempty"`

				// DraftsParties Parties of the drafted mail thread
				DraftsParties *[]map[string]interface{} `json:"drafts_parties,omitempty"`

				// ExternalDeletedFlag Whether the mail thread has been deleted externally
				ExternalDeletedFlag *GetMailThread200DataExternalDeletedFlag `json:"external_deleted_flag,omitempty"`

				// FirstMessageTimestamp The time when the mail thread has had the first message received or created
				FirstMessageTimestamp *time.Time `json:"first_message_timestamp,omitempty"`

				// FirstMessageToMeFlag Whether the mail thread was initialized by others
				FirstMessageToMeFlag *GetMailThread200DataFirstMessageToMeFlag `json:"first_message_to_me_flag,omitempty"`

				// Folders Folders in which messages from thread are being stored
				Folders *[]string `json:"folders,omitempty"`

				// HasAttachmentsFlag Whether the mail thread has an attachment
				HasAttachmentsFlag *GetMailThread200DataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

				// HasDraftFlag Whether the mail thread has any drafts
				HasDraftFlag *GetMailThread200DataHasDraftFlag `json:"has_draft_flag,omitempty"`

				// HasInlineAttachmentsFlag Whether the mail thread has inline attachments
				HasInlineAttachmentsFlag *GetMailThread200DataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

				// HasRealAttachmentsFlag Whether the mail thread has real attachments (which are not inline)
				HasRealAttachmentsFlag *GetMailThread200DataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

				// HasSentFlag Whether the mail thread has messages sent
				HasSentFlag *GetMailThread200DataHasSentFlag `json:"has_sent_flag,omitempty"`

				// Id ID of the mail thread
				Id *int `json:"id,omitempty"`

				// LastMessageReceivedTimestamp The last time when the mail thread has had a message received
				LastMessageReceivedTimestamp *time.Time `json:"last_message_received_timestamp,omitempty"`

				// LastMessageSentTimestamp The last time when the mail thread has had a message sent
				LastMessageSentTimestamp *time.Time `json:"last_message_sent_timestamp"`

				// LastMessageTimestamp Last message timestamp
				LastMessageTimestamp *time.Time `json:"last_message_timestamp,omitempty"`

				// LeadId The ID of the lead
				LeadId *openapi_types.UUID `json:"lead_id"`

				// MailLinkTrackingEnabledFlag Whether the link tracking of the mail thread is enabled
				MailLinkTrackingEnabledFlag *GetMailThread200DataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

				// MailTrackingStatus Mail tracking status
				MailTrackingStatus *string `json:"mail_tracking_status"`

				// MessageCount An amount of messages
				MessageCount *int `json:"message_count,omitempty"`

				// Parties Parties of the mail thread
				Parties *struct {
					// From Senders of the mail thread
					From *[]struct {
						// EmailAddress Email address of the mail thread participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail thread participant
						Id *int `json:"id,omitempty"`

						// LatestSent Whether the mail thread participant was last to send an email
						LatestSent *bool `json:"latest_sent,omitempty"`

						// LinkedOrganizationId Linked Organization ID
						LinkedOrganizationId *int `json:"linked_organization_id"`

						// LinkedPersonId ID of the linked person
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Email of the linked person
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message party
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// MessageTime Message time
						MessageTime *float32 `json:"message_time,omitempty"`

						// Name Name of the mail thread participant
						Name *string `json:"name,omitempty"`
					} `json:"from,omitempty"`

					// To Recipients of the mail thread
					To *[]struct {
						// EmailAddress Email address of the mail thread participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail thread participant
						Id *int `json:"id,omitempty"`

						// LatestSent Whether the mail thread participant was last to send an email
						LatestSent *bool `json:"latest_sent,omitempty"`

						// LinkedOrganizationId Linked Organization ID
						LinkedOrganizationId *int `json:"linked_organization_id"`

						// LinkedPersonId ID of the linked person
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Email of the linked person
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message party
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// MessageTime Message time
						MessageTime *float32 `json:"message_time,omitempty"`

						// Name Name of the mail thread participant
						Name *string `json:"name,omitempty"`
					} `json:"to,omitempty"`
				} `json:"parties,omitempty"`

				// ReadFlag Whether the mail thread is read
				ReadFlag *GetMailThread200DataReadFlag `json:"read_flag,omitempty"`

				// SharedFlag Whether the mail thread is shared
				SharedFlag *GetMailThread200DataSharedFlag `json:"shared_flag,omitempty"`

				// SmartBccFlag Whether one of the parties of the mail thread is Bcc
				SmartBccFlag *GetMailThread200DataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

				// Snippet A snippet
				Snippet *string `json:"snippet,omitempty"`

				// SnippetDraft A snippet from a draft
				SnippetDraft *string `json:"snippet_draft"`

				// SnippetSent A snippet from a message sent
				SnippetSent *string `json:"snippet_sent,omitempty"`

				// Subject The subject
				Subject *string `json:"subject,omitempty"`

				// SyncedFlag Whether the mail thread is synced
				SyncedFlag *GetMailThread200DataSyncedFlag `json:"synced_flag,omitempty"`

				// UpdateTime The time when the mail thread was updated in database received
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// UserId ID of the user whom mail message will be assigned to
				UserId *int `json:"user_id,omitempty"`

				// Version Version
				Version *float32 `json:"version,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateMailThreadDetailsResponse parses an HTTP response from a UpdateMailThreadDetailsWithResponse call
func ParseUpdateMailThreadDetailsResponse(rsp *http.Response) (*UpdateMailThreadDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMailThreadDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The mail thread object
			Data *struct {
				// AccountId The connection account ID
				AccountId *string `json:"account_id,omitempty"`

				// AddTime The time when the mail thread was inserted to database
				AddTime *time.Time `json:"add_time,omitempty"`

				// AllMessagesSentFlag Whether all the mail thread messages have been sent
				AllMessagesSentFlag *UpdateMailThreadDetails200DataAllMessagesSentFlag `json:"all_messages_sent_flag,omitempty"`

				// ArchivedFlag Whether the mail thread is archived
				ArchivedFlag *UpdateMailThreadDetails200DataArchivedFlag `json:"archived_flag,omitempty"`

				// DealId The ID of the deal
				DealId *int `json:"deal_id"`

				// DealStatus Status of the deal
				DealStatus *string `json:"deal_status"`

				// DeletedFlag Whether the mail thread is deleted
				DeletedFlag *UpdateMailThreadDetails200DataDeletedFlag `json:"deleted_flag,omitempty"`

				// DraftsParties Parties of the drafted mail thread
				DraftsParties *[]map[string]interface{} `json:"drafts_parties,omitempty"`

				// ExternalDeletedFlag Whether the mail thread has been deleted externally
				ExternalDeletedFlag *UpdateMailThreadDetails200DataExternalDeletedFlag `json:"external_deleted_flag,omitempty"`

				// FirstMessageTimestamp The time when the mail thread has had the first message received or created
				FirstMessageTimestamp *time.Time `json:"first_message_timestamp,omitempty"`

				// FirstMessageToMeFlag Whether the mail thread was initialized by others
				FirstMessageToMeFlag *UpdateMailThreadDetails200DataFirstMessageToMeFlag `json:"first_message_to_me_flag,omitempty"`

				// Folders Folders in which messages from thread are being stored
				Folders *[]string `json:"folders,omitempty"`

				// HasAttachmentsFlag Whether the mail thread has an attachment
				HasAttachmentsFlag *UpdateMailThreadDetails200DataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

				// HasDraftFlag Whether the mail thread has any drafts
				HasDraftFlag *UpdateMailThreadDetails200DataHasDraftFlag `json:"has_draft_flag,omitempty"`

				// HasInlineAttachmentsFlag Whether the mail thread has inline attachments
				HasInlineAttachmentsFlag *UpdateMailThreadDetails200DataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

				// HasRealAttachmentsFlag Whether the mail thread has real attachments (which are not inline)
				HasRealAttachmentsFlag *UpdateMailThreadDetails200DataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

				// HasSentFlag Whether the mail thread has messages sent
				HasSentFlag *UpdateMailThreadDetails200DataHasSentFlag `json:"has_sent_flag,omitempty"`

				// Id ID of the mail thread
				Id *int `json:"id,omitempty"`

				// LastMessageReceivedTimestamp The last time when the mail thread has had a message received
				LastMessageReceivedTimestamp *time.Time `json:"last_message_received_timestamp,omitempty"`

				// LastMessageSentTimestamp The last time when the mail thread has had a message sent
				LastMessageSentTimestamp *time.Time `json:"last_message_sent_timestamp"`

				// LastMessageTimestamp Last message timestamp
				LastMessageTimestamp *time.Time `json:"last_message_timestamp,omitempty"`

				// LeadId The ID of the lead
				LeadId *openapi_types.UUID `json:"lead_id"`

				// MailLinkTrackingEnabledFlag Whether the link tracking of the mail thread is enabled
				MailLinkTrackingEnabledFlag *UpdateMailThreadDetails200DataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

				// MailTrackingStatus Mail tracking status
				MailTrackingStatus *string `json:"mail_tracking_status"`

				// MessageCount An amount of messages
				MessageCount *int `json:"message_count,omitempty"`

				// Parties Parties of the mail thread
				Parties *struct {
					// From Senders of the mail thread
					From *[]struct {
						// EmailAddress Email address of the mail thread participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail thread participant
						Id *int `json:"id,omitempty"`

						// LatestSent Whether the mail thread participant was last to send an email
						LatestSent *bool `json:"latest_sent,omitempty"`

						// LinkedOrganizationId Linked Organization ID
						LinkedOrganizationId *int `json:"linked_organization_id"`

						// LinkedPersonId ID of the linked person
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Email of the linked person
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message party
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// MessageTime Message time
						MessageTime *float32 `json:"message_time,omitempty"`

						// Name Name of the mail thread participant
						Name *string `json:"name,omitempty"`
					} `json:"from,omitempty"`

					// To Recipients of the mail thread
					To *[]struct {
						// EmailAddress Email address of the mail thread participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail thread participant
						Id *int `json:"id,omitempty"`

						// LatestSent Whether the mail thread participant was last to send an email
						LatestSent *bool `json:"latest_sent,omitempty"`

						// LinkedOrganizationId Linked Organization ID
						LinkedOrganizationId *int `json:"linked_organization_id"`

						// LinkedPersonId ID of the linked person
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Email of the linked person
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message party
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// MessageTime Message time
						MessageTime *float32 `json:"message_time,omitempty"`

						// Name Name of the mail thread participant
						Name *string `json:"name,omitempty"`
					} `json:"to,omitempty"`
				} `json:"parties,omitempty"`

				// ReadFlag Whether the mail thread is read
				ReadFlag *UpdateMailThreadDetails200DataReadFlag `json:"read_flag,omitempty"`

				// SharedFlag Whether the mail thread is shared
				SharedFlag *UpdateMailThreadDetails200DataSharedFlag `json:"shared_flag,omitempty"`

				// SmartBccFlag Whether one of the parties of the mail thread is Bcc
				SmartBccFlag *UpdateMailThreadDetails200DataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

				// Snippet A snippet
				Snippet *string `json:"snippet,omitempty"`

				// SnippetDraft A snippet from a draft
				SnippetDraft *string `json:"snippet_draft"`

				// SnippetSent A snippet from a message sent
				SnippetSent *string `json:"snippet_sent,omitempty"`

				// Subject The subject
				Subject *string `json:"subject,omitempty"`

				// SyncedFlag Whether the mail thread is synced
				SyncedFlag *UpdateMailThreadDetails200DataSyncedFlag `json:"synced_flag,omitempty"`

				// UpdateTime The time when the mail thread was updated in database received
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// UserId ID of the user whom mail message will be assigned to
				UserId *int `json:"user_id,omitempty"`

				// Version Version
				Version *float32 `json:"version,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMailThreadMessagesResponse parses an HTTP response from a GetMailThreadMessagesWithResponse call
func ParseGetMailThreadMessagesResponse(rsp *http.Response) (*GetMailThreadMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailThreadMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The array of the mail messages of the mail thread
			Data *[]struct {
				// AccountId The connection account ID
				AccountId *string `json:"account_id,omitempty"`

				// AddTime The time when the mail message was inserted to database
				AddTime *time.Time `json:"add_time,omitempty"`

				// Bcc Participants of the Bcc
				Bcc *[]struct {
					// EmailAddress Email address of the mail thread participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail thread participant
					Id *int `json:"id,omitempty"`

					// LatestSent Whether the mail thread participant was last to send an email
					LatestSent *bool `json:"latest_sent,omitempty"`

					// LinkedOrganizationId Linked Organization ID
					LinkedOrganizationId *int `json:"linked_organization_id"`

					// LinkedPersonId ID of the linked person
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Email of the linked person
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message party
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// MessageTime Message time
					MessageTime *float32 `json:"message_time,omitempty"`

					// Name Name of the mail thread participant
					Name *string `json:"name,omitempty"`
				} `json:"bcc,omitempty"`

				// BodyUrl A link to the mail thread message
				BodyUrl *string `json:"body_url,omitempty"`

				// Cc Participants of the Cc
				Cc *[]struct {
					// EmailAddress Email address of the mail thread participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail thread participant
					Id *int `json:"id,omitempty"`

					// LatestSent Whether the mail thread participant was last to send an email
					LatestSent *bool `json:"latest_sent,omitempty"`

					// LinkedOrganizationId Linked Organization ID
					LinkedOrganizationId *int `json:"linked_organization_id"`

					// LinkedPersonId ID of the linked person
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Email of the linked person
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message party
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// MessageTime Message time
					MessageTime *float32 `json:"message_time,omitempty"`

					// Name Name of the mail thread participant
					Name *string `json:"name,omitempty"`
				} `json:"cc,omitempty"`

				// DeletedFlag Whether the mail thread is deleted
				DeletedFlag *GetMailThreadMessages200DataDeletedFlag `json:"deleted_flag,omitempty"`

				// Draft If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
				Draft *string `json:"draft"`

				// From Senders of the mail thread
				From *[]struct {
					// EmailAddress Email address of the mail thread participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail thread participant
					Id *int `json:"id,omitempty"`

					// LatestSent Whether the mail thread participant was last to send an email
					LatestSent *bool `json:"latest_sent,omitempty"`

					// LinkedOrganizationId Linked Organization ID
					LinkedOrganizationId *int `json:"linked_organization_id"`

					// LinkedPersonId ID of the linked person
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Email of the linked person
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message party
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// MessageTime Message time
					MessageTime *float32 `json:"message_time,omitempty"`

					// Name Name of the mail thread participant
					Name *string `json:"name,omitempty"`
				} `json:"from,omitempty"`

				// HasAttachmentsFlag Whether the mail thread has an attachment
				HasAttachmentsFlag *GetMailThreadMessages200DataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

				// HasBodyFlag Whether the mail thread message has a body
				HasBodyFlag *GetMailThreadMessages200DataHasBodyFlag `json:"has_body_flag,omitempty"`

				// HasInlineAttachmentsFlag Whether the mail thread has inline attachments
				HasInlineAttachmentsFlag *GetMailThreadMessages200DataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

				// HasRealAttachmentsFlag Whether the mail thread has real attachments (which are not inline)
				HasRealAttachmentsFlag *GetMailThreadMessages200DataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

				// Id ID of the mail thread
				Id *int `json:"id,omitempty"`

				// MailLinkTrackingEnabledFlag Whether the link tracking of the mail thread is enabled
				MailLinkTrackingEnabledFlag *GetMailThreadMessages200DataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

				// MailThreadId ID of the mail thread
				MailThreadId *int `json:"mail_thread_id,omitempty"`

				// MailTrackingStatus Mail tracking status
				MailTrackingStatus *string `json:"mail_tracking_status"`

				// MessageTime The time when the mail message was received or created
				MessageTime *time.Time `json:"message_time,omitempty"`

				// ReadFlag Whether the mail thread is read
				ReadFlag *GetMailThreadMessages200DataReadFlag `json:"read_flag,omitempty"`

				// SentFlag Whether the mail thread message is sent
				SentFlag *GetMailThreadMessages200DataSentFlag `json:"sent_flag,omitempty"`

				// SentFromPipedriveFlag Whether the mail thread message is sent from Pipedrive
				SentFromPipedriveFlag *GetMailThreadMessages200DataSentFromPipedriveFlag `json:"sent_from_pipedrive_flag,omitempty"`

				// SmartBccFlag Whether one of the parties of the mail thread is Bcc
				SmartBccFlag *GetMailThreadMessages200DataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

				// Snippet A snippet
				Snippet *string `json:"snippet,omitempty"`

				// Subject The subject
				Subject *string `json:"subject,omitempty"`

				// SyncedFlag Whether the mail thread is synced
				SyncedFlag *GetMailThreadMessages200DataSyncedFlag `json:"synced_flag,omitempty"`

				// To Recipients of the mail thread
				To *[]struct {
					// EmailAddress Email address of the mail thread participant
					EmailAddress *string `json:"email_address,omitempty"`

					// Id ID of the mail thread participant
					Id *int `json:"id,omitempty"`

					// LatestSent Whether the mail thread participant was last to send an email
					LatestSent *bool `json:"latest_sent,omitempty"`

					// LinkedOrganizationId Linked Organization ID
					LinkedOrganizationId *int `json:"linked_organization_id"`

					// LinkedPersonId ID of the linked person
					LinkedPersonId *int `json:"linked_person_id,omitempty"`

					// LinkedPersonName Email of the linked person
					LinkedPersonName *string `json:"linked_person_name,omitempty"`

					// MailMessagePartyId ID of the mail message party
					MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

					// MessageTime Message time
					MessageTime *float32 `json:"message_time,omitempty"`

					// Name Name of the mail thread participant
					Name *string `json:"name,omitempty"`
				} `json:"to,omitempty"`

				// UpdateTime The time when the mail message was updated in database received
				UpdateTime *time.Time `json:"update_time,omitempty"`

				// UserId ID of the user whom mail message will be assigned to
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSaveUserProviderLinkResponse parses an HTTP response from a SaveUserProviderLinkWithResponse call
func ParseSaveUserProviderLinkResponse(rsp *http.Response) (*SaveUserProviderLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveUserProviderLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Message The success message of the request
				Message *string `json:"message,omitempty"`
			} `json:"data,omitempty"`

			// Success Boolean that indicates whether the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Message The error message of the request
			Message *string `json:"message,omitempty"`

			// Success Boolean that indicates whether the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteUserProviderLinkResponse parses an HTTP response from a DeleteUserProviderLinkWithResponse call
func ParseDeleteUserProviderLinkResponse(rsp *http.Response) (*DeleteUserProviderLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserProviderLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Message The success message of the request
				Message *string `json:"message,omitempty"`
			} `json:"data,omitempty"`

			// Success Boolean that indicates whether the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Message The error message of the request
			Message *string `json:"message,omitempty"`

			// Success Boolean that indicates whether the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Message The error message of the request
			Message *string `json:"message,omitempty"`

			// Success Boolean that indicates whether the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetNoteFieldsResponse parses an HTTP response from a GetNoteFieldsWithResponse call
func ParseGetNoteFieldsResponse(rsp *http.Response) (*GetNoteFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNoteFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// ActiveFlag The active flag of the field
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// BulkEditAllowed Not used
				BulkEditAllowed *bool `json:"bulk_edit_allowed,omitempty"`

				// EditFlag The edit flag of the field
				EditFlag *bool `json:"edit_flag,omitempty"`

				// FieldType List of all possible field types
				FieldType *GetNoteFields200DataFieldType `json:"field_type,omitempty"`

				// Id The ID of the field
				Id *int `json:"id,omitempty"`

				// Key The key of the field
				Key *string `json:"key,omitempty"`

				// MandatoryFlag Whether or not the field is mandatory
				MandatoryFlag *bool `json:"mandatory_flag,omitempty"`

				// Name The name of the field
				Name *string `json:"name,omitempty"`

				// Options The options of the field. When there are no options, `null` is returned.
				Options *[]struct {
					Id    *int    `json:"id,omitempty"`
					Label *string `json:"label,omitempty"`
				} `json:"options,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNotesResponse parses an HTTP response from a GetNotesWithResponse call
func ParseGetNotesResponse(rsp *http.Response) (*GetNotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// Pagination The pagination details of the list
				Pagination *struct {
					// Limit Items shown per page
					Limit *int `json:"limit,omitempty"`

					// MoreItemsInCollection If there are more list items in the collection than displayed or not
					MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

					// NextStart Next pagination start
					NextStart *int `json:"next_start,omitempty"`

					// Start Pagination start
					Start *int `json:"start,omitempty"`
				} `json:"pagination,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of notes
			Data *[]struct {
				// ActiveFlag Whether the note is active or deleted
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the note
				AddTime *string `json:"add_time,omitempty"`

				// Content The content of the note in HTML format. Subject to sanitization on the back-end.
				Content *string `json:"content,omitempty"`

				// Deal The deal this note is attached to
				Deal *struct {
					// Title The title of the deal this note is attached to
					Title *string `json:"title,omitempty"`
				} `json:"deal,omitempty"`

				// DealId The ID of the deal the note is attached to
				DealId *int `json:"deal_id,omitempty"`

				// Id The ID of the note
				Id *int `json:"id,omitempty"`

				// LastUpdateUserId The ID of the user who last updated the note
				LastUpdateUserId *int `json:"last_update_user_id,omitempty"`

				// LeadId The ID of the lead the note is attached to
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// OrgId The ID of the organization the note is attached to
				OrgId *int `json:"org_id,omitempty"`

				// Organization The organization the note is attached to
				Organization *struct {
					// Name The name of the organization the note is attached to
					Name *string `json:"name,omitempty"`
				} `json:"organization,omitempty"`

				// Person The person the note is attached to
				Person *struct {
					// Name The name of the person the note is attached to
					Name *string `json:"name,omitempty"`
				} `json:"person,omitempty"`

				// PersonId The ID of the person the note is attached to
				PersonId *int `json:"person_id,omitempty"`

				// PinnedToDealFlag If true, the results are filtered by note to deal pinning state
				PinnedToDealFlag *bool `json:"pinned_to_deal_flag,omitempty"`

				// PinnedToOrganizationFlag If true, the results are filtered by note to organization pinning state
				PinnedToOrganizationFlag *bool `json:"pinned_to_organization_flag,omitempty"`

				// PinnedToPersonFlag If true, the results are filtered by note to person pinning state
				PinnedToPersonFlag *bool `json:"pinned_to_person_flag,omitempty"`

				// PinnedToProjectFlag If true, the results are filtered by note to project pinning state
				PinnedToProjectFlag *bool `json:"pinned_to_project_flag,omitempty"`

				// Project The project the note is attached to
				Project *struct {
					// Title The title of the project the note is attached to
					Title *string `json:"title,omitempty"`
				} `json:"project,omitempty"`

				// ProjectId The ID of the project the note is attached to
				ProjectId *int `json:"project_id,omitempty"`

				// UpdateTime The last updated date and time of the note
				UpdateTime *string `json:"update_time,omitempty"`

				// User The user who created the note
				User *struct {
					// Email The email of the note creator
					Email *string `json:"email,omitempty"`

					// IconUrl The URL of the note creator avatar picture
					IconUrl *string `json:"icon_url,omitempty"`

					// IsYou Whether the note is created by you or not
					IsYou *bool `json:"is_you,omitempty"`

					// Name The name of the note creator
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`

				// UserId The ID of the note creator
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddNoteResponse parses an HTTP response from a AddNoteWithResponse call
func ParseAddNoteResponse(rsp *http.Response) (*AddNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Whether the note is active or deleted
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the note
				AddTime *string `json:"add_time,omitempty"`

				// Content The content of the note in HTML format. Subject to sanitization on the back-end.
				Content *string `json:"content,omitempty"`

				// Deal The deal this note is attached to
				Deal *struct {
					// Title The title of the deal this note is attached to
					Title *string `json:"title,omitempty"`
				} `json:"deal,omitempty"`

				// DealId The ID of the deal the note is attached to
				DealId *int `json:"deal_id,omitempty"`

				// Id The ID of the note
				Id *int `json:"id,omitempty"`

				// LastUpdateUserId The ID of the user who last updated the note
				LastUpdateUserId *int `json:"last_update_user_id,omitempty"`

				// LeadId The ID of the lead the note is attached to
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// OrgId The ID of the organization the note is attached to
				OrgId *int `json:"org_id,omitempty"`

				// Organization The organization the note is attached to
				Organization *struct {
					// Name The name of the organization the note is attached to
					Name *string `json:"name,omitempty"`
				} `json:"organization,omitempty"`

				// Person The person the note is attached to
				Person *struct {
					// Name The name of the person the note is attached to
					Name *string `json:"name,omitempty"`
				} `json:"person,omitempty"`

				// PersonId The ID of the person the note is attached to
				PersonId *int `json:"person_id,omitempty"`

				// PinnedToDealFlag If true, the results are filtered by note to deal pinning state
				PinnedToDealFlag *bool `json:"pinned_to_deal_flag,omitempty"`

				// PinnedToOrganizationFlag If true, the results are filtered by note to organization pinning state
				PinnedToOrganizationFlag *bool `json:"pinned_to_organization_flag,omitempty"`

				// PinnedToPersonFlag If true, the results are filtered by note to person pinning state
				PinnedToPersonFlag *bool `json:"pinned_to_person_flag,omitempty"`

				// PinnedToProjectFlag If true, the results are filtered by note to project pinning state
				PinnedToProjectFlag *bool `json:"pinned_to_project_flag,omitempty"`

				// Project The project the note is attached to
				Project *struct {
					// Title The title of the project the note is attached to
					Title *string `json:"title,omitempty"`
				} `json:"project,omitempty"`

				// ProjectId The ID of the project the note is attached to
				ProjectId *int `json:"project_id,omitempty"`

				// UpdateTime The last updated date and time of the note
				UpdateTime *string `json:"update_time,omitempty"`

				// User The user who created the note
				User *struct {
					// Email The email of the note creator
					Email *string `json:"email,omitempty"`

					// IconUrl The URL of the note creator avatar picture
					IconUrl *string `json:"icon_url,omitempty"`

					// IsYou Whether the note is created by you or not
					IsYou *bool `json:"is_you,omitempty"`

					// Name The name of the note creator
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`

				// UserId The ID of the note creator
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNoteResponse parses an HTTP response from a DeleteNoteWithResponse call
func ParseDeleteNoteResponse(rsp *http.Response) (*DeleteNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data If the response is successful or not
			Data *bool `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNoteResponse parses an HTTP response from a GetNoteWithResponse call
func ParseGetNoteResponse(rsp *http.Response) (*GetNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Whether the note is active or deleted
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the note
				AddTime *string `json:"add_time,omitempty"`

				// Content The content of the note in HTML format. Subject to sanitization on the back-end.
				Content *string `json:"content,omitempty"`

				// Deal The deal this note is attached to
				Deal *struct {
					// Title The title of the deal this note is attached to
					Title *string `json:"title,omitempty"`
				} `json:"deal,omitempty"`

				// DealId The ID of the deal the note is attached to
				DealId *int `json:"deal_id,omitempty"`

				// Id The ID of the note
				Id *int `json:"id,omitempty"`

				// LastUpdateUserId The ID of the user who last updated the note
				LastUpdateUserId *int `json:"last_update_user_id,omitempty"`

				// LeadId The ID of the lead the note is attached to
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// OrgId The ID of the organization the note is attached to
				OrgId *int `json:"org_id,omitempty"`

				// Organization The organization the note is attached to
				Organization *struct {
					// Name The name of the organization the note is attached to
					Name *string `json:"name,omitempty"`
				} `json:"organization,omitempty"`

				// Person The person the note is attached to
				Person *struct {
					// Name The name of the person the note is attached to
					Name *string `json:"name,omitempty"`
				} `json:"person,omitempty"`

				// PersonId The ID of the person the note is attached to
				PersonId *int `json:"person_id,omitempty"`

				// PinnedToDealFlag If true, the results are filtered by note to deal pinning state
				PinnedToDealFlag *bool `json:"pinned_to_deal_flag,omitempty"`

				// PinnedToOrganizationFlag If true, the results are filtered by note to organization pinning state
				PinnedToOrganizationFlag *bool `json:"pinned_to_organization_flag,omitempty"`

				// PinnedToPersonFlag If true, the results are filtered by note to person pinning state
				PinnedToPersonFlag *bool `json:"pinned_to_person_flag,omitempty"`

				// PinnedToProjectFlag If true, the results are filtered by note to project pinning state
				PinnedToProjectFlag *bool `json:"pinned_to_project_flag,omitempty"`

				// Project The project the note is attached to
				Project *struct {
					// Title The title of the project the note is attached to
					Title *string `json:"title,omitempty"`
				} `json:"project,omitempty"`

				// ProjectId The ID of the project the note is attached to
				ProjectId *int `json:"project_id,omitempty"`

				// UpdateTime The last updated date and time of the note
				UpdateTime *string `json:"update_time,omitempty"`

				// User The user who created the note
				User *struct {
					// Email The email of the note creator
					Email *string `json:"email,omitempty"`

					// IconUrl The URL of the note creator avatar picture
					IconUrl *string `json:"icon_url,omitempty"`

					// IsYou Whether the note is created by you or not
					IsYou *bool `json:"is_you,omitempty"`

					// Name The name of the note creator
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`

				// UserId The ID of the note creator
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateNoteResponse parses an HTTP response from a UpdateNoteWithResponse call
func ParseUpdateNoteResponse(rsp *http.Response) (*UpdateNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Whether the note is active or deleted
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the note
				AddTime *string `json:"add_time,omitempty"`

				// Content The content of the note in HTML format. Subject to sanitization on the back-end.
				Content *string `json:"content,omitempty"`

				// Deal The deal this note is attached to
				Deal *struct {
					// Title The title of the deal this note is attached to
					Title *string `json:"title,omitempty"`
				} `json:"deal,omitempty"`

				// DealId The ID of the deal the note is attached to
				DealId *int `json:"deal_id,omitempty"`

				// Id The ID of the note
				Id *int `json:"id,omitempty"`

				// LastUpdateUserId The ID of the user who last updated the note
				LastUpdateUserId *int `json:"last_update_user_id,omitempty"`

				// LeadId The ID of the lead the note is attached to
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// OrgId The ID of the organization the note is attached to
				OrgId *int `json:"org_id,omitempty"`

				// Organization The organization the note is attached to
				Organization *struct {
					// Name The name of the organization the note is attached to
					Name *string `json:"name,omitempty"`
				} `json:"organization,omitempty"`

				// Person The person the note is attached to
				Person *struct {
					// Name The name of the person the note is attached to
					Name *string `json:"name,omitempty"`
				} `json:"person,omitempty"`

				// PersonId The ID of the person the note is attached to
				PersonId *int `json:"person_id,omitempty"`

				// PinnedToDealFlag If true, the results are filtered by note to deal pinning state
				PinnedToDealFlag *bool `json:"pinned_to_deal_flag,omitempty"`

				// PinnedToOrganizationFlag If true, the results are filtered by note to organization pinning state
				PinnedToOrganizationFlag *bool `json:"pinned_to_organization_flag,omitempty"`

				// PinnedToPersonFlag If true, the results are filtered by note to person pinning state
				PinnedToPersonFlag *bool `json:"pinned_to_person_flag,omitempty"`

				// PinnedToProjectFlag If true, the results are filtered by note to project pinning state
				PinnedToProjectFlag *bool `json:"pinned_to_project_flag,omitempty"`

				// Project The project the note is attached to
				Project *struct {
					// Title The title of the project the note is attached to
					Title *string `json:"title,omitempty"`
				} `json:"project,omitempty"`

				// ProjectId The ID of the project the note is attached to
				ProjectId *int `json:"project_id,omitempty"`

				// UpdateTime The last updated date and time of the note
				UpdateTime *string `json:"update_time,omitempty"`

				// User The user who created the note
				User *struct {
					// Email The email of the note creator
					Email *string `json:"email,omitempty"`

					// IconUrl The URL of the note creator avatar picture
					IconUrl *string `json:"icon_url,omitempty"`

					// IsYou Whether the note is created by you or not
					IsYou *bool `json:"is_you,omitempty"`

					// Name The name of the note creator
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`

				// UserId The ID of the note creator
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNoteCommentsResponse parses an HTTP response from a GetNoteCommentsWithResponse call
func ParseGetNoteCommentsResponse(rsp *http.Response) (*GetNoteCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNoteCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// Pagination The pagination details of the list
				Pagination *struct {
					// Limit Items shown per page
					Limit *int `json:"limit,omitempty"`

					// MoreItemsInCollection If there are more list items in the collection than displayed or not
					MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

					// NextStart Next pagination start
					NextStart *int `json:"next_start,omitempty"`

					// Start Pagination start
					Start *int `json:"start,omitempty"`
				} `json:"pagination,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of comments
			Data *[]struct {
				// ActiveFlag Whether the note is active or deleted
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the note
				AddTime *string `json:"add_time,omitempty"`

				// CompanyId The ID of the company
				CompanyId *int `json:"company_id,omitempty"`

				// Content The content of the note in HTML format. Subject to sanitization on the back-end.
				Content *string `json:"content,omitempty"`

				// ObjectId The ID of the object that the comment is attached to, will be the id of the note
				ObjectId *string `json:"object_id,omitempty"`

				// ObjectType The type of object that the comment is attached to, will be "note"
				ObjectType *string `json:"object_type,omitempty"`

				// UpdateTime The creation date and time of the note
				UpdateTime *string `json:"update_time,omitempty"`

				// UpdaterId The ID of the user who last updated the comment
				UpdaterId *int `json:"updater_id,omitempty"`

				// UserId The ID of the user who created the comment
				UserId *int `json:"user_id,omitempty"`

				// Uuid The ID of the note
				Uuid *openapi_types.UUID `json:"uuid,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddNoteCommentResponse parses an HTTP response from a AddNoteCommentWithResponse call
func ParseAddNoteCommentResponse(rsp *http.Response) (*AddNoteCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddNoteCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Whether the note is active or deleted
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the note
				AddTime *string `json:"add_time,omitempty"`

				// CompanyId The ID of the company
				CompanyId *int `json:"company_id,omitempty"`

				// Content The content of the note in HTML format. Subject to sanitization on the back-end.
				Content *string `json:"content,omitempty"`

				// ObjectId The ID of the object that the comment is attached to, will be the id of the note
				ObjectId *string `json:"object_id,omitempty"`

				// ObjectType The type of object that the comment is attached to, will be "note"
				ObjectType *string `json:"object_type,omitempty"`

				// UpdateTime The creation date and time of the note
				UpdateTime *string `json:"update_time,omitempty"`

				// UpdaterId The ID of the user who last updated the comment
				UpdaterId *int `json:"updater_id,omitempty"`

				// UserId The ID of the user who created the comment
				UserId *int `json:"user_id,omitempty"`

				// Uuid The ID of the note
				Uuid *openapi_types.UUID `json:"uuid,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCommentResponse parses an HTTP response from a DeleteCommentWithResponse call
func ParseDeleteCommentResponse(rsp *http.Response) (*DeleteCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data If the response is successful or not
			Data *bool `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCommentResponse parses an HTTP response from a GetCommentWithResponse call
func ParseGetCommentResponse(rsp *http.Response) (*GetCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Whether the note is active or deleted
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the note
				AddTime *string `json:"add_time,omitempty"`

				// CompanyId The ID of the company
				CompanyId *int `json:"company_id,omitempty"`

				// Content The content of the note in HTML format. Subject to sanitization on the back-end.
				Content *string `json:"content,omitempty"`

				// ObjectId The ID of the object that the comment is attached to, will be the id of the note
				ObjectId *string `json:"object_id,omitempty"`

				// ObjectType The type of object that the comment is attached to, will be "note"
				ObjectType *string `json:"object_type,omitempty"`

				// UpdateTime The creation date and time of the note
				UpdateTime *string `json:"update_time,omitempty"`

				// UpdaterId The ID of the user who last updated the comment
				UpdaterId *int `json:"updater_id,omitempty"`

				// UserId The ID of the user who created the comment
				UserId *int `json:"user_id,omitempty"`

				// Uuid The ID of the note
				Uuid *openapi_types.UUID `json:"uuid,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCommentForNoteResponse parses an HTTP response from a UpdateCommentForNoteWithResponse call
func ParseUpdateCommentForNoteResponse(rsp *http.Response) (*UpdateCommentForNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCommentForNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Whether the note is active or deleted
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the note
				AddTime *string `json:"add_time,omitempty"`

				// CompanyId The ID of the company
				CompanyId *int `json:"company_id,omitempty"`

				// Content The content of the note in HTML format. Subject to sanitization on the back-end.
				Content *string `json:"content,omitempty"`

				// ObjectId The ID of the object that the comment is attached to, will be the id of the note
				ObjectId *string `json:"object_id,omitempty"`

				// ObjectType The type of object that the comment is attached to, will be "note"
				ObjectType *string `json:"object_type,omitempty"`

				// UpdateTime The creation date and time of the note
				UpdateTime *string `json:"update_time,omitempty"`

				// UpdaterId The ID of the user who last updated the comment
				UpdaterId *int `json:"updater_id,omitempty"`

				// UserId The ID of the user who created the comment
				UserId *int `json:"user_id,omitempty"`

				// Uuid The ID of the note
				Uuid *openapi_types.UUID `json:"uuid,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAuthorizeResponse parses an HTTP response from a AuthorizeWithResponse call
func ParseAuthorizeResponse(rsp *http.Response) (*AuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTokensResponse parses an HTTP response from a GetTokensWithResponse call
func ParseGetTokensResponse(rsp *http.Response) (*GetTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AccessToken You need to use an `access_token` for accessing the user's data via API. You will need to [refresh the access token](https://pipedrive.readme.io/docs/marketplace-oauth-authorization#step-7-refreshing-the-tokens) if the `access_token` becomes invalid.
			AccessToken *string `json:"access_token,omitempty"`

			// ApiDomain The base URL path, including the company_domain, where the requests can be sent to
			ApiDomain *string `json:"api_domain,omitempty"`

			// ExpiresIn The maximum time in seconds until the `access_token` expires
			ExpiresIn *int `json:"expires_in,omitempty"`

			// RefreshToken A refresh token is needed when you refresh the access token. refresh_token will expire if it isn't used in 60 days. Each time refresh_token is used, its expiry date is reset back to 60 days.
			RefreshToken *string `json:"refresh_token,omitempty"`

			// Scope List of scopes to which users have agreed to grant access within this `access_token`
			Scope *string `json:"scope,omitempty"`

			// TokenType The format of the token. Always "Bearer".
			TokenType *string `json:"token_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRefreshTokensResponse parses an HTTP response from a RefreshTokensWithResponse call
func ParseRefreshTokensResponse(rsp *http.Response) (*RefreshTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AccessToken You need to use an `access_token` for accessing the user's data via API. You will need to [refresh the access token](https://pipedrive.readme.io/docs/marketplace-oauth-authorization#step-7-refreshing-the-tokens) if the `access_token` becomes invalid.
			AccessToken *string `json:"access_token,omitempty"`

			// ApiDomain The base URL path, including the company_domain, where the requests can be sent to
			ApiDomain *string `json:"api_domain,omitempty"`

			// ExpiresIn The maximum time in seconds until the `access_token` expires
			ExpiresIn *int `json:"expires_in,omitempty"`

			// RefreshToken A refresh token is needed when you refresh the access token. refresh_token will expire if it isn't used in 60 days. Each time refresh_token is used, its expiry date is reset back to 60 days.
			RefreshToken *string `json:"refresh_token,omitempty"`

			// Scope List of scopes to which users have agreed to grant access within this `access_token`
			Scope *string `json:"scope,omitempty"`

			// TokenType The format of the token. Always "Bearer".
			TokenType *string `json:"token_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationFieldsResponse parses an HTTP response from a DeleteOrganizationFieldsWithResponse call
func ParseDeleteOrganizationFieldsResponse(rsp *http.Response) (*DeleteOrganizationFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The list of deleted field IDs
				Id *[]int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationRelationshipsResponse parses an HTTP response from a GetOrganizationRelationshipsWithResponse call
func ParseGetOrganizationRelationshipsResponse(rsp *http.Response) (*GetOrganizationRelationshipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationRelationshipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of organization relationships
			Data *[]struct {
				// ActiveFlag Whether the relationship is active or not
				ActiveFlag *string `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the relationship
				AddTime *string `json:"add_time,omitempty"`

				// CalculatedRelatedOrgId The ID of the linked organization
				CalculatedRelatedOrgId *int `json:"calculated_related_org_id,omitempty"`

				// CalculatedType The calculated type of the relationship with the linked organization
				CalculatedType *string `json:"calculated_type,omitempty"`

				// Id The ID of the organization relationship
				Id             *int `json:"id,omitempty"`
				RelLinkedOrgId *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization
					Value *int `json:"value,omitempty"`
				} `json:"rel_linked_org_id,omitempty"`
				RelOwnerOrgId *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization
					Value *int `json:"value,omitempty"`
				} `json:"rel_owner_org_id,omitempty"`

				// RelatedOrganizationName The name of the linked organization
				RelatedOrganizationName *string `json:"related_organization_name,omitempty"`

				// Type The type of the relationship
				Type *string `json:"type,omitempty"`

				// UpdateTime The last updated date and time of the relationship
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddOrganizationRelationshipResponse parses an HTTP response from a AddOrganizationRelationshipWithResponse call
func ParseAddOrganizationRelationshipResponse(rsp *http.Response) (*AddOrganizationRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Whether the relationship is active or not
				ActiveFlag *string `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the relationship
				AddTime *string `json:"add_time,omitempty"`

				// Id The ID of the organization relationship
				Id             *int `json:"id,omitempty"`
				RelLinkedOrgId *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization
					Value *int `json:"value,omitempty"`
				} `json:"rel_linked_org_id,omitempty"`
				RelOwnerOrgId *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization
					Value *int `json:"value,omitempty"`
				} `json:"rel_owner_org_id,omitempty"`

				// Type The type of the relationship
				Type *string `json:"type,omitempty"`

				// UpdateTime The last updated date and time of the relationship
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationRelationshipResponse parses an HTTP response from a DeleteOrganizationRelationshipWithResponse call
func ParseDeleteOrganizationRelationshipResponse(rsp *http.Response) (*DeleteOrganizationRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of the deleted organization relationship
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationRelationshipResponse parses an HTTP response from a GetOrganizationRelationshipWithResponse call
func ParseGetOrganizationRelationshipResponse(rsp *http.Response) (*GetOrganizationRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Whether the relationship is active or not
				ActiveFlag *string `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the relationship
				AddTime *string `json:"add_time,omitempty"`

				// CalculatedRelatedOrgId The ID of the linked organization
				CalculatedRelatedOrgId *int `json:"calculated_related_org_id,omitempty"`

				// CalculatedType The calculated type of the relationship with the linked organization
				CalculatedType *string `json:"calculated_type,omitempty"`

				// Id The ID of the organization relationship
				Id             *int `json:"id,omitempty"`
				RelLinkedOrgId *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization
					Value *int `json:"value,omitempty"`
				} `json:"rel_linked_org_id,omitempty"`
				RelOwnerOrgId *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization
					Value *int `json:"value,omitempty"`
				} `json:"rel_owner_org_id,omitempty"`

				// Type The type of the relationship
				Type *string `json:"type,omitempty"`

				// UpdateTime The last updated date and time of the relationship
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateOrganizationRelationshipResponse parses an HTTP response from a UpdateOrganizationRelationshipWithResponse call
func ParseUpdateOrganizationRelationshipResponse(rsp *http.Response) (*UpdateOrganizationRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrganizationRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Whether the relationship is active or not
				ActiveFlag *string `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the relationship
				AddTime *string `json:"add_time,omitempty"`

				// Id The ID of the organization relationship
				Id             *int `json:"id,omitempty"`
				RelLinkedOrgId *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization
					Value *int `json:"value,omitempty"`
				} `json:"rel_linked_org_id,omitempty"`
				RelOwnerOrgId *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization
					Value *int `json:"value,omitempty"`
				} `json:"rel_owner_org_id,omitempty"`

				// Type The type of the relationship
				Type *string `json:"type,omitempty"`

				// UpdateTime The last updated date and time of the relationship
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationsResponse parses an HTTP response from a DeleteOrganizationsWithResponse call
func ParseDeleteOrganizationsResponse(rsp *http.Response) (*DeleteOrganizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The IDs of the organizations that were deleted
				Id *[]float32 `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationsCollectionResponse parses an HTTP response from a GetOrganizationsCollectionWithResponse call
func ParseGetOrganizationsCollectionResponse(rsp *http.Response) (*GetOrganizationsCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationsCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// ActiveFlag Whether the organization is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The date and time when the organization was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// Address The full address of the organization
				Address *string `json:"address,omitempty"`

				// AddressAdminAreaLevel1 The level 1 admin area of the organization location
				AddressAdminAreaLevel1 *string `json:"address_admin_area_level_1,omitempty"`

				// AddressAdminAreaLevel2 The level 2 admin area of the organization location
				AddressAdminAreaLevel2 *string `json:"address_admin_area_level_2,omitempty"`

				// AddressCountry The country of the organization location
				AddressCountry *string `json:"address_country,omitempty"`

				// AddressFormattedAddress The formatted organization location
				AddressFormattedAddress *string `json:"address_formatted_address,omitempty"`

				// AddressLocality The locality of the organization location
				AddressLocality *string `json:"address_locality,omitempty"`

				// AddressPostalCode The postal code of the organization location
				AddressPostalCode *string `json:"address_postal_code,omitempty"`

				// AddressRoute The route of the organization location
				AddressRoute *string `json:"address_route,omitempty"`

				// AddressStreetNumber The street number of the organization location
				AddressStreetNumber *string `json:"address_street_number,omitempty"`

				// AddressSublocality The sub-locality of the organization location
				AddressSublocality *string `json:"address_sublocality,omitempty"`

				// AddressSubpremise The sub-premise of the organization location
				AddressSubpremise *string `json:"address_subpremise,omitempty"`

				// CcEmail The BCC email associated with the organization
				CcEmail *string `json:"cc_email,omitempty"`

				// DeleteTime The date and time this organization was deleted. Format: YYYY-MM-DD HH:MM:SS
				DeleteTime *string `json:"delete_time"`

				// Id The ID of the organization
				Id *int `json:"id,omitempty"`

				// Label The label assigned to the organization. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
				Label *int `json:"label"`

				// LabelIds The IDs of labels assigned to the organization. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
				LabelIds *[]int `json:"label_ids,omitempty"`

				// Name The name of the organization
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the owner
				OwnerId *int `json:"owner_id,omitempty"`

				// UpdateTime The last updated date and time of the organization. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility group ID of who can see the organization
				VisibleTo *string `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetOrganizationActivitiesResponse parses an HTTP response from a GetOrganizationActivitiesWithResponse call
func ParseGetOrganizationActivitiesResponse(rsp *http.Response) (*GetOrganizationActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// ActivityDistribution The distribution of activities related to the organization grouped by the user ID
				ActivityDistribution *struct {
					// ASSIGNEDTOUSERID The ID of the user
					ASSIGNEDTOUSERID *struct {
						// Activities The count of activities related to the user grouped by activity type
						Activities *struct {
							// ACTIVITYTYPENAME The count of activities related to a specific type
							ACTIVITYTYPENAME *int `json:"ACTIVITY_TYPE_NAME,omitempty"`
						} `json:"activities,omitempty"`

						// ActivityCount The overall count of activities for the user
						ActivityCount *int `json:"activity_count,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// Share The percentage of activities belongs to the user
						Share *int `json:"share,omitempty"`
					} `json:"ASSIGNED_TO_USER_ID,omitempty"`
				} `json:"activity_distribution,omitempty"`

				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of activities
			Data *[]struct {
				// ActiveFlag Whether the activity is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// AssignedToUserId The ID of the user to whom the activity is assigned to. Equal to `user_id`.
				AssignedToUserId *int `json:"assigned_to_user_id,omitempty"`

				// Attendees The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address.
				Attendees *[]map[string]interface{} `json:"attendees"`

				// BusyFlag Marks if the activity is set as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
				BusyFlag *bool `json:"busy_flag,omitempty"`

				// CalendarSyncIncludeContext For activities that sync to an external calendar, this setting indicates if the activity syncs with context (what are the deals, persons, organizations this activity is related to)
				CalendarSyncIncludeContext *string `json:"calendar_sync_include_context,omitempty"`

				// CompanyId The user's company ID
				CompanyId *int `json:"company_id,omitempty"`

				// ConferenceMeetingClient The ID of the Marketplace app, which is connected to this activity
				ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

				// ConferenceMeetingId The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
				ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

				// ConferenceMeetingUrl The link to join the meeting which is associated with this activity
				ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

				// CreatedByUserId The ID of the user who created the activity
				CreatedByUserId *int `json:"created_by_user_id,omitempty"`

				// DealDropboxBcc The BCC email address of the deal
				DealDropboxBcc *string `json:"deal_dropbox_bcc,omitempty"`

				// DealId The ID of the deal this activity is associated with
				DealId *int `json:"deal_id,omitempty"`

				// DealTitle The name of the deal this activity is associated with
				DealTitle *string `json:"deal_title,omitempty"`

				// Done Whether the activity is done or not
				Done *bool `json:"done,omitempty"`

				// DueDate The due date of the activity. Format: YYYY-MM-DD
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// DueTime The due time of the activity in UTC. Format: HH:MM
				DueTime *string `json:"due_time,omitempty"`

				// Duration The duration of the activity. Format: HH:MM
				Duration *string `json:"duration,omitempty"`

				// File The file that is attached to this activity. For example, this can be a reference to an audio note file generated with Pipedrive mobile app.
				File *map[string]interface{} `json:"file,omitempty"`

				// GcalEventId For the activity which syncs to Google calendar, this is the Google event ID. NB! This field is related to old Google calendar sync and will be deprecated soon.
				GcalEventId *string `json:"gcal_event_id,omitempty"`

				// GoogleCalendarEtag The Google calendar API etag (version) that is used for syncing this activity. NB! This field is related to old Google calendar sync and will be deprecated soon.
				GoogleCalendarEtag *string `json:"google_calendar_etag,omitempty"`

				// GoogleCalendarId The Google calendar ID that this activity syncs to. NB! This field is related to old Google calendar sync and will be deprecated soon.
				GoogleCalendarId *string `json:"google_calendar_id,omitempty"`

				// Id The ID of the activity, generated when the activity was created
				Id *int `json:"id,omitempty"`

				// LastNotificationTime The date and time of latest notifications sent about this activity to the participants or the attendees of this activity
				LastNotificationTime *string `json:"last_notification_time,omitempty"`

				// LastNotificationUserId The ID of the user who triggered the sending of the latest notifications about this activity to the participants or the attendees of this activity
				LastNotificationUserId *int `json:"last_notification_user_id,omitempty"`

				// LeadId The ID of the lead in the UUID format this activity is associated with
				LeadId *openapi_types.UUID `json:"lead_id"`

				// Location The address of the activity.
				Location *string `json:"location,omitempty"`

				// LocationAdminAreaLevel1 A subfield of the location field. Indicates state/county.
				LocationAdminAreaLevel1 *string `json:"location_admin_area_level_1,omitempty"`

				// LocationAdminAreaLevel2 A subfield of the location field. Indicates region.
				LocationAdminAreaLevel2 *string `json:"location_admin_area_level_2,omitempty"`

				// LocationCountry A subfield of the location field. Indicates country.
				LocationCountry *string `json:"location_country,omitempty"`

				// LocationFormattedAddress A subfield of the location field. Indicates full/combined address.
				LocationFormattedAddress *string `json:"location_formatted_address,omitempty"`

				// LocationLocality A subfield of the location field. Indicates city/town/village/locality.
				LocationLocality *string `json:"location_locality,omitempty"`

				// LocationPostalCode A subfield of the location field. Indicates ZIP/postal code.
				LocationPostalCode *string `json:"location_postal_code,omitempty"`

				// LocationRoute A subfield of the location field. Indicates street name.
				LocationRoute *string `json:"location_route,omitempty"`

				// LocationStreetNumber A subfield of the location field. Indicates house number.
				LocationStreetNumber *string `json:"location_street_number,omitempty"`

				// LocationSublocality A subfield of the location field. Indicates district/sublocality.
				LocationSublocality *string `json:"location_sublocality,omitempty"`

				// LocationSubpremise A subfield of the location field. Indicates apartment/suite number.
				LocationSubpremise *string `json:"location_subpremise,omitempty"`

				// MarkedAsDoneTime The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// Note The note of the activity (HTML format)
				Note *string `json:"note,omitempty"`

				// NotificationLanguageId The ID of the language the notifications are sent in
				NotificationLanguageId *int `json:"notification_language_id,omitempty"`

				// OrgId The ID of the organization this activity is associated with
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization this activity is associated with
				OrgName *string `json:"org_name,omitempty"`

				// OwnerName The name of the user this activity is owned by
				OwnerName *string `json:"owner_name,omitempty"`

				// Participants List of multiple persons (participants) this activity is associated with
				Participants *[]map[string]interface{} `json:"participants"`

				// PersonDropboxBcc The BCC email address of the person
				PersonDropboxBcc *string `json:"person_dropbox_bcc,omitempty"`

				// PersonId The ID of the person this activity is associated with
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person this activity is associated with
				PersonName *string `json:"person_name,omitempty"`

				// ProjectId The ID of the project this activity is associated with
				ProjectId *int `json:"project_id"`

				// PublicDescription Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
				PublicDescription *string `json:"public_description,omitempty"`

				// RecMasterActivityId The ID of parent activity for a recurrent activity if the current activity is an exception to recurrence rules
				RecMasterActivityId *int `json:"rec_master_activity_id,omitempty"`

				// RecRule The rule for the recurrence of the activity. Is important for activities synced into Pipedrive from an external calendar. Example: "RRULE:FREQ=WEEKLY;BYDAY=WE"
				RecRule *string `json:"rec_rule,omitempty"`

				// RecRuleExtension Additional rules for the recurrence of the activity, extend the `rec_rule`. Is important for activities synced into Pipedrive from an external calendar.
				RecRuleExtension *string `json:"rec_rule_extension,omitempty"`

				// ReferenceId Together with the `reference_type`, gives the ID of the other object
				ReferenceId *int `json:"reference_id,omitempty"`

				// ReferenceType If the activity references some other object, it is indicated here. For example, value `Salesphone` refers to activities created with Caller.
				ReferenceType *string `json:"reference_type,omitempty"`

				// Series The list of recurring activity instances. It is in a structure as follows: `[{due_date: "2020-06-24", due_time: "10:00:00"}]`
				Series *[]map[string]interface{} `json:"series,omitempty"`

				// SourceTimezone The timezone the activity was created in an external calendar
				SourceTimezone *string `json:"source_timezone,omitempty"`

				// Subject The subject of the activity
				Subject *string `json:"subject,omitempty"`

				// Type The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
				Type *string `json:"type,omitempty"`

				// UpdateTime The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`

				// UpdateUserId The ID of the user who was the last to update this activity
				UpdateUserId *int `json:"update_user_id,omitempty"`

				// UserId The ID of the user whom the activity is assigned to
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationChangelogResponse parses an HTTP response from a GetOrganizationChangelogWithResponse call
func ParseGetOrganizationChangelogResponse(rsp *http.Response) (*GetOrganizationChangelogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationChangelogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// ActorUserId The ID of the user who made the change
				ActorUserId *int `json:"actor_user_id,omitempty"`

				// ChangeSource The source of change, for example 'app', 'mobile', 'api', etc.
				ChangeSource *string `json:"change_source"`

				// ChangeSourceUserAgent The user agent from which the change was made
				ChangeSourceUserAgent *string `json:"change_source_user_agent"`

				// FieldKey The key of the field that was changed
				FieldKey *string `json:"field_key,omitempty"`

				// IsBulkUpdateFlag Whether the change was made as part of a bulk update
				IsBulkUpdateFlag *bool `json:"is_bulk_update_flag,omitempty"`

				// NewValue The value of the field after the change
				NewValue *string `json:"new_value"`

				// OldValue The value of the field before the change
				OldValue *string `json:"old_value"`

				// Time The date and time of the change
				Time *string `json:"time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationDealsResponse parses an HTTP response from a GetOrganizationDealsWithResponse call
func ParseGetOrganizationDealsResponse(rsp *http.Response) (*GetOrganizationDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of deals
			Data *[]struct {
				// Active Whether the deal is active or not
				Active *bool `json:"active,omitempty"`

				// ActivitiesCount The number of activities associated with the deal
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AcvCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Contract Value of the deal
				//
				// If the `acv` is null, this will also be null
				AcvCurrency *string `json:"acv_currency"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// ArrCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Recurring Revenue of the deal
				//
				// If the `arr` is null, this will also be null
				ArrCurrency *string `json:"arr_currency"`

				// CcEmail The BCC email of the deal
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// CreatorUserId The creator of the deal
				CreatorUserId *struct {
					// ActiveFlag Whether the creator is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the deal creator
					Email *string `json:"email,omitempty"`

					// HasPic If the creator has a picture or not
					HasPic *bool `json:"has_pic,omitempty"`

					// Id The ID of the deal creator
					Id *int `json:"id,omitempty"`

					// Name The name of the deal creator
					Name *string `json:"name,omitempty"`

					// PicHash The creator picture hash
					PicHash *string `json:"pic_hash"`

					// Value The ID of the deal creator
					Value *int `json:"value,omitempty"`
				} `json:"creator_user_id,omitempty"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// Deleted Whether the deal is deleted or not
				Deleted *bool `json:"deleted,omitempty"`

				// DoneActivitiesCount The number of completed activities associated with the deal
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// EmailMessagesCount The number of emails associated with the deal
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// FilesCount The number of files associated with the deal
				FilesCount *int `json:"files_count,omitempty"`

				// FirstWonTime The date and time of the first time changing the deal status as won
				FirstWonTime *string `json:"first_won_time,omitempty"`

				// FollowersCount The number of followers associated with the deal
				FollowersCount *int `json:"followers_count,omitempty"`

				// FormattedValue The deal value formatted with selected currency. E.g. US$500
				FormattedValue *string `json:"formatted_value,omitempty"`

				// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
				FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// Label The label or multiple labels assigned to the deal
				Label *string `json:"label,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the deal
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// MrrCurrency Only available in Growth and above plans
				//
				// The Currency for Monthly Recurring Revenue of the deal
				//
				// If the `mrr` is null, this will also be null
				MrrCurrency *string `json:"mrr_currency"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date,omitempty"`

				// NextActivityDuration The duration of the next activity associated with the deal
				NextActivityDuration *string `json:"next_activity_duration,omitempty"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityNote The note of the next activity associated with the deal
				NextActivityNote *string `json:"next_activity_note,omitempty"`

				// NextActivitySubject The subject of the next activity associated with the deal
				NextActivitySubject *string `json:"next_activity_subject,omitempty"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time,omitempty"`

				// NextActivityType The type of the next activity associated with the deal
				NextActivityType *string `json:"next_activity_type,omitempty"`

				// NotesCount The number of notes associated with the deal
				NotesCount *int `json:"notes_count,omitempty"`

				// OrgHidden If the organization that is associated with the deal is hidden or not
				OrgHidden *bool `json:"org_hidden,omitempty"`
				OrgId     *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization that is associated with the deal
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the deal
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the deal
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the deal
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the deal
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization associated with the deal
					Value *int `json:"value,omitempty"`
				} `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the deal
				OrgName *string `json:"org_name,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerName The name of the deal owner
				OwnerName *string `json:"owner_name,omitempty"`

				// ParticipantsCount The number of participants associated with the deal
				ParticipantsCount *int `json:"participants_count,omitempty"`

				// PersonHidden If the person that is associated with the deal is hidden or not
				PersonHidden *bool `json:"person_hidden,omitempty"`
				PersonId     *struct {
					// ActiveFlag Whether the associated person is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The emails of the person associated with the deal
					Email *[]struct {
						// Label The type of the email
						Label *string `json:"label,omitempty"`

						// Primary If this is the primary email or not
						Primary *bool `json:"primary,omitempty"`

						// Value The email of the associated person
						Value *string `json:"value,omitempty"`
					} `json:"email,omitempty"`

					// Name The name of the person associated with the deal
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the person that is associated with the deal
					OwnerId *int `json:"owner_id,omitempty"`

					// Phone The phone numbers of the person associated with the deal
					Phone *[]struct {
						// Label The type of the phone number
						Label *string `json:"label,omitempty"`

						// Primary If this is the primary phone number or not
						Primary *bool `json:"primary,omitempty"`

						// Value The phone number of the person associated with the deal
						Value *string `json:"value,omitempty"`
					} `json:"phone,omitempty"`

					// Value The ID of the person associated with the deal
					Value *int `json:"value,omitempty"`
				} `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the deal
				PersonName *string `json:"person_name,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// ProductsCount The number of products associated with the deal
				ProductsCount *int `json:"products_count,omitempty"`

				// RottenTime The date and time of changing the deal status as rotten
				RottenTime *string `json:"rotten_time"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// StageOrderNr The order number of the deal stage associated with the deal
				StageOrderNr *int `json:"stage_order_nr,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UndoneActivitiesCount The number of incomplete activities associated with the deal
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`
				UserId     *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic If the user has a picture or not
					HasPic *bool `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`

					// Value The ID of the user
					Value *int `json:"value,omitempty"`
				} `json:"user_id,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *string `json:"visible_to,omitempty"`

				// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
				WeightedValue *float32 `json:"weighted_value,omitempty"`

				// WeightedValueCurrency The currency associated with the deal
				WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// ActiveFlag Whether the associated organization is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
				Person *struct {
					// PERSONID The ID of the person associated with the item
					PERSONID *struct {
						// ActiveFlag Whether the associated person is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The emails of the person associated with the item
						Email *[]struct {
							// Label The type of the email
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary email or not
							Primary *bool `json:"primary,omitempty"`

							// Value The email of the associated person
							Value *string `json:"value,omitempty"`
						} `json:"email,omitempty"`

						// Id The ID of the person associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the person associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the person that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// Phone The phone numbers of the person associated with the item
						Phone *[]struct {
							// Label The type of the phone number
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary phone number or not
							Primary *bool `json:"primary,omitempty"`

							// Value The phone number of the person associated with the item
							Value *string `json:"value,omitempty"`
						} `json:"phone,omitempty"`
					} `json:"PERSON_ID,omitempty"`
				} `json:"person,omitempty"`
				Pipeline *struct {
					// Active Whether this pipeline will be made inactive (hidden) or active
					Active *bool `json:"active,omitempty"`

					// AddTime The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
					AddTime *string `json:"add_time,omitempty"`

					// DealProbability Whether deal probability is disabled or enabled for this pipeline
					DealProbability *bool `json:"deal_probability,omitempty"`

					// Id The ID of the pipeline
					Id *int `json:"id,omitempty"`

					// Name The name of the pipeline
					Name *string `json:"name,omitempty"`

					// OrderNr Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
					OrderNr *int `json:"order_nr,omitempty"`

					// UpdateTime The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
					UpdateTime *string `json:"update_time,omitempty"`

					// UrlTitle The pipeline title displayed in the URL
					UrlTitle *string `json:"url_title,omitempty"`
				} `json:"pipeline,omitempty"`
				Stage *struct {
					// ActiveFlag Whether the stage is active or deleted
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// AddTime The stage creation time. Format: YYYY-MM-DD HH:MM:SS.
					AddTime *string `json:"add_time,omitempty"`

					// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
					DealProbability *int `json:"deal_probability,omitempty"`

					// Id The ID of the stage
					Id *int `json:"id,omitempty"`

					// Name The name of the stage
					Name *string `json:"name,omitempty"`

					// OrderNr Defines the order of the stage
					OrderNr *int `json:"order_nr,omitempty"`

					// PipelineId The ID of the pipeline to add the stage to
					PipelineId *int `json:"pipeline_id,omitempty"`

					// RottenDays The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
					RottenDays *int `json:"rotten_days,omitempty"`

					// RottenFlag Whether deals in this stage can become rotten
					RottenFlag *bool `json:"rotten_flag,omitempty"`

					// UpdateTime The stage update time. Format: YYYY-MM-DD HH:MM:SS.
					UpdateTime *string `json:"update_time,omitempty"`
				} `json:"stage,omitempty"`
				User *struct {
					USERID *struct {
						// ActiveFlag Whether the user is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The email of the user
						Email *string `json:"email,omitempty"`

						// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
						HasPic *int `json:"has_pic,omitempty"`

						// Id The ID of the user
						Id *int `json:"id,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// PicHash The user picture hash
						PicHash *string `json:"pic_hash"`
					} `json:"USER_ID,omitempty"`
				} `json:"user,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationFilesResponse parses an HTTP response from a GetOrganizationFilesWithResponse call
func ParseGetOrganizationFilesResponse(rsp *http.Response) (*GetOrganizationFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of files
			Data *[]struct {
				// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivityId The ID of the activity to associate the file with
				ActivityId *int `json:"activity_id,omitempty"`

				// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// Cid The ID of the inline attachment
				Cid *string `json:"cid,omitempty"`

				// DealId The ID of the deal to associate the file with
				DealId *int `json:"deal_id,omitempty"`

				// DealName The name of the deal associated with the dile
				DealName *string `json:"deal_name,omitempty"`

				// Description The description of the file
				Description *string `json:"description,omitempty"`

				// FileName The original name of the file
				FileName *string `json:"file_name,omitempty"`

				// FileSize The size of the file
				FileSize *int `json:"file_size,omitempty"`

				// Id The ID of the file
				Id *int `json:"id,omitempty"`

				// InlineFlag Whether the file was uploaded as inline or not
				InlineFlag *bool `json:"inline_flag,omitempty"`

				// LeadId The ID of the lead to associate the file with
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// LeadName The name of the lead associated with the file
				LeadName *string `json:"lead_name,omitempty"`

				// MailMessageId The ID of the mail message to associate the file with
				MailMessageId *string `json:"mail_message_id,omitempty"`

				// MailTemplateId The ID of the mail template to associate the file with
				MailTemplateId *string `json:"mail_template_id,omitempty"`

				// Name The visible name of the file
				Name *string `json:"name,omitempty"`

				// OrgId The ID of the organization to associate the file with
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the file
				OrgName *string `json:"org_name,omitempty"`

				// PersonId The ID of the person to associate the file with
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the file
				PersonName *string `json:"person_name,omitempty"`

				// ProductId The ID of the product to associate the file with
				ProductId *int `json:"product_id,omitempty"`

				// ProductName The name of the product associated with the file
				ProductName *string `json:"product_name,omitempty"`

				// RemoteId The ID of the remote item
				RemoteId *string `json:"remote_id,omitempty"`

				// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
				RemoteLocation *string `json:"remote_location,omitempty"`

				// S3Bucket The location of the cloud storage
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// Url The URL of the download file
				Url *string `json:"url,omitempty"`

				// UserId The ID of the user to associate the file with
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationUpdatesResponse parses an HTTP response from a GetOrganizationUpdatesWithResponse call
func ParseGetOrganizationUpdatesResponse(rsp *http.Response) (*GetOrganizationUpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// Data The data related to the update
				Data *map[string]interface{} `json:"data,omitempty"`

				// Object The type of the person update. (Possible object types - organizationChange, dealChange, file, activity)
				Object *string `json:"object,omitempty"`

				// Timestamp The creation date and time of the update
				Timestamp *string `json:"timestamp,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
				User *struct {
					USERID *struct {
						// ActiveFlag Whether the user is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The email of the user
						Email *string `json:"email,omitempty"`

						// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
						HasPic *int `json:"has_pic,omitempty"`

						// Id The ID of the user
						Id *int `json:"id,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// PicHash The user picture hash
						PicHash *string `json:"pic_hash"`
					} `json:"USER_ID,omitempty"`
				} `json:"user,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationMailMessagesResponse parses an HTTP response from a GetOrganizationMailMessagesWithResponse call
func ParseGetOrganizationMailMessagesResponse(rsp *http.Response) (*GetOrganizationMailMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationMailMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of mail messages
			Data *[]struct {
				Data *struct {
					// AccountId The connection account ID
					AccountId *string `json:"account_id,omitempty"`

					// AddTime The insertion into the database time of the mail message
					AddTime *time.Time `json:"add_time,omitempty"`

					// Bcc The array of mail message blind copies (object)
					Bcc *[]struct {
						// EmailAddress Mail address of the mail participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail participant
						Id *int `json:"id,omitempty"`

						// LinkedPersonId ID of the linked person to the mail message
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Name of the linked person to the mail message
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message participant
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// Name Name of the mail participant
						Name *string `json:"name,omitempty"`
					} `json:"bcc,omitempty"`

					// BodyUrl The mail message body URL
					BodyUrl *string `json:"body_url,omitempty"`

					// Cc The array of mail message copies (object)
					Cc *[]struct {
						// EmailAddress Mail address of the mail participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail participant
						Id *int `json:"id,omitempty"`

						// LinkedPersonId ID of the linked person to the mail message
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Name of the linked person to the mail message
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message participant
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// Name Name of the mail participant
						Name *string `json:"name,omitempty"`
					} `json:"cc,omitempty"`

					// CompanyId The ID of the company
					CompanyId *int `json:"company_id,omitempty"`

					// DeletedFlag Whether the mail message is deleted or not
					DeletedFlag *GetOrganizationMailMessages200DataDataDeletedFlag `json:"deleted_flag,omitempty"`

					// Draft If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
					Draft *string `json:"draft,omitempty"`

					// DraftFlag Whether the mail message is a draft or not
					DraftFlag *GetOrganizationMailMessages200DataDataDraftFlag `json:"draft_flag,omitempty"`

					// ExternalDeletedFlag If the Mail Message has been deleted on the provider side or not
					ExternalDeletedFlag *bool `json:"external_deleted_flag,omitempty"`

					// From The array of mail message sender (object)
					From *[]struct {
						// EmailAddress Mail address of the mail participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail participant
						Id *int `json:"id,omitempty"`

						// LinkedPersonId ID of the linked person to the mail message
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Name of the linked person to the mail message
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message participant
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// Name Name of the mail participant
						Name *string `json:"name,omitempty"`
					} `json:"from,omitempty"`

					// HasAttachmentsFlag Whether the mail message has an attachment or not
					HasAttachmentsFlag *GetOrganizationMailMessages200DataDataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

					// HasBodyFlag Whether the mail message has a body or not
					HasBodyFlag *GetOrganizationMailMessages200DataDataHasBodyFlag `json:"has_body_flag,omitempty"`

					// HasInlineAttachmentsFlag Whether the mail message has an inline attachment or not
					HasInlineAttachmentsFlag *GetOrganizationMailMessages200DataDataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

					// HasRealAttachmentsFlag Whether the mail message has an attachment (which is not inline) or not
					HasRealAttachmentsFlag *GetOrganizationMailMessages200DataDataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

					// Id ID of the mail message.
					Id *int `json:"id,omitempty"`

					// ItemType The type of the data item
					ItemType *string `json:"item_type,omitempty"`

					// MailLinkTrackingEnabledFlag Whether the link tracking in mail message body is enabled.
					MailLinkTrackingEnabledFlag *GetOrganizationMailMessages200DataDataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

					// MailThreadId ID of the mail message thread
					MailThreadId *int `json:"mail_thread_id,omitempty"`

					// MailTrackingStatus The status of tracking mail message. Value is `null` if tracking is not enabled.
					MailTrackingStatus *GetOrganizationMailMessages200DataDataMailTrackingStatus `json:"mail_tracking_status"`

					// MessageTime Creation or receival time of the mail message
					MessageTime *time.Time `json:"message_time,omitempty"`

					// MuaMessageId The Mail Message ID assigned by the mail user agent
					MuaMessageId *string `json:"mua_message_id,omitempty"`

					// NylasId The Mail Message ID assigned by the sync provider
					NylasId *string `json:"nylas_id,omitempty"`

					// ReadFlag Whether the mail message is read or not by the user
					ReadFlag *GetOrganizationMailMessages200DataDataReadFlag `json:"read_flag,omitempty"`

					// S3Bucket The name of the S3 bucket
					S3Bucket *string `json:"s3_bucket,omitempty"`

					// S3BucketPath The path of the S3 bucket
					S3BucketPath *string `json:"s3_bucket_path,omitempty"`

					// SentFlag Whether the mail message has been sent or not
					SentFlag *GetOrganizationMailMessages200DataDataSentFlag `json:"sent_flag,omitempty"`

					// SentFromPipedriveFlag Whether the mail message has been sent from Pipedrive app or not
					SentFromPipedriveFlag *GetOrganizationMailMessages200DataDataSentFromPipedriveFlag `json:"sent_from_pipedrive_flag,omitempty"`

					// SmartBccFlag Whether the mail message has been created by Smart Email BCC feature or not
					SmartBccFlag *GetOrganizationMailMessages200DataDataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

					// Snippet The snippet of mail message. Snippet length is up to 225 characters.
					Snippet *string `json:"snippet,omitempty"`

					// Subject The subject of mail message
					Subject *string `json:"subject,omitempty"`

					// SyncedFlag Whether the mail message is synced with the provider or not
					SyncedFlag *GetOrganizationMailMessages200DataDataSyncedFlag `json:"synced_flag,omitempty"`

					// TemplateId The ID of the mail template
					TemplateId *int `json:"template_id,omitempty"`

					// Timestamp The add date and time of the Mail Message
					Timestamp *string `json:"timestamp,omitempty"`

					// To The array of mail message receiver (object)
					To *[]struct {
						// EmailAddress Mail address of the mail participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail participant
						Id *int `json:"id,omitempty"`

						// LinkedPersonId ID of the linked person to the mail message
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Name of the linked person to the mail message
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message participant
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// Name Name of the mail participant
						Name *string `json:"name,omitempty"`
					} `json:"to,omitempty"`

					// UpdateTime The updating time in the database of the mail message
					UpdateTime *time.Time `json:"update_time,omitempty"`

					// UserId ID of the user whom mail message will be assigned to
					UserId *int `json:"user_id,omitempty"`
				} `json:"data,omitempty"`

				// Object The type of the data item
				Object *string `json:"object,omitempty"`

				// Timestamp The date and time when the item was created
				Timestamp *string `json:"timestamp,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMergeOrganizationsResponse parses an HTTP response from a MergeOrganizationsWithResponse call
func ParseMergeOrganizationsResponse(rsp *http.Response) (*MergeOrganizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of the merged organization
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationUsersResponse parses an HTTP response from a GetOrganizationUsersWithResponse call
func ParseGetOrganizationUsersResponse(rsp *http.Response) (*GetOrganizationUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The list of permitted user IDs
			Data *[]float32 `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationPersonsResponse parses an HTTP response from a GetOrganizationPersonsWithResponse call
func ParseGetOrganizationPersonsResponse(rsp *http.Response) (*GetOrganizationPersonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationPersonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of persons
			Data *[]struct {
				// ActiveFlag Whether the person is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivitiesCount The count of activities related to the person
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// CcEmail The BCC email associated with the person
				CcEmail *string `json:"cc_email,omitempty"`

				// ClosedDealsCount The count of closed deals related with the item
				ClosedDealsCount *int `json:"closed_deals_count,omitempty"`

				// CompanyId The ID of the company related to the person
				CompanyId *int `json:"company_id,omitempty"`

				// DoneActivitiesCount The count of done activities related to the person
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" } ]`. Please note that only `value` is required.
				Email *[]struct {
					// Label The label that indicates the type of the email. (Possible values - work, home or other)
					Label *string `json:"label,omitempty"`

					// Primary Boolean that indicates if email is primary for the person or not
					Primary *bool `json:"primary,omitempty"`

					// Value Email
					Value *string `json:"value,omitempty"`
				} `json:"email,omitempty"`

				// EmailMessagesCount The count of email messages related to the person
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// FilesCount The count of files related to the person
				FilesCount *int `json:"files_count,omitempty"`

				// FirstChar The first letter of the name of the person
				FirstChar *string `json:"first_char,omitempty"`

				// FirstName The first name of the person
				FirstName *string `json:"first_name,omitempty"`

				// FollowersCount The count of followers related to the person
				FollowersCount *int `json:"followers_count,omitempty"`

				// Id The ID of the person
				Id *int `json:"id,omitempty"`

				// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
				Label *int `json:"label,omitempty"`

				// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the person
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastName The last name of the person
				LastName *string `json:"last_name,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the person
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostDealsCount The count of lost deals related with the item
				LostDealsCount *int `json:"lost_deals_count,omitempty"`

				// Name The name of the person
				Name *string `json:"name,omitempty"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time"`

				// NotesCount The count of notes related to the person
				NotesCount *int `json:"notes_count,omitempty"`

				// OpenDealsCount The count of open deals related with the item
				OpenDealsCount *int `json:"open_deals_count,omitempty"`
				OrgId          *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the item
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the item
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the item
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the item
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization
					Value *int `json:"value,omitempty"`
				} `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the person
				OrgName *string `json:"org_name,omitempty"`
				OwnerId *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
					HasPic *int `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`

					// Value The ID of the owner
					Value *int `json:"value,omitempty"`
				} `json:"owner_id,omitempty"`

				// OwnerName The name of the owner associated with the person
				OwnerName *string `json:"owner_name,omitempty"`

				// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
				Phone *[]struct {
					// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
					Label *string `json:"label,omitempty"`

					// Primary Boolean that indicates if phone number is primary for the person or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number
					Value *string `json:"value,omitempty"`
				} `json:"phone,omitempty"`
				PictureId *struct {
					// ActiveFlag Whether the associated picture is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// AddTime The add time of the picture
					AddTime *string `json:"add_time,omitempty"`

					// AddedByUserId The ID of the user who added the picture
					AddedByUserId *int `json:"added_by_user_id,omitempty"`

					// Id The ID of the picture associated with the item
					Id *int `json:"id,omitempty"`

					// ItemId The ID of related item
					ItemId *int `json:"item_id,omitempty"`

					// ItemType The type of item the picture is related to
					ItemType *string `json:"item_type,omitempty"`
					Pictures *struct {
						// N128 The URL of the 128*128 picture
						N128 *string `json:"128,omitempty"`

						// N512 The URL of the 512*512 picture
						N512 *string `json:"512,omitempty"`
					} `json:"pictures,omitempty"`

					// UpdateTime The update time of the picture
					UpdateTime *string `json:"update_time,omitempty"`
				} `json:"picture_id,omitempty"`

				// RelatedClosedDealsCount The count of related closed deals related with the item
				RelatedClosedDealsCount *int `json:"related_closed_deals_count,omitempty"`

				// RelatedLostDealsCount The count of related lost deals related with the item
				RelatedLostDealsCount *int `json:"related_lost_deals_count,omitempty"`

				// RelatedOpenDealsCount The count of related open deals related with the item
				RelatedOpenDealsCount *int `json:"related_open_deals_count,omitempty"`

				// RelatedWonDealsCount The count of related won deals related with the item
				RelatedWonDealsCount *int `json:"related_won_deals_count,omitempty"`

				// UndoneActivitiesCount The count of undone activities related to the person
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility group ID of who can see the person
				VisibleTo *string `json:"visible_to,omitempty"`

				// WonDealsCount The count of won deals related with the item
				WonDealsCount *int `json:"won_deals_count,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// ActiveFlag Whether the associated organization is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
				User *struct {
					USERID *struct {
						// ActiveFlag Whether the user is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The email of the user
						Email *string `json:"email,omitempty"`

						// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
						HasPic *int `json:"has_pic,omitempty"`

						// Id The ID of the user
						Id *int `json:"id,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// PicHash The user picture hash
						PicHash *string `json:"pic_hash"`
					} `json:"USER_ID,omitempty"`
				} `json:"user,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPermissionSetsResponse parses an HTTP response from a GetPermissionSetsWithResponse call
func ParseGetPermissionSetsResponse(rsp *http.Response) (*GetPermissionSetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionSetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The array of permission set
			Data *[]struct {
				// App The app that permission set belongs to
				App *GetPermissionSets200DataApp `json:"app,omitempty"`

				// AssignmentCount The number of users assigned to this permission set
				AssignmentCount *int `json:"assignment_count,omitempty"`

				// Description The description of the permission set
				Description *string `json:"description,omitempty"`

				// Id The ID of user permission set
				Id *string `json:"id,omitempty"`

				// Name The name of the permission set
				Name *string `json:"name,omitempty"`

				// Type The type of permission set
				Type *GetPermissionSets200DataType `json:"type,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPermissionSetResponse parses an HTTP response from a GetPermissionSetWithResponse call
func ParseGetPermissionSetResponse(rsp *http.Response) (*GetPermissionSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// App The app that permission set belongs to
			App *GetPermissionSet200App `json:"app,omitempty"`

			// AssignmentCount The number of users assigned to this permission set
			AssignmentCount *int `json:"assignment_count,omitempty"`

			// Contents A permission assigned to this permission set
			Contents *[]string `json:"contents,omitempty"`

			// Description The description of the permission set
			Description *string `json:"description,omitempty"`

			// Id The ID of user permission set
			Id *string `json:"id,omitempty"`

			// Name The name of the permission set
			Name *string `json:"name,omitempty"`

			// Type The type of permission set
			Type *GetPermissionSet200Type `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPermissionSetAssignmentsResponse parses an HTTP response from a GetPermissionSetAssignmentsWithResponse call
func ParseGetPermissionSetAssignmentsResponse(rsp *http.Response) (*GetPermissionSetAssignmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionSetAssignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An array of the assignments of the user
			Data *[]struct {
				// Name The name of the permission set
				Name *string `json:"name,omitempty"`

				// PermissionSetId The ID of the permission set
				PermissionSetId *string `json:"permission_set_id,omitempty"`

				// UserId The ID of the user in the permission set
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeletePersonFieldsResponse parses an HTTP response from a DeletePersonFieldsWithResponse call
func ParseDeletePersonFieldsResponse(rsp *http.Response) (*DeletePersonFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersonFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The list of deleted field IDs
				Id *[]int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePersonsResponse parses an HTTP response from a DeletePersonsWithResponse call
func ParseDeletePersonsResponse(rsp *http.Response) (*DeletePersonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The list of deleted persons IDs
				Id *[]int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonsCollectionResponse parses an HTTP response from a GetPersonsCollectionWithResponse call
func ParseGetPersonsCollectionResponse(rsp *http.Response) (*GetPersonsCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonsCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// ActiveFlag Whether the person is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// CcEmail The BCC email associated with the person
				CcEmail *string `json:"cc_email,omitempty"`

				// DeleteTime The date and time this person was deleted. Format: YYYY-MM-DD HH:MM:SS
				DeleteTime *string `json:"delete_time"`

				// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" }]`. Please note that only `value` is required.
				Email *[]struct {
					// Label The label that indicates the type of the email. (Possible values - work, home or other)
					Label *string `json:"label,omitempty"`

					// Primary Boolean that indicates if email is primary for the person or not
					Primary *bool `json:"primary,omitempty"`

					// Value The email
					Value *string `json:"value,omitempty"`
				} `json:"email,omitempty"`

				// Id The ID of the person
				Id *int `json:"id,omitempty"`

				// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
				Label *int `json:"label"`

				// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
				LabelIds *[]int `json:"label_ids,omitempty"`

				// Name The name of the person
				Name *string `json:"name,omitempty"`

				// OrgId The ID of the organization related to the person
				OrgId *int `json:"org_id,omitempty"`

				// OwnerId The ID of the owner related to the person
				OwnerId *int `json:"owner_id,omitempty"`

				// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
				Phone *[]struct {
					// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
					Label *string `json:"label,omitempty"`

					// Primary Boolean that indicates if phone number is primary for the person or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number
					Value *string `json:"value,omitempty"`
				} `json:"phone,omitempty"`

				// PictureId The ID of the picture associated with the item
				PictureId *int `json:"picture_id"`

				// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility group ID of who can see the person
				VisibleTo *string `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPersonActivitiesResponse parses an HTTP response from a GetPersonActivitiesWithResponse call
func ParseGetPersonActivitiesResponse(rsp *http.Response) (*GetPersonActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// ActivityDistribution The distribution of activities related to the organization grouped by the user ID
				ActivityDistribution *struct {
					// ASSIGNEDTOUSERID The ID of the user
					ASSIGNEDTOUSERID *struct {
						// Activities The count of activities related to the user grouped by activity type
						Activities *struct {
							// ACTIVITYTYPENAME The count of activities related to a specific type
							ACTIVITYTYPENAME *int `json:"ACTIVITY_TYPE_NAME,omitempty"`
						} `json:"activities,omitempty"`

						// ActivityCount The overall count of activities for the user
						ActivityCount *int `json:"activity_count,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// Share The percentage of activities belongs to the user
						Share *int `json:"share,omitempty"`
					} `json:"ASSIGNED_TO_USER_ID,omitempty"`
				} `json:"activity_distribution,omitempty"`

				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of activities
			Data *[]struct {
				// ActiveFlag Whether the activity is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// AssignedToUserId The ID of the user to whom the activity is assigned to. Equal to `user_id`.
				AssignedToUserId *int `json:"assigned_to_user_id,omitempty"`

				// Attendees The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address.
				Attendees *[]map[string]interface{} `json:"attendees"`

				// BusyFlag Marks if the activity is set as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
				BusyFlag *bool `json:"busy_flag,omitempty"`

				// CalendarSyncIncludeContext For activities that sync to an external calendar, this setting indicates if the activity syncs with context (what are the deals, persons, organizations this activity is related to)
				CalendarSyncIncludeContext *string `json:"calendar_sync_include_context,omitempty"`

				// CompanyId The user's company ID
				CompanyId *int `json:"company_id,omitempty"`

				// ConferenceMeetingClient The ID of the Marketplace app, which is connected to this activity
				ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

				// ConferenceMeetingId The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
				ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

				// ConferenceMeetingUrl The link to join the meeting which is associated with this activity
				ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

				// CreatedByUserId The ID of the user who created the activity
				CreatedByUserId *int `json:"created_by_user_id,omitempty"`

				// DealDropboxBcc The BCC email address of the deal
				DealDropboxBcc *string `json:"deal_dropbox_bcc,omitempty"`

				// DealId The ID of the deal this activity is associated with
				DealId *int `json:"deal_id,omitempty"`

				// DealTitle The name of the deal this activity is associated with
				DealTitle *string `json:"deal_title,omitempty"`

				// Done Whether the activity is done or not
				Done *bool `json:"done,omitempty"`

				// DueDate The due date of the activity. Format: YYYY-MM-DD
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// DueTime The due time of the activity in UTC. Format: HH:MM
				DueTime *string `json:"due_time,omitempty"`

				// Duration The duration of the activity. Format: HH:MM
				Duration *string `json:"duration,omitempty"`

				// File The file that is attached to this activity. For example, this can be a reference to an audio note file generated with Pipedrive mobile app.
				File *map[string]interface{} `json:"file,omitempty"`

				// GcalEventId For the activity which syncs to Google calendar, this is the Google event ID. NB! This field is related to old Google calendar sync and will be deprecated soon.
				GcalEventId *string `json:"gcal_event_id,omitempty"`

				// GoogleCalendarEtag The Google calendar API etag (version) that is used for syncing this activity. NB! This field is related to old Google calendar sync and will be deprecated soon.
				GoogleCalendarEtag *string `json:"google_calendar_etag,omitempty"`

				// GoogleCalendarId The Google calendar ID that this activity syncs to. NB! This field is related to old Google calendar sync and will be deprecated soon.
				GoogleCalendarId *string `json:"google_calendar_id,omitempty"`

				// Id The ID of the activity, generated when the activity was created
				Id *int `json:"id,omitempty"`

				// LastNotificationTime The date and time of latest notifications sent about this activity to the participants or the attendees of this activity
				LastNotificationTime *string `json:"last_notification_time,omitempty"`

				// LastNotificationUserId The ID of the user who triggered the sending of the latest notifications about this activity to the participants or the attendees of this activity
				LastNotificationUserId *int `json:"last_notification_user_id,omitempty"`

				// LeadId The ID of the lead in the UUID format this activity is associated with
				LeadId *openapi_types.UUID `json:"lead_id"`

				// Location The address of the activity.
				Location *string `json:"location,omitempty"`

				// LocationAdminAreaLevel1 A subfield of the location field. Indicates state/county.
				LocationAdminAreaLevel1 *string `json:"location_admin_area_level_1,omitempty"`

				// LocationAdminAreaLevel2 A subfield of the location field. Indicates region.
				LocationAdminAreaLevel2 *string `json:"location_admin_area_level_2,omitempty"`

				// LocationCountry A subfield of the location field. Indicates country.
				LocationCountry *string `json:"location_country,omitempty"`

				// LocationFormattedAddress A subfield of the location field. Indicates full/combined address.
				LocationFormattedAddress *string `json:"location_formatted_address,omitempty"`

				// LocationLocality A subfield of the location field. Indicates city/town/village/locality.
				LocationLocality *string `json:"location_locality,omitempty"`

				// LocationPostalCode A subfield of the location field. Indicates ZIP/postal code.
				LocationPostalCode *string `json:"location_postal_code,omitempty"`

				// LocationRoute A subfield of the location field. Indicates street name.
				LocationRoute *string `json:"location_route,omitempty"`

				// LocationStreetNumber A subfield of the location field. Indicates house number.
				LocationStreetNumber *string `json:"location_street_number,omitempty"`

				// LocationSublocality A subfield of the location field. Indicates district/sublocality.
				LocationSublocality *string `json:"location_sublocality,omitempty"`

				// LocationSubpremise A subfield of the location field. Indicates apartment/suite number.
				LocationSubpremise *string `json:"location_subpremise,omitempty"`

				// MarkedAsDoneTime The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// Note The note of the activity (HTML format)
				Note *string `json:"note,omitempty"`

				// NotificationLanguageId The ID of the language the notifications are sent in
				NotificationLanguageId *int `json:"notification_language_id,omitempty"`

				// OrgId The ID of the organization this activity is associated with
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization this activity is associated with
				OrgName *string `json:"org_name,omitempty"`

				// OwnerName The name of the user this activity is owned by
				OwnerName *string `json:"owner_name,omitempty"`

				// Participants List of multiple persons (participants) this activity is associated with
				Participants *[]map[string]interface{} `json:"participants"`

				// PersonDropboxBcc The BCC email address of the person
				PersonDropboxBcc *string `json:"person_dropbox_bcc,omitempty"`

				// PersonId The ID of the person this activity is associated with
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person this activity is associated with
				PersonName *string `json:"person_name,omitempty"`

				// ProjectId The ID of the project this activity is associated with
				ProjectId *int `json:"project_id"`

				// PublicDescription Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
				PublicDescription *string `json:"public_description,omitempty"`

				// RecMasterActivityId The ID of parent activity for a recurrent activity if the current activity is an exception to recurrence rules
				RecMasterActivityId *int `json:"rec_master_activity_id,omitempty"`

				// RecRule The rule for the recurrence of the activity. Is important for activities synced into Pipedrive from an external calendar. Example: "RRULE:FREQ=WEEKLY;BYDAY=WE"
				RecRule *string `json:"rec_rule,omitempty"`

				// RecRuleExtension Additional rules for the recurrence of the activity, extend the `rec_rule`. Is important for activities synced into Pipedrive from an external calendar.
				RecRuleExtension *string `json:"rec_rule_extension,omitempty"`

				// ReferenceId Together with the `reference_type`, gives the ID of the other object
				ReferenceId *int `json:"reference_id,omitempty"`

				// ReferenceType If the activity references some other object, it is indicated here. For example, value `Salesphone` refers to activities created with Caller.
				ReferenceType *string `json:"reference_type,omitempty"`

				// Series The list of recurring activity instances. It is in a structure as follows: `[{due_date: "2020-06-24", due_time: "10:00:00"}]`
				Series *[]map[string]interface{} `json:"series,omitempty"`

				// SourceTimezone The timezone the activity was created in an external calendar
				SourceTimezone *string `json:"source_timezone,omitempty"`

				// Subject The subject of the activity
				Subject *string `json:"subject,omitempty"`

				// Type The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
				Type *string `json:"type,omitempty"`

				// UpdateTime The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`

				// UpdateUserId The ID of the user who was the last to update this activity
				UpdateUserId *int `json:"update_user_id,omitempty"`

				// UserId The ID of the user whom the activity is assigned to
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonChangelogResponse parses an HTTP response from a GetPersonChangelogWithResponse call
func ParseGetPersonChangelogResponse(rsp *http.Response) (*GetPersonChangelogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonChangelogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// ActorUserId The ID of the user who made the change
				ActorUserId *int `json:"actor_user_id,omitempty"`

				// ChangeSource The source of change, for example 'app', 'mobile', 'api', etc.
				ChangeSource *string `json:"change_source"`

				// ChangeSourceUserAgent The user agent from which the change was made
				ChangeSourceUserAgent *string `json:"change_source_user_agent"`

				// FieldKey The key of the field that was changed
				FieldKey *string `json:"field_key,omitempty"`

				// IsBulkUpdateFlag Whether the change was made as part of a bulk update
				IsBulkUpdateFlag *bool `json:"is_bulk_update_flag,omitempty"`

				// NewValue The value of the field after the change
				NewValue *string `json:"new_value"`

				// OldValue The value of the field before the change
				OldValue *string `json:"old_value"`

				// Time The date and time of the change
				Time *string `json:"time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonDealsResponse parses an HTTP response from a GetPersonDealsWithResponse call
func ParseGetPersonDealsResponse(rsp *http.Response) (*GetPersonDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of deals
			Data *[]struct {
				// Active Whether the deal is active or not
				Active *bool `json:"active,omitempty"`

				// ActivitiesCount The number of activities associated with the deal
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AcvCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Contract Value of the deal
				//
				// If the `acv` is null, this will also be null
				AcvCurrency *string `json:"acv_currency"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// ArrCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Recurring Revenue of the deal
				//
				// If the `arr` is null, this will also be null
				ArrCurrency *string `json:"arr_currency"`

				// CcEmail The BCC email of the deal
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// CreatorUserId The creator of the deal
				CreatorUserId *struct {
					// ActiveFlag Whether the creator is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the deal creator
					Email *string `json:"email,omitempty"`

					// HasPic If the creator has a picture or not
					HasPic *bool `json:"has_pic,omitempty"`

					// Id The ID of the deal creator
					Id *int `json:"id,omitempty"`

					// Name The name of the deal creator
					Name *string `json:"name,omitempty"`

					// PicHash The creator picture hash
					PicHash *string `json:"pic_hash"`

					// Value The ID of the deal creator
					Value *int `json:"value,omitempty"`
				} `json:"creator_user_id,omitempty"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// Deleted Whether the deal is deleted or not
				Deleted *bool `json:"deleted,omitempty"`

				// DoneActivitiesCount The number of completed activities associated with the deal
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// EmailMessagesCount The number of emails associated with the deal
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// FilesCount The number of files associated with the deal
				FilesCount *int `json:"files_count,omitempty"`

				// FirstWonTime The date and time of the first time changing the deal status as won
				FirstWonTime *string `json:"first_won_time,omitempty"`

				// FollowersCount The number of followers associated with the deal
				FollowersCount *int `json:"followers_count,omitempty"`

				// FormattedValue The deal value formatted with selected currency. E.g. US$500
				FormattedValue *string `json:"formatted_value,omitempty"`

				// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
				FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// Label The label or multiple labels assigned to the deal
				Label *string `json:"label,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the deal
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// MrrCurrency Only available in Growth and above plans
				//
				// The Currency for Monthly Recurring Revenue of the deal
				//
				// If the `mrr` is null, this will also be null
				MrrCurrency *string `json:"mrr_currency"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date,omitempty"`

				// NextActivityDuration The duration of the next activity associated with the deal
				NextActivityDuration *string `json:"next_activity_duration,omitempty"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityNote The note of the next activity associated with the deal
				NextActivityNote *string `json:"next_activity_note,omitempty"`

				// NextActivitySubject The subject of the next activity associated with the deal
				NextActivitySubject *string `json:"next_activity_subject,omitempty"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time,omitempty"`

				// NextActivityType The type of the next activity associated with the deal
				NextActivityType *string `json:"next_activity_type,omitempty"`

				// NotesCount The number of notes associated with the deal
				NotesCount *int `json:"notes_count,omitempty"`

				// OrgHidden If the organization that is associated with the deal is hidden or not
				OrgHidden *bool `json:"org_hidden,omitempty"`
				OrgId     *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization that is associated with the deal
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the deal
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the deal
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the deal
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the deal
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization associated with the deal
					Value *int `json:"value,omitempty"`
				} `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the deal
				OrgName *string `json:"org_name,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerName The name of the deal owner
				OwnerName *string `json:"owner_name,omitempty"`

				// ParticipantsCount The number of participants associated with the deal
				ParticipantsCount *int `json:"participants_count,omitempty"`

				// PersonHidden If the person that is associated with the deal is hidden or not
				PersonHidden *bool `json:"person_hidden,omitempty"`
				PersonId     *struct {
					// ActiveFlag Whether the associated person is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The emails of the person associated with the deal
					Email *[]struct {
						// Label The type of the email
						Label *string `json:"label,omitempty"`

						// Primary If this is the primary email or not
						Primary *bool `json:"primary,omitempty"`

						// Value The email of the associated person
						Value *string `json:"value,omitempty"`
					} `json:"email,omitempty"`

					// Name The name of the person associated with the deal
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the person that is associated with the deal
					OwnerId *int `json:"owner_id,omitempty"`

					// Phone The phone numbers of the person associated with the deal
					Phone *[]struct {
						// Label The type of the phone number
						Label *string `json:"label,omitempty"`

						// Primary If this is the primary phone number or not
						Primary *bool `json:"primary,omitempty"`

						// Value The phone number of the person associated with the deal
						Value *string `json:"value,omitempty"`
					} `json:"phone,omitempty"`

					// Value The ID of the person associated with the deal
					Value *int `json:"value,omitempty"`
				} `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the deal
				PersonName *string `json:"person_name,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// ProductsCount The number of products associated with the deal
				ProductsCount *int `json:"products_count,omitempty"`

				// RottenTime The date and time of changing the deal status as rotten
				RottenTime *string `json:"rotten_time"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// StageOrderNr The order number of the deal stage associated with the deal
				StageOrderNr *int `json:"stage_order_nr,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UndoneActivitiesCount The number of incomplete activities associated with the deal
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`
				UserId     *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic If the user has a picture or not
					HasPic *bool `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`

					// Value The ID of the user
					Value *int `json:"value,omitempty"`
				} `json:"user_id,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *string `json:"visible_to,omitempty"`

				// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
				WeightedValue *float32 `json:"weighted_value,omitempty"`

				// WeightedValueCurrency The currency associated with the deal
				WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// ActiveFlag Whether the associated organization is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
				Person *struct {
					// PERSONID The ID of the person associated with the item
					PERSONID *struct {
						// ActiveFlag Whether the associated person is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The emails of the person associated with the item
						Email *[]struct {
							// Label The type of the email
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary email or not
							Primary *bool `json:"primary,omitempty"`

							// Value The email of the associated person
							Value *string `json:"value,omitempty"`
						} `json:"email,omitempty"`

						// Id The ID of the person associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the person associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the person that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// Phone The phone numbers of the person associated with the item
						Phone *[]struct {
							// Label The type of the phone number
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary phone number or not
							Primary *bool `json:"primary,omitempty"`

							// Value The phone number of the person associated with the item
							Value *string `json:"value,omitempty"`
						} `json:"phone,omitempty"`
					} `json:"PERSON_ID,omitempty"`
				} `json:"person,omitempty"`
				Pipeline *struct {
					// Active Whether this pipeline will be made inactive (hidden) or active
					Active *bool `json:"active,omitempty"`

					// AddTime The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
					AddTime *string `json:"add_time,omitempty"`

					// DealProbability Whether deal probability is disabled or enabled for this pipeline
					DealProbability *bool `json:"deal_probability,omitempty"`

					// Id The ID of the pipeline
					Id *int `json:"id,omitempty"`

					// Name The name of the pipeline
					Name *string `json:"name,omitempty"`

					// OrderNr Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
					OrderNr *int `json:"order_nr,omitempty"`

					// UpdateTime The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
					UpdateTime *string `json:"update_time,omitempty"`

					// UrlTitle The pipeline title displayed in the URL
					UrlTitle *string `json:"url_title,omitempty"`
				} `json:"pipeline,omitempty"`
				Stage *struct {
					// ActiveFlag Whether the stage is active or deleted
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// AddTime The stage creation time. Format: YYYY-MM-DD HH:MM:SS.
					AddTime *string `json:"add_time,omitempty"`

					// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
					DealProbability *int `json:"deal_probability,omitempty"`

					// Id The ID of the stage
					Id *int `json:"id,omitempty"`

					// Name The name of the stage
					Name *string `json:"name,omitempty"`

					// OrderNr Defines the order of the stage
					OrderNr *int `json:"order_nr,omitempty"`

					// PipelineId The ID of the pipeline to add the stage to
					PipelineId *int `json:"pipeline_id,omitempty"`

					// RottenDays The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
					RottenDays *int `json:"rotten_days,omitempty"`

					// RottenFlag Whether deals in this stage can become rotten
					RottenFlag *bool `json:"rotten_flag,omitempty"`

					// UpdateTime The stage update time. Format: YYYY-MM-DD HH:MM:SS.
					UpdateTime *string `json:"update_time,omitempty"`
				} `json:"stage,omitempty"`
				User *struct {
					USERID *struct {
						// ActiveFlag Whether the user is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The email of the user
						Email *string `json:"email,omitempty"`

						// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
						HasPic *int `json:"has_pic,omitempty"`

						// Id The ID of the user
						Id *int `json:"id,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// PicHash The user picture hash
						PicHash *string `json:"pic_hash"`
					} `json:"USER_ID,omitempty"`
				} `json:"user,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonFilesResponse parses an HTTP response from a GetPersonFilesWithResponse call
func ParseGetPersonFilesResponse(rsp *http.Response) (*GetPersonFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of files
			Data *[]struct {
				// ActiveFlag Whether the user is active or not. false = Not activated, true = Activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivityId The ID of the activity to associate the file with
				ActivityId *int `json:"activity_id,omitempty"`

				// AddTime The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// Cid The ID of the inline attachment
				Cid *string `json:"cid,omitempty"`

				// DealId The ID of the deal to associate the file with
				DealId *int `json:"deal_id,omitempty"`

				// DealName The name of the deal associated with the dile
				DealName *string `json:"deal_name,omitempty"`

				// Description The description of the file
				Description *string `json:"description,omitempty"`

				// FileName The original name of the file
				FileName *string `json:"file_name,omitempty"`

				// FileSize The size of the file
				FileSize *int `json:"file_size,omitempty"`

				// Id The ID of the file
				Id *int `json:"id,omitempty"`

				// InlineFlag Whether the file was uploaded as inline or not
				InlineFlag *bool `json:"inline_flag,omitempty"`

				// LeadId The ID of the lead to associate the file with
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// LeadName The name of the lead associated with the file
				LeadName *string `json:"lead_name,omitempty"`

				// MailMessageId The ID of the mail message to associate the file with
				MailMessageId *string `json:"mail_message_id,omitempty"`

				// MailTemplateId The ID of the mail template to associate the file with
				MailTemplateId *string `json:"mail_template_id,omitempty"`

				// Name The visible name of the file
				Name *string `json:"name,omitempty"`

				// OrgId The ID of the organization to associate the file with
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the file
				OrgName *string `json:"org_name,omitempty"`

				// PersonId The ID of the person to associate the file with
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the file
				PersonName *string `json:"person_name,omitempty"`

				// ProductId The ID of the product to associate the file with
				ProductId *int `json:"product_id,omitempty"`

				// ProductName The name of the product associated with the file
				ProductName *string `json:"product_name,omitempty"`

				// RemoteId The ID of the remote item
				RemoteId *string `json:"remote_id,omitempty"`

				// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
				RemoteLocation *string `json:"remote_location,omitempty"`

				// S3Bucket The location of the cloud storage
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// UpdateTime The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// Url The URL of the download file
				Url *string `json:"url,omitempty"`

				// UserId The ID of the user to associate the file with
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonUpdatesResponse parses an HTTP response from a GetPersonUpdatesWithResponse call
func ParseGetPersonUpdatesResponse(rsp *http.Response) (*GetPersonUpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// Data The data related to the update
				Data *map[string]interface{} `json:"data,omitempty"`

				// Object The type of the person update. (Possible object types - personChange, note, activity, file)
				Object *string `json:"object,omitempty"`

				// Timestamp The creation date and time of the update
				Timestamp *string `json:"timestamp,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Deal *struct {
					// DEALID The ID of the deal which is associated with the item
					DEALID *struct {
						// Currency The currency of the deal value
						Currency *string `json:"currency,omitempty"`

						// Id The ID of the deal associated with the item
						Id *int `json:"id,omitempty"`

						// PipelineId The ID of the pipeline the deal is in
						PipelineId *int `json:"pipeline_id,omitempty"`

						// StageId The ID of the stage the deal is currently at
						StageId *int `json:"stage_id,omitempty"`

						// Status The status of the deal associated with the item
						Status *string `json:"status,omitempty"`

						// Title The title of the deal associated with the item
						Title *string `json:"title,omitempty"`

						// Value The value of the deal that is associated with the item
						Value *float32 `json:"value,omitempty"`
					} `json:"DEAL_ID,omitempty"`
				} `json:"deal,omitempty"`
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
				Person *struct {
					// PERSONID The ID of the person associated with the item
					PERSONID *struct {
						// ActiveFlag Whether the associated person is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The emails of the person associated with the item
						Email *[]struct {
							// Label The type of the email
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary email or not
							Primary *bool `json:"primary,omitempty"`

							// Value The email of the associated person
							Value *string `json:"value,omitempty"`
						} `json:"email,omitempty"`

						// Id The ID of the person associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the person associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the person that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// Phone The phone numbers of the person associated with the item
						Phone *[]struct {
							// Label The type of the phone number
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary phone number or not
							Primary *bool `json:"primary,omitempty"`

							// Value The phone number of the person associated with the item
							Value *string `json:"value,omitempty"`
						} `json:"phone,omitempty"`
					} `json:"PERSON_ID,omitempty"`
				} `json:"person,omitempty"`
				User *struct {
					USERID *struct {
						// ActiveFlag Whether the user is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The email of the user
						Email *string `json:"email,omitempty"`

						// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
						HasPic *int `json:"has_pic,omitempty"`

						// Id The ID of the user
						Id *int `json:"id,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// PicHash The user picture hash
						PicHash *string `json:"pic_hash"`
					} `json:"USER_ID,omitempty"`
				} `json:"user,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonMailMessagesResponse parses an HTTP response from a GetPersonMailMessagesWithResponse call
func ParseGetPersonMailMessagesResponse(rsp *http.Response) (*GetPersonMailMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonMailMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of mail messages
			Data *[]struct {
				Data *struct {
					// AccountId The connection account ID
					AccountId *string `json:"account_id,omitempty"`

					// AddTime The insertion into the database time of the mail message
					AddTime *time.Time `json:"add_time,omitempty"`

					// Bcc The array of mail message blind copies (object)
					Bcc *[]struct {
						// EmailAddress Mail address of the mail participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail participant
						Id *int `json:"id,omitempty"`

						// LinkedPersonId ID of the linked person to the mail message
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Name of the linked person to the mail message
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message participant
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// Name Name of the mail participant
						Name *string `json:"name,omitempty"`
					} `json:"bcc,omitempty"`

					// BodyUrl The mail message body URL
					BodyUrl *string `json:"body_url,omitempty"`

					// Cc The array of mail message copies (object)
					Cc *[]struct {
						// EmailAddress Mail address of the mail participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail participant
						Id *int `json:"id,omitempty"`

						// LinkedPersonId ID of the linked person to the mail message
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Name of the linked person to the mail message
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message participant
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// Name Name of the mail participant
						Name *string `json:"name,omitempty"`
					} `json:"cc,omitempty"`

					// CompanyId The ID of the company
					CompanyId *int `json:"company_id,omitempty"`

					// DeletedFlag Whether the mail message is deleted or not
					DeletedFlag *GetPersonMailMessages200DataDataDeletedFlag `json:"deleted_flag,omitempty"`

					// Draft If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
					Draft *string `json:"draft,omitempty"`

					// DraftFlag Whether the mail message is a draft or not
					DraftFlag *GetPersonMailMessages200DataDataDraftFlag `json:"draft_flag,omitempty"`

					// ExternalDeletedFlag If the Mail Message has been deleted on the provider side or not
					ExternalDeletedFlag *bool `json:"external_deleted_flag,omitempty"`

					// From The array of mail message sender (object)
					From *[]struct {
						// EmailAddress Mail address of the mail participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail participant
						Id *int `json:"id,omitempty"`

						// LinkedPersonId ID of the linked person to the mail message
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Name of the linked person to the mail message
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message participant
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// Name Name of the mail participant
						Name *string `json:"name,omitempty"`
					} `json:"from,omitempty"`

					// HasAttachmentsFlag Whether the mail message has an attachment or not
					HasAttachmentsFlag *GetPersonMailMessages200DataDataHasAttachmentsFlag `json:"has_attachments_flag,omitempty"`

					// HasBodyFlag Whether the mail message has a body or not
					HasBodyFlag *GetPersonMailMessages200DataDataHasBodyFlag `json:"has_body_flag,omitempty"`

					// HasInlineAttachmentsFlag Whether the mail message has an inline attachment or not
					HasInlineAttachmentsFlag *GetPersonMailMessages200DataDataHasInlineAttachmentsFlag `json:"has_inline_attachments_flag,omitempty"`

					// HasRealAttachmentsFlag Whether the mail message has an attachment (which is not inline) or not
					HasRealAttachmentsFlag *GetPersonMailMessages200DataDataHasRealAttachmentsFlag `json:"has_real_attachments_flag,omitempty"`

					// Id ID of the mail message.
					Id *int `json:"id,omitempty"`

					// ItemType The type of the data item
					ItemType *string `json:"item_type,omitempty"`

					// MailLinkTrackingEnabledFlag Whether the link tracking in mail message body is enabled.
					MailLinkTrackingEnabledFlag *GetPersonMailMessages200DataDataMailLinkTrackingEnabledFlag `json:"mail_link_tracking_enabled_flag,omitempty"`

					// MailThreadId ID of the mail message thread
					MailThreadId *int `json:"mail_thread_id,omitempty"`

					// MailTrackingStatus The status of tracking mail message. Value is `null` if tracking is not enabled.
					MailTrackingStatus *GetPersonMailMessages200DataDataMailTrackingStatus `json:"mail_tracking_status"`

					// MessageTime Creation or receival time of the mail message
					MessageTime *time.Time `json:"message_time,omitempty"`

					// MuaMessageId The Mail Message ID assigned by the mail user agent
					MuaMessageId *string `json:"mua_message_id,omitempty"`

					// NylasId The Mail Message ID assigned by the sync provider
					NylasId *string `json:"nylas_id,omitempty"`

					// ReadFlag Whether the mail message is read or not by the user
					ReadFlag *GetPersonMailMessages200DataDataReadFlag `json:"read_flag,omitempty"`

					// S3Bucket The name of the S3 bucket
					S3Bucket *string `json:"s3_bucket,omitempty"`

					// S3BucketPath The path of the S3 bucket
					S3BucketPath *string `json:"s3_bucket_path,omitempty"`

					// SentFlag Whether the mail message has been sent or not
					SentFlag *GetPersonMailMessages200DataDataSentFlag `json:"sent_flag,omitempty"`

					// SentFromPipedriveFlag Whether the mail message has been sent from Pipedrive app or not
					SentFromPipedriveFlag *GetPersonMailMessages200DataDataSentFromPipedriveFlag `json:"sent_from_pipedrive_flag,omitempty"`

					// SmartBccFlag Whether the mail message has been created by Smart Email BCC feature or not
					SmartBccFlag *GetPersonMailMessages200DataDataSmartBccFlag `json:"smart_bcc_flag,omitempty"`

					// Snippet The snippet of mail message. Snippet length is up to 225 characters.
					Snippet *string `json:"snippet,omitempty"`

					// Subject The subject of mail message
					Subject *string `json:"subject,omitempty"`

					// SyncedFlag Whether the mail message is synced with the provider or not
					SyncedFlag *GetPersonMailMessages200DataDataSyncedFlag `json:"synced_flag,omitempty"`

					// TemplateId The ID of the mail template
					TemplateId *int `json:"template_id,omitempty"`

					// Timestamp The add date and time of the Mail Message
					Timestamp *string `json:"timestamp,omitempty"`

					// To The array of mail message receiver (object)
					To *[]struct {
						// EmailAddress Mail address of the mail participant
						EmailAddress *string `json:"email_address,omitempty"`

						// Id ID of the mail participant
						Id *int `json:"id,omitempty"`

						// LinkedPersonId ID of the linked person to the mail message
						LinkedPersonId *int `json:"linked_person_id,omitempty"`

						// LinkedPersonName Name of the linked person to the mail message
						LinkedPersonName *string `json:"linked_person_name,omitempty"`

						// MailMessagePartyId ID of the mail message participant
						MailMessagePartyId *int `json:"mail_message_party_id,omitempty"`

						// Name Name of the mail participant
						Name *string `json:"name,omitempty"`
					} `json:"to,omitempty"`

					// UpdateTime The updating time in the database of the mail message
					UpdateTime *time.Time `json:"update_time,omitempty"`

					// UserId ID of the user whom mail message will be assigned to
					UserId *int `json:"user_id,omitempty"`
				} `json:"data,omitempty"`

				// Object The type of the data item
				Object *string `json:"object,omitempty"`

				// Timestamp The date and time when the item was created
				Timestamp *string `json:"timestamp,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMergePersonsResponse parses an HTTP response from a MergePersonsWithResponse call
func ParseMergePersonsResponse(rsp *http.Response) (*MergePersonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergePersonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Whether the person is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// ActivitiesCount The count of activities related to the person
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// AddTime The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// CcEmail The BCC email associated with the person
				CcEmail *string `json:"cc_email,omitempty"`

				// ClosedDealsCount The count of closed deals related with the item
				ClosedDealsCount *int `json:"closed_deals_count,omitempty"`

				// CompanyId The ID of the company related to the person
				CompanyId *int `json:"company_id,omitempty"`

				// DoneActivitiesCount The count of done activities related to the person
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// Email An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ "value": "mail@example.com", "primary": "true", "label": "main" } ]`. Please note that only `value` is required.
				Email *[]struct {
					// Label The label that indicates the type of the email. (Possible values - work, home or other)
					Label *string `json:"label,omitempty"`

					// Primary Boolean that indicates if email is primary for the person or not
					Primary *bool `json:"primary,omitempty"`

					// Value Email
					Value *string `json:"value,omitempty"`
				} `json:"email,omitempty"`

				// EmailMessagesCount The count of email messages related to the person
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// FilesCount The count of files related to the person
				FilesCount *int `json:"files_count,omitempty"`

				// FirstChar The first letter of the name of the person
				FirstChar *string `json:"first_char,omitempty"`

				// FirstName The first name of the person
				FirstName *string `json:"first_name,omitempty"`

				// FollowersCount The count of followers related to the person
				FollowersCount *int `json:"followers_count,omitempty"`

				// Id The ID of the person
				Id *int `json:"id,omitempty"`

				// Label The label assigned to the person. When the `label` field is updated, the `label_ids` field value will be overwritten by the `label` field value.
				Label *int `json:"label,omitempty"`

				// LabelIds The IDs of labels assigned to the person. When the `label_ids` field is updated, the `label` field value will be set to the first value of the `label_ids` field.
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the person
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastName The last name of the person
				LastName *string `json:"last_name,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the person
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostDealsCount The count of lost deals related with the item
				LostDealsCount *int `json:"lost_deals_count,omitempty"`

				// MergeWhatId The ID of the person with what the main person was merged
				MergeWhatId *int `json:"merge_what_id,omitempty"`

				// Name The name of the person
				Name *string `json:"name,omitempty"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time"`

				// NotesCount The count of notes related to the person
				NotesCount *int `json:"notes_count,omitempty"`

				// OpenDealsCount The count of open deals related with the item
				OpenDealsCount *int `json:"open_deals_count,omitempty"`

				// OrgId The ID of the organization related to the person
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the person
				OrgName *string `json:"org_name,omitempty"`

				// OwnerId The ID of the owner related to the person
				OwnerId *int `json:"owner_id,omitempty"`

				// OwnerName The name of the owner associated with the person
				OwnerName *string `json:"owner_name,omitempty"`

				// ParticipantClosedDealsCount The count of closed participant deals related with the item
				ParticipantClosedDealsCount *int `json:"participant_closed_deals_count,omitempty"`

				// ParticipantOpenDealsCount The count of open participant deals related with the item
				ParticipantOpenDealsCount *int `json:"participant_open_deals_count,omitempty"`

				// Phone A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ "value": "12345", "primary": "true", "label": "mobile" }]`. Please note that only `value` is required.
				Phone *[]struct {
					// Label The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
					Label *string `json:"label,omitempty"`

					// Primary Boolean that indicates if phone number is primary for the person or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number
					Value *string `json:"value,omitempty"`
				} `json:"phone,omitempty"`
				PictureId *struct {
					// ActiveFlag Whether the associated picture is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// AddTime The add time of the picture
					AddTime *string `json:"add_time,omitempty"`

					// AddedByUserId The ID of the user who added the picture
					AddedByUserId *int `json:"added_by_user_id,omitempty"`

					// Id The ID of the picture associated with the item
					Id *int `json:"id,omitempty"`

					// ItemId The ID of related item
					ItemId *int `json:"item_id,omitempty"`

					// ItemType The type of item the picture is related to
					ItemType *string `json:"item_type,omitempty"`
					Pictures *struct {
						// N128 The URL of the 128*128 picture
						N128 *string `json:"128,omitempty"`

						// N512 The URL of the 512*512 picture
						N512 *string `json:"512,omitempty"`
					} `json:"pictures,omitempty"`

					// UpdateTime The update time of the picture
					UpdateTime *string `json:"update_time,omitempty"`
				} `json:"picture_id,omitempty"`

				// RelatedClosedDealsCount The count of related closed deals related with the item
				RelatedClosedDealsCount *int `json:"related_closed_deals_count,omitempty"`

				// RelatedLostDealsCount The count of related lost deals related with the item
				RelatedLostDealsCount *int `json:"related_lost_deals_count,omitempty"`

				// RelatedOpenDealsCount The count of related open deals related with the item
				RelatedOpenDealsCount *int `json:"related_open_deals_count,omitempty"`

				// RelatedWonDealsCount The count of related won deals related with the item
				RelatedWonDealsCount *int `json:"related_won_deals_count,omitempty"`

				// UndoneActivitiesCount The count of undone activities related to the person
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility group ID of who can see the person
				VisibleTo *string `json:"visible_to,omitempty"`

				// WonDealsCount The count of won deals related with the item
				WonDealsCount *int `json:"won_deals_count,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonUsersResponse parses an HTTP response from a GetPersonUsersWithResponse call
func ParseGetPersonUsersResponse(rsp *http.Response) (*GetPersonUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The list of permitted user IDs
			Data *[]float32 `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePersonPictureResponse parses an HTTP response from a DeletePersonPictureWithResponse call
func ParseDeletePersonPictureResponse(rsp *http.Response) (*DeletePersonPictureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersonPictureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of the deleted person
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddPersonPictureResponse parses an HTTP response from a AddPersonPictureWithResponse call
func ParseAddPersonPictureResponse(rsp *http.Response) (*AddPersonPictureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPersonPictureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The picture that is associated with the item
			Data *struct {
				// PICTUREID The ID of the picture
				PICTUREID *struct {
					// ActiveFlag Whether the associated picture is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// AddTime The add time of the picture
					AddTime *string `json:"add_time,omitempty"`

					// AddedByUserId The ID of the user who added the picture
					AddedByUserId *int `json:"added_by_user_id,omitempty"`

					// Id The ID of the picture associated with the item
					Id *int `json:"id,omitempty"`

					// ItemId The ID of related item
					ItemId *int `json:"item_id,omitempty"`

					// ItemType The type of item the picture is related to
					ItemType *string `json:"item_type,omitempty"`
					Pictures *struct {
						// N128 The URL of the 128*128 picture
						N128 *string `json:"128,omitempty"`

						// N512 The URL of the 512*512 picture
						N512 *string `json:"512,omitempty"`
					} `json:"pictures,omitempty"`

					// UpdateTime The update time of the picture
					UpdateTime *string `json:"update_time,omitempty"`
				} `json:"PICTURE_ID,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonProductsResponse parses an HTTP response from a GetPersonProductsWithResponse call
func ParseGetPersonProductsResponse(rsp *http.Response) (*GetPersonProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// Pagination Pagination details of the list
				Pagination *struct {
					// Limit Items shown per page
					Limit *int `json:"limit,omitempty"`

					// MoreItemsInCollection Whether there are more list items in the collection than displayed
					MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

					// NextStart Next pagination start
					NextStart *int `json:"next_start,omitempty"`

					// Start Pagination start
					Start *int `json:"start,omitempty"`
				} `json:"pagination,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of deal products
			Data *[]struct {
				DEALID *struct {
					Deal *struct {
						// Active Whether the deal is active or not
						Active *bool `json:"active,omitempty"`

						// ActivitiesCount The number of activities associated with the deal
						ActivitiesCount *int `json:"activities_count,omitempty"`

						// AddTime The creation date and time of the deal
						AddTime *string `json:"add_time,omitempty"`

						// CloseTime The date and time of closing the deal
						CloseTime *string `json:"close_time"`

						// CompanyId The ID of the company
						CompanyId *int `json:"company_id,omitempty"`

						// CreatorUserId The ID of the deal creator
						CreatorUserId *int `json:"creator_user_id,omitempty"`

						// Currency The currency associated with the deal
						Currency *string `json:"currency,omitempty"`

						// Deleted Whether the deal is deleted or not
						Deleted *bool `json:"deleted,omitempty"`

						// DoneActivitiesCount The number of completed activities associated with the deal
						DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

						// EmailMessagesCount The number of emails associated with the deal
						EmailMessagesCount *int `json:"email_messages_count,omitempty"`

						// ExpectedCloseDate The expected close date of the deal
						ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

						// FilesCount The number of files associated with the deal
						FilesCount *int `json:"files_count,omitempty"`

						// FirstAddTime The first creation date and time of the deal
						FirstAddTime *string `json:"first_add_time,omitempty"`

						// FirstWonTime The date and time of the first time changing the deal status as won
						FirstWonTime *string `json:"first_won_time,omitempty"`

						// FollowersCount The number of followers associated with the deal
						FollowersCount *int `json:"followers_count,omitempty"`

						// Id The ID of the deal
						Id *int `json:"id,omitempty"`

						// Label The label or multiple labels assigned to the deal
						Label *string `json:"label,omitempty"`

						// LastActivityDate The date of the last activity associated with the deal
						LastActivityDate *string `json:"last_activity_date"`

						// LastActivityId The ID of the last activity associated with the deal
						LastActivityId *int `json:"last_activity_id"`

						// LastIncomingMailTime The date and time of the last incoming email associated with the deal
						LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

						// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
						LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

						// LostReason The reason for losing the deal
						LostReason *string `json:"lost_reason"`

						// LostTime The date and time of changing the deal status as lost
						LostTime *string `json:"lost_time,omitempty"`

						// NextActivityDate The date of the next activity associated with the deal
						NextActivityDate *string `json:"next_activity_date,omitempty"`

						// NextActivityId The ID of the next activity associated with the deal
						NextActivityId *int `json:"next_activity_id"`

						// NextActivityTime The time of the next activity associated with the deal
						NextActivityTime *string `json:"next_activity_time,omitempty"`

						// NotesCount The number of notes associated with the deal
						NotesCount *int `json:"notes_count,omitempty"`

						// OrgId The ID of the organization associated with the deal
						OrgId *int `json:"org_id,omitempty"`

						// ParticipantsCount The number of participants associated with the deal
						ParticipantsCount *int `json:"participants_count,omitempty"`

						// PersonId The ID of the person associated with the deal
						PersonId *int `json:"person_id,omitempty"`

						// PipelineId The ID of the pipeline associated with the deal
						PipelineId *int `json:"pipeline_id,omitempty"`

						// Probability The success probability percentage of the deal
						Probability *float32 `json:"probability"`

						// ProductsCount The number of products associated with the deal
						ProductsCount *int `json:"products_count,omitempty"`

						// StageChangeTime The last updated date and time of the deal stage
						StageChangeTime *string `json:"stage_change_time,omitempty"`

						// StageId The ID of the deal stage
						StageId *int `json:"stage_id,omitempty"`

						// Status The status of the deal
						Status *string `json:"status,omitempty"`

						// Title The title of the deal
						Title *string `json:"title,omitempty"`

						// UndoneActivitiesCount The number of incomplete activities associated with the deal
						UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

						// UpdateTime The last updated date and time of the deal
						UpdateTime *string `json:"update_time,omitempty"`

						// UserId The ID of the user
						UserId *int `json:"user_id,omitempty"`

						// Value The value of the deal
						Value *float32 `json:"value,omitempty"`

						// VisibleTo The visibility of the deal
						VisibleTo *string `json:"visible_to,omitempty"`

						// WonTime The date and time of changing the deal status as won
						WonTime *string `json:"won_time,omitempty"`
					} `json:"deal,omitempty"`
					Product *struct {
						// ActiveFlag Whether this product will be made active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// AddTime The date and time when the product was added to the deal
						AddTime *string `json:"add_time,omitempty"`

						// Category The category of the product
						Category *string `json:"category,omitempty"`

						// Code The product code
						Code *string `json:"code,omitempty"`

						// CompanyId The ID of the company
						CompanyId *int `json:"company_id,omitempty"`

						// DealId The ID of the deal
						DealId *int `json:"deal_id,omitempty"`

						// Description The description of the product
						Description *string `json:"description,omitempty"`

						// FilesCount The count of files
						FilesCount *int `json:"files_count,omitempty"`

						// FirstChar The first letter of the product name
						FirstChar *string `json:"first_char,omitempty"`

						// Id The ID of the product
						Id *int `json:"id,omitempty"`

						// Name The name of the product
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used
						OwnerId *int `json:"owner_id,omitempty"`

						// Selectable Whether this product can be selected in deals or not
						Selectable *bool `json:"selectable,omitempty"`

						// Tax The tax percentage
						Tax *float32 `json:"tax,omitempty"`

						// Unit The unit in which this product is sold
						Unit *string `json:"unit,omitempty"`

						// UpdateTime The date and time when the product was updated to the deal
						UpdateTime *string `json:"update_time,omitempty"`

						// VisibleTo The visibility of the product. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
						VisibleTo *GetPersonProducts200DataDEALIDProductVisibleTo `json:"visible_to,omitempty"`
					} `json:"product,omitempty"`
				} `json:"DEAL_ID,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPipelineConversionStatisticsResponse parses an HTTP response from a GetPipelineConversionStatisticsWithResponse call
func ParseGetPipelineConversionStatisticsResponse(rsp *http.Response) (*GetPipelineConversionStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineConversionStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The pipeline object
			Data *struct {
				// LostConversion The lost conversion
				LostConversion *int `json:"lost_conversion,omitempty"`

				// StageConversions The stage conversions
				StageConversions *[]struct {
					// ConversionRate The conversion rate
					ConversionRate *int `json:"conversion_rate,omitempty"`

					// FromStageId The stage ID from where conversion starts
					FromStageId *int `json:"from_stage_id,omitempty"`

					// ToStageId The stage ID to where conversion ends
					ToStageId *int `json:"to_stage_id,omitempty"`
				} `json:"stage_conversions,omitempty"`

				// WonConversion The won conversion
				WonConversion *int `json:"won_conversion,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPipelineDealsResponse parses an HTTP response from a GetPipelineDealsWithResponse call
func ParseGetPipelineDealsResponse(rsp *http.Response) (*GetPipelineDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of deals
			Data *[]struct {
				// Active Whether the deal is active or not
				Active *bool `json:"active,omitempty"`

				// ActivitiesCount The number of activities associated with the deal
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AcvCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Contract Value of the deal
				//
				// If the `acv` is null, this will also be null
				AcvCurrency *string `json:"acv_currency"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// ArrCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Recurring Revenue of the deal
				//
				// If the `arr` is null, this will also be null
				ArrCurrency *string `json:"arr_currency"`

				// CcEmail The BCC email of the deal
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// CreatorUserId The ID of the deal creator
				CreatorUserId *int `json:"creator_user_id,omitempty"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// Deleted Whether the deal is deleted or not
				Deleted *bool `json:"deleted,omitempty"`

				// DoneActivitiesCount The number of completed activities associated with the deal
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// EmailMessagesCount The number of emails associated with the deal
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// FilesCount The number of files associated with the deal
				FilesCount *int `json:"files_count,omitempty"`

				// FirstWonTime The date and time of the first time changing the deal status as won
				FirstWonTime *string `json:"first_won_time,omitempty"`

				// FollowersCount The number of followers associated with the deal
				FollowersCount *int `json:"followers_count,omitempty"`

				// FormattedValue The deal value formatted with selected currency. E.g. US$500
				FormattedValue *string `json:"formatted_value,omitempty"`

				// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
				FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// Label The label or multiple labels assigned to the deal
				Label *string `json:"label,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the deal
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// MrrCurrency Only available in Growth and above plans
				//
				// The Currency for Monthly Recurring Revenue of the deal
				//
				// If the `mrr` is null, this will also be null
				MrrCurrency *string `json:"mrr_currency"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date,omitempty"`

				// NextActivityDuration The duration of the next activity associated with the deal
				NextActivityDuration *string `json:"next_activity_duration,omitempty"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityNote The note of the next activity associated with the deal
				NextActivityNote *string `json:"next_activity_note,omitempty"`

				// NextActivitySubject The subject of the next activity associated with the deal
				NextActivitySubject *string `json:"next_activity_subject,omitempty"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time,omitempty"`

				// NextActivityType The type of the next activity associated with the deal
				NextActivityType *string `json:"next_activity_type,omitempty"`

				// NotesCount The number of notes associated with the deal
				NotesCount *int `json:"notes_count,omitempty"`

				// OrgHidden If the organization that is associated with the deal is hidden or not
				OrgHidden *bool `json:"org_hidden,omitempty"`

				// OrgId The ID of the organization associated with the deal
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the deal
				OrgName *string `json:"org_name,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerName The name of the deal owner
				OwnerName *string `json:"owner_name,omitempty"`

				// ParticipantsCount The number of participants associated with the deal
				ParticipantsCount *int `json:"participants_count,omitempty"`

				// PersonHidden If the person that is associated with the deal is hidden or not
				PersonHidden *bool `json:"person_hidden,omitempty"`

				// PersonId The ID of the person associated with the deal
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the deal
				PersonName *string `json:"person_name,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// ProductsCount The number of products associated with the deal
				ProductsCount *int `json:"products_count,omitempty"`

				// RottenTime The date and time of changing the deal status as rotten
				RottenTime *string `json:"rotten_time"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// StageOrderNr The order number of the deal stage associated with the deal
				StageOrderNr *int `json:"stage_order_nr,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UndoneActivitiesCount The number of incomplete activities associated with the deal
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`

				// UserId The ID of the user
				UserId *int `json:"user_id,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *string `json:"visible_to,omitempty"`

				// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
				WeightedValue *float32 `json:"weighted_value,omitempty"`

				// WeightedValueCurrency The currency associated with the deal
				WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPipelineMovementStatisticsResponse parses an HTTP response from a GetPipelineMovementStatisticsWithResponse call
func ParseGetPipelineMovementStatisticsResponse(rsp *http.Response) (*GetPipelineMovementStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineMovementStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The pipeline object
			Data *struct {
				// AverageAgeInDays The moved deals average age in days
				AverageAgeInDays *struct {
					// AcrossAllStages The moved deals average age across all stages
					AcrossAllStages *int `json:"across_all_stages,omitempty"`

					// ByStages The moved deals average age by stages
					ByStages *[]struct {
						// StageId The stage ID
						StageId *int `json:"stage_id,omitempty"`

						// Value The average deals age in specific stage
						Value *int `json:"value,omitempty"`
					} `json:"by_stages,omitempty"`
				} `json:"average_age_in_days,omitempty"`

				// DealsLeftOpen Deals summary
				DealsLeftOpen *struct {
					// Count The count of the deals
					Count *int `json:"count,omitempty"`

					// DealsIds The IDs of the deals that have been moved
					DealsIds *[]int `json:"deals_ids,omitempty"`

					// FormattedValues The formatted values of the deals
					FormattedValues *struct {
						// CURRENCYID The formatted values of the deals
						CURRENCYID *string `json:"CURRENCY_ID,omitempty"`
					} `json:"formatted_values,omitempty"`

					// Values The values of the deals
					Values *struct {
						// CURRENCYID The value of the deals
						CURRENCYID *int `json:"CURRENCY_ID,omitempty"`
					} `json:"values,omitempty"`
				} `json:"deals_left_open,omitempty"`

				// LostDeals Deals summary
				LostDeals *struct {
					// Count The count of the deals
					Count *int `json:"count,omitempty"`

					// DealsIds The IDs of the deals that have been moved
					DealsIds *[]int `json:"deals_ids,omitempty"`

					// FormattedValues The formatted values of the deals
					FormattedValues *struct {
						// CURRENCYID The formatted values of the deals
						CURRENCYID *string `json:"CURRENCY_ID,omitempty"`
					} `json:"formatted_values,omitempty"`

					// Values The values of the deals
					Values *struct {
						// CURRENCYID The value of the deals
						CURRENCYID *int `json:"CURRENCY_ID,omitempty"`
					} `json:"values,omitempty"`
				} `json:"lost_deals,omitempty"`

				// MovementsBetweenStages Movements between stages
				MovementsBetweenStages *struct {
					// Count The count of the deals that have been moved between stages
					Count *int `json:"count,omitempty"`
				} `json:"movements_between_stages,omitempty"`

				// NewDeals Deals summary
				NewDeals *struct {
					// Count The count of the deals
					Count *int `json:"count,omitempty"`

					// DealsIds The IDs of the deals that have been moved
					DealsIds *[]int `json:"deals_ids,omitempty"`

					// FormattedValues The formatted values of the deals
					FormattedValues *struct {
						// CURRENCYID The formatted values of the deals
						CURRENCYID *string `json:"CURRENCY_ID,omitempty"`
					} `json:"formatted_values,omitempty"`

					// Values The values of the deals
					Values *struct {
						// CURRENCYID The value of the deals
						CURRENCYID *int `json:"CURRENCY_ID,omitempty"`
					} `json:"values,omitempty"`
				} `json:"new_deals,omitempty"`

				// WonDeals Deals summary
				WonDeals *struct {
					// Count The count of the deals
					Count *int `json:"count,omitempty"`

					// DealsIds The IDs of the deals that have been moved
					DealsIds *[]int `json:"deals_ids,omitempty"`

					// FormattedValues The formatted values of the deals
					FormattedValues *struct {
						// CURRENCYID The formatted values of the deals
						CURRENCYID *string `json:"CURRENCY_ID,omitempty"`
					} `json:"formatted_values,omitempty"`

					// Values The values of the deals
					Values *struct {
						// CURRENCYID The value of the deals
						CURRENCYID *int `json:"CURRENCY_ID,omitempty"`
					} `json:"values,omitempty"`
				} `json:"won_deals,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProductFieldsResponse parses an HTTP response from a DeleteProductFieldsWithResponse call
func ParseDeleteProductFieldsResponse(rsp *http.Response) (*DeleteProductFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id Array of all the IDs of the deleted product fields
				Id *[]int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProductDealsResponse parses an HTTP response from a GetProductDealsWithResponse call
func ParseGetProductDealsResponse(rsp *http.Response) (*GetProductDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of deals
			Data *[]struct {
				// Active Whether the deal is active or not
				Active *bool `json:"active,omitempty"`

				// ActivitiesCount The number of activities associated with the deal
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AcvCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Contract Value of the deal
				//
				// If the `acv` is null, this will also be null
				AcvCurrency *string `json:"acv_currency"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// ArrCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Recurring Revenue of the deal
				//
				// If the `arr` is null, this will also be null
				ArrCurrency *string `json:"arr_currency"`

				// CcEmail The BCC email of the deal
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// CreatorUserId The creator of the deal
				CreatorUserId *struct {
					// ActiveFlag Whether the creator is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the deal creator
					Email *string `json:"email,omitempty"`

					// HasPic If the creator has a picture or not
					HasPic *bool `json:"has_pic,omitempty"`

					// Id The ID of the deal creator
					Id *int `json:"id,omitempty"`

					// Name The name of the deal creator
					Name *string `json:"name,omitempty"`

					// PicHash The creator picture hash
					PicHash *string `json:"pic_hash"`

					// Value The ID of the deal creator
					Value *int `json:"value,omitempty"`
				} `json:"creator_user_id,omitempty"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// Deleted Whether the deal is deleted or not
				Deleted *bool `json:"deleted,omitempty"`

				// DoneActivitiesCount The number of completed activities associated with the deal
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// EmailMessagesCount The number of emails associated with the deal
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// FilesCount The number of files associated with the deal
				FilesCount *int `json:"files_count,omitempty"`

				// FirstWonTime The date and time of the first time changing the deal status as won
				FirstWonTime *string `json:"first_won_time,omitempty"`

				// FollowersCount The number of followers associated with the deal
				FollowersCount *int `json:"followers_count,omitempty"`

				// FormattedValue The deal value formatted with selected currency. E.g. US$500
				FormattedValue *string `json:"formatted_value,omitempty"`

				// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
				FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// Label The label or multiple labels assigned to the deal
				Label *string `json:"label,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the deal
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// MrrCurrency Only available in Growth and above plans
				//
				// The Currency for Monthly Recurring Revenue of the deal
				//
				// If the `mrr` is null, this will also be null
				MrrCurrency *string `json:"mrr_currency"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date,omitempty"`

				// NextActivityDuration The duration of the next activity associated with the deal
				NextActivityDuration *string `json:"next_activity_duration,omitempty"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityNote The note of the next activity associated with the deal
				NextActivityNote *string `json:"next_activity_note,omitempty"`

				// NextActivitySubject The subject of the next activity associated with the deal
				NextActivitySubject *string `json:"next_activity_subject,omitempty"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time,omitempty"`

				// NextActivityType The type of the next activity associated with the deal
				NextActivityType *string `json:"next_activity_type,omitempty"`

				// NotesCount The number of notes associated with the deal
				NotesCount *int `json:"notes_count,omitempty"`

				// OrgHidden If the organization that is associated with the deal is hidden or not
				OrgHidden *bool `json:"org_hidden,omitempty"`
				OrgId     *struct {
					// ActiveFlag Whether the associated organization is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Address The address of the organization that is associated with the deal
					Address *string `json:"address,omitempty"`

					// CcEmail The BCC email of the organization associated with the deal
					CcEmail *string `json:"cc_email,omitempty"`

					// Name The name of the organization associated with the deal
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the organization that is associated with the deal
					OwnerId *int `json:"owner_id,omitempty"`

					// PeopleCount The number of people connected with the organization that is associated with the deal
					PeopleCount *int `json:"people_count,omitempty"`

					// Value The ID of the organization associated with the deal
					Value *int `json:"value,omitempty"`
				} `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the deal
				OrgName *string `json:"org_name,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerName The name of the deal owner
				OwnerName *string `json:"owner_name,omitempty"`

				// ParticipantsCount The number of participants associated with the deal
				ParticipantsCount *int `json:"participants_count,omitempty"`

				// PersonHidden If the person that is associated with the deal is hidden or not
				PersonHidden *bool `json:"person_hidden,omitempty"`
				PersonId     *struct {
					// ActiveFlag Whether the associated person is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The emails of the person associated with the deal
					Email *[]struct {
						// Label The type of the email
						Label *string `json:"label,omitempty"`

						// Primary If this is the primary email or not
						Primary *bool `json:"primary,omitempty"`

						// Value The email of the associated person
						Value *string `json:"value,omitempty"`
					} `json:"email,omitempty"`

					// Name The name of the person associated with the deal
					Name *string `json:"name,omitempty"`

					// OwnerId The ID of the owner of the person that is associated with the deal
					OwnerId *int `json:"owner_id,omitempty"`

					// Phone The phone numbers of the person associated with the deal
					Phone *[]struct {
						// Label The type of the phone number
						Label *string `json:"label,omitempty"`

						// Primary If this is the primary phone number or not
						Primary *bool `json:"primary,omitempty"`

						// Value The phone number of the person associated with the deal
						Value *string `json:"value,omitempty"`
					} `json:"phone,omitempty"`

					// Value The ID of the person associated with the deal
					Value *int `json:"value,omitempty"`
				} `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the deal
				PersonName *string `json:"person_name,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// ProductsCount The number of products associated with the deal
				ProductsCount *int `json:"products_count,omitempty"`

				// RottenTime The date and time of changing the deal status as rotten
				RottenTime *string `json:"rotten_time"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// StageOrderNr The order number of the deal stage associated with the deal
				StageOrderNr *int `json:"stage_order_nr,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UndoneActivitiesCount The number of incomplete activities associated with the deal
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`
				UserId     *struct {
					// ActiveFlag Whether the user is active or not
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// Email The email of the user
					Email *string `json:"email,omitempty"`

					// HasPic If the user has a picture or not
					HasPic *bool `json:"has_pic,omitempty"`

					// Id The ID of the user
					Id *int `json:"id,omitempty"`

					// Name The name of the user
					Name *string `json:"name,omitempty"`

					// PicHash The user picture hash
					PicHash *string `json:"pic_hash"`

					// Value The ID of the user
					Value *int `json:"value,omitempty"`
				} `json:"user_id,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *string `json:"visible_to,omitempty"`

				// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
				WeightedValue *float32 `json:"weighted_value,omitempty"`

				// WeightedValueCurrency The currency associated with the deal
				WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`
			RelatedObjects *struct {
				Organization *struct {
					// ORGANIZATIONID The ID of the organization associated with the item
					ORGANIZATIONID *struct {
						// ActiveFlag Whether the associated organization is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CcEmail The BCC email of the organization associated with the item
						CcEmail *string `json:"cc_email,omitempty"`

						// Id The ID of the organization associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the organization associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the organization that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// PeopleCount The number of people connected with the organization that is associated with the item
						PeopleCount *int `json:"people_count,omitempty"`
					} `json:"ORGANIZATION_ID,omitempty"`
				} `json:"organization,omitempty"`
				Person *struct {
					// PERSONID The ID of the person associated with the item
					PERSONID *struct {
						// ActiveFlag Whether the associated person is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The emails of the person associated with the item
						Email *[]struct {
							// Label The type of the email
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary email or not
							Primary *bool `json:"primary,omitempty"`

							// Value The email of the associated person
							Value *string `json:"value,omitempty"`
						} `json:"email,omitempty"`

						// Id The ID of the person associated with the item
						Id *int `json:"id,omitempty"`

						// Name The name of the person associated with the item
						Name *string `json:"name,omitempty"`

						// OwnerId The ID of the owner of the person that is associated with the item
						OwnerId *int `json:"owner_id,omitempty"`

						// Phone The phone numbers of the person associated with the item
						Phone *[]struct {
							// Label The type of the phone number
							Label *string `json:"label,omitempty"`

							// Primary Whether this is the primary phone number or not
							Primary *bool `json:"primary,omitempty"`

							// Value The phone number of the person associated with the item
							Value *string `json:"value,omitempty"`
						} `json:"phone,omitempty"`
					} `json:"PERSON_ID,omitempty"`
				} `json:"person,omitempty"`
				Pipeline *struct {
					// Active Whether this pipeline will be made inactive (hidden) or active
					Active *bool `json:"active,omitempty"`

					// AddTime The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
					AddTime *string `json:"add_time,omitempty"`

					// DealProbability Whether deal probability is disabled or enabled for this pipeline
					DealProbability *bool `json:"deal_probability,omitempty"`

					// Id The ID of the pipeline
					Id *int `json:"id,omitempty"`

					// Name The name of the pipeline
					Name *string `json:"name,omitempty"`

					// OrderNr Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
					OrderNr *int `json:"order_nr,omitempty"`

					// UpdateTime The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
					UpdateTime *string `json:"update_time,omitempty"`

					// UrlTitle The pipeline title displayed in the URL
					UrlTitle *string `json:"url_title,omitempty"`
				} `json:"pipeline,omitempty"`
				Stage *struct {
					// ActiveFlag Whether the stage is active or deleted
					ActiveFlag *bool `json:"active_flag,omitempty"`

					// AddTime The stage creation time. Format: YYYY-MM-DD HH:MM:SS.
					AddTime *string `json:"add_time,omitempty"`

					// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
					DealProbability *int `json:"deal_probability,omitempty"`

					// Id The ID of the stage
					Id *int `json:"id,omitempty"`

					// Name The name of the stage
					Name *string `json:"name,omitempty"`

					// OrderNr Defines the order of the stage
					OrderNr *int `json:"order_nr,omitempty"`

					// PipelineId The ID of the pipeline to add the stage to
					PipelineId *int `json:"pipeline_id,omitempty"`

					// RottenDays The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
					RottenDays *int `json:"rotten_days,omitempty"`

					// RottenFlag Whether deals in this stage can become rotten
					RottenFlag *bool `json:"rotten_flag,omitempty"`

					// UpdateTime The stage update time. Format: YYYY-MM-DD HH:MM:SS.
					UpdateTime *string `json:"update_time,omitempty"`
				} `json:"stage,omitempty"`
				User *struct {
					USERID *struct {
						// ActiveFlag Whether the user is active or not
						ActiveFlag *bool `json:"active_flag,omitempty"`

						// Email The email of the user
						Email *string `json:"email,omitempty"`

						// HasPic Whether the user has picture or not. 0 = No picture, 1 = Has picture.
						HasPic *int `json:"has_pic,omitempty"`

						// Id The ID of the user
						Id *int `json:"id,omitempty"`

						// Name The name of the user
						Name *string `json:"name,omitempty"`

						// PicHash The user picture hash
						PicHash *string `json:"pic_hash"`
					} `json:"USER_ID,omitempty"`
				} `json:"user,omitempty"`
			} `json:"related_objects,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProductFilesResponse parses an HTTP response from a GetProductFilesWithResponse call
func ParseGetProductFilesResponse(rsp *http.Response) (*GetProductFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of files
			Data *[]struct {
				// ActiveFlag Whether the user is active or not.
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The UTC date time when the file was uploaded. Format: YYYY-MM-DD HH:MM:SS
				AddTime *string `json:"add_time,omitempty"`

				// Description The description of the file
				Description *string `json:"description,omitempty"`

				// FileName The original name of the file
				FileName *string `json:"file_name,omitempty"`

				// FileSize The size of the file in bytes
				FileSize *int `json:"file_size,omitempty"`

				// Id The ID of the file
				Id *int `json:"id,omitempty"`

				// InlineFlag Whether the file was uploaded as inline or not
				InlineFlag *bool `json:"inline_flag,omitempty"`

				// Name The visible name of the file
				Name *string `json:"name,omitempty"`

				// ProductId The ID of the product associated with the file
				ProductId *int `json:"product_id,omitempty"`

				// ProductName The name of the product associated with the file
				ProductName *string `json:"product_name,omitempty"`

				// RemoteId The ID of the remote item
				RemoteId *string `json:"remote_id,omitempty"`

				// RemoteLocation The location type to send the file to. Only googledrive is supported at the moment.
				RemoteLocation *string `json:"remote_location,omitempty"`

				// S3Bucket The location of the cloud storage
				S3Bucket *string `json:"s3_bucket,omitempty"`

				// UpdateTime The UTC date time when the file was last updated. Format: YYYY-MM-DD HH:MM:SS
				UpdateTime *string `json:"update_time,omitempty"`

				// Url The URL to download the file
				Url *string `json:"url,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProductUsersResponse parses an HTTP response from a GetProductUsersWithResponse call
func ParseGetProductUsersResponse(rsp *http.Response) (*GetProductUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The list of user IDs
			Data *[]int `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectTemplatesResponse parses an HTTP response from a GetProjectTemplatesWithResponse call
func ParseGetProjectTemplatesResponse(rsp *http.Response) (*GetProjectTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// AddTime The creation date and time of the template in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// Description The description of a template
				Description *string `json:"description,omitempty"`

				// Id The ID of a template
				Id *float32 `json:"id,omitempty"`

				// OwnerId The ID of a template owner
				OwnerId *float32 `json:"owner_id,omitempty"`

				// ProjectsBoardId The ID of the project board this template is associated with
				ProjectsBoardId *float32 `json:"projects_board_id,omitempty"`

				// Title The title of a template
				Title *string `json:"title,omitempty"`

				// UpdateTime The update date and time of the template in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectTemplateResponse parses an HTTP response from a GetProjectTemplateWithResponse call
func ParseGetProjectTemplateResponse(rsp *http.Response) (*GetProjectTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				// AddTime The creation date and time of the template in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// Description The description of a template
				Description *string `json:"description,omitempty"`

				// Id The ID of a template
				Id *float32 `json:"id,omitempty"`

				// OwnerId The ID of a template owner
				OwnerId *float32 `json:"owner_id,omitempty"`

				// ProjectsBoardId The ID of the project board this template is associated with
				ProjectsBoardId *float32 `json:"projects_board_id,omitempty"`

				// Title The title of a template
				Title *string `json:"title,omitempty"`

				// UpdateTime The update date and time of the template in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectsResponse parses an HTTP response from a GetProjectsWithResponse call
func ParseGetProjectsResponse(rsp *http.Response) (*GetProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// AddTime The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// ArchiveTime The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then 'null'.
				ArchiveTime *string `json:"archive_time,omitempty"`

				// BoardId The ID of the board this project is associated with
				BoardId *float32 `json:"board_id,omitempty"`

				// DealIds An array of IDs of the deals this project is associated with
				DealIds *[]int `json:"deal_ids,omitempty"`

				// Description The description of the project
				Description *string `json:"description,omitempty"`

				// EndDate The end date of the project. Format: YYYY-MM-DD.
				EndDate *openapi_types.Date `json:"end_date,omitempty"`

				// Id The ID of the project, generated when the task was created
				Id *int `json:"id,omitempty"`

				// Labels An array of IDs of the labels this project has
				Labels *[]int `json:"labels,omitempty"`

				// OrgId The ID of the organization this project is associated with
				OrgId *float32 `json:"org_id,omitempty"`

				// OwnerId The ID of a project owner
				OwnerId *float32 `json:"owner_id,omitempty"`

				// PersonId The ID of the person this project is associated with
				PersonId *float32 `json:"person_id,omitempty"`

				// PhaseId The ID of the phase this project is associated with
				PhaseId *float32 `json:"phase_id,omitempty"`

				// StartDate The start date of the project. Format: YYYY-MM-DD.
				StartDate *openapi_types.Date `json:"start_date,omitempty"`

				// Status The status of the project
				Status *string `json:"status,omitempty"`

				// StatusChangeTime The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				StatusChangeTime *string `json:"status_change_time,omitempty"`

				// Title The title of the project
				Title *string `json:"title,omitempty"`

				// UpdateTime The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddProjectResponse parses an HTTP response from a AddProjectWithResponse call
func ParseAddProjectResponse(rsp *http.Response) (*AddProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				// AddTime The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// ArchiveTime The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then 'null'.
				ArchiveTime *string `json:"archive_time,omitempty"`

				// BoardId The ID of the board this project is associated with
				BoardId *float32 `json:"board_id,omitempty"`

				// DealIds An array of IDs of the deals this project is associated with
				DealIds *[]int `json:"deal_ids,omitempty"`

				// Description The description of the project
				Description *string `json:"description,omitempty"`

				// EndDate The end date of the project. Format: YYYY-MM-DD.
				EndDate *openapi_types.Date `json:"end_date,omitempty"`

				// Id The ID of the project, generated when the task was created
				Id *int `json:"id,omitempty"`

				// Labels An array of IDs of the labels this project has
				Labels *[]int `json:"labels,omitempty"`

				// OrgId The ID of the organization this project is associated with
				OrgId *float32 `json:"org_id,omitempty"`

				// OwnerId The ID of a project owner
				OwnerId *float32 `json:"owner_id,omitempty"`

				// PersonId The ID of the person this project is associated with
				PersonId *float32 `json:"person_id,omitempty"`

				// PhaseId The ID of the phase this project is associated with
				PhaseId *float32 `json:"phase_id,omitempty"`

				// StartDate The start date of the project. Format: YYYY-MM-DD.
				StartDate *openapi_types.Date `json:"start_date,omitempty"`

				// Status The status of the project
				Status *string `json:"status,omitempty"`

				// StatusChangeTime The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				StatusChangeTime *string `json:"status_change_time,omitempty"`

				// Title The title of the project
				Title *string `json:"title,omitempty"`

				// UpdateTime The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetProjectsBoardsResponse parses an HTTP response from a GetProjectsBoardsWithResponse call
func ParseGetProjectsBoardsResponse(rsp *http.Response) (*GetProjectsBoardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsBoardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// AddTime The creation date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// Id The ID of the project board
				Id *int `json:"id,omitempty"`

				// Name Name of a project board
				Name *string `json:"name,omitempty"`

				// OrderNr The order of a board
				OrderNr *float32 `json:"order_nr,omitempty"`

				// UpdateTime The update date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectsBoardResponse parses an HTTP response from a GetProjectsBoardWithResponse call
func ParseGetProjectsBoardResponse(rsp *http.Response) (*GetProjectsBoardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsBoardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				// AddTime The creation date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// Id The ID of the project board
				Id *int `json:"id,omitempty"`

				// Name Name of a project board
				Name *string `json:"name,omitempty"`

				// OrderNr The order of a board
				OrderNr *float32 `json:"order_nr,omitempty"`

				// UpdateTime The update date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectsPhasesResponse parses an HTTP response from a GetProjectsPhasesWithResponse call
func ParseGetProjectsPhasesResponse(rsp *http.Response) (*GetProjectsPhasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsPhasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// AddTime The creation date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// BoardId The ID of the project board this phase is linked to
				BoardId *float32 `json:"board_id,omitempty"`

				// Id The ID of the project phase
				Id *int `json:"id,omitempty"`

				// Name Name of a project phase
				Name *string `json:"name,omitempty"`

				// OrderNr The order of a phase
				OrderNr *float32 `json:"order_nr,omitempty"`

				// UpdateTime The update date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectsPhaseResponse parses an HTTP response from a GetProjectsPhaseWithResponse call
func ParseGetProjectsPhaseResponse(rsp *http.Response) (*GetProjectsPhaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsPhaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				// AddTime The creation date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// BoardId The ID of the project board this phase is linked to
				BoardId *float32 `json:"board_id,omitempty"`

				// Id The ID of the project phase
				Id *int `json:"id,omitempty"`

				// Name Name of a project phase
				Name *string `json:"name,omitempty"`

				// OrderNr The order of a phase
				OrderNr *float32 `json:"order_nr,omitempty"`

				// UpdateTime The update date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProjectResponse parses an HTTP response from a DeleteProjectWithResponse call
func ParseDeleteProjectResponse(rsp *http.Response) (*DeleteProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				Data *struct {
					// Id The ID of the project that was deleted
					Id *int `json:"id,omitempty"`
				} `json:"data,omitempty"`

				// Success If the request was successful or not
				Success *bool `json:"success,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectResponse parses an HTTP response from a GetProjectWithResponse call
func ParseGetProjectResponse(rsp *http.Response) (*GetProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				// AddTime The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// ArchiveTime The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then 'null'.
				ArchiveTime *string `json:"archive_time,omitempty"`

				// BoardId The ID of the board this project is associated with
				BoardId *float32 `json:"board_id,omitempty"`

				// DealIds An array of IDs of the deals this project is associated with
				DealIds *[]int `json:"deal_ids,omitempty"`

				// Description The description of the project
				Description *string `json:"description,omitempty"`

				// EndDate The end date of the project. Format: YYYY-MM-DD.
				EndDate *openapi_types.Date `json:"end_date,omitempty"`

				// Id The ID of the project, generated when the task was created
				Id *int `json:"id,omitempty"`

				// Labels An array of IDs of the labels this project has
				Labels *[]int `json:"labels,omitempty"`

				// OrgId The ID of the organization this project is associated with
				OrgId *float32 `json:"org_id,omitempty"`

				// OwnerId The ID of a project owner
				OwnerId *float32 `json:"owner_id,omitempty"`

				// PersonId The ID of the person this project is associated with
				PersonId *float32 `json:"person_id,omitempty"`

				// PhaseId The ID of the phase this project is associated with
				PhaseId *float32 `json:"phase_id,omitempty"`

				// StartDate The start date of the project. Format: YYYY-MM-DD.
				StartDate *openapi_types.Date `json:"start_date,omitempty"`

				// Status The status of the project
				Status *string `json:"status,omitempty"`

				// StatusChangeTime The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				StatusChangeTime *string `json:"status_change_time,omitempty"`

				// Title The title of the project
				Title *string `json:"title,omitempty"`

				// UpdateTime The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProjectResponse parses an HTTP response from a UpdateProjectWithResponse call
func ParseUpdateProjectResponse(rsp *http.Response) (*UpdateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				// AddTime The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// ArchiveTime The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then 'null'.
				ArchiveTime *string `json:"archive_time,omitempty"`

				// BoardId The ID of the board this project is associated with
				BoardId *float32 `json:"board_id,omitempty"`

				// DealIds An array of IDs of the deals this project is associated with
				DealIds *[]int `json:"deal_ids,omitempty"`

				// Description The description of the project
				Description *string `json:"description,omitempty"`

				// EndDate The end date of the project. Format: YYYY-MM-DD.
				EndDate *openapi_types.Date `json:"end_date,omitempty"`

				// Id The ID of the project, generated when the task was created
				Id *int `json:"id,omitempty"`

				// Labels An array of IDs of the labels this project has
				Labels *[]int `json:"labels,omitempty"`

				// OrgId The ID of the organization this project is associated with
				OrgId *float32 `json:"org_id,omitempty"`

				// OwnerId The ID of a project owner
				OwnerId *float32 `json:"owner_id,omitempty"`

				// PersonId The ID of the person this project is associated with
				PersonId *float32 `json:"person_id,omitempty"`

				// PhaseId The ID of the phase this project is associated with
				PhaseId *float32 `json:"phase_id,omitempty"`

				// StartDate The start date of the project. Format: YYYY-MM-DD.
				StartDate *openapi_types.Date `json:"start_date,omitempty"`

				// Status The status of the project
				Status *string `json:"status,omitempty"`

				// StatusChangeTime The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				StatusChangeTime *string `json:"status_change_time,omitempty"`

				// Title The title of the project
				Title *string `json:"title,omitempty"`

				// UpdateTime The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectActivitiesResponse parses an HTTP response from a GetProjectActivitiesWithResponse call
func ParseGetProjectActivitiesResponse(rsp *http.Response) (*GetProjectActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// ActiveFlag Whether the activity is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddTime The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// BusyFlag Marks if the activity is set as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
				BusyFlag *bool `json:"busy_flag,omitempty"`

				// CompanyId The user's company ID
				CompanyId *int `json:"company_id,omitempty"`

				// ConferenceMeetingClient The ID of the Marketplace app, which is connected to this activity
				ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

				// ConferenceMeetingId The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
				ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

				// ConferenceMeetingUrl The link to join the meeting which is associated with this activity
				ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

				// DealId The ID of the deal this activity is associated with
				DealId *int `json:"deal_id,omitempty"`

				// Done Whether the activity is done or not
				Done *bool `json:"done,omitempty"`

				// DueDate The due date of the activity. Format: YYYY-MM-DD
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// DueTime The due time of the activity in UTC. Format: HH:MM
				DueTime *string `json:"due_time,omitempty"`

				// Duration The duration of the activity. Format: HH:MM
				Duration *string `json:"duration,omitempty"`

				// Id The ID of the activity, generated when the activity was created
				Id *int `json:"id,omitempty"`

				// LeadId The ID of the lead in the UUID format this activity is associated with
				LeadId *openapi_types.UUID `json:"lead_id"`

				// Location The address of the activity.
				Location *string `json:"location,omitempty"`

				// LocationAdminAreaLevel1 A subfield of the location field. Indicates state/county.
				LocationAdminAreaLevel1 *string `json:"location_admin_area_level_1,omitempty"`

				// LocationAdminAreaLevel2 A subfield of the location field. Indicates region.
				LocationAdminAreaLevel2 *string `json:"location_admin_area_level_2,omitempty"`

				// LocationCountry A subfield of the location field. Indicates country.
				LocationCountry *string `json:"location_country,omitempty"`

				// LocationFormattedAddress A subfield of the location field. Indicates full/combined address.
				LocationFormattedAddress *string `json:"location_formatted_address,omitempty"`

				// LocationLocality A subfield of the location field. Indicates city/town/village/locality.
				LocationLocality *string `json:"location_locality,omitempty"`

				// LocationPostalCode A subfield of the location field. Indicates ZIP/postal code.
				LocationPostalCode *string `json:"location_postal_code,omitempty"`

				// LocationRoute A subfield of the location field. Indicates street name.
				LocationRoute *string `json:"location_route,omitempty"`

				// LocationStreetNumber A subfield of the location field. Indicates house number.
				LocationStreetNumber *string `json:"location_street_number,omitempty"`

				// LocationSublocality A subfield of the location field. Indicates district/sublocality.
				LocationSublocality *string `json:"location_sublocality,omitempty"`

				// LocationSubpremise A subfield of the location field. Indicates apartment/suite number.
				LocationSubpremise *string `json:"location_subpremise,omitempty"`

				// MarkedAsDoneTime The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// OrgId The ID of the organization this activity is associated with
				OrgId *int `json:"org_id,omitempty"`

				// PersonId The ID of the person this activity is associated with
				PersonId *int `json:"person_id,omitempty"`

				// ProjectId The ID of the project this activity is associated with
				ProjectId *int `json:"project_id"`

				// PublicDescription Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
				PublicDescription *string `json:"public_description,omitempty"`

				// SourceTimezone The timezone the activity was created in an external calendar
				SourceTimezone *string `json:"source_timezone,omitempty"`

				// Subject The subject of the activity
				Subject *string `json:"subject,omitempty"`

				// Type The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
				Type *string `json:"type,omitempty"`

				// UpdateTime The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`

				// UpdateUserId The ID of the user who was the last to update this activity
				UpdateUserId *int `json:"update_user_id,omitempty"`

				// UserId The ID of the user whom the activity is assigned to
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveProjectResponse parses an HTTP response from a ArchiveProjectWithResponse call
func ParseArchiveProjectResponse(rsp *http.Response) (*ArchiveProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				// AddTime The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// ArchiveTime The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then 'null'.
				ArchiveTime *string `json:"archive_time,omitempty"`

				// BoardId The ID of the board this project is associated with
				BoardId *float32 `json:"board_id,omitempty"`

				// DealIds An array of IDs of the deals this project is associated with
				DealIds *[]int `json:"deal_ids,omitempty"`

				// Description The description of the project
				Description *string `json:"description,omitempty"`

				// EndDate The end date of the project. Format: YYYY-MM-DD.
				EndDate *openapi_types.Date `json:"end_date,omitempty"`

				// Id The ID of the project, generated when the task was created
				Id *int `json:"id,omitempty"`

				// Labels An array of IDs of the labels this project has
				Labels *[]int `json:"labels,omitempty"`

				// OrgId The ID of the organization this project is associated with
				OrgId *float32 `json:"org_id,omitempty"`

				// OwnerId The ID of a project owner
				OwnerId *float32 `json:"owner_id,omitempty"`

				// PersonId The ID of the person this project is associated with
				PersonId *float32 `json:"person_id,omitempty"`

				// PhaseId The ID of the phase this project is associated with
				PhaseId *float32 `json:"phase_id,omitempty"`

				// StartDate The start date of the project. Format: YYYY-MM-DD.
				StartDate *openapi_types.Date `json:"start_date,omitempty"`

				// Status The status of the project
				Status *string `json:"status,omitempty"`

				// StatusChangeTime The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				StatusChangeTime *string `json:"status_change_time,omitempty"`

				// Title The title of the project
				Title *string `json:"title,omitempty"`

				// UpdateTime The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectGroupsResponse parses an HTTP response from a GetProjectGroupsWithResponse call
func ParseGetProjectGroupsResponse(rsp *http.Response) (*GetProjectGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id ID of the group
				Id *float32 `json:"id,omitempty"`

				// Name Name of the group
				Name *string `json:"name,omitempty"`

				// OrderNr Order number of the group
				OrderNr *float32 `json:"order_nr,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectPlanResponse parses an HTTP response from a GetProjectPlanWithResponse call
func ParseGetProjectPlanResponse(rsp *http.Response) (*GetProjectPlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectPlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// GroupId The ID of the board this project is associated with. If null then plan item is not in any group.
				GroupId *float32 `json:"group_id,omitempty"`

				// ItemId ID of plan item (either activity or task ID)
				ItemId *float32 `json:"item_id,omitempty"`

				// ItemType Type of a plan item (task / activity)
				ItemType *string `json:"item_type,omitempty"`

				// PhaseId The ID of the board this project is associated with. If null then plan item is not in any phase.
				PhaseId *float32 `json:"phase_id,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutProjectPlanActivityResponse parses an HTTP response from a PutProjectPlanActivityWithResponse call
func ParsePutProjectPlanActivityResponse(rsp *http.Response) (*PutProjectPlanActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutProjectPlanActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				// GroupId The ID of the board this project is associated with. If null then plan item is not in any group.
				GroupId *float32 `json:"group_id,omitempty"`

				// ItemId ID of plan item (either activity or task ID)
				ItemId *float32 `json:"item_id,omitempty"`

				// ItemType Type of a plan item (task / activity)
				ItemType *string `json:"item_type,omitempty"`

				// PhaseId The ID of the board this project is associated with. If null then plan item is not in any phase.
				PhaseId *float32 `json:"phase_id,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutProjectPlanTaskResponse parses an HTTP response from a PutProjectPlanTaskWithResponse call
func ParsePutProjectPlanTaskResponse(rsp *http.Response) (*PutProjectPlanTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutProjectPlanTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				// GroupId The ID of the board this project is associated with. If null then plan item is not in any group.
				GroupId *float32 `json:"group_id,omitempty"`

				// ItemId ID of plan item (either activity or task ID)
				ItemId *float32 `json:"item_id,omitempty"`

				// ItemType Type of a plan item (task / activity)
				ItemType *string `json:"item_type,omitempty"`

				// PhaseId The ID of the board this project is associated with. If null then plan item is not in any phase.
				PhaseId *float32 `json:"phase_id,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectTasksResponse parses an HTTP response from a GetProjectTasksWithResponse call
func ParseGetProjectTasksResponse(rsp *http.Response) (*GetProjectTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// AddTime The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// AssigneeId The ID of the user who will be the assignee of the task
				AssigneeId *float32 `json:"assignee_id,omitempty"`

				// CreatorId The creator of a task
				CreatorId *float32 `json:"creator_id,omitempty"`

				// Description The description of the task
				Description *string `json:"description,omitempty"`

				// Done Whether the task is done or not. 0 = Not done, 1 = Done.
				Done *GetProjectTasks200DataDone `json:"done,omitempty"`

				// DueDate The due date of the task. Format: YYYY-MM-DD.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// Id The ID of the task, generated when the task was created
				Id *int `json:"id,omitempty"`

				// MarkedAsDoneTime The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// ParentTaskId The ID of a parent task. Can not be ID of a task which is already a subtask.
				ParentTaskId *float32 `json:"parent_task_id,omitempty"`

				// ProjectId The ID of the project this task is associated with
				ProjectId *float32 `json:"project_id,omitempty"`

				// Title The title of the task
				Title *string `json:"title,omitempty"`

				// UpdateTime The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRecentsResponse parses an HTTP response from a GetRecentsWithResponse call
func ParseGetRecentsResponse(rsp *http.Response) (*GetRecentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// LastTimestampOnPage The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
				LastTimestampOnPage *string `json:"last_timestamp_on_page,omitempty"`

				// Pagination The additional data of the list
				Pagination *struct {
					// Limit Items shown per page
					Limit *int `json:"limit,omitempty"`

					// MoreItemsInCollection If there are more list items in the collection than displayed or not
					MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

					// Start Pagination start
					Start *int `json:"start,omitempty"`
				} `json:"pagination,omitempty"`

				// SinceTimestamp The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
				SinceTimestamp *string `json:"since_timestamp,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]GetRecents_200_Data_Item `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRolesResponse parses an HTTP response from a GetRolesWithResponse call
func ParseGetRolesResponse(rsp *http.Response) (*GetRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data in the role list
			AdditionalData *struct {
				// Pagination The pagination details in the role list
				Pagination *struct {
					// Limit Items shown per page
					Limit *int `json:"limit,omitempty"`

					// MoreItemsInCollection Whether there are more list items in the collection than displayed
					MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

					// Start Pagination start
					Start *int `json:"start,omitempty"`
				} `json:"pagination,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of roles
			Data *[]struct {
				// ActiveFlag Whether the role is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AssignmentCount The number of users assigned to this role
				AssignmentCount *string `json:"assignment_count,omitempty"`

				// Id The ID of the role
				Id *int `json:"id,omitempty"`

				// Level The level of role in the role hierarchy
				Level *int `json:"level,omitempty"`

				// Name The name of the role
				Name *string `json:"name,omitempty"`

				// ParentRoleId The ID of the parent role
				ParentRoleId *int `json:"parent_role_id"`

				// SubRoleCount The number of sub-roles
				SubRoleCount *string `json:"sub_role_count,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddRoleResponse parses an HTTP response from a AddRoleWithResponse call
func ParseAddRoleResponse(rsp *http.Response) (*AddRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The response data
			Data *struct {
				// Id The ID of the created role
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRoleResponse parses an HTTP response from a DeleteRoleWithResponse call
func ParseDeleteRoleResponse(rsp *http.Response) (*DeleteRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The response data
			Data *struct {
				// Id The ID of the deleted role
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data in the role
			AdditionalData *struct {
				// Settings The settings for the role
				Settings *struct {
					// DealAccessLevel The access level of the deals for the role (only for default role)
					DealAccessLevel *float32 `json:"deal_access_level,omitempty"`

					// DealDefaultVisibility The default visibility level of the deals for the role
					DealDefaultVisibility *float32 `json:"deal_default_visibility,omitempty"`

					// LeadDefaultVisibility The default visibility level of the leads for the role
					LeadDefaultVisibility *float32 `json:"lead_default_visibility,omitempty"`

					// OrgAccessLevel The access level of the organizations for the role (only for default role)
					OrgAccessLevel *float32 `json:"org_access_level,omitempty"`

					// OrgDefaultVisibility The default visibility level of the organizations for the role
					OrgDefaultVisibility *float32 `json:"org_default_visibility,omitempty"`

					// PersonAccessLevel The access level of the people for the role (only for default role)
					PersonAccessLevel *float32 `json:"person_access_level,omitempty"`

					// PersonDefaultVisibility The default visibility level of the people for the role
					PersonDefaultVisibility *float32 `json:"person_default_visibility,omitempty"`

					// ProductAccessLevel The access level of the products for the role (only for default role)
					ProductAccessLevel *float32 `json:"product_access_level,omitempty"`

					// ProductDefaultVisibility The default visibility level of the products for the role
					ProductDefaultVisibility *float32 `json:"product_default_visibility,omitempty"`
				} `json:"settings,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The details of the sub-role
			Data *struct {
				// ActiveFlag Whether the role is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AssignmentCount The number of users assigned to this role
				AssignmentCount *string `json:"assignment_count,omitempty"`

				// Id The ID of the role
				Id *int `json:"id,omitempty"`

				// Name The name of the role
				Name *string `json:"name,omitempty"`

				// ParentRoleId The ID of the parent role
				ParentRoleId *int `json:"parent_role_id"`

				// SubRoleCount The number of sub-roles
				SubRoleCount *string `json:"sub_role_count,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRoleResponse parses an HTTP response from a UpdateRoleWithResponse call
func ParseUpdateRoleResponse(rsp *http.Response) (*UpdateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The response data
			Data *struct {
				// Id The ID of the updated role
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRoleAssignmentResponse parses an HTTP response from a DeleteRoleAssignmentWithResponse call
func ParseDeleteRoleAssignmentResponse(rsp *http.Response) (*DeleteRoleAssignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The response data
			Data *struct {
				// Id The ID of the role the user was removed from
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRoleAssignmentsResponse parses an HTTP response from a GetRoleAssignmentsWithResponse call
func ParseGetRoleAssignmentsResponse(rsp *http.Response) (*GetRoleAssignmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleAssignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data in the role list
			AdditionalData *struct {
				// Pagination The pagination details in the role list
				Pagination *struct {
					// Limit Items shown per page
					Limit *int `json:"limit,omitempty"`

					// MoreItemsInCollection Whether there are more list items in the collection than displayed
					MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

					// Start Pagination start
					Start *int `json:"start,omitempty"`
				} `json:"pagination,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The role assignments
			Data *[]struct {
				// ActiveFlag Whether the role is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Name The name of the role
				Name *string `json:"name,omitempty"`

				// ParentRoleId The ID of the parent role
				ParentRoleId *int `json:"parent_role_id"`

				// RoleId The role ID
				RoleId *int `json:"role_id,omitempty"`

				// Type The assignment type
				Type *string `json:"type,omitempty"`

				// UserId The user ID
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddRoleAssignmentResponse parses an HTTP response from a AddRoleAssignmentWithResponse call
func ParseAddRoleAssignmentResponse(rsp *http.Response) (*AddRoleAssignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRoleAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The response data
			Data *struct {
				// RoleId The ID of the role the user was added to
				RoleId *int `json:"role_id,omitempty"`

				// UserId The ID of the user that was added to the role
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRolePipelinesResponse parses an HTTP response from a GetRolePipelinesWithResponse call
func ParseGetRolePipelinesResponse(rsp *http.Response) (*GetRolePipelinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolePipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The response data
			Data *struct {
				// PipelineIds Either visible or hidden pipeline ids
				PipelineIds *[]float32 `json:"pipeline_ids,omitempty"`

				// Visible Whether visible or hidden pipeline ids were returned
				Visible *bool `json:"visible,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRolePipelinesResponse parses an HTTP response from a UpdateRolePipelinesWithResponse call
func ParseUpdateRolePipelinesResponse(rsp *http.Response) (*UpdateRolePipelinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRolePipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The response data
			Data *struct {
				// PipelineIds Either visible or hidden pipeline ids
				PipelineIds *[]float32 `json:"pipeline_ids,omitempty"`

				// Visible Whether visible or hidden pipeline ids were returned
				Visible *bool `json:"visible,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRoleSettingsResponse parses an HTTP response from a GetRoleSettingsWithResponse call
func ParseGetRoleSettingsResponse(rsp *http.Response) (*GetRoleSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The settings for the role
			Data *struct {
				// DealAccessLevel The access level of the deals for the role (only for default role)
				DealAccessLevel *float32 `json:"deal_access_level,omitempty"`

				// DealDefaultVisibility The default visibility level of the deals for the role
				DealDefaultVisibility *float32 `json:"deal_default_visibility,omitempty"`

				// LeadDefaultVisibility The default visibility level of the leads for the role
				LeadDefaultVisibility *float32 `json:"lead_default_visibility,omitempty"`

				// OrgAccessLevel The access level of the organizations for the role (only for default role)
				OrgAccessLevel *float32 `json:"org_access_level,omitempty"`

				// OrgDefaultVisibility The default visibility level of the organizations for the role
				OrgDefaultVisibility *float32 `json:"org_default_visibility,omitempty"`

				// PersonAccessLevel The access level of the people for the role (only for default role)
				PersonAccessLevel *float32 `json:"person_access_level,omitempty"`

				// PersonDefaultVisibility The default visibility level of the people for the role
				PersonDefaultVisibility *float32 `json:"person_default_visibility,omitempty"`

				// ProductAccessLevel The access level of the products for the role (only for default role)
				ProductAccessLevel *float32 `json:"product_access_level,omitempty"`

				// ProductDefaultVisibility The default visibility level of the products for the role
				ProductDefaultVisibility *float32 `json:"product_default_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddOrUpdateRoleSettingResponse parses an HTTP response from a AddOrUpdateRoleSettingWithResponse call
func ParseAddOrUpdateRoleSettingResponse(rsp *http.Response) (*AddOrUpdateRoleSettingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrUpdateRoleSettingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The response data
			Data *struct {
				// DealDefaultVisibility The setting
				DealDefaultVisibility *AddOrUpdateRoleSetting200DataDealDefaultVisibility `json:"deal_default_visibility,omitempty"`

				// Id The ID of the role
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStagesResponse parses an HTTP response from a DeleteStagesWithResponse call
func ParseDeleteStagesResponse(rsp *http.Response) (*DeleteStagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The list of deleted stage IDs
				Id *[]int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStageDealsResponse parses an HTTP response from a GetStageDealsWithResponse call
func ParseGetStageDealsResponse(rsp *http.Response) (*GetStageDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStageDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// Limit Items shown per page
				Limit *int `json:"limit,omitempty"`

				// MoreItemsInCollection If there are more list items in the collection than displayed or not
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

				// Start Pagination start
				Start *int `json:"start,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of deals
			Data *[]struct {
				// Active Whether the deal is active or not
				Active *bool `json:"active,omitempty"`

				// ActivitiesCount The number of activities associated with the deal
				ActivitiesCount *int `json:"activities_count,omitempty"`

				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AcvCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Contract Value of the deal
				//
				// If the `acv` is null, this will also be null
				AcvCurrency *string `json:"acv_currency"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// ArrCurrency Only available in Growth and above plans
				//
				// The Currency for Annual Recurring Revenue of the deal
				//
				// If the `arr` is null, this will also be null
				ArrCurrency *string `json:"arr_currency"`

				// CcEmail The BCC email of the deal
				CcEmail *string `json:"cc_email,omitempty"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// CreatorUserId The ID of the deal creator
				CreatorUserId *int `json:"creator_user_id,omitempty"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// Deleted Whether the deal is deleted or not
				Deleted *bool `json:"deleted,omitempty"`

				// DoneActivitiesCount The number of completed activities associated with the deal
				DoneActivitiesCount *int `json:"done_activities_count,omitempty"`

				// EmailMessagesCount The number of emails associated with the deal
				EmailMessagesCount *int `json:"email_messages_count,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// FilesCount The number of files associated with the deal
				FilesCount *int `json:"files_count,omitempty"`

				// FirstWonTime The date and time of the first time changing the deal status as won
				FirstWonTime *string `json:"first_won_time,omitempty"`

				// FollowersCount The number of followers associated with the deal
				FollowersCount *int `json:"followers_count,omitempty"`

				// FormattedValue The deal value formatted with selected currency. E.g. US$500
				FormattedValue *string `json:"formatted_value,omitempty"`

				// FormattedWeightedValue The weighted_value formatted with selected currency. E.g. US$500
				FormattedWeightedValue *string `json:"formatted_weighted_value,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// Label The label or multiple labels assigned to the deal
				Label *string `json:"label,omitempty"`

				// LastActivityDate The date of the last activity associated with the deal
				LastActivityDate *string `json:"last_activity_date"`

				// LastActivityId The ID of the last activity associated with the deal
				LastActivityId *int `json:"last_activity_id"`

				// LastIncomingMailTime The date and time of the last incoming email associated with the deal
				LastIncomingMailTime *string `json:"last_incoming_mail_time,omitempty"`

				// LastOutgoingMailTime The date and time of the last outgoing email associated with the deal
				LastOutgoingMailTime *string `json:"last_outgoing_mail_time,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// MrrCurrency Only available in Growth and above plans
				//
				// The Currency for Monthly Recurring Revenue of the deal
				//
				// If the `mrr` is null, this will also be null
				MrrCurrency *string `json:"mrr_currency"`

				// NextActivityDate The date of the next activity associated with the deal
				NextActivityDate *string `json:"next_activity_date,omitempty"`

				// NextActivityDuration The duration of the next activity associated with the deal
				NextActivityDuration *string `json:"next_activity_duration,omitempty"`

				// NextActivityId The ID of the next activity associated with the deal
				NextActivityId *int `json:"next_activity_id"`

				// NextActivityNote The note of the next activity associated with the deal
				NextActivityNote *string `json:"next_activity_note,omitempty"`

				// NextActivitySubject The subject of the next activity associated with the deal
				NextActivitySubject *string `json:"next_activity_subject,omitempty"`

				// NextActivityTime The time of the next activity associated with the deal
				NextActivityTime *string `json:"next_activity_time,omitempty"`

				// NextActivityType The type of the next activity associated with the deal
				NextActivityType *string `json:"next_activity_type,omitempty"`

				// NotesCount The number of notes associated with the deal
				NotesCount *int `json:"notes_count,omitempty"`

				// OrgHidden If the organization that is associated with the deal is hidden or not
				OrgHidden *bool `json:"org_hidden,omitempty"`

				// OrgId The ID of the organization associated with the deal
				OrgId *int `json:"org_id,omitempty"`

				// OrgName The name of the organization associated with the deal
				OrgName *string `json:"org_name,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerName The name of the deal owner
				OwnerName *string `json:"owner_name,omitempty"`

				// ParticipantsCount The number of participants associated with the deal
				ParticipantsCount *int `json:"participants_count,omitempty"`

				// PersonHidden If the person that is associated with the deal is hidden or not
				PersonHidden *bool `json:"person_hidden,omitempty"`

				// PersonId The ID of the person associated with the deal
				PersonId *int `json:"person_id,omitempty"`

				// PersonName The name of the person associated with the deal
				PersonName *string `json:"person_name,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// ProductsCount The number of products associated with the deal
				ProductsCount *int `json:"products_count,omitempty"`

				// RottenTime The date and time of changing the deal status as rotten
				RottenTime *string `json:"rotten_time"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// StageOrderNr The order number of the deal stage associated with the deal
				StageOrderNr *int `json:"stage_order_nr,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UndoneActivitiesCount The number of incomplete activities associated with the deal
				UndoneActivitiesCount *int `json:"undone_activities_count,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`

				// UserId The ID of the user
				UserId *int `json:"user_id,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *string `json:"visible_to,omitempty"`

				// WeightedValue Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
				WeightedValue *float32 `json:"weighted_value,omitempty"`

				// WeightedValueCurrency The currency associated with the deal
				WeightedValueCurrency *string `json:"weighted_value_currency,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the request was successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTasksResponse parses an HTTP response from a GetTasksWithResponse call
func ParseGetTasksResponse(rsp *http.Response) (*GetTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// AddTime The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// AssigneeId The ID of the user who will be the assignee of the task
				AssigneeId *float32 `json:"assignee_id,omitempty"`

				// CreatorId The creator of a task
				CreatorId *float32 `json:"creator_id,omitempty"`

				// Description The description of the task
				Description *string `json:"description,omitempty"`

				// Done Whether the task is done or not. 0 = Not done, 1 = Done.
				Done *GetTasks200DataDone `json:"done,omitempty"`

				// DueDate The due date of the task. Format: YYYY-MM-DD.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// Id The ID of the task, generated when the task was created
				Id *int `json:"id,omitempty"`

				// MarkedAsDoneTime The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// ParentTaskId The ID of a parent task. Can not be ID of a task which is already a subtask.
				ParentTaskId *float32 `json:"parent_task_id,omitempty"`

				// ProjectId The ID of the project this task is associated with
				ProjectId *float32 `json:"project_id,omitempty"`

				// Title The title of the task
				Title *string `json:"title,omitempty"`

				// UpdateTime The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddTaskResponse parses an HTTP response from a AddTaskWithResponse call
func ParseAddTaskResponse(rsp *http.Response) (*AddTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				// AddTime The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// AssigneeId The ID of the user who will be the assignee of the task
				AssigneeId *float32 `json:"assignee_id,omitempty"`

				// CreatorId The creator of a task
				CreatorId *float32 `json:"creator_id,omitempty"`

				// Description The description of the task
				Description *string `json:"description,omitempty"`

				// Done Whether the task is done or not. 0 = Not done, 1 = Done.
				Done *AddTask201DataDone `json:"done,omitempty"`

				// DueDate The due date of the task. Format: YYYY-MM-DD.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// Id The ID of the task, generated when the task was created
				Id *int `json:"id,omitempty"`

				// MarkedAsDoneTime The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// ParentTaskId The ID of a parent task. Can not be ID of a task which is already a subtask.
				ParentTaskId *float32 `json:"parent_task_id,omitempty"`

				// ProjectId The ID of the project this task is associated with
				ProjectId *float32 `json:"project_id,omitempty"`

				// Title The title of the task
				Title *string `json:"title,omitempty"`

				// UpdateTime The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteTaskResponse parses an HTTP response from a DeleteTaskWithResponse call
func ParseDeleteTaskResponse(rsp *http.Response) (*DeleteTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				Data *struct {
					// Id The ID of the task that was deleted
					Id *int `json:"id,omitempty"`
				} `json:"data,omitempty"`

				// Success If the request was successful or not
				Success *bool `json:"success,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTaskResponse parses an HTTP response from a GetTaskWithResponse call
func ParseGetTaskResponse(rsp *http.Response) (*GetTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				// AddTime The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// AssigneeId The ID of the user who will be the assignee of the task
				AssigneeId *float32 `json:"assignee_id,omitempty"`

				// CreatorId The creator of a task
				CreatorId *float32 `json:"creator_id,omitempty"`

				// Description The description of the task
				Description *string `json:"description,omitempty"`

				// Done Whether the task is done or not. 0 = Not done, 1 = Done.
				Done *GetTask200DataDone `json:"done,omitempty"`

				// DueDate The due date of the task. Format: YYYY-MM-DD.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// Id The ID of the task, generated when the task was created
				Id *int `json:"id,omitempty"`

				// MarkedAsDoneTime The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// ParentTaskId The ID of a parent task. Can not be ID of a task which is already a subtask.
				ParentTaskId *float32 `json:"parent_task_id,omitempty"`

				// ProjectId The ID of the project this task is associated with
				ProjectId *float32 `json:"project_id,omitempty"`

				// Title The title of the task
				Title *string `json:"title,omitempty"`

				// UpdateTime The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTaskResponse parses an HTTP response from a UpdateTaskWithResponse call
func ParseUpdateTaskResponse(rsp *http.Response) (*UpdateTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *struct {
				// AddTime The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				AddTime *string `json:"add_time,omitempty"`

				// AssigneeId The ID of the user who will be the assignee of the task
				AssigneeId *float32 `json:"assignee_id,omitempty"`

				// CreatorId The creator of a task
				CreatorId *float32 `json:"creator_id,omitempty"`

				// Description The description of the task
				Description *string `json:"description,omitempty"`

				// Done Whether the task is done or not. 0 = Not done, 1 = Done.
				Done *UpdateTask200DataDone `json:"done,omitempty"`

				// DueDate The due date of the task. Format: YYYY-MM-DD.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// Id The ID of the task, generated when the task was created
				Id *int `json:"id,omitempty"`

				// MarkedAsDoneTime The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// ParentTaskId The ID of a parent task. Can not be ID of a task which is already a subtask.
				ParentTaskId *float32 `json:"parent_task_id,omitempty"`

				// ProjectId The ID of the project this task is associated with
				ProjectId *float32 `json:"project_id,omitempty"`

				// Title The title of the task
				Title *string `json:"title,omitempty"`

				// UpdateTime The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserConnectionsResponse parses an HTTP response from a GetUserConnectionsWithResponse call
func ParseGetUserConnectionsResponse(rsp *http.Response) (*GetUserConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The object of UserConnections
			Data *struct {
				// Google The third party ID or false in case the ID is not found
				Google *string `json:"google,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// ErrorCode The response error code
			ErrorCode *int `json:"errorCode,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUserSettingsResponse parses an HTTP response from a GetUserSettingsWithResponse call
func ParseGetUserSettingsResponse(rsp *http.Response) (*GetUserSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// AutofillDealExpectedCloseDate Whether the expected close date of the deal is filled automatically or not
				AutofillDealExpectedCloseDate *bool `json:"autofill_deal_expected_close_date,omitempty"`

				// BetaApp Whether beta app is enabled
				BetaApp *bool `json:"beta_app,omitempty"`

				// CalltoLinkSyntax The call to link syntax
				CalltoLinkSyntax *string `json:"callto_link_syntax,omitempty"`

				// FileUploadDestination The destination of file upload
				FileUploadDestination *string `json:"file_upload_destination,omitempty"`

				// ListLimit The number of results shown in list by default
				ListLimit *float32 `json:"list_limit,omitempty"`

				// MarketplaceTeam If the vendors are allowed to be part of the Marketplace team or not
				MarketplaceTeam *bool `json:"marketplace_team,omitempty"`

				// PersonDuplicateCondition Allow the vendors to duplicate a person
				PersonDuplicateCondition *string `json:"person_duplicate_condition,omitempty"`

				// PreventSalesphoneCalltoOverride Prevent salesphone call to override
				PreventSalesphoneCalltoOverride *bool `json:"prevent_salesphone_callto_override,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// ErrorCode The response error code
			ErrorCode *int `json:"errorCode,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				Access *[]struct {
					Admin           *bool                     `json:"admin,omitempty"`
					App             *GetUsers200DataAccessApp `json:"app,omitempty"`
					PermissionSetId *string                   `json:"permission_set_id,omitempty"`
				} `json:"access,omitempty"`

				// Activated Boolean that indicates whether the user is activated
				Activated *bool `json:"activated,omitempty"`

				// ActiveFlag Boolean that indicates whether the user is activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				Created *string `json:"created,omitempty"`

				// DefaultCurrency The user default currency
				DefaultCurrency *string `json:"default_currency,omitempty"`

				// Email The user email
				Email *string `json:"email,omitempty"`

				// HasCreatedCompany Boolean that indicates whether the user has created a company
				HasCreatedCompany *bool `json:"has_created_company,omitempty"`

				// IconUrl The user icon URL
				IconUrl *string `json:"icon_url"`

				// Id The user ID
				Id *int `json:"id,omitempty"`

				// IsDeleted Boolean that indicates whether the user is deleted from the company
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
				IsYou *bool `json:"is_you,omitempty"`

				// Lang The user language ID
				Lang *int `json:"lang,omitempty"`

				// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				LastLogin *string `json:"last_login,omitempty"`

				// Locale The user locale
				Locale *string `json:"locale,omitempty"`

				// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				Modified *string `json:"modified"`

				// Name The user name
				Name *string `json:"name,omitempty"`

				// Phone The user phone
				Phone *string `json:"phone"`

				// RoleId The ID of the user role
				RoleId *int `json:"role_id,omitempty"`

				// TimezoneName The user timezone name
				TimezoneName *string `json:"timezone_name,omitempty"`

				// TimezoneOffset The user timezone offset
				TimezoneOffset *string `json:"timezone_offset,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddUserResponse parses an HTTP response from a AddUserWithResponse call
func ParseAddUserResponse(rsp *http.Response) (*AddUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Access *[]struct {
					Admin           *bool                    `json:"admin,omitempty"`
					App             *AddUser200DataAccessApp `json:"app,omitempty"`
					PermissionSetId *string                  `json:"permission_set_id,omitempty"`
				} `json:"access,omitempty"`

				// Activated Boolean that indicates whether the user is activated
				Activated *bool `json:"activated,omitempty"`

				// ActiveFlag Boolean that indicates whether the user is activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				Created *string `json:"created,omitempty"`

				// DefaultCurrency The user default currency
				DefaultCurrency *string `json:"default_currency,omitempty"`

				// Email The user email
				Email *string `json:"email,omitempty"`

				// HasCreatedCompany Boolean that indicates whether the user has created a company
				HasCreatedCompany *bool `json:"has_created_company,omitempty"`

				// IconUrl The user icon URL
				IconUrl *string `json:"icon_url"`

				// Id The user ID
				Id *int `json:"id,omitempty"`

				// IsDeleted Boolean that indicates whether the user is deleted from the company
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
				IsYou *bool `json:"is_you,omitempty"`

				// Lang The user language ID
				Lang *int `json:"lang,omitempty"`

				// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				LastLogin *string `json:"last_login,omitempty"`

				// Locale The user locale
				Locale *string `json:"locale,omitempty"`

				// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				Modified *string `json:"modified"`

				// Name The user name
				Name *string `json:"name,omitempty"`

				// Phone The user phone
				Phone *string `json:"phone"`

				// RoleId The ID of the user role
				RoleId *int `json:"role_id,omitempty"`

				// TimezoneName The user timezone name
				TimezoneName *string `json:"timezone_name,omitempty"`

				// TimezoneOffset The user timezone offset
				TimezoneOffset *string `json:"timezone_offset,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseFindUsersByNameResponse parses an HTTP response from a FindUsersByNameWithResponse call
func ParseFindUsersByNameResponse(rsp *http.Response) (*FindUsersByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindUsersByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				Access *[]struct {
					Admin           *bool                            `json:"admin,omitempty"`
					App             *FindUsersByName200DataAccessApp `json:"app,omitempty"`
					PermissionSetId *string                          `json:"permission_set_id,omitempty"`
				} `json:"access,omitempty"`

				// Activated Boolean that indicates whether the user is activated
				Activated *bool `json:"activated,omitempty"`

				// ActiveFlag Boolean that indicates whether the user is activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				Created *string `json:"created,omitempty"`

				// DefaultCurrency The user default currency
				DefaultCurrency *string `json:"default_currency,omitempty"`

				// Email The user email
				Email *string `json:"email,omitempty"`

				// HasCreatedCompany Boolean that indicates whether the user has created a company
				HasCreatedCompany *bool `json:"has_created_company,omitempty"`

				// IconUrl The user icon URL
				IconUrl *string `json:"icon_url"`

				// Id The user ID
				Id *int `json:"id,omitempty"`

				// IsDeleted Boolean that indicates whether the user is deleted from the company
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
				IsYou *bool `json:"is_you,omitempty"`

				// Lang The user language ID
				Lang *int `json:"lang,omitempty"`

				// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				LastLogin *string `json:"last_login,omitempty"`

				// Locale The user locale
				Locale *string `json:"locale,omitempty"`

				// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				Modified *string `json:"modified"`

				// Name The user name
				Name *string `json:"name,omitempty"`

				// Phone The user phone
				Phone *string `json:"phone"`

				// RoleId The ID of the user role
				RoleId *int `json:"role_id,omitempty"`

				// TimezoneName The user timezone name
				TimezoneName *string `json:"timezone_name,omitempty"`

				// TimezoneOffset The user timezone offset
				TimezoneOffset *string `json:"timezone_offset,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Access *[]struct {
					Admin           *bool                           `json:"admin,omitempty"`
					App             *GetCurrentUser200DataAccessApp `json:"app,omitempty"`
					PermissionSetId *string                         `json:"permission_set_id,omitempty"`
				} `json:"access,omitempty"`

				// Activated Boolean that indicates whether the user is activated
				Activated *bool `json:"activated,omitempty"`

				// ActiveFlag Boolean that indicates whether the user is activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// CompanyCountry The user company country
				CompanyCountry *string `json:"company_country,omitempty"`

				// CompanyDomain The user company domain
				CompanyDomain *string `json:"company_domain,omitempty"`

				// CompanyId The user company ID
				CompanyId *int `json:"company_id,omitempty"`

				// CompanyIndustry The user company industry
				CompanyIndustry *string `json:"company_industry,omitempty"`

				// CompanyName The user company name
				CompanyName *string `json:"company_name,omitempty"`

				// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				Created *string `json:"created,omitempty"`

				// DefaultCurrency The user default currency
				DefaultCurrency *string `json:"default_currency,omitempty"`

				// Email The user email
				Email *string `json:"email,omitempty"`

				// HasCreatedCompany Boolean that indicates whether the user has created a company
				HasCreatedCompany *bool `json:"has_created_company,omitempty"`

				// IconUrl The user icon URL
				IconUrl *string `json:"icon_url"`

				// Id The user ID
				Id *int `json:"id,omitempty"`

				// IsDeleted Boolean that indicates whether the user is deleted from the company
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
				IsYou *bool `json:"is_you,omitempty"`

				// Lang The user language ID
				Lang *int `json:"lang,omitempty"`

				// Language The user language details
				Language *struct {
					// CountryCode The country code. E.g. US
					CountryCode *string `json:"country_code,omitempty"`

					// LanguageCode The language code. E.g. en
					LanguageCode *string `json:"language_code,omitempty"`
				} `json:"language,omitempty"`

				// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				LastLogin *string `json:"last_login,omitempty"`

				// Locale The user locale
				Locale *string `json:"locale,omitempty"`

				// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				Modified *string `json:"modified"`

				// Name The user name
				Name *string `json:"name,omitempty"`

				// Phone The user phone
				Phone *string `json:"phone"`

				// RoleId The ID of the user role
				RoleId *int `json:"role_id,omitempty"`

				// TimezoneName The user timezone name
				TimezoneName *string `json:"timezone_name,omitempty"`

				// TimezoneOffset The user timezone offset
				TimezoneOffset *string `json:"timezone_offset,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// ErrorCode The response error code
			ErrorCode *int `json:"errorCode,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Access *[]struct {
					Admin           *bool                    `json:"admin,omitempty"`
					App             *GetUser200DataAccessApp `json:"app,omitempty"`
					PermissionSetId *string                  `json:"permission_set_id,omitempty"`
				} `json:"access,omitempty"`

				// Activated Boolean that indicates whether the user is activated
				Activated *bool `json:"activated,omitempty"`

				// ActiveFlag Boolean that indicates whether the user is activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				Created *string `json:"created,omitempty"`

				// DefaultCurrency The user default currency
				DefaultCurrency *string `json:"default_currency,omitempty"`

				// Email The user email
				Email *string `json:"email,omitempty"`

				// HasCreatedCompany Boolean that indicates whether the user has created a company
				HasCreatedCompany *bool `json:"has_created_company,omitempty"`

				// IconUrl The user icon URL
				IconUrl *string `json:"icon_url"`

				// Id The user ID
				Id *int `json:"id,omitempty"`

				// IsDeleted Boolean that indicates whether the user is deleted from the company
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
				IsYou *bool `json:"is_you,omitempty"`

				// Lang The user language ID
				Lang *int `json:"lang,omitempty"`

				// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				LastLogin *string `json:"last_login,omitempty"`

				// Locale The user locale
				Locale *string `json:"locale,omitempty"`

				// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				Modified *string `json:"modified"`

				// Name The user name
				Name *string `json:"name,omitempty"`

				// Phone The user phone
				Phone *string `json:"phone"`

				// RoleId The ID of the user role
				RoleId *int `json:"role_id,omitempty"`

				// TimezoneName The user timezone name
				TimezoneName *string `json:"timezone_name,omitempty"`

				// TimezoneOffset The user timezone offset
				TimezoneOffset *string `json:"timezone_offset,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Access *[]struct {
					Admin           *bool                       `json:"admin,omitempty"`
					App             *UpdateUser200DataAccessApp `json:"app,omitempty"`
					PermissionSetId *string                     `json:"permission_set_id,omitempty"`
				} `json:"access,omitempty"`

				// Activated Boolean that indicates whether the user is activated
				Activated *bool `json:"activated,omitempty"`

				// ActiveFlag Boolean that indicates whether the user is activated
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Created The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				Created *string `json:"created,omitempty"`

				// DefaultCurrency The user default currency
				DefaultCurrency *string `json:"default_currency,omitempty"`

				// Email The user email
				Email *string `json:"email,omitempty"`

				// HasCreatedCompany Boolean that indicates whether the user has created a company
				HasCreatedCompany *bool `json:"has_created_company,omitempty"`

				// IconUrl The user icon URL
				IconUrl *string `json:"icon_url"`

				// Id The user ID
				Id *int `json:"id,omitempty"`

				// IsDeleted Boolean that indicates whether the user is deleted from the company
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// IsYou Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
				IsYou *bool `json:"is_you,omitempty"`

				// Lang The user language ID
				Lang *int `json:"lang,omitempty"`

				// LastLogin The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				LastLogin *string `json:"last_login,omitempty"`

				// Locale The user locale
				Locale *string `json:"locale,omitempty"`

				// Modified The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
				Modified *string `json:"modified"`

				// Name The user name
				Name *string `json:"name,omitempty"`

				// Phone The user phone
				Phone *string `json:"phone"`

				// RoleId The ID of the user role
				RoleId *int `json:"role_id,omitempty"`

				// TimezoneName The user timezone name
				TimezoneName *string `json:"timezone_name,omitempty"`

				// TimezoneOffset The user timezone offset
				TimezoneOffset *string `json:"timezone_offset,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserPermissionsResponse parses an HTTP response from a GetUserPermissionsWithResponse call
func ParseGetUserPermissionsResponse(rsp *http.Response) (*GetUserPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// CanAddCustomFields If the user can add custom fields
				CanAddCustomFields *bool `json:"can_add_custom_fields,omitempty"`

				// CanAddProducts If the user can add products
				CanAddProducts *bool `json:"can_add_products,omitempty"`

				// CanAddProspectsAsLeads If the user can add prospects as leads
				CanAddProspectsAsLeads *bool `json:"can_add_prospects_as_leads,omitempty"`

				// CanBulkEditItems If the user can bulk edit items
				CanBulkEditItems *bool `json:"can_bulk_edit_items,omitempty"`

				// CanChangeVisibilityOfItems If the user can change visibility of items
				CanChangeVisibilityOfItems *bool `json:"can_change_visibility_of_items,omitempty"`

				// CanConvertDealsToLeads If the user can convert deals to leads
				CanConvertDealsToLeads *bool `json:"can_convert_deals_to_leads,omitempty"`

				// CanCreateOwnWorkflow If the user can create workflows
				CanCreateOwnWorkflow *bool `json:"can_create_own_workflow,omitempty"`

				// CanDeleteActivities If the user can delete activities
				CanDeleteActivities *bool `json:"can_delete_activities,omitempty"`

				// CanDeleteCustomFields If the user can delete custom fields
				CanDeleteCustomFields *bool `json:"can_delete_custom_fields,omitempty"`

				// CanDeleteDeals If the user can delete deals
				CanDeleteDeals *bool `json:"can_delete_deals,omitempty"`

				// CanEditCustomFields If the user can edit custom fields
				CanEditCustomFields *bool `json:"can_edit_custom_fields,omitempty"`

				// CanEditDealsClosedDate If the user can edit deals' closed date
				CanEditDealsClosedDate *bool `json:"can_edit_deals_closed_date,omitempty"`

				// CanEditProducts If the user can edit products
				CanEditProducts *bool `json:"can_edit_products,omitempty"`

				// CanEditSharedFilters If the user can edit shared filters
				CanEditSharedFilters *bool `json:"can_edit_shared_filters,omitempty"`

				// CanExportDataFromLists If the user can export data from item lists
				CanExportDataFromLists *bool `json:"can_export_data_from_lists,omitempty"`

				// CanFollowOtherUsers If the user can follow other users
				CanFollowOtherUsers *bool `json:"can_follow_other_users,omitempty"`

				// CanMergeDeals If the user can merge deals
				CanMergeDeals *bool `json:"can_merge_deals,omitempty"`

				// CanMergeOrganizations If the user can merge organizations
				CanMergeOrganizations *bool `json:"can_merge_organizations,omitempty"`

				// CanMergePeople If the user can merge people
				CanMergePeople *bool `json:"can_merge_people,omitempty"`

				// CanModifyLabels If the user can modify labels
				CanModifyLabels *bool `json:"can_modify_labels,omitempty"`

				// CanSeeCompanyWideStatistics If the user can see company-wide statistics
				CanSeeCompanyWideStatistics *bool `json:"can_see_company_wide_statistics,omitempty"`

				// CanSeeDealsListSummary If the user can see the summary on the deals page
				CanSeeDealsListSummary *bool `json:"can_see_deals_list_summary,omitempty"`

				// CanSeeHiddenItemsNames If the user can see the names of hidden items
				CanSeeHiddenItemsNames *bool `json:"can_see_hidden_items_names,omitempty"`

				// CanSeeOtherUsers If the user can see other users
				CanSeeOtherUsers *bool `json:"can_see_other_users,omitempty"`

				// CanSeeOtherUsersStatistics If the user can see other users' statistics
				CanSeeOtherUsersStatistics *bool `json:"can_see_other_users_statistics,omitempty"`

				// CanSeeSecurityDashboard If the user can see security dashboard
				CanSeeSecurityDashboard *bool `json:"can_see_security_dashboard,omitempty"`

				// CanShareFilters If the user can share filters
				CanShareFilters *bool `json:"can_share_filters,omitempty"`

				// CanShareInsights If the user can share insights
				CanShareInsights *bool `json:"can_share_insights,omitempty"`

				// CanUseApi If the user can use API
				CanUseApi *bool `json:"can_use_api,omitempty"`

				// CanUseEmailTracking If the user can use email tracking
				CanUseEmailTracking *bool `json:"can_use_email_tracking,omitempty"`

				// CanUseImport If the user can use import
				CanUseImport *bool `json:"can_use_import,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserRoleAssignmentsResponse parses an HTTP response from a GetUserRoleAssignmentsWithResponse call
func ParseGetUserRoleAssignmentsResponse(rsp *http.Response) (*GetUserRoleAssignmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserRoleAssignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data in the role list
			AdditionalData *struct {
				// Pagination The pagination details in the role list
				Pagination *struct {
					// Limit Items shown per page
					Limit *int `json:"limit,omitempty"`

					// MoreItemsInCollection Whether there are more list items in the collection than displayed
					MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`

					// Start Pagination start
					Start *int `json:"start,omitempty"`
				} `json:"pagination,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The role assignments
			Data *[]struct {
				// ActiveFlag Whether the role is active or not
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// Name The name of the role
				Name *string `json:"name,omitempty"`

				// ParentRoleId The ID of the parent role
				ParentRoleId *int `json:"parent_role_id"`

				// RoleId The role ID
				RoleId *int `json:"role_id,omitempty"`

				// Type The assignment type
				Type *string `json:"type,omitempty"`

				// UserId The user ID
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserRoleSettingsResponse parses an HTTP response from a GetUserRoleSettingsWithResponse call
func ParseGetUserRoleSettingsResponse(rsp *http.Response) (*GetUserRoleSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserRoleSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The settings for the role
			Data *struct {
				// DealAccessLevel The access level of the deals for the role (only for default role)
				DealAccessLevel *float32 `json:"deal_access_level,omitempty"`

				// DealDefaultVisibility The default visibility level of the deals for the role
				DealDefaultVisibility *float32 `json:"deal_default_visibility,omitempty"`

				// LeadDefaultVisibility The default visibility level of the leads for the role
				LeadDefaultVisibility *float32 `json:"lead_default_visibility,omitempty"`

				// OrgAccessLevel The access level of the organizations for the role (only for default role)
				OrgAccessLevel *float32 `json:"org_access_level,omitempty"`

				// OrgDefaultVisibility The default visibility level of the organizations for the role
				OrgDefaultVisibility *float32 `json:"org_default_visibility,omitempty"`

				// PersonAccessLevel The access level of the people for the role (only for default role)
				PersonAccessLevel *float32 `json:"person_access_level,omitempty"`

				// PersonDefaultVisibility The default visibility level of the people for the role
				PersonDefaultVisibility *float32 `json:"person_default_visibility,omitempty"`

				// ProductAccessLevel The access level of the products for the role (only for default role)
				ProductAccessLevel *float32 `json:"product_access_level,omitempty"`

				// ProductDefaultVisibility The default visibility level of the products for the role
				ProductDefaultVisibility *float32 `json:"product_default_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWebhooksResponse parses an HTTP response from a GetWebhooksWithResponse call
func ParseGetWebhooksResponse(rsp *http.Response) (*GetWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The array of Webhooks
			Data *[]struct {
				// AddTime The date when the Webhook was added
				AddTime *time.Time `json:"add_time,omitempty"`

				// AdminId The ID of the admin of the Webhook
				AdminId *int `json:"admin_id,omitempty"`

				// CompanyId The ID of the company related to the Webhook
				CompanyId *int `json:"company_id,omitempty"`

				// EventAction The Webhook action
				EventAction *string `json:"event_action,omitempty"`

				// EventObject The Webhook object
				EventObject *string `json:"event_object,omitempty"`

				// HttpAuthPassword The password of the `subscription_url` of the Webhook
				HttpAuthPassword *string `json:"http_auth_password"`

				// HttpAuthUser The username of the `subscription_url` of the Webhook
				HttpAuthUser *string `json:"http_auth_user"`

				// Id The ID of the Webhook
				Id *int `json:"id,omitempty"`

				// IsActive The Webhook's status
				IsActive *GetWebhooks200DataIsActive `json:"is_active,omitempty"`

				// LastDeliveryTime The last delivery time of the Webhook
				LastDeliveryTime *time.Time `json:"last_delivery_time"`

				// LastHttpStatus The last delivery HTTP status of the Webhook
				LastHttpStatus *int `json:"last_http_status"`

				// Name The Webhook name
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the user who owns the Webhook
				OwnerId *int `json:"owner_id,omitempty"`

				// RemoveReason The removal reason of the Webhook (if removed)
				RemoveReason *string `json:"remove_reason"`

				// RemoveTime The date when the Webhook was removed (if removed)
				RemoveTime *time.Time `json:"remove_time"`

				// SubscriptionUrl The subscription URL of the Webhook
				SubscriptionUrl *string `json:"subscription_url,omitempty"`

				// Type The type of the Webhook
				Type *GetWebhooks200DataType `json:"type,omitempty"`

				// UserId The ID of the user related to the Webhook
				UserId *int `json:"user_id,omitempty"`

				// Version The Webhook version
				Version *string `json:"version,omitempty"`
			} `json:"data,omitempty"`

			// Status The status of the response
			Status *string `json:"status,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// ErrorCode The response error code
			ErrorCode *int `json:"errorCode,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAddWebhookResponse parses an HTTP response from a AddWebhookWithResponse call
func ParseAddWebhookResponse(rsp *http.Response) (*AddWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// AddTime The date when the Webhook was added
				AddTime *time.Time `json:"add_time,omitempty"`

				// AdminId The ID of the admin of the Webhook
				AdminId *int `json:"admin_id,omitempty"`

				// CompanyId The ID of the company related to the Webhook
				CompanyId *int `json:"company_id,omitempty"`

				// EventAction The Webhook action
				EventAction *string `json:"event_action,omitempty"`

				// EventObject The Webhook object
				EventObject *string `json:"event_object,omitempty"`

				// HttpAuthPassword The password of the `subscription_url` of the Webhook
				HttpAuthPassword *string `json:"http_auth_password"`

				// HttpAuthUser The username of the `subscription_url` of the Webhook
				HttpAuthUser *string `json:"http_auth_user"`

				// Id The ID of the Webhook
				Id *int `json:"id,omitempty"`

				// IsActive The Webhook's status
				IsActive *AddWebhook201DataIsActive `json:"is_active,omitempty"`

				// LastDeliveryTime The last delivery time of the Webhook
				LastDeliveryTime *time.Time `json:"last_delivery_time"`

				// LastHttpStatus The last delivery HTTP status of the Webhook
				LastHttpStatus *int `json:"last_http_status"`

				// Name The Webhook name
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the user who owns the Webhook
				OwnerId *int `json:"owner_id,omitempty"`

				// RemoveReason The removal reason of the Webhook (if removed)
				RemoveReason *string `json:"remove_reason"`

				// RemoveTime The date when the Webhook was removed (if removed)
				RemoveTime *time.Time `json:"remove_time"`

				// SubscriptionUrl The subscription URL of the Webhook
				SubscriptionUrl *string `json:"subscription_url,omitempty"`

				// Type The type of the Webhook
				Type *AddWebhook201DataType `json:"type,omitempty"`

				// UserId The ID of the user related to the Webhook
				UserId *int `json:"user_id,omitempty"`

				// Version The Webhook version
				Version *string `json:"version,omitempty"`
			} `json:"data,omitempty"`

			// Status The status of the response
			Status *string `json:"status,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Errors List of errors
			Errors *map[string]interface{} `json:"errors,omitempty"`

			// Status The status of the response
			Status *string `json:"status,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// ErrorCode The response error code
			ErrorCode *int `json:"errorCode,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookResponse parses an HTTP response from a DeleteWebhookWithResponse call
func ParseDeleteWebhookResponse(rsp *http.Response) (*DeleteWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Status The status of the response
			Status *string `json:"status,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error The error message
			Error *string `json:"error,omitempty"`

			// ErrorCode The response error code
			ErrorCode *int `json:"errorCode,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Message The error message
			Message *string `json:"message,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Errors List of errors
			Errors *map[string]interface{} `json:"errors,omitempty"`

			// Status The status of the response
			Status *string `json:"status,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
