// Package v2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package v2

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Api_keyScopes = "api_key.Scopes"
	Oauth2Scopes  = "oauth2.Scopes"
)

// Defines values for GetActivitiesParamsSortBy.
const (
	GetActivitiesParamsSortByAddTime    GetActivitiesParamsSortBy = "add_time"
	GetActivitiesParamsSortByDueDate    GetActivitiesParamsSortBy = "due_date"
	GetActivitiesParamsSortById         GetActivitiesParamsSortBy = "id"
	GetActivitiesParamsSortByUpdateTime GetActivitiesParamsSortBy = "update_time"
)

// Defines values for GetActivitiesParamsSortDirection.
const (
	GetActivitiesParamsSortDirectionAsc  GetActivitiesParamsSortDirection = "asc"
	GetActivitiesParamsSortDirectionDesc GetActivitiesParamsSortDirection = "desc"
)

// Defines values for GetActivitiesParamsIncludeFields.
const (
	GetActivitiesParamsIncludeFieldsAttendees GetActivitiesParamsIncludeFields = "attendees"
)

// Defines values for GetActivityParamsIncludeFields.
const (
	GetActivityParamsIncludeFieldsAttendees GetActivityParamsIncludeFields = "attendees"
)

// Defines values for GetActivityFieldsParamsIncludeFields.
const (
	GetActivityFieldsParamsIncludeFieldsUiVisibility GetActivityFieldsParamsIncludeFields = "ui_visibility"
)

// Defines values for GetActivityFieldParamsIncludeFields.
const (
	GetActivityFieldParamsIncludeFieldsUiVisibility GetActivityFieldParamsIncludeFields = "ui_visibility"
)

// Defines values for GetDealFieldsParamsIncludeFields.
const (
	GetDealFieldsParamsIncludeFieldsImportantFields                           GetDealFieldsParamsIncludeFields = "important_fields"
	GetDealFieldsParamsIncludeFieldsImportantFieldsrequiredFields             GetDealFieldsParamsIncludeFields = "important_fields,required_fields"
	GetDealFieldsParamsIncludeFieldsRequiredFields                            GetDealFieldsParamsIncludeFields = "required_fields"
	GetDealFieldsParamsIncludeFieldsUiVisibility                              GetDealFieldsParamsIncludeFields = "ui_visibility"
	GetDealFieldsParamsIncludeFieldsUiVisibilityimportantFields               GetDealFieldsParamsIncludeFields = "ui_visibility,important_fields"
	GetDealFieldsParamsIncludeFieldsUiVisibilityimportantFieldsrequiredFields GetDealFieldsParamsIncludeFields = "ui_visibility,important_fields,required_fields"
	GetDealFieldsParamsIncludeFieldsUiVisibilityrequiredFields                GetDealFieldsParamsIncludeFields = "ui_visibility,required_fields"
)

// Defines values for AddDealFieldJSONBodyFieldType.
const (
	AddDealFieldJSONBodyFieldTypeAddress     AddDealFieldJSONBodyFieldType = "address"
	AddDealFieldJSONBodyFieldTypeDate        AddDealFieldJSONBodyFieldType = "date"
	AddDealFieldJSONBodyFieldTypeDaterange   AddDealFieldJSONBodyFieldType = "daterange"
	AddDealFieldJSONBodyFieldTypeDouble      AddDealFieldJSONBodyFieldType = "double"
	AddDealFieldJSONBodyFieldTypeEnum        AddDealFieldJSONBodyFieldType = "enum"
	AddDealFieldJSONBodyFieldTypeMonetary    AddDealFieldJSONBodyFieldType = "monetary"
	AddDealFieldJSONBodyFieldTypeOrg         AddDealFieldJSONBodyFieldType = "org"
	AddDealFieldJSONBodyFieldTypePeople      AddDealFieldJSONBodyFieldType = "people"
	AddDealFieldJSONBodyFieldTypePhone       AddDealFieldJSONBodyFieldType = "phone"
	AddDealFieldJSONBodyFieldTypeSet         AddDealFieldJSONBodyFieldType = "set"
	AddDealFieldJSONBodyFieldTypeText        AddDealFieldJSONBodyFieldType = "text"
	AddDealFieldJSONBodyFieldTypeTime        AddDealFieldJSONBodyFieldType = "time"
	AddDealFieldJSONBodyFieldTypeTimerange   AddDealFieldJSONBodyFieldType = "timerange"
	AddDealFieldJSONBodyFieldTypeUser        AddDealFieldJSONBodyFieldType = "user"
	AddDealFieldJSONBodyFieldTypeVarchar     AddDealFieldJSONBodyFieldType = "varchar"
	AddDealFieldJSONBodyFieldTypeVarcharAuto AddDealFieldJSONBodyFieldType = "varchar_auto"
)

// Defines values for AddDealFieldJSONBodyRequiredFieldsStatuses.
const (
	AddDealFieldJSONBodyRequiredFieldsStatusesLost AddDealFieldJSONBodyRequiredFieldsStatuses = "lost"
	AddDealFieldJSONBodyRequiredFieldsStatusesWon  AddDealFieldJSONBodyRequiredFieldsStatuses = "won"
)

// Defines values for GetDealFieldParamsIncludeFields.
const (
	GetDealFieldParamsIncludeFieldsImportantFields                           GetDealFieldParamsIncludeFields = "important_fields"
	GetDealFieldParamsIncludeFieldsImportantFieldsrequiredFields             GetDealFieldParamsIncludeFields = "important_fields,required_fields"
	GetDealFieldParamsIncludeFieldsRequiredFields                            GetDealFieldParamsIncludeFields = "required_fields"
	GetDealFieldParamsIncludeFieldsUiVisibility                              GetDealFieldParamsIncludeFields = "ui_visibility"
	GetDealFieldParamsIncludeFieldsUiVisibilityimportantFields               GetDealFieldParamsIncludeFields = "ui_visibility,important_fields"
	GetDealFieldParamsIncludeFieldsUiVisibilityimportantFieldsrequiredFields GetDealFieldParamsIncludeFields = "ui_visibility,important_fields,required_fields"
	GetDealFieldParamsIncludeFieldsUiVisibilityrequiredFields                GetDealFieldParamsIncludeFields = "ui_visibility,required_fields"
)

// Defines values for UpdateDealFieldJSONBodyRequiredFieldsStatuses.
const (
	UpdateDealFieldJSONBodyRequiredFieldsStatusesLost UpdateDealFieldJSONBodyRequiredFieldsStatuses = "lost"
	UpdateDealFieldJSONBodyRequiredFieldsStatusesWon  UpdateDealFieldJSONBodyRequiredFieldsStatuses = "won"
)

// Defines values for GetDealsParamsStatus.
const (
	GetDealsParamsStatusDeleted GetDealsParamsStatus = "deleted"
	GetDealsParamsStatusLost    GetDealsParamsStatus = "lost"
	GetDealsParamsStatusOpen    GetDealsParamsStatus = "open"
	GetDealsParamsStatusWon     GetDealsParamsStatus = "won"
)

// Defines values for GetDealsParamsSortBy.
const (
	GetDealsParamsSortByAddTime    GetDealsParamsSortBy = "add_time"
	GetDealsParamsSortById         GetDealsParamsSortBy = "id"
	GetDealsParamsSortByUpdateTime GetDealsParamsSortBy = "update_time"
)

// Defines values for GetDealsParamsSortDirection.
const (
	GetDealsParamsSortDirectionAsc  GetDealsParamsSortDirection = "asc"
	GetDealsParamsSortDirectionDesc GetDealsParamsSortDirection = "desc"
)

// Defines values for GetDealsParamsIncludeFields.
const (
	GetDealsParamsIncludeFieldsActivitiesCount       GetDealsParamsIncludeFields = "activities_count"
	GetDealsParamsIncludeFieldsDoneActivitiesCount   GetDealsParamsIncludeFields = "done_activities_count"
	GetDealsParamsIncludeFieldsEmailMessagesCount    GetDealsParamsIncludeFields = "email_messages_count"
	GetDealsParamsIncludeFieldsFilesCount            GetDealsParamsIncludeFields = "files_count"
	GetDealsParamsIncludeFieldsFirstWonTime          GetDealsParamsIncludeFields = "first_won_time"
	GetDealsParamsIncludeFieldsFollowersCount        GetDealsParamsIncludeFields = "followers_count"
	GetDealsParamsIncludeFieldsLastActivityId        GetDealsParamsIncludeFields = "last_activity_id"
	GetDealsParamsIncludeFieldsLastIncomingMailTime  GetDealsParamsIncludeFields = "last_incoming_mail_time"
	GetDealsParamsIncludeFieldsLastOutgoingMailTime  GetDealsParamsIncludeFields = "last_outgoing_mail_time"
	GetDealsParamsIncludeFieldsNextActivityId        GetDealsParamsIncludeFields = "next_activity_id"
	GetDealsParamsIncludeFieldsNotesCount            GetDealsParamsIncludeFields = "notes_count"
	GetDealsParamsIncludeFieldsParticipantsCount     GetDealsParamsIncludeFields = "participants_count"
	GetDealsParamsIncludeFieldsProductsCount         GetDealsParamsIncludeFields = "products_count"
	GetDealsParamsIncludeFieldsSmartBccEmail         GetDealsParamsIncludeFields = "smart_bcc_email"
	GetDealsParamsIncludeFieldsUndoneActivitiesCount GetDealsParamsIncludeFields = "undone_activities_count"
)

// Defines values for GetArchivedDealsParamsStatus.
const (
	GetArchivedDealsParamsStatusDeleted GetArchivedDealsParamsStatus = "deleted"
	GetArchivedDealsParamsStatusLost    GetArchivedDealsParamsStatus = "lost"
	GetArchivedDealsParamsStatusOpen    GetArchivedDealsParamsStatus = "open"
	GetArchivedDealsParamsStatusWon     GetArchivedDealsParamsStatus = "won"
)

// Defines values for GetArchivedDealsParamsSortBy.
const (
	GetArchivedDealsParamsSortByAddTime    GetArchivedDealsParamsSortBy = "add_time"
	GetArchivedDealsParamsSortById         GetArchivedDealsParamsSortBy = "id"
	GetArchivedDealsParamsSortByUpdateTime GetArchivedDealsParamsSortBy = "update_time"
)

// Defines values for GetArchivedDealsParamsSortDirection.
const (
	GetArchivedDealsParamsSortDirectionAsc  GetArchivedDealsParamsSortDirection = "asc"
	GetArchivedDealsParamsSortDirectionDesc GetArchivedDealsParamsSortDirection = "desc"
)

// Defines values for GetArchivedDealsParamsIncludeFields.
const (
	GetArchivedDealsParamsIncludeFieldsActivitiesCount       GetArchivedDealsParamsIncludeFields = "activities_count"
	GetArchivedDealsParamsIncludeFieldsDoneActivitiesCount   GetArchivedDealsParamsIncludeFields = "done_activities_count"
	GetArchivedDealsParamsIncludeFieldsEmailMessagesCount    GetArchivedDealsParamsIncludeFields = "email_messages_count"
	GetArchivedDealsParamsIncludeFieldsFilesCount            GetArchivedDealsParamsIncludeFields = "files_count"
	GetArchivedDealsParamsIncludeFieldsFirstWonTime          GetArchivedDealsParamsIncludeFields = "first_won_time"
	GetArchivedDealsParamsIncludeFieldsFollowersCount        GetArchivedDealsParamsIncludeFields = "followers_count"
	GetArchivedDealsParamsIncludeFieldsLastActivityId        GetArchivedDealsParamsIncludeFields = "last_activity_id"
	GetArchivedDealsParamsIncludeFieldsLastIncomingMailTime  GetArchivedDealsParamsIncludeFields = "last_incoming_mail_time"
	GetArchivedDealsParamsIncludeFieldsLastOutgoingMailTime  GetArchivedDealsParamsIncludeFields = "last_outgoing_mail_time"
	GetArchivedDealsParamsIncludeFieldsNextActivityId        GetArchivedDealsParamsIncludeFields = "next_activity_id"
	GetArchivedDealsParamsIncludeFieldsNotesCount            GetArchivedDealsParamsIncludeFields = "notes_count"
	GetArchivedDealsParamsIncludeFieldsParticipantsCount     GetArchivedDealsParamsIncludeFields = "participants_count"
	GetArchivedDealsParamsIncludeFieldsProductsCount         GetArchivedDealsParamsIncludeFields = "products_count"
	GetArchivedDealsParamsIncludeFieldsSmartBccEmail         GetArchivedDealsParamsIncludeFields = "smart_bcc_email"
	GetArchivedDealsParamsIncludeFieldsUndoneActivitiesCount GetArchivedDealsParamsIncludeFields = "undone_activities_count"
)

// Defines values for GetInstallmentsParamsSortBy.
const (
	GetInstallmentsParamsSortByBillingDate GetInstallmentsParamsSortBy = "billing_date"
	GetInstallmentsParamsSortByDealId      GetInstallmentsParamsSortBy = "deal_id"
	GetInstallmentsParamsSortById          GetInstallmentsParamsSortBy = "id"
)

// Defines values for GetInstallmentsParamsSortDirection.
const (
	GetInstallmentsParamsSortDirectionAsc  GetInstallmentsParamsSortDirection = "asc"
	GetInstallmentsParamsSortDirectionDesc GetInstallmentsParamsSortDirection = "desc"
)

// Defines values for GetDealsProductsParamsSortBy.
const (
	GetDealsProductsParamsSortByAddTime    GetDealsProductsParamsSortBy = "add_time"
	GetDealsProductsParamsSortByDealId     GetDealsProductsParamsSortBy = "deal_id"
	GetDealsProductsParamsSortById         GetDealsProductsParamsSortBy = "id"
	GetDealsProductsParamsSortByOrderNr    GetDealsProductsParamsSortBy = "order_nr"
	GetDealsProductsParamsSortByUpdateTime GetDealsProductsParamsSortBy = "update_time"
)

// Defines values for GetDealsProductsParamsSortDirection.
const (
	GetDealsProductsParamsSortDirectionAsc  GetDealsProductsParamsSortDirection = "asc"
	GetDealsProductsParamsSortDirectionDesc GetDealsProductsParamsSortDirection = "desc"
)

// Defines values for SearchDealsParamsFields.
const (
	SearchDealsParamsFieldsCustomFields SearchDealsParamsFields = "custom_fields"
	SearchDealsParamsFieldsNotes        SearchDealsParamsFields = "notes"
	SearchDealsParamsFieldsTitle        SearchDealsParamsFields = "title"
)

// Defines values for SearchDealsParamsStatus.
const (
	Lost SearchDealsParamsStatus = "lost"
	Open SearchDealsParamsStatus = "open"
	Won  SearchDealsParamsStatus = "won"
)

// Defines values for SearchDealsParamsIncludeFields.
const (
	SearchDealsParamsIncludeFieldsDealCcEmail SearchDealsParamsIncludeFields = "deal.cc_email"
)

// Defines values for GetDealParamsIncludeFields.
const (
	GetDealParamsIncludeFieldsActivitiesCount       GetDealParamsIncludeFields = "activities_count"
	GetDealParamsIncludeFieldsDoneActivitiesCount   GetDealParamsIncludeFields = "done_activities_count"
	GetDealParamsIncludeFieldsEmailMessagesCount    GetDealParamsIncludeFields = "email_messages_count"
	GetDealParamsIncludeFieldsFilesCount            GetDealParamsIncludeFields = "files_count"
	GetDealParamsIncludeFieldsFirstWonTime          GetDealParamsIncludeFields = "first_won_time"
	GetDealParamsIncludeFieldsFollowersCount        GetDealParamsIncludeFields = "followers_count"
	GetDealParamsIncludeFieldsLastActivityId        GetDealParamsIncludeFields = "last_activity_id"
	GetDealParamsIncludeFieldsLastIncomingMailTime  GetDealParamsIncludeFields = "last_incoming_mail_time"
	GetDealParamsIncludeFieldsLastOutgoingMailTime  GetDealParamsIncludeFields = "last_outgoing_mail_time"
	GetDealParamsIncludeFieldsNextActivityId        GetDealParamsIncludeFields = "next_activity_id"
	GetDealParamsIncludeFieldsNotesCount            GetDealParamsIncludeFields = "notes_count"
	GetDealParamsIncludeFieldsParticipantsCount     GetDealParamsIncludeFields = "participants_count"
	GetDealParamsIncludeFieldsProductsCount         GetDealParamsIncludeFields = "products_count"
	GetDealParamsIncludeFieldsSmartBccEmail         GetDealParamsIncludeFields = "smart_bcc_email"
	GetDealParamsIncludeFieldsUndoneActivitiesCount GetDealParamsIncludeFields = "undone_activities_count"
)

// Defines values for PostAdditionalDiscountJSONBodyType.
const (
	PostAdditionalDiscountJSONBodyTypeAmount     PostAdditionalDiscountJSONBodyType = "amount"
	PostAdditionalDiscountJSONBodyTypePercentage PostAdditionalDiscountJSONBodyType = "percentage"
)

// Defines values for UpdateAdditionalDiscountJSONBodyType.
const (
	UpdateAdditionalDiscountJSONBodyTypeAmount     UpdateAdditionalDiscountJSONBodyType = "amount"
	UpdateAdditionalDiscountJSONBodyTypePercentage UpdateAdditionalDiscountJSONBodyType = "percentage"
)

// Defines values for GetDealProductsParamsSortBy.
const (
	GetDealProductsParamsSortByAddTime    GetDealProductsParamsSortBy = "add_time"
	GetDealProductsParamsSortById         GetDealProductsParamsSortBy = "id"
	GetDealProductsParamsSortByOrderNr    GetDealProductsParamsSortBy = "order_nr"
	GetDealProductsParamsSortByUpdateTime GetDealProductsParamsSortBy = "update_time"
)

// Defines values for GetDealProductsParamsSortDirection.
const (
	GetDealProductsParamsSortDirectionAsc  GetDealProductsParamsSortDirection = "asc"
	GetDealProductsParamsSortDirectionDesc GetDealProductsParamsSortDirection = "desc"
)

// Defines values for AddDealProductJSONBodyBillingFrequency.
const (
	AddDealProductJSONBodyBillingFrequencyAnnually     AddDealProductJSONBodyBillingFrequency = "annually"
	AddDealProductJSONBodyBillingFrequencyMonthly      AddDealProductJSONBodyBillingFrequency = "monthly"
	AddDealProductJSONBodyBillingFrequencyOneTime      AddDealProductJSONBodyBillingFrequency = "one-time"
	AddDealProductJSONBodyBillingFrequencyQuarterly    AddDealProductJSONBodyBillingFrequency = "quarterly"
	AddDealProductJSONBodyBillingFrequencySemiAnnually AddDealProductJSONBodyBillingFrequency = "semi-annually"
	AddDealProductJSONBodyBillingFrequencyWeekly       AddDealProductJSONBodyBillingFrequency = "weekly"
)

// Defines values for AddDealProductJSONBodyDiscountType.
const (
	AddDealProductJSONBodyDiscountTypeAmount     AddDealProductJSONBodyDiscountType = "amount"
	AddDealProductJSONBodyDiscountTypePercentage AddDealProductJSONBodyDiscountType = "percentage"
)

// Defines values for AddDealProductJSONBodyTaxMethod.
const (
	AddDealProductJSONBodyTaxMethodExclusive AddDealProductJSONBodyTaxMethod = "exclusive"
	AddDealProductJSONBodyTaxMethodInclusive AddDealProductJSONBodyTaxMethod = "inclusive"
	AddDealProductJSONBodyTaxMethodNone      AddDealProductJSONBodyTaxMethod = "none"
)

// Defines values for AddManyDealProductsJSONBodyDataBillingFrequency.
const (
	AddManyDealProductsJSONBodyDataBillingFrequencyAnnually     AddManyDealProductsJSONBodyDataBillingFrequency = "annually"
	AddManyDealProductsJSONBodyDataBillingFrequencyMonthly      AddManyDealProductsJSONBodyDataBillingFrequency = "monthly"
	AddManyDealProductsJSONBodyDataBillingFrequencyOneTime      AddManyDealProductsJSONBodyDataBillingFrequency = "one-time"
	AddManyDealProductsJSONBodyDataBillingFrequencyQuarterly    AddManyDealProductsJSONBodyDataBillingFrequency = "quarterly"
	AddManyDealProductsJSONBodyDataBillingFrequencySemiAnnually AddManyDealProductsJSONBodyDataBillingFrequency = "semi-annually"
	AddManyDealProductsJSONBodyDataBillingFrequencyWeekly       AddManyDealProductsJSONBodyDataBillingFrequency = "weekly"
)

// Defines values for AddManyDealProductsJSONBodyDataDiscountType.
const (
	AddManyDealProductsJSONBodyDataDiscountTypeAmount     AddManyDealProductsJSONBodyDataDiscountType = "amount"
	AddManyDealProductsJSONBodyDataDiscountTypePercentage AddManyDealProductsJSONBodyDataDiscountType = "percentage"
)

// Defines values for AddManyDealProductsJSONBodyDataTaxMethod.
const (
	AddManyDealProductsJSONBodyDataTaxMethodExclusive AddManyDealProductsJSONBodyDataTaxMethod = "exclusive"
	AddManyDealProductsJSONBodyDataTaxMethodInclusive AddManyDealProductsJSONBodyDataTaxMethod = "inclusive"
	AddManyDealProductsJSONBodyDataTaxMethodNone      AddManyDealProductsJSONBodyDataTaxMethod = "none"
)

// Defines values for UpdateDealProductJSONBodyBillingFrequency.
const (
	UpdateDealProductJSONBodyBillingFrequencyAnnually     UpdateDealProductJSONBodyBillingFrequency = "annually"
	UpdateDealProductJSONBodyBillingFrequencyMonthly      UpdateDealProductJSONBodyBillingFrequency = "monthly"
	UpdateDealProductJSONBodyBillingFrequencyOneTime      UpdateDealProductJSONBodyBillingFrequency = "one-time"
	UpdateDealProductJSONBodyBillingFrequencyQuarterly    UpdateDealProductJSONBodyBillingFrequency = "quarterly"
	UpdateDealProductJSONBodyBillingFrequencySemiAnnually UpdateDealProductJSONBodyBillingFrequency = "semi-annually"
	UpdateDealProductJSONBodyBillingFrequencyWeekly       UpdateDealProductJSONBodyBillingFrequency = "weekly"
)

// Defines values for UpdateDealProductJSONBodyDiscountType.
const (
	Amount     UpdateDealProductJSONBodyDiscountType = "amount"
	Percentage UpdateDealProductJSONBodyDiscountType = "percentage"
)

// Defines values for UpdateDealProductJSONBodyTaxMethod.
const (
	Exclusive UpdateDealProductJSONBodyTaxMethod = "exclusive"
	Inclusive UpdateDealProductJSONBodyTaxMethod = "inclusive"
	None      UpdateDealProductJSONBodyTaxMethod = "none"
)

// Defines values for SearchItemParamsItemTypes.
const (
	SearchItemParamsItemTypesDeal           SearchItemParamsItemTypes = "deal"
	SearchItemParamsItemTypesFile           SearchItemParamsItemTypes = "file"
	SearchItemParamsItemTypesLead           SearchItemParamsItemTypes = "lead"
	SearchItemParamsItemTypesMailAttachment SearchItemParamsItemTypes = "mail_attachment"
	SearchItemParamsItemTypesOrganization   SearchItemParamsItemTypes = "organization"
	SearchItemParamsItemTypesPerson         SearchItemParamsItemTypes = "person"
	SearchItemParamsItemTypesProduct        SearchItemParamsItemTypes = "product"
	SearchItemParamsItemTypesProject        SearchItemParamsItemTypes = "project"
)

// Defines values for SearchItemParamsFields.
const (
	SearchItemParamsFieldsAddress      SearchItemParamsFields = "address"
	SearchItemParamsFieldsCode         SearchItemParamsFields = "code"
	SearchItemParamsFieldsCustomFields SearchItemParamsFields = "custom_fields"
	SearchItemParamsFieldsDescription  SearchItemParamsFields = "description"
	SearchItemParamsFieldsEmail        SearchItemParamsFields = "email"
	SearchItemParamsFieldsName         SearchItemParamsFields = "name"
	SearchItemParamsFieldsNotes        SearchItemParamsFields = "notes"
	SearchItemParamsFieldsPhone        SearchItemParamsFields = "phone"
	SearchItemParamsFieldsTitle        SearchItemParamsFields = "title"
)

// Defines values for SearchItemParamsIncludeFields.
const (
	SearchItemParamsIncludeFieldsDealCcEmail   SearchItemParamsIncludeFields = "deal.cc_email"
	SearchItemParamsIncludeFieldsPersonPicture SearchItemParamsIncludeFields = "person.picture"
	SearchItemParamsIncludeFieldsProductPrice  SearchItemParamsIncludeFields = "product.price"
)

// Defines values for SearchItemByFieldParamsEntityType.
const (
	SearchItemByFieldParamsEntityTypeDeal         SearchItemByFieldParamsEntityType = "deal"
	SearchItemByFieldParamsEntityTypeLead         SearchItemByFieldParamsEntityType = "lead"
	SearchItemByFieldParamsEntityTypeOrganization SearchItemByFieldParamsEntityType = "organization"
	SearchItemByFieldParamsEntityTypePerson       SearchItemByFieldParamsEntityType = "person"
	SearchItemByFieldParamsEntityTypeProduct      SearchItemByFieldParamsEntityType = "product"
	SearchItemByFieldParamsEntityTypeProject      SearchItemByFieldParamsEntityType = "project"
)

// Defines values for SearchItemByFieldParamsMatch.
const (
	Beginning SearchItemByFieldParamsMatch = "beginning"
	Exact     SearchItemByFieldParamsMatch = "exact"
	Middle    SearchItemByFieldParamsMatch = "middle"
)

// Defines values for SearchLeadsParamsFields.
const (
	SearchLeadsParamsFieldsCustomFields SearchLeadsParamsFields = "custom_fields"
	SearchLeadsParamsFieldsNotes        SearchLeadsParamsFields = "notes"
	SearchLeadsParamsFieldsTitle        SearchLeadsParamsFields = "title"
)

// Defines values for SearchLeadsParamsIncludeFields.
const (
	LeadWasSeen SearchLeadsParamsIncludeFields = "lead.was_seen"
)

// Defines values for GetOrganizationFieldsParamsIncludeFields.
const (
	GetOrganizationFieldsParamsIncludeFieldsImportantFields                           GetOrganizationFieldsParamsIncludeFields = "important_fields"
	GetOrganizationFieldsParamsIncludeFieldsImportantFieldsrequiredFields             GetOrganizationFieldsParamsIncludeFields = "important_fields,required_fields"
	GetOrganizationFieldsParamsIncludeFieldsRequiredFields                            GetOrganizationFieldsParamsIncludeFields = "required_fields"
	GetOrganizationFieldsParamsIncludeFieldsUiVisibility                              GetOrganizationFieldsParamsIncludeFields = "ui_visibility"
	GetOrganizationFieldsParamsIncludeFieldsUiVisibilityimportantFields               GetOrganizationFieldsParamsIncludeFields = "ui_visibility,important_fields"
	GetOrganizationFieldsParamsIncludeFieldsUiVisibilityimportantFieldsrequiredFields GetOrganizationFieldsParamsIncludeFields = "ui_visibility,important_fields,required_fields"
	GetOrganizationFieldsParamsIncludeFieldsUiVisibilityrequiredFields                GetOrganizationFieldsParamsIncludeFields = "ui_visibility,required_fields"
)

// Defines values for AddOrganizationFieldJSONBodyFieldType.
const (
	AddOrganizationFieldJSONBodyFieldTypeAddress     AddOrganizationFieldJSONBodyFieldType = "address"
	AddOrganizationFieldJSONBodyFieldTypeDate        AddOrganizationFieldJSONBodyFieldType = "date"
	AddOrganizationFieldJSONBodyFieldTypeDaterange   AddOrganizationFieldJSONBodyFieldType = "daterange"
	AddOrganizationFieldJSONBodyFieldTypeDouble      AddOrganizationFieldJSONBodyFieldType = "double"
	AddOrganizationFieldJSONBodyFieldTypeEnum        AddOrganizationFieldJSONBodyFieldType = "enum"
	AddOrganizationFieldJSONBodyFieldTypeMonetary    AddOrganizationFieldJSONBodyFieldType = "monetary"
	AddOrganizationFieldJSONBodyFieldTypeOrg         AddOrganizationFieldJSONBodyFieldType = "org"
	AddOrganizationFieldJSONBodyFieldTypePeople      AddOrganizationFieldJSONBodyFieldType = "people"
	AddOrganizationFieldJSONBodyFieldTypePhone       AddOrganizationFieldJSONBodyFieldType = "phone"
	AddOrganizationFieldJSONBodyFieldTypeSet         AddOrganizationFieldJSONBodyFieldType = "set"
	AddOrganizationFieldJSONBodyFieldTypeText        AddOrganizationFieldJSONBodyFieldType = "text"
	AddOrganizationFieldJSONBodyFieldTypeTime        AddOrganizationFieldJSONBodyFieldType = "time"
	AddOrganizationFieldJSONBodyFieldTypeTimerange   AddOrganizationFieldJSONBodyFieldType = "timerange"
	AddOrganizationFieldJSONBodyFieldTypeUser        AddOrganizationFieldJSONBodyFieldType = "user"
	AddOrganizationFieldJSONBodyFieldTypeVarchar     AddOrganizationFieldJSONBodyFieldType = "varchar"
	AddOrganizationFieldJSONBodyFieldTypeVarcharAuto AddOrganizationFieldJSONBodyFieldType = "varchar_auto"
)

// Defines values for GetOrganizationFieldParamsIncludeFields.
const (
	GetOrganizationFieldParamsIncludeFieldsImportantFields                           GetOrganizationFieldParamsIncludeFields = "important_fields"
	GetOrganizationFieldParamsIncludeFieldsImportantFieldsrequiredFields             GetOrganizationFieldParamsIncludeFields = "important_fields,required_fields"
	GetOrganizationFieldParamsIncludeFieldsRequiredFields                            GetOrganizationFieldParamsIncludeFields = "required_fields"
	GetOrganizationFieldParamsIncludeFieldsUiVisibility                              GetOrganizationFieldParamsIncludeFields = "ui_visibility"
	GetOrganizationFieldParamsIncludeFieldsUiVisibilityimportantFields               GetOrganizationFieldParamsIncludeFields = "ui_visibility,important_fields"
	GetOrganizationFieldParamsIncludeFieldsUiVisibilityimportantFieldsrequiredFields GetOrganizationFieldParamsIncludeFields = "ui_visibility,important_fields,required_fields"
	GetOrganizationFieldParamsIncludeFieldsUiVisibilityrequiredFields                GetOrganizationFieldParamsIncludeFields = "ui_visibility,required_fields"
)

// Defines values for GetOrganizationsParamsSortBy.
const (
	GetOrganizationsParamsSortByAddTime    GetOrganizationsParamsSortBy = "add_time"
	GetOrganizationsParamsSortById         GetOrganizationsParamsSortBy = "id"
	GetOrganizationsParamsSortByUpdateTime GetOrganizationsParamsSortBy = "update_time"
)

// Defines values for GetOrganizationsParamsSortDirection.
const (
	GetOrganizationsParamsSortDirectionAsc  GetOrganizationsParamsSortDirection = "asc"
	GetOrganizationsParamsSortDirectionDesc GetOrganizationsParamsSortDirection = "desc"
)

// Defines values for GetOrganizationsParamsIncludeFields.
const (
	GetOrganizationsParamsIncludeFieldsActivitiesCount         GetOrganizationsParamsIncludeFields = "activities_count"
	GetOrganizationsParamsIncludeFieldsClosedDealsCount        GetOrganizationsParamsIncludeFields = "closed_deals_count"
	GetOrganizationsParamsIncludeFieldsDoneActivitiesCount     GetOrganizationsParamsIncludeFields = "done_activities_count"
	GetOrganizationsParamsIncludeFieldsEmailMessagesCount      GetOrganizationsParamsIncludeFields = "email_messages_count"
	GetOrganizationsParamsIncludeFieldsFilesCount              GetOrganizationsParamsIncludeFields = "files_count"
	GetOrganizationsParamsIncludeFieldsFollowersCount          GetOrganizationsParamsIncludeFields = "followers_count"
	GetOrganizationsParamsIncludeFieldsLastActivityId          GetOrganizationsParamsIncludeFields = "last_activity_id"
	GetOrganizationsParamsIncludeFieldsLostDealsCount          GetOrganizationsParamsIncludeFields = "lost_deals_count"
	GetOrganizationsParamsIncludeFieldsNextActivityId          GetOrganizationsParamsIncludeFields = "next_activity_id"
	GetOrganizationsParamsIncludeFieldsNotesCount              GetOrganizationsParamsIncludeFields = "notes_count"
	GetOrganizationsParamsIncludeFieldsOpenDealsCount          GetOrganizationsParamsIncludeFields = "open_deals_count"
	GetOrganizationsParamsIncludeFieldsPeopleCount             GetOrganizationsParamsIncludeFields = "people_count"
	GetOrganizationsParamsIncludeFieldsRelatedClosedDealsCount GetOrganizationsParamsIncludeFields = "related_closed_deals_count"
	GetOrganizationsParamsIncludeFieldsRelatedLostDealsCount   GetOrganizationsParamsIncludeFields = "related_lost_deals_count"
	GetOrganizationsParamsIncludeFieldsRelatedOpenDealsCount   GetOrganizationsParamsIncludeFields = "related_open_deals_count"
	GetOrganizationsParamsIncludeFieldsRelatedWonDealsCount    GetOrganizationsParamsIncludeFields = "related_won_deals_count"
	GetOrganizationsParamsIncludeFieldsUndoneActivitiesCount   GetOrganizationsParamsIncludeFields = "undone_activities_count"
	GetOrganizationsParamsIncludeFieldsWonDealsCount           GetOrganizationsParamsIncludeFields = "won_deals_count"
)

// Defines values for SearchOrganizationParamsFields.
const (
	SearchOrganizationParamsFieldsAddress      SearchOrganizationParamsFields = "address"
	SearchOrganizationParamsFieldsCustomFields SearchOrganizationParamsFields = "custom_fields"
	SearchOrganizationParamsFieldsName         SearchOrganizationParamsFields = "name"
	SearchOrganizationParamsFieldsNotes        SearchOrganizationParamsFields = "notes"
)

// Defines values for GetOrganizationParamsIncludeFields.
const (
	GetOrganizationParamsIncludeFieldsActivitiesCount         GetOrganizationParamsIncludeFields = "activities_count"
	GetOrganizationParamsIncludeFieldsClosedDealsCount        GetOrganizationParamsIncludeFields = "closed_deals_count"
	GetOrganizationParamsIncludeFieldsDoneActivitiesCount     GetOrganizationParamsIncludeFields = "done_activities_count"
	GetOrganizationParamsIncludeFieldsEmailMessagesCount      GetOrganizationParamsIncludeFields = "email_messages_count"
	GetOrganizationParamsIncludeFieldsFilesCount              GetOrganizationParamsIncludeFields = "files_count"
	GetOrganizationParamsIncludeFieldsFollowersCount          GetOrganizationParamsIncludeFields = "followers_count"
	GetOrganizationParamsIncludeFieldsLastActivityId          GetOrganizationParamsIncludeFields = "last_activity_id"
	GetOrganizationParamsIncludeFieldsLostDealsCount          GetOrganizationParamsIncludeFields = "lost_deals_count"
	GetOrganizationParamsIncludeFieldsNextActivityId          GetOrganizationParamsIncludeFields = "next_activity_id"
	GetOrganizationParamsIncludeFieldsNotesCount              GetOrganizationParamsIncludeFields = "notes_count"
	GetOrganizationParamsIncludeFieldsOpenDealsCount          GetOrganizationParamsIncludeFields = "open_deals_count"
	GetOrganizationParamsIncludeFieldsPeopleCount             GetOrganizationParamsIncludeFields = "people_count"
	GetOrganizationParamsIncludeFieldsRelatedClosedDealsCount GetOrganizationParamsIncludeFields = "related_closed_deals_count"
	GetOrganizationParamsIncludeFieldsRelatedLostDealsCount   GetOrganizationParamsIncludeFields = "related_lost_deals_count"
	GetOrganizationParamsIncludeFieldsRelatedOpenDealsCount   GetOrganizationParamsIncludeFields = "related_open_deals_count"
	GetOrganizationParamsIncludeFieldsRelatedWonDealsCount    GetOrganizationParamsIncludeFields = "related_won_deals_count"
	GetOrganizationParamsIncludeFieldsUndoneActivitiesCount   GetOrganizationParamsIncludeFields = "undone_activities_count"
	GetOrganizationParamsIncludeFieldsWonDealsCount           GetOrganizationParamsIncludeFields = "won_deals_count"
)

// Defines values for GetPersonFieldsParamsIncludeFields.
const (
	GetPersonFieldsParamsIncludeFieldsImportantFields                           GetPersonFieldsParamsIncludeFields = "important_fields"
	GetPersonFieldsParamsIncludeFieldsImportantFieldsrequiredFields             GetPersonFieldsParamsIncludeFields = "important_fields,required_fields"
	GetPersonFieldsParamsIncludeFieldsRequiredFields                            GetPersonFieldsParamsIncludeFields = "required_fields"
	GetPersonFieldsParamsIncludeFieldsUiVisibility                              GetPersonFieldsParamsIncludeFields = "ui_visibility"
	GetPersonFieldsParamsIncludeFieldsUiVisibilityimportantFields               GetPersonFieldsParamsIncludeFields = "ui_visibility,important_fields"
	GetPersonFieldsParamsIncludeFieldsUiVisibilityimportantFieldsrequiredFields GetPersonFieldsParamsIncludeFields = "ui_visibility,important_fields,required_fields"
	GetPersonFieldsParamsIncludeFieldsUiVisibilityrequiredFields                GetPersonFieldsParamsIncludeFields = "ui_visibility,required_fields"
)

// Defines values for AddPersonFieldJSONBodyFieldType.
const (
	AddPersonFieldJSONBodyFieldTypeAddress     AddPersonFieldJSONBodyFieldType = "address"
	AddPersonFieldJSONBodyFieldTypeDate        AddPersonFieldJSONBodyFieldType = "date"
	AddPersonFieldJSONBodyFieldTypeDaterange   AddPersonFieldJSONBodyFieldType = "daterange"
	AddPersonFieldJSONBodyFieldTypeDouble      AddPersonFieldJSONBodyFieldType = "double"
	AddPersonFieldJSONBodyFieldTypeEnum        AddPersonFieldJSONBodyFieldType = "enum"
	AddPersonFieldJSONBodyFieldTypeMonetary    AddPersonFieldJSONBodyFieldType = "monetary"
	AddPersonFieldJSONBodyFieldTypeOrg         AddPersonFieldJSONBodyFieldType = "org"
	AddPersonFieldJSONBodyFieldTypePeople      AddPersonFieldJSONBodyFieldType = "people"
	AddPersonFieldJSONBodyFieldTypePhone       AddPersonFieldJSONBodyFieldType = "phone"
	AddPersonFieldJSONBodyFieldTypeSet         AddPersonFieldJSONBodyFieldType = "set"
	AddPersonFieldJSONBodyFieldTypeText        AddPersonFieldJSONBodyFieldType = "text"
	AddPersonFieldJSONBodyFieldTypeTime        AddPersonFieldJSONBodyFieldType = "time"
	AddPersonFieldJSONBodyFieldTypeTimerange   AddPersonFieldJSONBodyFieldType = "timerange"
	AddPersonFieldJSONBodyFieldTypeUser        AddPersonFieldJSONBodyFieldType = "user"
	AddPersonFieldJSONBodyFieldTypeVarchar     AddPersonFieldJSONBodyFieldType = "varchar"
	AddPersonFieldJSONBodyFieldTypeVarcharAuto AddPersonFieldJSONBodyFieldType = "varchar_auto"
)

// Defines values for GetPersonFieldParamsIncludeFields.
const (
	GetPersonFieldParamsIncludeFieldsImportantFields                           GetPersonFieldParamsIncludeFields = "important_fields"
	GetPersonFieldParamsIncludeFieldsImportantFieldsrequiredFields             GetPersonFieldParamsIncludeFields = "important_fields,required_fields"
	GetPersonFieldParamsIncludeFieldsRequiredFields                            GetPersonFieldParamsIncludeFields = "required_fields"
	GetPersonFieldParamsIncludeFieldsUiVisibility                              GetPersonFieldParamsIncludeFields = "ui_visibility"
	GetPersonFieldParamsIncludeFieldsUiVisibilityimportantFields               GetPersonFieldParamsIncludeFields = "ui_visibility,important_fields"
	GetPersonFieldParamsIncludeFieldsUiVisibilityimportantFieldsrequiredFields GetPersonFieldParamsIncludeFields = "ui_visibility,important_fields,required_fields"
	GetPersonFieldParamsIncludeFieldsUiVisibilityrequiredFields                GetPersonFieldParamsIncludeFields = "ui_visibility,required_fields"
)

// Defines values for GetPersonsParamsSortBy.
const (
	GetPersonsParamsSortByAddTime    GetPersonsParamsSortBy = "add_time"
	GetPersonsParamsSortById         GetPersonsParamsSortBy = "id"
	GetPersonsParamsSortByUpdateTime GetPersonsParamsSortBy = "update_time"
)

// Defines values for GetPersonsParamsSortDirection.
const (
	GetPersonsParamsSortDirectionAsc  GetPersonsParamsSortDirection = "asc"
	GetPersonsParamsSortDirectionDesc GetPersonsParamsSortDirection = "desc"
)

// Defines values for GetPersonsParamsIncludeFields.
const (
	GetPersonsParamsIncludeFieldsActivitiesCount             GetPersonsParamsIncludeFields = "activities_count"
	GetPersonsParamsIncludeFieldsClosedDealsCount            GetPersonsParamsIncludeFields = "closed_deals_count"
	GetPersonsParamsIncludeFieldsDoiStatus                   GetPersonsParamsIncludeFields = "doi_status"
	GetPersonsParamsIncludeFieldsDoneActivitiesCount         GetPersonsParamsIncludeFields = "done_activities_count"
	GetPersonsParamsIncludeFieldsEmailMessagesCount          GetPersonsParamsIncludeFields = "email_messages_count"
	GetPersonsParamsIncludeFieldsFilesCount                  GetPersonsParamsIncludeFields = "files_count"
	GetPersonsParamsIncludeFieldsFollowersCount              GetPersonsParamsIncludeFields = "followers_count"
	GetPersonsParamsIncludeFieldsLastActivityId              GetPersonsParamsIncludeFields = "last_activity_id"
	GetPersonsParamsIncludeFieldsLastIncomingMailTime        GetPersonsParamsIncludeFields = "last_incoming_mail_time"
	GetPersonsParamsIncludeFieldsLastOutgoingMailTime        GetPersonsParamsIncludeFields = "last_outgoing_mail_time"
	GetPersonsParamsIncludeFieldsLostDealsCount              GetPersonsParamsIncludeFields = "lost_deals_count"
	GetPersonsParamsIncludeFieldsMarketingStatus             GetPersonsParamsIncludeFields = "marketing_status"
	GetPersonsParamsIncludeFieldsNextActivityId              GetPersonsParamsIncludeFields = "next_activity_id"
	GetPersonsParamsIncludeFieldsNotesCount                  GetPersonsParamsIncludeFields = "notes_count"
	GetPersonsParamsIncludeFieldsOpenDealsCount              GetPersonsParamsIncludeFields = "open_deals_count"
	GetPersonsParamsIncludeFieldsParticipantClosedDealsCount GetPersonsParamsIncludeFields = "participant_closed_deals_count"
	GetPersonsParamsIncludeFieldsParticipantOpenDealsCount   GetPersonsParamsIncludeFields = "participant_open_deals_count"
	GetPersonsParamsIncludeFieldsRelatedClosedDealsCount     GetPersonsParamsIncludeFields = "related_closed_deals_count"
	GetPersonsParamsIncludeFieldsRelatedLostDealsCount       GetPersonsParamsIncludeFields = "related_lost_deals_count"
	GetPersonsParamsIncludeFieldsRelatedOpenDealsCount       GetPersonsParamsIncludeFields = "related_open_deals_count"
	GetPersonsParamsIncludeFieldsRelatedWonDealsCount        GetPersonsParamsIncludeFields = "related_won_deals_count"
	GetPersonsParamsIncludeFieldsUndoneActivitiesCount       GetPersonsParamsIncludeFields = "undone_activities_count"
	GetPersonsParamsIncludeFieldsWonDealsCount               GetPersonsParamsIncludeFields = "won_deals_count"
)

// Defines values for AddPersonJSONBodyMarketingStatus.
const (
	AddPersonJSONBodyMarketingStatusArchived     AddPersonJSONBodyMarketingStatus = "archived"
	AddPersonJSONBodyMarketingStatusNoConsent    AddPersonJSONBodyMarketingStatus = "no_consent"
	AddPersonJSONBodyMarketingStatusSubscribed   AddPersonJSONBodyMarketingStatus = "subscribed"
	AddPersonJSONBodyMarketingStatusUnsubscribed AddPersonJSONBodyMarketingStatus = "unsubscribed"
)

// Defines values for SearchPersonsParamsFields.
const (
	SearchPersonsParamsFieldsCustomFields SearchPersonsParamsFields = "custom_fields"
	SearchPersonsParamsFieldsEmail        SearchPersonsParamsFields = "email"
	SearchPersonsParamsFieldsName         SearchPersonsParamsFields = "name"
	SearchPersonsParamsFieldsNotes        SearchPersonsParamsFields = "notes"
	SearchPersonsParamsFieldsPhone        SearchPersonsParamsFields = "phone"
)

// Defines values for SearchPersonsParamsIncludeFields.
const (
	PersonPicture SearchPersonsParamsIncludeFields = "person.picture"
)

// Defines values for GetPersonParamsIncludeFields.
const (
	ActivitiesCount             GetPersonParamsIncludeFields = "activities_count"
	ClosedDealsCount            GetPersonParamsIncludeFields = "closed_deals_count"
	DoiStatus                   GetPersonParamsIncludeFields = "doi_status"
	DoneActivitiesCount         GetPersonParamsIncludeFields = "done_activities_count"
	EmailMessagesCount          GetPersonParamsIncludeFields = "email_messages_count"
	FilesCount                  GetPersonParamsIncludeFields = "files_count"
	FollowersCount              GetPersonParamsIncludeFields = "followers_count"
	LastActivityId              GetPersonParamsIncludeFields = "last_activity_id"
	LastIncomingMailTime        GetPersonParamsIncludeFields = "last_incoming_mail_time"
	LastOutgoingMailTime        GetPersonParamsIncludeFields = "last_outgoing_mail_time"
	LostDealsCount              GetPersonParamsIncludeFields = "lost_deals_count"
	MarketingStatus             GetPersonParamsIncludeFields = "marketing_status"
	NextActivityId              GetPersonParamsIncludeFields = "next_activity_id"
	NotesCount                  GetPersonParamsIncludeFields = "notes_count"
	OpenDealsCount              GetPersonParamsIncludeFields = "open_deals_count"
	ParticipantClosedDealsCount GetPersonParamsIncludeFields = "participant_closed_deals_count"
	ParticipantOpenDealsCount   GetPersonParamsIncludeFields = "participant_open_deals_count"
	RelatedClosedDealsCount     GetPersonParamsIncludeFields = "related_closed_deals_count"
	RelatedLostDealsCount       GetPersonParamsIncludeFields = "related_lost_deals_count"
	RelatedOpenDealsCount       GetPersonParamsIncludeFields = "related_open_deals_count"
	RelatedWonDealsCount        GetPersonParamsIncludeFields = "related_won_deals_count"
	UndoneActivitiesCount       GetPersonParamsIncludeFields = "undone_activities_count"
	WonDealsCount               GetPersonParamsIncludeFields = "won_deals_count"
)

// Defines values for UpdatePersonJSONBodyMarketingStatus.
const (
	UpdatePersonJSONBodyMarketingStatusArchived     UpdatePersonJSONBodyMarketingStatus = "archived"
	UpdatePersonJSONBodyMarketingStatusNoConsent    UpdatePersonJSONBodyMarketingStatus = "no_consent"
	UpdatePersonJSONBodyMarketingStatusSubscribed   UpdatePersonJSONBodyMarketingStatus = "subscribed"
	UpdatePersonJSONBodyMarketingStatusUnsubscribed UpdatePersonJSONBodyMarketingStatus = "unsubscribed"
)

// Defines values for GetPipelinesParamsSortBy.
const (
	GetPipelinesParamsSortByAddTime    GetPipelinesParamsSortBy = "add_time"
	GetPipelinesParamsSortById         GetPipelinesParamsSortBy = "id"
	GetPipelinesParamsSortByUpdateTime GetPipelinesParamsSortBy = "update_time"
)

// Defines values for GetPipelinesParamsSortDirection.
const (
	GetPipelinesParamsSortDirectionAsc  GetPipelinesParamsSortDirection = "asc"
	GetPipelinesParamsSortDirectionDesc GetPipelinesParamsSortDirection = "desc"
)

// Defines values for GetProductFieldsParamsIncludeFields.
const (
	GetProductFieldsParamsIncludeFieldsUiVisibility GetProductFieldsParamsIncludeFields = "ui_visibility"
)

// Defines values for AddProductFieldJSONBodyFieldType.
const (
	Address     AddProductFieldJSONBodyFieldType = "address"
	Date        AddProductFieldJSONBodyFieldType = "date"
	Daterange   AddProductFieldJSONBodyFieldType = "daterange"
	Double      AddProductFieldJSONBodyFieldType = "double"
	Enum        AddProductFieldJSONBodyFieldType = "enum"
	Monetary    AddProductFieldJSONBodyFieldType = "monetary"
	Org         AddProductFieldJSONBodyFieldType = "org"
	People      AddProductFieldJSONBodyFieldType = "people"
	Phone       AddProductFieldJSONBodyFieldType = "phone"
	Set         AddProductFieldJSONBodyFieldType = "set"
	Text        AddProductFieldJSONBodyFieldType = "text"
	Time        AddProductFieldJSONBodyFieldType = "time"
	Timerange   AddProductFieldJSONBodyFieldType = "timerange"
	User        AddProductFieldJSONBodyFieldType = "user"
	Varchar     AddProductFieldJSONBodyFieldType = "varchar"
	VarcharAuto AddProductFieldJSONBodyFieldType = "varchar_auto"
)

// Defines values for GetProductFieldParamsIncludeFields.
const (
	GetProductFieldParamsIncludeFieldsUiVisibility GetProductFieldParamsIncludeFields = "ui_visibility"
)

// Defines values for GetProductsParamsSortBy.
const (
	GetProductsParamsSortByAddTime    GetProductsParamsSortBy = "add_time"
	GetProductsParamsSortById         GetProductsParamsSortBy = "id"
	GetProductsParamsSortByName       GetProductsParamsSortBy = "name"
	GetProductsParamsSortByUpdateTime GetProductsParamsSortBy = "update_time"
)

// Defines values for GetProductsParamsSortDirection.
const (
	GetProductsParamsSortDirectionAsc  GetProductsParamsSortDirection = "asc"
	GetProductsParamsSortDirectionDesc GetProductsParamsSortDirection = "desc"
)

// Defines values for AddProductJSONBodyBillingFrequency.
const (
	AddProductJSONBodyBillingFrequencyAnnually     AddProductJSONBodyBillingFrequency = "annually"
	AddProductJSONBodyBillingFrequencyMonthly      AddProductJSONBodyBillingFrequency = "monthly"
	AddProductJSONBodyBillingFrequencyOneTime      AddProductJSONBodyBillingFrequency = "one-time"
	AddProductJSONBodyBillingFrequencyQuarterly    AddProductJSONBodyBillingFrequency = "quarterly"
	AddProductJSONBodyBillingFrequencySemiAnnually AddProductJSONBodyBillingFrequency = "semi-annually"
	AddProductJSONBodyBillingFrequencyWeekly       AddProductJSONBodyBillingFrequency = "weekly"
)

// Defines values for AddProductJSONBodyVisibleTo.
const (
	AddProductJSONBodyVisibleToN1 AddProductJSONBodyVisibleTo = 1
	AddProductJSONBodyVisibleToN3 AddProductJSONBodyVisibleTo = 3
	AddProductJSONBodyVisibleToN5 AddProductJSONBodyVisibleTo = 5
	AddProductJSONBodyVisibleToN7 AddProductJSONBodyVisibleTo = 7
)

// Defines values for SearchProductsParamsFields.
const (
	Code         SearchProductsParamsFields = "code"
	CustomFields SearchProductsParamsFields = "custom_fields"
	Name         SearchProductsParamsFields = "name"
)

// Defines values for SearchProductsParamsIncludeFields.
const (
	ProductPrice SearchProductsParamsIncludeFields = "product.price"
)

// Defines values for UpdateProductJSONBodyBillingFrequency.
const (
	Annually     UpdateProductJSONBodyBillingFrequency = "annually"
	Monthly      UpdateProductJSONBodyBillingFrequency = "monthly"
	OneTime      UpdateProductJSONBodyBillingFrequency = "one-time"
	Quarterly    UpdateProductJSONBodyBillingFrequency = "quarterly"
	SemiAnnually UpdateProductJSONBodyBillingFrequency = "semi-annually"
	Weekly       UpdateProductJSONBodyBillingFrequency = "weekly"
)

// Defines values for UpdateProductJSONBodyVisibleTo.
const (
	UpdateProductJSONBodyVisibleToN1 UpdateProductJSONBodyVisibleTo = 1
	UpdateProductJSONBodyVisibleToN3 UpdateProductJSONBodyVisibleTo = 3
	UpdateProductJSONBodyVisibleToN5 UpdateProductJSONBodyVisibleTo = 5
	UpdateProductJSONBodyVisibleToN7 UpdateProductJSONBodyVisibleTo = 7
)

// Defines values for GetStagesParamsSortBy.
const (
	AddTime    GetStagesParamsSortBy = "add_time"
	Id         GetStagesParamsSortBy = "id"
	OrderNr    GetStagesParamsSortBy = "order_nr"
	UpdateTime GetStagesParamsSortBy = "update_time"
)

// Defines values for GetStagesParamsSortDirection.
const (
	Asc  GetStagesParamsSortDirection = "asc"
	Desc GetStagesParamsSortDirection = "desc"
)

// GetActivitiesParams defines parameters for GetActivities.
type GetActivitiesParams struct {
	// FilterId If supplied, only activities matching the specified filter are returned
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// Ids Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// OwnerId If supplied, only activities owned by the specified user are returned. If filter_id is provided, this is ignored.
	OwnerId *int `form:"owner_id,omitempty" json:"owner_id,omitempty"`

	// DealId If supplied, only activities linked to the specified deal are returned. If filter_id is provided, this is ignored.
	DealId *int `form:"deal_id,omitempty" json:"deal_id,omitempty"`

	// LeadId If supplied, only activities linked to the specified lead are returned. If filter_id is provided, this is ignored.
	LeadId *string `form:"lead_id,omitempty" json:"lead_id,omitempty"`

	// PersonId If supplied, only activities whose primary participant is the given person are returned. If filter_id is provided, this is ignored.
	PersonId *int `form:"person_id,omitempty" json:"person_id,omitempty"`

	// OrgId If supplied, only activities linked to the specified organization are returned. If filter_id is provided, this is ignored.
	OrgId *int `form:"org_id,omitempty" json:"org_id,omitempty"`

	// Done If supplied, only activities with specified 'done' flag value are returned
	Done *bool `form:"done,omitempty" json:"done,omitempty"`

	// UpdatedSince If set, only activities with an `update_time` later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
	UpdatedSince *string `form:"updated_since,omitempty" json:"updated_since,omitempty"`

	// UpdatedUntil If set, only activities with an `update_time` earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
	UpdatedUntil *string `form:"updated_until,omitempty" json:"updated_until,omitempty"`

	// SortBy The field to sort by. Supported fields: `id`, `update_time`, `add_time`, `due_date`.
	SortBy *GetActivitiesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection The sorting direction. Supported values: `asc`, `desc`.
	SortDirection *GetActivitiesParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`

	// IncludeFields Optional comma separated string array of additional fields to include
	IncludeFields *GetActivitiesParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetActivitiesParamsSortBy defines parameters for GetActivities.
type GetActivitiesParamsSortBy string

// GetActivitiesParamsSortDirection defines parameters for GetActivities.
type GetActivitiesParamsSortDirection string

// GetActivitiesParamsIncludeFields defines parameters for GetActivities.
type GetActivitiesParamsIncludeFields string

// AddActivityJSONBody defines parameters for AddActivity.
type AddActivityJSONBody struct {
	// Attendees The attendees of the activity
	Attendees *[]struct {
		// Email The email address of the attendee
		Email *string `json:"email,omitempty"`

		// IsOrganizer Whether the attendee is the organizer or not
		IsOrganizer *bool `json:"is_organizer,omitempty"`

		// Name The name of the attendee
		Name *string `json:"name,omitempty"`

		// PersonId The ID of the person if the attendee has a person record
		PersonId *int `json:"person_id,omitempty"`

		// Status The status of the attendee
		Status *string `json:"status,omitempty"`

		// UserId The ID of the user if the attendee is a user
		UserId *int `json:"user_id,omitempty"`
	} `json:"attendees,omitempty"`

	// Busy Whether the activity marks the assignee as busy or not in their calendar
	Busy *bool `json:"busy,omitempty"`

	// DealId The ID of the deal linked to the activity
	DealId *int `json:"deal_id,omitempty"`

	// Done Whether the activity is marked as done or not
	Done *bool `json:"done,omitempty"`

	// DueDate The due date of the activity
	DueDate *string `json:"due_date,omitempty"`

	// DueTime The due time of the activity
	DueTime *string `json:"due_time,omitempty"`

	// Duration The duration of the activity
	Duration *string `json:"duration,omitempty"`

	// LeadId The ID of the lead linked to the activity
	LeadId *string `json:"lead_id,omitempty"`

	// Location Location of the activity
	Location *struct {
		// AdminAreaLevel1 Admin area level 1 (e.g. state) of the activity
		AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

		// AdminAreaLevel2 Admin area level 2 (e.g. county) of the activity
		AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

		// Country Country of the activity
		Country *string `json:"country,omitempty"`

		// Locality Locality (e.g. city) of the activity
		Locality *string `json:"locality,omitempty"`

		// PostalCode Postal code of the activity
		PostalCode *string `json:"postal_code,omitempty"`

		// Route Route (e.g. street) of the activity
		Route *string `json:"route,omitempty"`

		// StreetNumber Street number of the activity
		StreetNumber *string `json:"street_number,omitempty"`

		// Sublocality Sublocality (e.g. neighborhood) of the activity
		Sublocality *string `json:"sublocality,omitempty"`

		// Subpremise Subpremise (e.g. apartment/suite number) of the activity
		Subpremise *string `json:"subpremise,omitempty"`

		// Value The full address of the activity
		Value *string `json:"value,omitempty"`
	} `json:"location,omitempty"`

	// Note The note of the activity
	Note *string `json:"note,omitempty"`

	// OrgId The ID of the organization linked to the activity
	OrgId *int `json:"org_id,omitempty"`

	// OwnerId The ID of the user who owns the activity
	OwnerId *int `json:"owner_id,omitempty"`

	// Participants The participants of the activity
	Participants *[]struct {
		// PersonId The ID of the person
		PersonId *int `json:"person_id,omitempty"`

		// Primary Whether the person is the primary participant or not
		Primary *bool `json:"primary,omitempty"`
	} `json:"participants,omitempty"`

	// PersonId The ID of the person linked to the activity
	PersonId *int `json:"person_id,omitempty"`

	// Priority The priority of the activity. Mappable to a specific string using activityFields API.
	Priority *int `json:"priority,omitempty"`

	// ProjectId The ID of the project linked to the activity
	ProjectId *int `json:"project_id,omitempty"`

	// PublicDescription The public description of the activity
	PublicDescription *string `json:"public_description,omitempty"`

	// Subject The subject of the activity
	Subject *string `json:"subject,omitempty"`

	// Type The type of the activity
	Type *string `json:"type,omitempty"`
}

// GetActivityParams defines parameters for GetActivity.
type GetActivityParams struct {
	// IncludeFields Optional comma separated string array of additional fields to include
	IncludeFields *GetActivityParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`
}

// GetActivityParamsIncludeFields defines parameters for GetActivity.
type GetActivityParamsIncludeFields string

// UpdateActivityJSONBody defines parameters for UpdateActivity.
type UpdateActivityJSONBody struct {
	// Attendees The attendees of the activity
	Attendees *[]struct {
		// Email The email address of the attendee
		Email *string `json:"email,omitempty"`

		// IsOrganizer Whether the attendee is the organizer or not
		IsOrganizer *bool `json:"is_organizer,omitempty"`

		// Name The name of the attendee
		Name *string `json:"name,omitempty"`

		// PersonId The ID of the person if the attendee has a person record
		PersonId *int `json:"person_id,omitempty"`

		// Status The status of the attendee
		Status *string `json:"status,omitempty"`

		// UserId The ID of the user if the attendee is a user
		UserId *int `json:"user_id,omitempty"`
	} `json:"attendees,omitempty"`

	// Busy Whether the activity marks the assignee as busy or not in their calendar
	Busy *bool `json:"busy,omitempty"`

	// DealId The ID of the deal linked to the activity
	DealId *int `json:"deal_id,omitempty"`

	// Done Whether the activity is marked as done or not
	Done *bool `json:"done,omitempty"`

	// DueDate The due date of the activity
	DueDate *string `json:"due_date,omitempty"`

	// DueTime The due time of the activity
	DueTime *string `json:"due_time,omitempty"`

	// Duration The duration of the activity
	Duration *string `json:"duration,omitempty"`

	// LeadId The ID of the lead linked to the activity
	LeadId *string `json:"lead_id,omitempty"`

	// Location Location of the activity
	Location *struct {
		// AdminAreaLevel1 Admin area level 1 (e.g. state) of the activity
		AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

		// AdminAreaLevel2 Admin area level 2 (e.g. county) of the activity
		AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

		// Country Country of the activity
		Country *string `json:"country,omitempty"`

		// Locality Locality (e.g. city) of the activity
		Locality *string `json:"locality,omitempty"`

		// PostalCode Postal code of the activity
		PostalCode *string `json:"postal_code,omitempty"`

		// Route Route (e.g. street) of the activity
		Route *string `json:"route,omitempty"`

		// StreetNumber Street number of the activity
		StreetNumber *string `json:"street_number,omitempty"`

		// Sublocality Sublocality (e.g. neighborhood) of the activity
		Sublocality *string `json:"sublocality,omitempty"`

		// Subpremise Subpremise (e.g. apartment/suite number) of the activity
		Subpremise *string `json:"subpremise,omitempty"`

		// Value The full address of the activity
		Value *string `json:"value,omitempty"`
	} `json:"location,omitempty"`

	// Note The note of the activity
	Note *string `json:"note,omitempty"`

	// OrgId The ID of the organization linked to the activity
	OrgId *int `json:"org_id,omitempty"`

	// OwnerId The ID of the user who owns the activity
	OwnerId *int `json:"owner_id,omitempty"`

	// Participants The participants of the activity
	Participants *[]struct {
		// PersonId The ID of the person
		PersonId *int `json:"person_id,omitempty"`

		// Primary Whether the person is the primary participant or not
		Primary *bool `json:"primary,omitempty"`
	} `json:"participants,omitempty"`

	// PersonId The ID of the person linked to the activity
	PersonId *int `json:"person_id,omitempty"`

	// Priority The priority of the activity. Mappable to a specific string using activityFields API.
	Priority *int `json:"priority,omitempty"`

	// ProjectId The ID of the project linked to the activity
	ProjectId *int `json:"project_id,omitempty"`

	// PublicDescription The public description of the activity
	PublicDescription *string `json:"public_description,omitempty"`

	// Subject The subject of the activity
	Subject *string `json:"subject,omitempty"`

	// Type The type of the activity
	Type *string `json:"type,omitempty"`
}

// GetActivityFieldsParams defines parameters for GetActivityFields.
type GetActivityFieldsParams struct {
	// IncludeFields Optional comma separated string array of additional data namespaces to include in response
	IncludeFields *GetActivityFieldsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetActivityFieldsParamsIncludeFields defines parameters for GetActivityFields.
type GetActivityFieldsParamsIncludeFields string

// GetActivityFieldParams defines parameters for GetActivityField.
type GetActivityFieldParams struct {
	// IncludeFields Optional comma separated string array of additional data namespaces to include in response
	IncludeFields *GetActivityFieldParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`
}

// GetActivityFieldParamsIncludeFields defines parameters for GetActivityField.
type GetActivityFieldParamsIncludeFields string

// GetDealFieldsParams defines parameters for GetDealFields.
type GetDealFieldsParams struct {
	// IncludeFields Optional comma separated string array of additional data namespaces to include in response
	IncludeFields *GetDealFieldsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetDealFieldsParamsIncludeFields defines parameters for GetDealFields.
type GetDealFieldsParamsIncludeFields string

// AddDealFieldJSONBody defines parameters for AddDealField.
type AddDealFieldJSONBody struct {
	// Description Field description
	Description *string `json:"description"`

	// FieldName Field name
	FieldName string `json:"field_name"`

	// FieldType The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td><tr><td>`text`</td><td>Long text (up to 65k characters)</td><tr><td>`double`</td><td>Numeric value</td><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td><tr><td>`enum`</td><td>Options field with a single possible chosen option</td><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td><tr><td>`people`</td><td>Person field (contains a product ID which is stored on the same account)</td><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td><tr><td>`address`</td><td>Address field</dd></table>
	FieldType AddDealFieldJSONBodyFieldType `json:"field_type"`

	// ImportantFields Configuration for highlighting the field at specific stages.
	ImportantFields *AddDealFieldJSONBody_ImportantFields `json:"important_fields,omitempty"`

	// Options Field options (required for enum and set field types)
	Options *[]struct {
		// Label The option label
		Label string `json:"label"`
	} `json:"options,omitempty"`

	// RequiredFields Required fields configuration for marking the field as mandatory when interacted with in the Pipedrive web UI.
	RequiredFields *AddDealFieldJSONBody_RequiredFields `json:"required_fields,omitempty"`

	// UiVisibility UI visibility settings for the field. Controls where the field appears in the Pipedrive web UI.
	UiVisibility *AddDealFieldJSONBody_UiVisibility `json:"ui_visibility,omitempty"`
}

// AddDealFieldJSONBodyFieldType defines parameters for AddDealField.
type AddDealFieldJSONBodyFieldType string

// AddDealFieldJSONBody_ImportantFields defines parameters for AddDealField.
type AddDealFieldJSONBody_ImportantFields struct {
	// Enabled Whether the field is marked as important. When false, the field is not highlighted. When true with empty stage_ids, the field is important everywhere. When true with specific stage_ids, the field is important only at those stages. Default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// StageIds Array of deal stage IDs where this field should be highlighted as important. Must reference valid, active deal stages. Empty array when enabled is false. The stages must be in pipelines where this field is visible (show_in_pipelines).
	StageIds             *[]int                 `json:"stage_ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AddDealFieldJSONBodyRequiredFieldsStatuses defines parameters for AddDealField.
type AddDealFieldJSONBodyRequiredFieldsStatuses string

// AddDealFieldJSONBody_RequiredFields defines parameters for AddDealField.
type AddDealFieldJSONBody_RequiredFields struct {
	// Enabled Whether the field is required. When false, the field is optional. When true with empty stage_ids, the field is required everywhere. When true with specific stage_ids, the field is required only at those stages. Default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// StageIds Array of deal stage IDs where this field is required. Must reference valid, active deal stages. Empty array when enabled is false. The stages must be in pipelines where this field is visible (show_in_pipelines).
	StageIds *[]int `json:"stage_ids,omitempty"`

	// Statuses Pipeline-specific status requirements for when deals are won or lost. Keys are pipeline IDs (as strings), values are arrays of status strings ('won', 'lost'). Example - {"1":["won","lost"],"2":["won"]} means the field is required when marking deals as won or lost in pipeline 1, and only when won in pipeline 2. Must reference valid, active pipelines.
	Statuses             *map[string][]AddDealFieldJSONBodyRequiredFieldsStatuses `json:"statuses,omitempty"`
	AdditionalProperties map[string]interface{}                                   `json:"-"`
}

// AddDealFieldJSONBody_UiVisibility defines parameters for AddDealField.
type AddDealFieldJSONBody_UiVisibility struct {
	// AddVisibleFlag Whether the field is shown in the add deal modal. Default is false. Cannot be set to false for required system fields (title, pipeline, stage_id, probability).
	AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

	// DetailsVisibleFlag Whether the field is shown in the deal details view. Default is true.
	DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

	// ProjectsDetailVisibleFlag Whether the field is shown in the project details view when the deal is linked to a project. Default is false.
	ProjectsDetailVisibleFlag *bool `json:"projects_detail_visible_flag,omitempty"`

	// ShowInPipelines Controls which pipelines display this field. Default is show_in_all=true. Note that fields marked as important or required must be visible in the pipelines where they are configured.
	ShowInPipelines *struct {
		// PipelineIds Array of pipeline IDs where the field should be visible. Only used when show_in_all is false. Must reference valid, active pipelines.
		PipelineIds *[]int `json:"pipeline_ids,omitempty"`

		// ShowInAll When true, the field is visible in all pipelines. When false, visibility is controlled by pipeline_ids. Default is true.
		ShowInAll *bool `json:"show_in_all,omitempty"`
	} `json:"show_in_pipelines,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GetDealFieldParams defines parameters for GetDealField.
type GetDealFieldParams struct {
	// IncludeFields Optional comma separated string array of additional data namespaces to include in response
	IncludeFields *GetDealFieldParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`
}

// GetDealFieldParamsIncludeFields defines parameters for GetDealField.
type GetDealFieldParamsIncludeFields string

// UpdateDealFieldJSONBody defines parameters for UpdateDealField.
type UpdateDealFieldJSONBody struct {
	// Description Field description
	Description *string `json:"description"`

	// FieldName Field name
	FieldName *string `json:"field_name,omitempty"`

	// ImportantFields Configuration for highlighting the field at specific stages.
	ImportantFields *UpdateDealFieldJSONBody_ImportantFields `json:"important_fields,omitempty"`

	// RequiredFields Required fields configuration for marking the field as mandatory when interacted with in the Pipedrive web UI.
	RequiredFields *UpdateDealFieldJSONBody_RequiredFields `json:"required_fields,omitempty"`

	// UiVisibility UI visibility settings for the field. Controls where the field appears in the Pipedrive web UI.
	UiVisibility *UpdateDealFieldJSONBody_UiVisibility `json:"ui_visibility,omitempty"`
}

// UpdateDealFieldJSONBody_ImportantFields defines parameters for UpdateDealField.
type UpdateDealFieldJSONBody_ImportantFields struct {
	// Enabled Whether the field is marked as important. When false, the field is not highlighted. When true with empty stage_ids, the field is important everywhere. When true with specific stage_ids, the field is important only at those stages. Default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// StageIds Array of deal stage IDs where this field should be highlighted as important. Must reference valid, active deal stages. Empty array when enabled is false. The stages must be in pipelines where this field is visible (show_in_pipelines).
	StageIds             *[]int                 `json:"stage_ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdateDealFieldJSONBodyRequiredFieldsStatuses defines parameters for UpdateDealField.
type UpdateDealFieldJSONBodyRequiredFieldsStatuses string

// UpdateDealFieldJSONBody_RequiredFields defines parameters for UpdateDealField.
type UpdateDealFieldJSONBody_RequiredFields struct {
	// Enabled Whether the field is required. When false, the field is optional. When true with empty stage_ids, the field is required everywhere. When true with specific stage_ids, the field is required only at those stages. Default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// StageIds Array of deal stage IDs where this field is required. Must reference valid, active deal stages. Empty array when enabled is false. The stages must be in pipelines where this field is visible (show_in_pipelines).
	StageIds *[]int `json:"stage_ids,omitempty"`

	// Statuses Pipeline-specific status requirements for when deals are won or lost. Keys are pipeline IDs (as strings), values are arrays of status strings ('won', 'lost'). Example - {"1":["won","lost"],"2":["won"]} means the field is required when marking deals as won or lost in pipeline 1, and only when won in pipeline 2. Must reference valid, active pipelines.
	Statuses             *map[string][]UpdateDealFieldJSONBodyRequiredFieldsStatuses `json:"statuses,omitempty"`
	AdditionalProperties map[string]interface{}                                      `json:"-"`
}

// UpdateDealFieldJSONBody_UiVisibility defines parameters for UpdateDealField.
type UpdateDealFieldJSONBody_UiVisibility struct {
	// AddVisibleFlag Whether the field is shown in the add deal modal. Default is false. Cannot be set to false for required system fields (title, pipeline, stage_id, probability).
	AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

	// DetailsVisibleFlag Whether the field is shown in the deal details view. Default is true.
	DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

	// ProjectsDetailVisibleFlag Whether the field is shown in the project details view when the deal is linked to a project. Default is false.
	ProjectsDetailVisibleFlag *bool `json:"projects_detail_visible_flag,omitempty"`

	// ShowInPipelines Controls which pipelines display this field. Default is show_in_all=true. Note that fields marked as important or required must be visible in the pipelines where they are configured.
	ShowInPipelines *struct {
		// PipelineIds Array of pipeline IDs where the field should be visible. Only used when show_in_all is false. Must reference valid, active pipelines.
		PipelineIds *[]int `json:"pipeline_ids,omitempty"`

		// ShowInAll When true, the field is visible in all pipelines. When false, visibility is controlled by pipeline_ids. Default is true.
		ShowInAll *bool `json:"show_in_all,omitempty"`
	} `json:"show_in_pipelines,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// DeleteDealFieldOptionsJSONBody defines parameters for DeleteDealFieldOptions.
type DeleteDealFieldOptionsJSONBody = []struct {
	// Id The unique identifier of the option to delete
	Id int `json:"id"`
}

// UpdateDealFieldOptionsJSONBody defines parameters for UpdateDealFieldOptions.
type UpdateDealFieldOptionsJSONBody = []struct {
	// Id The unique identifier of the option to update
	Id int `json:"id"`

	// Label The new display label for the option
	Label string `json:"label"`
}

// AddDealFieldOptionsJSONBody defines parameters for AddDealFieldOptions.
type AddDealFieldOptionsJSONBody = []struct {
	// Label The display label for the new option
	Label string `json:"label"`
}

// GetDealsParams defines parameters for GetDeals.
type GetDealsParams struct {
	// FilterId If supplied, only deals matching the specified filter are returned
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// Ids Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// OwnerId If supplied, only deals owned by the specified user are returned. If filter_id is provided, this is ignored.
	OwnerId *int `form:"owner_id,omitempty" json:"owner_id,omitempty"`

	// PersonId If supplied, only deals linked to the specified person are returned. If filter_id is provided, this is ignored.
	PersonId *int `form:"person_id,omitempty" json:"person_id,omitempty"`

	// OrgId If supplied, only deals linked to the specified organization are returned. If filter_id is provided, this is ignored.
	OrgId *int `form:"org_id,omitempty" json:"org_id,omitempty"`

	// PipelineId If supplied, only deals in the specified pipeline are returned. If filter_id is provided, this is ignored.
	PipelineId *int `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty"`

	// StageId If supplied, only deals in the specified stage are returned. If filter_id is provided, this is ignored.
	StageId *int `form:"stage_id,omitempty" json:"stage_id,omitempty"`

	// Status Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. Multiple statuses can be included as a comma separated array. If filter_id is provided, this is ignored.
	Status *GetDealsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// UpdatedSince If set, only deals with an `update_time` later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
	UpdatedSince *string `form:"updated_since,omitempty" json:"updated_since,omitempty"`

	// UpdatedUntil If set, only deals with an `update_time` earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
	UpdatedUntil *string `form:"updated_until,omitempty" json:"updated_until,omitempty"`

	// SortBy The field to sort by. Supported fields: `id`, `update_time`, `add_time`.
	SortBy *GetDealsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection The sorting direction. Supported values: `asc`, `desc`.
	SortDirection *GetDealsParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`

	// IncludeFields Optional comma separated string array of additional fields to include
	IncludeFields *GetDealsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// CustomFields Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.<br/>A maximum of 15 keys is allowed.
	CustomFields *string `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetDealsParamsStatus defines parameters for GetDeals.
type GetDealsParamsStatus string

// GetDealsParamsSortBy defines parameters for GetDeals.
type GetDealsParamsSortBy string

// GetDealsParamsSortDirection defines parameters for GetDeals.
type GetDealsParamsSortDirection string

// GetDealsParamsIncludeFields defines parameters for GetDeals.
type GetDealsParamsIncludeFields string

// AddDealJSONBody defines parameters for AddDeal.
type AddDealJSONBody struct {
	// ArchiveTime The optional date and time of archiving the deal in UTC. Format: YYYY-MM-DD HH:MM:SS. If omitted and `is_archived` is true, it will be set to the current date and time.
	ArchiveTime *string `json:"archive_time,omitempty"`

	// CloseTime The date and time of closing the deal. Can only be set if deal status is won or lost.
	CloseTime *string `json:"close_time"`

	// Currency The currency associated with the deal
	Currency *string `json:"currency,omitempty"`

	// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// ExpectedCloseDate The expected close date of the deal
	ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

	// IsArchived Whether the deal is archived or not
	IsArchived *bool `json:"is_archived,omitempty"`

	// IsDeleted Whether the deal is deleted or not
	IsDeleted *bool `json:"is_deleted,omitempty"`

	// LabelIds The IDs of labels assigned to the deal
	LabelIds *[]int `json:"label_ids,omitempty"`

	// LostReason The reason for losing the deal. Can only be set if deal status is lost.
	LostReason *string `json:"lost_reason"`

	// LostTime The date and time of changing the deal status as lost. Can only be set if deal status is lost.
	LostTime *string `json:"lost_time,omitempty"`

	// OrgId The ID of the organization linked to the deal
	OrgId *int `json:"org_id,omitempty"`

	// OwnerId The ID of the user who owns the deal
	OwnerId *int `json:"owner_id,omitempty"`

	// PersonId The ID of the person linked to the deal
	PersonId *int `json:"person_id,omitempty"`

	// PipelineId The ID of the pipeline associated with the deal
	PipelineId *int `json:"pipeline_id,omitempty"`

	// Probability The success probability percentage of the deal
	Probability *float32 `json:"probability"`

	// StageId The ID of the deal stage
	StageId *int `json:"stage_id,omitempty"`

	// Status The status of the deal
	Status *string `json:"status,omitempty"`

	// Title The title of the deal
	Title string `json:"title"`

	// Value The value of the deal
	Value *float32 `json:"value,omitempty"`

	// VisibleTo The visibility of the deal
	VisibleTo *int `json:"visible_to,omitempty"`

	// WonTime The date and time of changing the deal status as won. Can only be set if deal status is won.
	WonTime *string `json:"won_time,omitempty"`
}

// GetArchivedDealsParams defines parameters for GetArchivedDeals.
type GetArchivedDealsParams struct {
	// FilterId If supplied, only deals matching the specified filter are returned
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// Ids Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// OwnerId If supplied, only deals owned by the specified user are returned. If filter_id is provided, this is ignored.
	OwnerId *int `form:"owner_id,omitempty" json:"owner_id,omitempty"`

	// PersonId If supplied, only deals linked to the specified person are returned. If filter_id is provided, this is ignored.
	PersonId *int `form:"person_id,omitempty" json:"person_id,omitempty"`

	// OrgId If supplied, only deals linked to the specified organization are returned. If filter_id is provided, this is ignored.
	OrgId *int `form:"org_id,omitempty" json:"org_id,omitempty"`

	// PipelineId If supplied, only deals in the specified pipeline are returned. If filter_id is provided, this is ignored.
	PipelineId *int `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty"`

	// StageId If supplied, only deals in the specified stage are returned. If filter_id is provided, this is ignored.
	StageId *int `form:"stage_id,omitempty" json:"stage_id,omitempty"`

	// Status Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. Multiple statuses can be included as a comma separated array. If filter_id is provided, this is ignored.
	Status *GetArchivedDealsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// UpdatedSince If set, only deals with an `update_time` later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
	UpdatedSince *string `form:"updated_since,omitempty" json:"updated_since,omitempty"`

	// UpdatedUntil If set, only deals with an `update_time` earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
	UpdatedUntil *string `form:"updated_until,omitempty" json:"updated_until,omitempty"`

	// SortBy The field to sort by. Supported fields: `id`, `update_time`, `add_time`.
	SortBy *GetArchivedDealsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection The sorting direction. Supported values: `asc`, `desc`.
	SortDirection *GetArchivedDealsParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`

	// IncludeFields Optional comma separated string array of additional fields to include
	IncludeFields *GetArchivedDealsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// CustomFields Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.<br/>A maximum of 15 keys is allowed.
	CustomFields *string `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetArchivedDealsParamsStatus defines parameters for GetArchivedDeals.
type GetArchivedDealsParamsStatus string

// GetArchivedDealsParamsSortBy defines parameters for GetArchivedDeals.
type GetArchivedDealsParamsSortBy string

// GetArchivedDealsParamsSortDirection defines parameters for GetArchivedDeals.
type GetArchivedDealsParamsSortDirection string

// GetArchivedDealsParamsIncludeFields defines parameters for GetArchivedDeals.
type GetArchivedDealsParamsIncludeFields string

// GetInstallmentsParams defines parameters for GetInstallments.
type GetInstallmentsParams struct {
	// DealIds An array of integers with the IDs of the deals for which the attached installments will be returned. A maximum of 100 deal IDs can be provided.
	DealIds []int `form:"deal_ids" json:"deal_ids"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy The field to sort by. Supported fields: `id`, `billing_date`, `deal_id`.
	SortBy *GetInstallmentsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection The sorting direction. Supported values: `asc`, `desc`.
	SortDirection *GetInstallmentsParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`
}

// GetInstallmentsParamsSortBy defines parameters for GetInstallments.
type GetInstallmentsParamsSortBy string

// GetInstallmentsParamsSortDirection defines parameters for GetInstallments.
type GetInstallmentsParamsSortDirection string

// GetDealsProductsParams defines parameters for GetDealsProducts.
type GetDealsProductsParams struct {
	// DealIds An array of integers with the IDs of the deals for which the attached products will be returned. A maximum of 100 deal IDs can be provided.
	DealIds []int `form:"deal_ids" json:"deal_ids"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy The field to sort by. Supported fields: `id`, `deal_id`, `add_time`, `update_time`, `order_nr`.
	SortBy *GetDealsProductsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection The sorting direction. Supported values: `asc`, `desc`.
	SortDirection *GetDealsProductsParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`
}

// GetDealsProductsParamsSortBy defines parameters for GetDealsProducts.
type GetDealsProductsParamsSortBy string

// GetDealsProductsParamsSortDirection defines parameters for GetDealsProducts.
type GetDealsProductsParamsSortDirection string

// SearchDealsParams defines parameters for SearchDeals.
type SearchDealsParams struct {
	// Term The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded.
	Term string `form:"term" json:"term"`

	// Fields A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: `address`, `varchar`, `text`, `varchar_auto`, `double`, `monetary` and `phone`. Read more about searching by custom fields <a href="https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields" target="_blank" rel="noopener noreferrer">here</a>.
	Fields *SearchDealsParamsFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExactMatch When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive.
	ExactMatch *bool `form:"exact_match,omitempty" json:"exact_match,omitempty"`

	// PersonId Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
	PersonId *int `form:"person_id,omitempty" json:"person_id,omitempty"`

	// OrganizationId Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
	OrganizationId *int `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// Status Will filter deals by the provided specific status. open = Open, won = Won, lost = Lost. The upper limit of found deals associated with the status is 2000.
	Status *SearchDealsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// IncludeFields Supports including optional fields in the results which are not provided by default
	IncludeFields *SearchDealsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// SearchDealsParamsFields defines parameters for SearchDeals.
type SearchDealsParamsFields string

// SearchDealsParamsStatus defines parameters for SearchDeals.
type SearchDealsParamsStatus string

// SearchDealsParamsIncludeFields defines parameters for SearchDeals.
type SearchDealsParamsIncludeFields string

// GetDealParams defines parameters for GetDeal.
type GetDealParams struct {
	// IncludeFields Optional comma separated string array of additional fields to include
	IncludeFields *GetDealParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// CustomFields Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.<br/>A maximum of 15 keys is allowed.
	CustomFields *string `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`
}

// GetDealParamsIncludeFields defines parameters for GetDeal.
type GetDealParamsIncludeFields string

// UpdateDealJSONBody defines parameters for UpdateDeal.
type UpdateDealJSONBody struct {
	// ArchiveTime The optional date and time of archiving the deal in UTC. Format: YYYY-MM-DD HH:MM:SS. If omitted and `is_archived` is true, it will be set to the current date and time.
	ArchiveTime *string `json:"archive_time,omitempty"`

	// CloseTime The date and time of closing the deal. Can only be set if deal status is won or lost.
	CloseTime *string `json:"close_time"`

	// Currency The currency associated with the deal
	Currency *string `json:"currency,omitempty"`

	// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// ExpectedCloseDate The expected close date of the deal
	ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

	// IsArchived Whether the deal is archived or not
	IsArchived *bool `json:"is_archived,omitempty"`

	// IsDeleted Whether the deal is deleted or not
	IsDeleted *bool `json:"is_deleted,omitempty"`

	// LabelIds The IDs of labels assigned to the deal
	LabelIds *[]int `json:"label_ids,omitempty"`

	// LostReason The reason for losing the deal. Can only be set if deal status is lost.
	LostReason *string `json:"lost_reason"`

	// LostTime The date and time of changing the deal status as lost. Can only be set if deal status is lost.
	LostTime *string `json:"lost_time,omitempty"`

	// OrgId The ID of the organization linked to the deal
	OrgId *int `json:"org_id,omitempty"`

	// OwnerId The ID of the user who owns the deal
	OwnerId *int `json:"owner_id,omitempty"`

	// PersonId The ID of the person linked to the deal
	PersonId *int `json:"person_id,omitempty"`

	// PipelineId The ID of the pipeline associated with the deal
	PipelineId *int `json:"pipeline_id,omitempty"`

	// Probability The success probability percentage of the deal
	Probability *float32 `json:"probability"`

	// StageId The ID of the deal stage
	StageId *int `json:"stage_id,omitempty"`

	// Status The status of the deal
	Status *string `json:"status,omitempty"`

	// Title The title of the deal
	Title *string `json:"title,omitempty"`

	// Value The value of the deal
	Value *float32 `json:"value,omitempty"`

	// VisibleTo The visibility of the deal
	VisibleTo *int `json:"visible_to,omitempty"`

	// WonTime The date and time of changing the deal status as won. Can only be set if deal status is won.
	WonTime *string `json:"won_time,omitempty"`
}

// PostAdditionalDiscountJSONBody defines parameters for PostAdditionalDiscount.
type PostAdditionalDiscountJSONBody struct {
	// Amount The discount amount. Must be a positive number (excluding 0).
	Amount float32 `json:"amount"`

	// Description The name of the discount.
	Description string `json:"description"`

	// Type Determines whether the discount is applied as a percentage or a fixed amount.
	Type PostAdditionalDiscountJSONBodyType `json:"type"`
}

// PostAdditionalDiscountJSONBodyType defines parameters for PostAdditionalDiscount.
type PostAdditionalDiscountJSONBodyType string

// UpdateAdditionalDiscountJSONBody defines parameters for UpdateAdditionalDiscount.
type UpdateAdditionalDiscountJSONBody struct {
	// Amount The discount amount. Must be a positive number (excluding 0).
	Amount *float32 `json:"amount,omitempty"`

	// Description The name of the discount.
	Description *string `json:"description,omitempty"`

	// Type Determines whether the discount is applied as a percentage or a fixed amount.
	Type *UpdateAdditionalDiscountJSONBodyType `json:"type,omitempty"`
}

// UpdateAdditionalDiscountJSONBodyType defines parameters for UpdateAdditionalDiscount.
type UpdateAdditionalDiscountJSONBodyType string

// GetDealFollowersParams defines parameters for GetDealFollowers.
type GetDealFollowersParams struct {
	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// AddDealFollowerJSONBody defines parameters for AddDealFollower.
type AddDealFollowerJSONBody struct {
	// UserId The ID of the user to add as a follower
	UserId int `json:"user_id"`
}

// GetDealFollowersChangelogParams defines parameters for GetDealFollowersChangelog.
type GetDealFollowersChangelogParams struct {
	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// PostInstallmentJSONBody defines parameters for PostInstallment.
type PostInstallmentJSONBody struct {
	// Amount The installment amount. Must be a positive number (excluding 0).
	Amount float32 `json:"amount"`

	// BillingDate The date which the installment will be charged. Must be in the format YYYY-MM-DD.
	BillingDate string `json:"billing_date"`

	// Description The name of the installment.
	Description string `json:"description"`
}

// UpdateInstallmentJSONBody defines parameters for UpdateInstallment.
type UpdateInstallmentJSONBody struct {
	// Amount The installment amount. Must be a positive number (excluding 0).
	Amount *float32 `json:"amount,omitempty"`

	// BillingDate The date which the installment will be charged. Must be in the format YYYY-MM-DD.
	BillingDate *string `json:"billing_date,omitempty"`

	// Description The name of the installment.
	Description *string `json:"description,omitempty"`
}

// DeleteManyDealProductsParams defines parameters for DeleteManyDealProducts.
type DeleteManyDealProductsParams struct {
	// Ids Comma-separated list of deal product IDs to delete. If not provided, all deal products will be deleted up to 100 items. Maximum 100 IDs allowed.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`
}

// GetDealProductsParams defines parameters for GetDealProducts.
type GetDealProductsParams struct {
	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy The field to sort by. Supported fields: `id`, `add_time`, `update_time`, `order_nr`.
	SortBy *GetDealProductsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection The sorting direction. Supported values: `asc`, `desc`.
	SortDirection *GetDealProductsParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`
}

// GetDealProductsParamsSortBy defines parameters for GetDealProducts.
type GetDealProductsParamsSortBy string

// GetDealProductsParamsSortDirection defines parameters for GetDealProducts.
type GetDealProductsParamsSortDirection string

// AddDealProductJSONBody defines parameters for AddDealProduct.
type AddDealProductJSONBody struct {
	// BillingFrequency Only available in Growth and above plans
	//
	// How often a customer is billed for access to a service or product
	//
	// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
	//
	// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
	BillingFrequency *AddDealProductJSONBodyBillingFrequency `json:"billing_frequency,omitempty"`

	// BillingFrequencyCycles Only available in Growth and above plans
	//
	// The number of times the billing frequency repeats for a product in a deal
	//
	// When `billing_frequency` is set to `one-time`, this field must be `null`
	//
	// When `billing_frequency` is set to `weekly`, this field cannot be `null`
	//
	// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
	//
	// Must be a positive integer less or equal to 208
	BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

	// BillingStartDate Only available in Growth and above plans
	//
	// The billing start date. Must be between 10 years in the past and 10 years in the future
	BillingStartDate *string `json:"billing_start_date"`

	// Comments The comments of the product
	Comments *string `json:"comments,omitempty"`

	// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
	Discount *float32 `json:"discount,omitempty"`

	// DiscountType The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
	DiscountType *AddDealProductJSONBodyDiscountType `json:"discount_type,omitempty"`

	// IsEnabled Whether this product is enabled for the deal
	//
	// Not possible to disable the product if the deal has installments associated and the product is the last one enabled
	//
	// Not possible to enable the product if the deal has installments associated and the product is recurring
	IsEnabled *bool `json:"is_enabled,omitempty"`

	// ItemPrice The price value of the product
	ItemPrice float32 `json:"item_price"`

	// ProductId The ID of the product
	ProductId int `json:"product_id"`

	// ProductVariationId The ID of the product variation
	ProductVariationId *int `json:"product_variation_id"`

	// Quantity The quantity of the product
	Quantity float32 `json:"quantity"`

	// Tax The product tax
	Tax *float32 `json:"tax,omitempty"`

	// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
	TaxMethod *AddDealProductJSONBodyTaxMethod `json:"tax_method,omitempty"`
}

// AddDealProductJSONBodyBillingFrequency defines parameters for AddDealProduct.
type AddDealProductJSONBodyBillingFrequency string

// AddDealProductJSONBodyDiscountType defines parameters for AddDealProduct.
type AddDealProductJSONBodyDiscountType string

// AddDealProductJSONBodyTaxMethod defines parameters for AddDealProduct.
type AddDealProductJSONBodyTaxMethod string

// AddManyDealProductsJSONBody defines parameters for AddManyDealProducts.
type AddManyDealProductsJSONBody struct {
	// Data Array of products to attach to the deal. See the single product endpoint (https://developers.pipedrive.com/docs/api/v1/Deals#addDealProduct) for the expected format of array items.
	Data []struct {
		// BillingFrequency Only available in Growth and above plans
		//
		// How often a customer is billed for access to a service or product
		//
		// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
		//
		// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
		BillingFrequency *AddManyDealProductsJSONBodyDataBillingFrequency `json:"billing_frequency,omitempty"`

		// BillingFrequencyCycles Only available in Growth and above plans
		//
		// The number of times the billing frequency repeats for a product in a deal
		//
		// When `billing_frequency` is set to `one-time`, this field must be `null`
		//
		// When `billing_frequency` is set to `weekly`, this field cannot be `null`
		//
		// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
		//
		// Must be a positive integer less or equal to 208
		BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

		// BillingStartDate Only available in Growth and above plans
		//
		// The billing start date. Must be between 10 years in the past and 10 years in the future
		BillingStartDate *string `json:"billing_start_date"`

		// Comments The comments of the product
		Comments *string `json:"comments,omitempty"`

		// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
		Discount *float32 `json:"discount,omitempty"`

		// DiscountType The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
		DiscountType *AddManyDealProductsJSONBodyDataDiscountType `json:"discount_type,omitempty"`

		// IsEnabled Whether this product is enabled for the deal
		//
		// Not possible to disable the product if the deal has installments associated and the product is the last one enabled
		//
		// Not possible to enable the product if the deal has installments associated and the product is recurring
		IsEnabled *bool `json:"is_enabled,omitempty"`

		// ItemPrice The price value of the product
		ItemPrice float32 `json:"item_price"`

		// ProductId The ID of the product
		ProductId int `json:"product_id"`

		// ProductVariationId The ID of the product variation
		ProductVariationId *int `json:"product_variation_id"`

		// Quantity The quantity of the product
		Quantity float32 `json:"quantity"`

		// Tax The product tax
		Tax *float32 `json:"tax,omitempty"`

		// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
		TaxMethod *AddManyDealProductsJSONBodyDataTaxMethod `json:"tax_method,omitempty"`
	} `json:"data"`
}

// AddManyDealProductsJSONBodyDataBillingFrequency defines parameters for AddManyDealProducts.
type AddManyDealProductsJSONBodyDataBillingFrequency string

// AddManyDealProductsJSONBodyDataDiscountType defines parameters for AddManyDealProducts.
type AddManyDealProductsJSONBodyDataDiscountType string

// AddManyDealProductsJSONBodyDataTaxMethod defines parameters for AddManyDealProducts.
type AddManyDealProductsJSONBodyDataTaxMethod string

// UpdateDealProductJSONBody defines parameters for UpdateDealProduct.
type UpdateDealProductJSONBody struct {
	// BillingFrequency Only available in Growth and above plans
	//
	// How often a customer is billed for access to a service or product
	//
	// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
	//
	// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
	BillingFrequency *UpdateDealProductJSONBodyBillingFrequency `json:"billing_frequency,omitempty"`

	// BillingFrequencyCycles Only available in Growth and above plans
	//
	// The number of times the billing frequency repeats for a product in a deal
	//
	// When `billing_frequency` is set to `one-time`, this field must be `null`
	//
	// When `billing_frequency` is set to `weekly`, this field cannot be `null`
	//
	// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
	//
	// Must be a positive integer less or equal to 208
	BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

	// BillingStartDate Only available in Growth and above plans
	//
	// The billing start date. Must be between 10 years in the past and 10 years in the future
	BillingStartDate *string `json:"billing_start_date"`

	// Comments The comments of the product
	Comments *string `json:"comments,omitempty"`

	// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
	Discount *float32 `json:"discount,omitempty"`

	// DiscountType The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
	DiscountType *UpdateDealProductJSONBodyDiscountType `json:"discount_type,omitempty"`

	// IsEnabled Whether this product is enabled for the deal
	//
	// Not possible to disable the product if the deal has installments associated and the product is the last one enabled
	//
	// Not possible to enable the product if the deal has installments associated and the product is recurring
	IsEnabled *bool `json:"is_enabled,omitempty"`

	// ItemPrice The price value of the product
	ItemPrice *float32 `json:"item_price,omitempty"`

	// ProductId The ID of the product
	ProductId *int `json:"product_id,omitempty"`

	// ProductVariationId The ID of the product variation
	ProductVariationId *int `json:"product_variation_id"`

	// Quantity The quantity of the product
	Quantity *float32 `json:"quantity,omitempty"`

	// Tax The product tax
	Tax *float32 `json:"tax,omitempty"`

	// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
	TaxMethod *UpdateDealProductJSONBodyTaxMethod `json:"tax_method,omitempty"`
}

// UpdateDealProductJSONBodyBillingFrequency defines parameters for UpdateDealProduct.
type UpdateDealProductJSONBodyBillingFrequency string

// UpdateDealProductJSONBodyDiscountType defines parameters for UpdateDealProduct.
type UpdateDealProductJSONBodyDiscountType string

// UpdateDealProductJSONBodyTaxMethod defines parameters for UpdateDealProduct.
type UpdateDealProductJSONBodyTaxMethod string

// SearchItemParams defines parameters for SearchItem.
type SearchItemParams struct {
	// Term The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded.
	Term string `form:"term" json:"term"`

	// ItemTypes A comma-separated string array. The type of items to perform the search from. Defaults to all.
	ItemTypes *SearchItemParamsItemTypes `form:"item_types,omitempty" json:"item_types,omitempty"`

	// Fields A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:<br> <table> <tr><th><b>Item type</b></th><th><b>Field</b></th></tr> <tr><td>Deal</td><td>`custom_fields`, `notes`, `title`</td></tr> <tr><td>Person</td><td>`custom_fields`, `email`, `name`, `notes`, `phone`</td></tr> <tr><td>Organization</td><td>`address`, `custom_fields`, `name`, `notes`</td></tr> <tr><td>Product</td><td>`code`, `custom_fields`, `name`</td></tr> <tr><td>Lead</td><td>`custom_fields`, `notes`, `title`</td></tr> <tr><td>File</td><td>`name`</td></tr> <tr><td>Mail attachment</td><td>`name`</td></tr> <tr><td>Project</td><td> `custom_fields`, `notes`, `title`, `description` </td></tr> </table> <br> Only the following custom field types are searchable: `address`, `varchar`, `text`, `varchar_auto`, `double`, `monetary` and `phone`. Read more about searching by custom fields <a href="https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields" target="_blank" rel="noopener noreferrer">here</a>.
	Fields *SearchItemParamsFields `form:"fields,omitempty" json:"fields,omitempty"`

	// SearchForRelatedItems When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization
	SearchForRelatedItems *bool `form:"search_for_related_items,omitempty" json:"search_for_related_items,omitempty"`

	// ExactMatch When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive.
	ExactMatch *bool `form:"exact_match,omitempty" json:"exact_match,omitempty"`

	// IncludeFields A comma-separated string array. Supports including optional fields in the results which are not provided by default.
	IncludeFields *SearchItemParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 100 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// SearchItemParamsItemTypes defines parameters for SearchItem.
type SearchItemParamsItemTypes string

// SearchItemParamsFields defines parameters for SearchItem.
type SearchItemParamsFields string

// SearchItemParamsIncludeFields defines parameters for SearchItem.
type SearchItemParamsIncludeFields string

// SearchItemByFieldParams defines parameters for SearchItemByField.
type SearchItemByFieldParams struct {
	// Term The search term to look for. Minimum 2 characters (or 1 if `match` is `exact`). Please note that the search term has to be URL encoded.
	Term string `form:"term" json:"term"`

	// EntityType The type of the field to perform the search from
	EntityType SearchItemByFieldParamsEntityType `form:"entity_type" json:"entity_type"`

	// Match The type of match used against the term. The search <b>is</b> case sensitive.<br/><br/> E.g. in case of searching for a value `monkey`, <ul> <li>with `exact` match, you will only find it if term is `monkey`</li> <li>with `beginning` match, you will only find it if the term matches the beginning or the whole string, e.g. `monk` and `monkey`</li> <li>with `middle` match, you will find the it if the term matches any substring of the value, e.g. `onk` and `ke`</li> </ul>.
	Match *SearchItemByFieldParamsMatch `form:"match,omitempty" json:"match,omitempty"`

	// Field The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields' API GET methods (dealFields, personFields, etc.). Only the following custom field types are searchable: `address`, `varchar`, `text`, `varchar_auto`, `double`, `monetary` and `phone`. Read more about searching by custom fields <a href="https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields" target="_blank" rel="noopener noreferrer">here</a>.
	Field string `form:"field" json:"field"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// SearchItemByFieldParamsEntityType defines parameters for SearchItemByField.
type SearchItemByFieldParamsEntityType string

// SearchItemByFieldParamsMatch defines parameters for SearchItemByField.
type SearchItemByFieldParamsMatch string

// SearchLeadsParams defines parameters for SearchLeads.
type SearchLeadsParams struct {
	// Term The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded.
	Term string `form:"term" json:"term"`

	// Fields A comma-separated string array. The fields to perform the search from. Defaults to all of them.
	Fields *SearchLeadsParamsFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExactMatch When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive.
	ExactMatch *bool `form:"exact_match,omitempty" json:"exact_match,omitempty"`

	// PersonId Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
	PersonId *int `form:"person_id,omitempty" json:"person_id,omitempty"`

	// OrganizationId Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
	OrganizationId *int `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// IncludeFields Supports including optional fields in the results which are not provided by default
	IncludeFields *SearchLeadsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// SearchLeadsParamsFields defines parameters for SearchLeads.
type SearchLeadsParamsFields string

// SearchLeadsParamsIncludeFields defines parameters for SearchLeads.
type SearchLeadsParamsIncludeFields string

// ConvertLeadToDealJSONBody defines parameters for ConvertLeadToDeal.
type ConvertLeadToDealJSONBody struct {
	// PipelineId The ID of a pipeline the created deal will be added to. By default, the deal will be added to the first stage of the specified pipeline. Please note that `pipeline_id` and `stage_id` should not be used together as `pipeline_id` will be ignored.
	PipelineId *int `json:"pipeline_id,omitempty"`

	// StageId The ID of a stage the created deal will be added to. Please note that a pipeline will be assigned automatically based on the `stage_id`. If omitted, the deal will be placed in the first stage of the default pipeline.
	StageId *int `json:"stage_id,omitempty"`
}

// GetOrganizationFieldsParams defines parameters for GetOrganizationFields.
type GetOrganizationFieldsParams struct {
	// IncludeFields Optional comma separated string array of additional data namespaces to include in response
	IncludeFields *GetOrganizationFieldsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetOrganizationFieldsParamsIncludeFields defines parameters for GetOrganizationFields.
type GetOrganizationFieldsParamsIncludeFields string

// AddOrganizationFieldJSONBody defines parameters for AddOrganizationField.
type AddOrganizationFieldJSONBody struct {
	// Description Field description
	Description *string `json:"description"`

	// FieldName Field name
	FieldName string `json:"field_name"`

	// FieldType The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td><tr><td>`text`</td><td>Long text (up to 65k characters)</td><tr><td>`double`</td><td>Numeric value</td><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td><tr><td>`enum`</td><td>Options field with a single possible chosen option</td><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td><tr><td>`people`</td><td>Person field (contains a product ID which is stored on the same account)</td><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td><tr><td>`address`</td><td>Address field</dd></table>
	FieldType AddOrganizationFieldJSONBodyFieldType `json:"field_type"`

	// ImportantFields Configuration for highlighting the field at specific stages.
	ImportantFields *AddOrganizationFieldJSONBody_ImportantFields `json:"important_fields,omitempty"`

	// Options Field options (required for enum and set field types)
	Options *[]struct {
		// Label The option label
		Label string `json:"label"`
	} `json:"options,omitempty"`

	// RequiredFields Required fields configuration for marking the field as mandatory when interacted with in the Pipedrive web UI.
	RequiredFields *AddOrganizationFieldJSONBody_RequiredFields `json:"required_fields,omitempty"`

	// UiVisibility UI visibility settings for the field. Controls where the field appears in the Pipedrive web UI.
	UiVisibility *AddOrganizationFieldJSONBody_UiVisibility `json:"ui_visibility,omitempty"`
}

// AddOrganizationFieldJSONBodyFieldType defines parameters for AddOrganizationField.
type AddOrganizationFieldJSONBodyFieldType string

// AddOrganizationFieldJSONBody_ImportantFields defines parameters for AddOrganizationField.
type AddOrganizationFieldJSONBody_ImportantFields struct {
	// Enabled Whether the field is marked as important. When false, the field is not highlighted. When true with empty stage_ids, the field is important everywhere. When true with specific stage_ids, the field is important only at those deal stages. Default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// StageIds Array of deal stage IDs where this organization field should be highlighted as important. Must reference valid, active deal stages. Empty array when enabled is false.
	StageIds             *[]int                 `json:"stage_ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AddOrganizationFieldJSONBody_RequiredFields defines parameters for AddOrganizationField.
type AddOrganizationFieldJSONBody_RequiredFields struct {
	// Enabled Whether the field is required. When false, the field is optional. When true, the field is required when creating or updating organizations. Default is false.
	Enabled              *bool                  `json:"enabled,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AddOrganizationFieldJSONBody_UiVisibility defines parameters for AddOrganizationField.
type AddOrganizationFieldJSONBody_UiVisibility struct {
	// AddVisibleFlag Whether the field is shown in the add organization modal. Default is false. Cannot be set to false for the 'name' system field.
	AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

	// DetailsVisibleFlag Whether the field is shown in the organization details view. Default is true.
	DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

	// ShowInAddDealDialog Configuration for showing this organization field when adding a new deal. Only available for custom fields or specific eligible system fields. Default is show=false, order=null.
	ShowInAddDealDialog *struct {
		// Order Display order in the add deal dialog. This value is auto-calculated and managed by the system. When show is set to false, order is automatically set to null. When show changes from false to true, order is automatically assigned the next available position.
		Order *int `json:"order"`

		// Show Whether the field is shown in the add deal dialog. Default is false.
		Show *bool `json:"show,omitempty"`
	} `json:"show_in_add_deal_dialog,omitempty"`

	// ShowInAddPersonDialog Configuration for showing this organization field when adding a new person. Only available for custom fields or specific eligible system fields. Default is show=false, order=null.
	ShowInAddPersonDialog *struct {
		// Order Display order in the add person dialog. This value is auto-calculated and managed by the system. When show is set to false, order is automatically set to null. When show changes from false to true, order is automatically assigned the next available position.
		Order *int `json:"order"`

		// Show Whether the field is shown in the add person dialog. Default is false.
		Show *bool `json:"show,omitempty"`
	} `json:"show_in_add_person_dialog,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GetOrganizationFieldParams defines parameters for GetOrganizationField.
type GetOrganizationFieldParams struct {
	// IncludeFields Optional comma separated string array of additional data namespaces to include in response
	IncludeFields *GetOrganizationFieldParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`
}

// GetOrganizationFieldParamsIncludeFields defines parameters for GetOrganizationField.
type GetOrganizationFieldParamsIncludeFields string

// UpdateOrganizationFieldJSONBody defines parameters for UpdateOrganizationField.
type UpdateOrganizationFieldJSONBody struct {
	// Description Field description
	Description *string `json:"description"`

	// FieldName Field name
	FieldName *string `json:"field_name,omitempty"`

	// ImportantFields Configuration for highlighting the field at specific stages.
	ImportantFields *UpdateOrganizationFieldJSONBody_ImportantFields `json:"important_fields,omitempty"`

	// RequiredFields Required fields configuration for marking the field as mandatory when interacted with in the Pipedrive web UI.
	RequiredFields *UpdateOrganizationFieldJSONBody_RequiredFields `json:"required_fields,omitempty"`

	// UiVisibility UI visibility settings for the field. Controls where the field appears in the Pipedrive web UI.
	UiVisibility *UpdateOrganizationFieldJSONBody_UiVisibility `json:"ui_visibility,omitempty"`
}

// UpdateOrganizationFieldJSONBody_ImportantFields defines parameters for UpdateOrganizationField.
type UpdateOrganizationFieldJSONBody_ImportantFields struct {
	// Enabled Whether the field is marked as important. When false, the field is not highlighted. When true with empty stage_ids, the field is important everywhere. When true with specific stage_ids, the field is important only at those deal stages. Default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// StageIds Array of deal stage IDs where this organization field should be highlighted as important. Must reference valid, active deal stages. Empty array when enabled is false.
	StageIds             *[]int                 `json:"stage_ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdateOrganizationFieldJSONBody_RequiredFields defines parameters for UpdateOrganizationField.
type UpdateOrganizationFieldJSONBody_RequiredFields struct {
	// Enabled Whether the field is required. When false, the field is optional. When true, the field is required when creating or updating organizations. Default is false.
	Enabled              *bool                  `json:"enabled,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdateOrganizationFieldJSONBody_UiVisibility defines parameters for UpdateOrganizationField.
type UpdateOrganizationFieldJSONBody_UiVisibility struct {
	// AddVisibleFlag Whether the field is shown in the add organization modal. Default is false. Cannot be set to false for the 'name' system field.
	AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

	// DetailsVisibleFlag Whether the field is shown in the organization details view. Default is true.
	DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

	// ShowInAddDealDialog Configuration for showing this organization field when adding a new deal. Only available for custom fields or specific eligible system fields. Default is show=false, order=null.
	ShowInAddDealDialog *struct {
		// Order Display order in the add deal dialog. This value is auto-calculated and managed by the system. When show is set to false, order is automatically set to null. When show changes from false to true, order is automatically assigned the next available position.
		Order *int `json:"order"`

		// Show Whether the field is shown in the add deal dialog. Default is false.
		Show *bool `json:"show,omitempty"`
	} `json:"show_in_add_deal_dialog,omitempty"`

	// ShowInAddPersonDialog Configuration for showing this organization field when adding a new person. Only available for custom fields or specific eligible system fields. Default is show=false, order=null.
	ShowInAddPersonDialog *struct {
		// Order Display order in the add person dialog. This value is auto-calculated and managed by the system. When show is set to false, order is automatically set to null. When show changes from false to true, order is automatically assigned the next available position.
		Order *int `json:"order"`

		// Show Whether the field is shown in the add person dialog. Default is false.
		Show *bool `json:"show,omitempty"`
	} `json:"show_in_add_person_dialog,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// DeleteOrganizationFieldOptionsJSONBody defines parameters for DeleteOrganizationFieldOptions.
type DeleteOrganizationFieldOptionsJSONBody = []struct {
	// Id The unique identifier of the option to delete
	Id int `json:"id"`
}

// UpdateOrganizationFieldOptionsJSONBody defines parameters for UpdateOrganizationFieldOptions.
type UpdateOrganizationFieldOptionsJSONBody = []struct {
	// Id The unique identifier of the option to update
	Id int `json:"id"`

	// Label The new display label for the option
	Label string `json:"label"`
}

// AddOrganizationFieldOptionsJSONBody defines parameters for AddOrganizationFieldOptions.
type AddOrganizationFieldOptionsJSONBody = []struct {
	// Label The display label for the new option
	Label string `json:"label"`
}

// GetOrganizationsParams defines parameters for GetOrganizations.
type GetOrganizationsParams struct {
	// FilterId If supplied, only organizations matching the specified filter are returned
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// Ids Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// OwnerId If supplied, only organization owned by the specified user are returned. If filter_id is provided, this is ignored.
	OwnerId *int `form:"owner_id,omitempty" json:"owner_id,omitempty"`

	// UpdatedSince If set, only organizations with an `update_time` later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
	UpdatedSince *string `form:"updated_since,omitempty" json:"updated_since,omitempty"`

	// UpdatedUntil If set, only organizations with an `update_time` earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
	UpdatedUntil *string `form:"updated_until,omitempty" json:"updated_until,omitempty"`

	// SortBy The field to sort by. Supported fields: `id`, `update_time`, `add_time`.
	SortBy *GetOrganizationsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection The sorting direction. Supported values: `asc`, `desc`.
	SortDirection *GetOrganizationsParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`

	// IncludeFields Optional comma separated string array of additional fields to include
	IncludeFields *GetOrganizationsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// CustomFields Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.<br/>A maximum of 15 keys is allowed.
	CustomFields *string `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetOrganizationsParamsSortBy defines parameters for GetOrganizations.
type GetOrganizationsParamsSortBy string

// GetOrganizationsParamsSortDirection defines parameters for GetOrganizations.
type GetOrganizationsParamsSortDirection string

// GetOrganizationsParamsIncludeFields defines parameters for GetOrganizations.
type GetOrganizationsParamsIncludeFields string

// AddOrganizationJSONBody defines parameters for AddOrganization.
type AddOrganizationJSONBody struct {
	// AddTime The creation date and time of the organization
	AddTime *string `json:"add_time,omitempty"`

	// Address The address of the organization
	Address *struct {
		// AdminAreaLevel1 Admin area level 1 (e.g. state) of the organization
		AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

		// AdminAreaLevel2 Admin area level 2 (e.g. county) of the organization
		AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

		// Country Country of the organization
		Country *string `json:"country,omitempty"`

		// Locality Locality (e.g. city) of the organization
		Locality *string `json:"locality,omitempty"`

		// PostalCode Postal code of the organization
		PostalCode *string `json:"postal_code,omitempty"`

		// Route Route (e.g. street) of the organization
		Route *string `json:"route,omitempty"`

		// StreetNumber Street number of the organization
		StreetNumber *string `json:"street_number,omitempty"`

		// Sublocality Sublocality (e.g. neighborhood) of the organization
		Sublocality *string `json:"sublocality,omitempty"`

		// Subpremise Subpremise (e.g. apartment/suite number) of the organization
		Subpremise *string `json:"subpremise,omitempty"`

		// Value The full address of the organization
		Value *string `json:"value,omitempty"`
	} `json:"address,omitempty"`

	// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// LabelIds The IDs of labels assigned to the organization
	LabelIds *[]int `json:"label_ids,omitempty"`

	// Name The name of the organization
	Name *string `json:"name,omitempty"`

	// OwnerId The ID of the user who owns the organization
	OwnerId *int `json:"owner_id,omitempty"`

	// UpdateTime The last updated date and time of the organization
	UpdateTime *string `json:"update_time,omitempty"`

	// VisibleTo The visibility of the organization
	VisibleTo *int `json:"visible_to,omitempty"`
}

// SearchOrganizationParams defines parameters for SearchOrganization.
type SearchOrganizationParams struct {
	// Term The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded.
	Term string `form:"term" json:"term"`

	// Fields A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: `address`, `varchar`, `text`, `varchar_auto`, `double`, `monetary` and `phone`. Read more about searching by custom fields <a href="https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields" target="_blank" rel="noopener noreferrer">here</a>.
	Fields *SearchOrganizationParamsFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExactMatch When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive.
	ExactMatch *bool `form:"exact_match,omitempty" json:"exact_match,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// SearchOrganizationParamsFields defines parameters for SearchOrganization.
type SearchOrganizationParamsFields string

// GetOrganizationParams defines parameters for GetOrganization.
type GetOrganizationParams struct {
	// IncludeFields Optional comma separated string array of additional fields to include
	IncludeFields *GetOrganizationParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// CustomFields Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.<br/>A maximum of 15 keys is allowed.
	CustomFields *string `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`
}

// GetOrganizationParamsIncludeFields defines parameters for GetOrganization.
type GetOrganizationParamsIncludeFields string

// UpdateOrganizationJSONBody defines parameters for UpdateOrganization.
type UpdateOrganizationJSONBody struct {
	// AddTime The creation date and time of the organization
	AddTime *string `json:"add_time,omitempty"`

	// Address The address of the organization
	Address *struct {
		// AdminAreaLevel1 Admin area level 1 (e.g. state) of the organization
		AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

		// AdminAreaLevel2 Admin area level 2 (e.g. county) of the organization
		AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

		// Country Country of the organization
		Country *string `json:"country,omitempty"`

		// Locality Locality (e.g. city) of the organization
		Locality *string `json:"locality,omitempty"`

		// PostalCode Postal code of the organization
		PostalCode *string `json:"postal_code,omitempty"`

		// Route Route (e.g. street) of the organization
		Route *string `json:"route,omitempty"`

		// StreetNumber Street number of the organization
		StreetNumber *string `json:"street_number,omitempty"`

		// Sublocality Sublocality (e.g. neighborhood) of the organization
		Sublocality *string `json:"sublocality,omitempty"`

		// Subpremise Subpremise (e.g. apartment/suite number) of the organization
		Subpremise *string `json:"subpremise,omitempty"`

		// Value The full address of the organization
		Value *string `json:"value,omitempty"`
	} `json:"address,omitempty"`

	// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// LabelIds The IDs of labels assigned to the organization
	LabelIds *[]int `json:"label_ids,omitempty"`

	// Name The name of the organization
	Name *string `json:"name,omitempty"`

	// OwnerId The ID of the user who owns the organization
	OwnerId *int `json:"owner_id,omitempty"`

	// UpdateTime The last updated date and time of the organization
	UpdateTime *string `json:"update_time,omitempty"`

	// VisibleTo The visibility of the organization
	VisibleTo *int `json:"visible_to,omitempty"`
}

// GetOrganizationFollowersParams defines parameters for GetOrganizationFollowers.
type GetOrganizationFollowersParams struct {
	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// AddOrganizationFollowerJSONBody defines parameters for AddOrganizationFollower.
type AddOrganizationFollowerJSONBody struct {
	// UserId The ID of the user to add as a follower
	UserId int `json:"user_id"`
}

// GetOrganizationFollowersChangelogParams defines parameters for GetOrganizationFollowersChangelog.
type GetOrganizationFollowersChangelogParams struct {
	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetPersonFieldsParams defines parameters for GetPersonFields.
type GetPersonFieldsParams struct {
	// IncludeFields Optional comma separated string array of additional data namespaces to include in response
	IncludeFields *GetPersonFieldsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetPersonFieldsParamsIncludeFields defines parameters for GetPersonFields.
type GetPersonFieldsParamsIncludeFields string

// AddPersonFieldJSONBody defines parameters for AddPersonField.
type AddPersonFieldJSONBody struct {
	// Description Field description
	Description *string `json:"description"`

	// FieldName Field name
	FieldName string `json:"field_name"`

	// FieldType The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td><tr><td>`text`</td><td>Long text (up to 65k characters)</td><tr><td>`double`</td><td>Numeric value</td><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td><tr><td>`enum`</td><td>Options field with a single possible chosen option</td><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td><tr><td>`people`</td><td>Person field (contains a product ID which is stored on the same account)</td><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td><tr><td>`address`</td><td>Address field</dd></table>
	FieldType AddPersonFieldJSONBodyFieldType `json:"field_type"`

	// ImportantFields Configuration for highlighting the field at specific stages.
	ImportantFields *AddPersonFieldJSONBody_ImportantFields `json:"important_fields,omitempty"`

	// Options Field options (required for enum and set field types)
	Options *[]struct {
		// Label The option label
		Label string `json:"label"`
	} `json:"options,omitempty"`

	// RequiredFields Required fields configuration for marking the field as mandatory when interacted with in the Pipedrive web UI.
	RequiredFields *AddPersonFieldJSONBody_RequiredFields `json:"required_fields,omitempty"`

	// UiVisibility UI visibility settings for the field. Controls where the field appears in the Pipedrive web UI.
	UiVisibility *AddPersonFieldJSONBody_UiVisibility `json:"ui_visibility,omitempty"`
}

// AddPersonFieldJSONBodyFieldType defines parameters for AddPersonField.
type AddPersonFieldJSONBodyFieldType string

// AddPersonFieldJSONBody_ImportantFields defines parameters for AddPersonField.
type AddPersonFieldJSONBody_ImportantFields struct {
	// Enabled Whether the field is marked as important. When false, the field is not highlighted. When true with empty stage_ids, the field is important everywhere. When true with specific stage_ids, the field is important only at those deal stages. Default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// StageIds Array of deal stage IDs where this person field should be highlighted as important. Must reference valid, active deal stages. Empty array when enabled is false.
	StageIds             *[]int                 `json:"stage_ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AddPersonFieldJSONBody_RequiredFields defines parameters for AddPersonField.
type AddPersonFieldJSONBody_RequiredFields struct {
	// Enabled Whether the field is required. When false, the field is optional. When true, the field is required when creating or updating persons. Default is false.
	Enabled              *bool                  `json:"enabled,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AddPersonFieldJSONBody_UiVisibility defines parameters for AddPersonField.
type AddPersonFieldJSONBody_UiVisibility struct {
	// AddVisibleFlag Whether the field is shown in the add person modal. Default is false. Cannot be set to false for required system fields ('name', 'org_id').
	AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

	// DetailsVisibleFlag Whether the field is shown in the person details view. Default is true.
	DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

	// ShowInAddDealDialog Configuration for showing this person field when adding a new deal. Only available for custom fields or specific eligible system fields. Default is show=false, order=null.
	ShowInAddDealDialog *struct {
		// Order Display order in the add deal dialog. This value is auto-calculated and managed by the system. When show is set to false, order is automatically set to null. When show changes from false to true, order is automatically assigned the next available position.
		Order *int `json:"order"`

		// Show Whether the field is shown in the add deal dialog. Default is false.
		Show *bool `json:"show,omitempty"`
	} `json:"show_in_add_deal_dialog,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GetPersonFieldParams defines parameters for GetPersonField.
type GetPersonFieldParams struct {
	// IncludeFields Optional comma separated string array of additional data namespaces to include in response
	IncludeFields *GetPersonFieldParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`
}

// GetPersonFieldParamsIncludeFields defines parameters for GetPersonField.
type GetPersonFieldParamsIncludeFields string

// UpdatePersonFieldJSONBody defines parameters for UpdatePersonField.
type UpdatePersonFieldJSONBody struct {
	// Description Field description
	Description *string `json:"description"`

	// FieldName Field name
	FieldName *string `json:"field_name,omitempty"`

	// ImportantFields Configuration for highlighting the field at specific stages.
	ImportantFields *UpdatePersonFieldJSONBody_ImportantFields `json:"important_fields,omitempty"`

	// RequiredFields Required fields configuration for marking the field as mandatory when interacted with in the Pipedrive web UI.
	RequiredFields *UpdatePersonFieldJSONBody_RequiredFields `json:"required_fields,omitempty"`

	// UiVisibility UI visibility settings for the field. Controls where the field appears in the Pipedrive web UI.
	UiVisibility *UpdatePersonFieldJSONBody_UiVisibility `json:"ui_visibility,omitempty"`
}

// UpdatePersonFieldJSONBody_ImportantFields defines parameters for UpdatePersonField.
type UpdatePersonFieldJSONBody_ImportantFields struct {
	// Enabled Whether the field is marked as important. When false, the field is not highlighted. When true with empty stage_ids, the field is important everywhere. When true with specific stage_ids, the field is important only at those deal stages. Default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// StageIds Array of deal stage IDs where this person field should be highlighted as important. Must reference valid, active deal stages. Empty array when enabled is false.
	StageIds             *[]int                 `json:"stage_ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdatePersonFieldJSONBody_RequiredFields defines parameters for UpdatePersonField.
type UpdatePersonFieldJSONBody_RequiredFields struct {
	// Enabled Whether the field is required. When false, the field is optional. When true, the field is required when creating or updating persons. Default is false.
	Enabled              *bool                  `json:"enabled,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdatePersonFieldJSONBody_UiVisibility defines parameters for UpdatePersonField.
type UpdatePersonFieldJSONBody_UiVisibility struct {
	// AddVisibleFlag Whether the field is shown in the add person modal. Default is false. Cannot be set to false for required system fields ('name', 'org_id').
	AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

	// DetailsVisibleFlag Whether the field is shown in the person details view. Default is true.
	DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

	// ShowInAddDealDialog Configuration for showing this person field when adding a new deal. Only available for custom fields or specific eligible system fields. Default is show=false, order=null.
	ShowInAddDealDialog *struct {
		// Order Display order in the add deal dialog. This value is auto-calculated and managed by the system. When show is set to false, order is automatically set to null. When show changes from false to true, order is automatically assigned the next available position.
		Order *int `json:"order"`

		// Show Whether the field is shown in the add deal dialog. Default is false.
		Show *bool `json:"show,omitempty"`
	} `json:"show_in_add_deal_dialog,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// DeletePersonFieldOptionsJSONBody defines parameters for DeletePersonFieldOptions.
type DeletePersonFieldOptionsJSONBody = []struct {
	// Id The unique identifier of the option to delete
	Id int `json:"id"`
}

// UpdatePersonFieldOptionsJSONBody defines parameters for UpdatePersonFieldOptions.
type UpdatePersonFieldOptionsJSONBody = []struct {
	// Id The unique identifier of the option to update
	Id int `json:"id"`

	// Label The new display label for the option
	Label string `json:"label"`
}

// AddPersonFieldOptionsJSONBody defines parameters for AddPersonFieldOptions.
type AddPersonFieldOptionsJSONBody = []struct {
	// Label The display label for the new option
	Label string `json:"label"`
}

// GetPersonsParams defines parameters for GetPersons.
type GetPersonsParams struct {
	// FilterId If supplied, only persons matching the specified filter are returned
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// Ids Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// OwnerId If supplied, only persons owned by the specified user are returned. If filter_id is provided, this is ignored.
	OwnerId *int `form:"owner_id,omitempty" json:"owner_id,omitempty"`

	// OrgId If supplied, only persons linked to the specified organization are returned. If filter_id is provided, this is ignored.
	OrgId *int `form:"org_id,omitempty" json:"org_id,omitempty"`

	// DealId If supplied, only persons linked to the specified deal are returned. If filter_id is provided, this is ignored.
	DealId *int `form:"deal_id,omitempty" json:"deal_id,omitempty"`

	// UpdatedSince If set, only persons with an `update_time` later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
	UpdatedSince *string `form:"updated_since,omitempty" json:"updated_since,omitempty"`

	// UpdatedUntil If set, only persons with an `update_time` earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
	UpdatedUntil *string `form:"updated_until,omitempty" json:"updated_until,omitempty"`

	// SortBy The field to sort by. Supported fields: `id`, `update_time`, `add_time`.
	SortBy *GetPersonsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection The sorting direction. Supported values: `asc`, `desc`.
	SortDirection *GetPersonsParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`

	// IncludeFields Optional comma separated string array of additional fields to include. `marketing_status` and `doi_status` can only be included if the company has marketing app enabled.
	IncludeFields *GetPersonsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// CustomFields Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.<br/>A maximum of 15 keys is allowed.
	CustomFields *string `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetPersonsParamsSortBy defines parameters for GetPersons.
type GetPersonsParamsSortBy string

// GetPersonsParamsSortDirection defines parameters for GetPersons.
type GetPersonsParamsSortDirection string

// GetPersonsParamsIncludeFields defines parameters for GetPersons.
type GetPersonsParamsIncludeFields string

// AddPersonJSONBody defines parameters for AddPerson.
type AddPersonJSONBody struct {
	// AddTime The creation date and time of the person
	AddTime *string `json:"add_time,omitempty"`

	// Emails The emails of the person
	Emails *[]struct {
		// Label The email address classification label
		Label *bool `json:"label,omitempty"`

		// Primary Whether the email is primary or not
		Primary *bool `json:"primary,omitempty"`

		// Value The email address of the person
		Value *string `json:"value,omitempty"`
	} `json:"emails,omitempty"`

	// LabelIds The IDs of labels assigned to the person
	LabelIds *[]int `json:"label_ids,omitempty"`

	// MarketingStatus If the person does not have a valid email address, then the marketing status is **not set** and `no_consent` is returned for the `marketing_status` value when the new person is created. If the change is forbidden, the status will remain unchanged for every call that tries to modify the marketing status. Please be aware that it is only allowed **once** to change the marketing status from an old status to a new one.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`no_consent`</td><td>The customer has not given consent to receive any marketing communications</td></tr><tr><td>`unsubscribed`</td><td>The customers have unsubscribed from ALL marketing communications</td></tr><tr><td>`subscribed`</td><td>The customers are subscribed and are counted towards marketing caps</td></tr><tr><td>`archived`</td><td>The customers with `subscribed` status can be moved to `archived` to save consent, but they are not paid for</td></tr></table>
	MarketingStatus *AddPersonJSONBodyMarketingStatus `json:"marketing_status,omitempty"`

	// Name The name of the person
	Name *string `json:"name,omitempty"`

	// OrgId The ID of the organization linked to the person
	OrgId *int `json:"org_id,omitempty"`

	// OwnerId The ID of the user who owns the person
	OwnerId *int `json:"owner_id,omitempty"`

	// Phones The phones of the person
	Phones *[]struct {
		// Label The phone number classification label
		Label *bool `json:"label,omitempty"`

		// Primary Whether the phone number is primary or not
		Primary *bool `json:"primary,omitempty"`

		// Value The phone number of the person
		Value *string `json:"value,omitempty"`
	} `json:"phones,omitempty"`

	// UpdateTime The last updated date and time of the person
	UpdateTime *string `json:"update_time,omitempty"`

	// VisibleTo The visibility of the person
	VisibleTo *int `json:"visible_to,omitempty"`
}

// AddPersonJSONBodyMarketingStatus defines parameters for AddPerson.
type AddPersonJSONBodyMarketingStatus string

// SearchPersonsParams defines parameters for SearchPersons.
type SearchPersonsParams struct {
	// Term The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded.
	Term string `form:"term" json:"term"`

	// Fields A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: `address`, `varchar`, `text`, `varchar_auto`, `double`, `monetary` and `phone`. Read more about searching by custom fields <a href="https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields" target="_blank" rel="noopener noreferrer">here</a>.
	Fields *SearchPersonsParamsFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExactMatch When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive.
	ExactMatch *bool `form:"exact_match,omitempty" json:"exact_match,omitempty"`

	// OrganizationId Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
	OrganizationId *int `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// IncludeFields Supports including optional fields in the results which are not provided by default
	IncludeFields *SearchPersonsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// SearchPersonsParamsFields defines parameters for SearchPersons.
type SearchPersonsParamsFields string

// SearchPersonsParamsIncludeFields defines parameters for SearchPersons.
type SearchPersonsParamsIncludeFields string

// GetPersonParams defines parameters for GetPerson.
type GetPersonParams struct {
	// IncludeFields Optional comma separated string array of additional fields to include. `marketing_status` and `doi_status` can only be included if the company has marketing app enabled.
	IncludeFields *GetPersonParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// CustomFields Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.<br/>A maximum of 15 keys is allowed.
	CustomFields *string `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`
}

// GetPersonParamsIncludeFields defines parameters for GetPerson.
type GetPersonParamsIncludeFields string

// UpdatePersonJSONBody defines parameters for UpdatePerson.
type UpdatePersonJSONBody struct {
	// AddTime The creation date and time of the person
	AddTime *string `json:"add_time,omitempty"`

	// Emails The emails of the person
	Emails *[]struct {
		// Label The email address classification label
		Label *bool `json:"label,omitempty"`

		// Primary Whether the email is primary or not
		Primary *bool `json:"primary,omitempty"`

		// Value The email address of the person
		Value *string `json:"value,omitempty"`
	} `json:"emails,omitempty"`

	// LabelIds The IDs of labels assigned to the person
	LabelIds *[]int `json:"label_ids,omitempty"`

	// MarketingStatus If the person does not have a valid email address, then the marketing status is **not set** and `no_consent` is returned for the `marketing_status` value when the new person is created. If the change is forbidden, the status will remain unchanged for every call that tries to modify the marketing status. Please be aware that it is only allowed **once** to change the marketing status from an old status to a new one.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`no_consent`</td><td>The customer has not given consent to receive any marketing communications</td></tr><tr><td>`unsubscribed`</td><td>The customers have unsubscribed from ALL marketing communications</td></tr><tr><td>`subscribed`</td><td>The customers are subscribed and are counted towards marketing caps</td></tr><tr><td>`archived`</td><td>The customers with `subscribed` status can be moved to `archived` to save consent, but they are not paid for</td></tr></table>
	MarketingStatus *UpdatePersonJSONBodyMarketingStatus `json:"marketing_status,omitempty"`

	// Name The name of the person
	Name *string `json:"name,omitempty"`

	// OrgId The ID of the organization linked to the person
	OrgId *int `json:"org_id,omitempty"`

	// OwnerId The ID of the user who owns the person
	OwnerId *int `json:"owner_id,omitempty"`

	// Phones The phones of the person
	Phones *[]struct {
		// Label The phone number classification label
		Label *bool `json:"label,omitempty"`

		// Primary Whether the phone number is primary or not
		Primary *bool `json:"primary,omitempty"`

		// Value The phone number of the person
		Value *string `json:"value,omitempty"`
	} `json:"phones,omitempty"`

	// UpdateTime The last updated date and time of the person
	UpdateTime *string `json:"update_time,omitempty"`

	// VisibleTo The visibility of the person
	VisibleTo *int `json:"visible_to,omitempty"`
}

// UpdatePersonJSONBodyMarketingStatus defines parameters for UpdatePerson.
type UpdatePersonJSONBodyMarketingStatus string

// GetPersonFollowersParams defines parameters for GetPersonFollowers.
type GetPersonFollowersParams struct {
	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// AddPersonFollowerJSONBody defines parameters for AddPersonFollower.
type AddPersonFollowerJSONBody struct {
	// UserId The ID of the user to add as a follower
	UserId int `json:"user_id"`
}

// GetPersonFollowersChangelogParams defines parameters for GetPersonFollowersChangelog.
type GetPersonFollowersChangelogParams struct {
	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetPipelinesParams defines parameters for GetPipelines.
type GetPipelinesParams struct {
	// SortBy The field to sort by. Supported fields: `id`, `update_time`, `add_time`.
	SortBy *GetPipelinesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection The sorting direction. Supported values: `asc`, `desc`.
	SortDirection *GetPipelinesParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetPipelinesParamsSortBy defines parameters for GetPipelines.
type GetPipelinesParamsSortBy string

// GetPipelinesParamsSortDirection defines parameters for GetPipelines.
type GetPipelinesParamsSortDirection string

// AddPipelineJSONBody defines parameters for AddPipeline.
type AddPipelineJSONBody struct {
	// IsDealProbabilityEnabled Whether deal probability is disabled or enabled for this pipeline
	IsDealProbabilityEnabled *bool `json:"is_deal_probability_enabled,omitempty"`

	// Name The name of the pipeline
	Name string `json:"name"`
}

// UpdatePipelineJSONBody defines parameters for UpdatePipeline.
type UpdatePipelineJSONBody struct {
	// IsDealProbabilityEnabled Whether deal probability is disabled or enabled for this pipeline
	IsDealProbabilityEnabled *bool `json:"is_deal_probability_enabled,omitempty"`

	// Name The name of the pipeline
	Name *string `json:"name,omitempty"`
}

// GetProductFieldsParams defines parameters for GetProductFields.
type GetProductFieldsParams struct {
	// IncludeFields Optional comma separated string array of additional data namespaces to include in response
	IncludeFields *GetProductFieldsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetProductFieldsParamsIncludeFields defines parameters for GetProductFields.
type GetProductFieldsParamsIncludeFields string

// AddProductFieldJSONBody defines parameters for AddProductField.
type AddProductFieldJSONBody struct {
	// Description Field description
	Description *string `json:"description"`

	// FieldName Field name
	FieldName string `json:"field_name"`

	// FieldType The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td><tr><td>`text`</td><td>Long text (up to 65k characters)</td><tr><td>`double`</td><td>Numeric value</td><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td><tr><td>`enum`</td><td>Options field with a single possible chosen option</td><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td><tr><td>`people`</td><td>Person field (contains a product ID which is stored on the same account)</td><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td><tr><td>`address`</td><td>Address field</dd></table>
	FieldType AddProductFieldJSONBodyFieldType `json:"field_type"`

	// Options Field options (required for enum and set field types)
	Options *[]struct {
		// Label The option label
		Label string `json:"label"`
	} `json:"options,omitempty"`

	// UiVisibility UI visibility settings for the field. Controls where the field appears in the Pipedrive web UI. Note that products have a simpler visibility model than other entity types.
	UiVisibility *AddProductFieldJSONBody_UiVisibility `json:"ui_visibility,omitempty"`
}

// AddProductFieldJSONBodyFieldType defines parameters for AddProductField.
type AddProductFieldJSONBodyFieldType string

// AddProductFieldJSONBody_UiVisibility defines parameters for AddProductField.
type AddProductFieldJSONBody_UiVisibility struct {
	// AddVisibleFlag Whether the field is shown in the add product modal. Default is false. Cannot be set to false for the 'name' system field.
	AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

	// DetailsVisibleFlag Whether the field is shown in the product details view. Default is true.
	DetailsVisibleFlag   *bool                  `json:"details_visible_flag,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GetProductFieldParams defines parameters for GetProductField.
type GetProductFieldParams struct {
	// IncludeFields Optional comma separated string array of additional data namespaces to include in response
	IncludeFields *GetProductFieldParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`
}

// GetProductFieldParamsIncludeFields defines parameters for GetProductField.
type GetProductFieldParamsIncludeFields string

// UpdateProductFieldJSONBody defines parameters for UpdateProductField.
type UpdateProductFieldJSONBody struct {
	// Description Field description
	Description *string `json:"description"`

	// FieldName Field name
	FieldName *string `json:"field_name,omitempty"`

	// UiVisibility UI visibility settings for the field. Controls where the field appears in the Pipedrive web UI. Note that products have a simpler visibility model than other entity types.
	UiVisibility *UpdateProductFieldJSONBody_UiVisibility `json:"ui_visibility,omitempty"`
}

// UpdateProductFieldJSONBody_UiVisibility defines parameters for UpdateProductField.
type UpdateProductFieldJSONBody_UiVisibility struct {
	// AddVisibleFlag Whether the field is shown in the add product modal. Default is false. Cannot be set to false for the 'name' system field.
	AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

	// DetailsVisibleFlag Whether the field is shown in the product details view. Default is true.
	DetailsVisibleFlag   *bool                  `json:"details_visible_flag,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// DeleteProductFieldOptionsJSONBody defines parameters for DeleteProductFieldOptions.
type DeleteProductFieldOptionsJSONBody = []struct {
	// Id The unique identifier of the option to delete
	Id int `json:"id"`
}

// UpdateProductFieldOptionsJSONBody defines parameters for UpdateProductFieldOptions.
type UpdateProductFieldOptionsJSONBody = []struct {
	// Id The unique identifier of the option to update
	Id int `json:"id"`

	// Label The new display label for the option
	Label string `json:"label"`
}

// AddProductFieldOptionsJSONBody defines parameters for AddProductFieldOptions.
type AddProductFieldOptionsJSONBody = []struct {
	// Label The display label for the new option
	Label string `json:"label"`
}

// GetProductsParams defines parameters for GetProducts.
type GetProductsParams struct {
	// OwnerId If supplied, only products owned by the given user will be returned
	OwnerId *int `form:"owner_id,omitempty" json:"owner_id,omitempty"`

	// Ids Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// FilterId The ID of the filter to use
	FilterId *int `form:"filter_id,omitempty" json:"filter_id,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy The field to sort by. Supported fields: `id`, `name`, `add_time`, `update_time`.
	SortBy *GetProductsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection The sorting direction. Supported values: `asc`, `desc`.
	SortDirection *GetProductsParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`

	// CustomFields Comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for a smaller response.<br/>A maximum of 15 keys is allowed.
	CustomFields *string `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`
}

// GetProductsParamsSortBy defines parameters for GetProducts.
type GetProductsParamsSortBy string

// GetProductsParamsSortDirection defines parameters for GetProducts.
type GetProductsParamsSortDirection string

// AddProductJSONBody defines parameters for AddProduct.
type AddProductJSONBody struct {
	// BillingFrequency Only available in Growth and above plans
	//
	// How often a customer is billed for access to a service or product
	BillingFrequency *AddProductJSONBodyBillingFrequency `json:"billing_frequency,omitempty"`

	// BillingFrequencyCycles Only available in Growth and above plans
	//
	// The number of times the billing frequency repeats for a product in a deal
	//
	// When `billing_frequency` is set to `one-time`, this field must be `null`
	//
	// When `billing_frequency` is set to `weekly`, this field cannot be `null`
	//
	// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
	//
	// Must be a positive integer less or equal to 208
	BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

	// Category The category of the product
	Category *float32 `json:"category,omitempty"`

	// Code The product code
	Code *string `json:"code,omitempty"`

	// Description The product description
	Description *string `json:"description,omitempty"`

	// IsLinkable Whether this product can be added to a deal or not
	IsLinkable *bool `json:"is_linkable,omitempty"`

	// Name The name of the product. Cannot be an empty string
	Name string `json:"name"`

	// OwnerId The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used
	OwnerId *int `json:"owner_id,omitempty"`

	// Prices An array of objects, each containing: `currency` (string), `price` (number), `cost` (number, optional), `direct_cost` (number, optional). Note that there can only be one price per product per currency. When `prices` is omitted altogether, a default price of 0 and the user's default currency will be assigned.
	Prices *[]map[string]interface{} `json:"prices,omitempty"`

	// Tax The tax percentage
	Tax *float32 `json:"tax,omitempty"`

	// Unit The unit in which this product is sold
	Unit *string `json:"unit,omitempty"`

	// VisibleTo The visibility of the product. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href="https://support.pipedrive.com/en/article/visibility-groups" target="_blank" rel="noopener noreferrer">here</a>.<h4>Light / Growth and Professional plans</h4><table><tr><th style="width: 40px">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Premium / Ultimate plan</h4><table><tr><th style="width: 40px">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
	VisibleTo *AddProductJSONBodyVisibleTo `json:"visible_to,omitempty"`
}

// AddProductJSONBodyBillingFrequency defines parameters for AddProduct.
type AddProductJSONBodyBillingFrequency string

// AddProductJSONBodyVisibleTo defines parameters for AddProduct.
type AddProductJSONBodyVisibleTo float32

// SearchProductsParams defines parameters for SearchProducts.
type SearchProductsParams struct {
	// Term The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded.
	Term string `form:"term" json:"term"`

	// Fields A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: `address`, `varchar`, `text`, `varchar_auto`, `double`, `monetary` and `phone`. Read more about searching by custom fields <a href="https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields" target="_blank" rel="noopener noreferrer">here</a>.
	Fields *SearchProductsParamsFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExactMatch When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive.
	ExactMatch *bool `form:"exact_match,omitempty" json:"exact_match,omitempty"`

	// IncludeFields Supports including optional fields in the results which are not provided by default
	IncludeFields *SearchProductsParamsIncludeFields `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// SearchProductsParamsFields defines parameters for SearchProducts.
type SearchProductsParamsFields string

// SearchProductsParamsIncludeFields defines parameters for SearchProducts.
type SearchProductsParamsIncludeFields string

// UpdateProductJSONBody defines parameters for UpdateProduct.
type UpdateProductJSONBody struct {
	// BillingFrequency Only available in Growth and above plans
	//
	// How often a customer is billed for access to a service or product
	BillingFrequency *UpdateProductJSONBodyBillingFrequency `json:"billing_frequency,omitempty"`

	// BillingFrequencyCycles Only available in Growth and above plans
	//
	// The number of times the billing frequency repeats for a product in a deal
	//
	// When `billing_frequency` is set to `one-time`, this field must be `null`
	//
	// When `billing_frequency` is set to `weekly`, this field cannot be `null`
	//
	// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
	//
	// Must be a positive integer less or equal to 208
	BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

	// Category The category of the product
	Category *float32 `json:"category,omitempty"`

	// Code The product code
	Code *string `json:"code,omitempty"`

	// Description The product description
	Description *string `json:"description,omitempty"`

	// IsLinkable Whether this product can be added to a deal or not
	IsLinkable *bool `json:"is_linkable,omitempty"`

	// Name The name of the product. Cannot be an empty string
	Name *string `json:"name,omitempty"`

	// OwnerId The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used
	OwnerId *int `json:"owner_id,omitempty"`

	// Prices An array of objects, each containing: `currency` (string), `price` (number), `cost` (number, optional), `direct_cost` (number, optional). Note that there can only be one price per product per currency. When `prices` is omitted altogether, a default price of 0 and the user's default currency will be assigned.
	Prices *[]map[string]interface{} `json:"prices,omitempty"`

	// Tax The tax percentage
	Tax *float32 `json:"tax,omitempty"`

	// Unit The unit in which this product is sold
	Unit *string `json:"unit,omitempty"`

	// VisibleTo The visibility of the product. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href="https://support.pipedrive.com/en/article/visibility-groups" target="_blank" rel="noopener noreferrer">here</a>.<h4>Light / Growth and Professional plans</h4><table><tr><th style="width: 40px">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Premium / Ultimate plan</h4><table><tr><th style="width: 40px">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
	VisibleTo *UpdateProductJSONBodyVisibleTo `json:"visible_to,omitempty"`
}

// UpdateProductJSONBodyBillingFrequency defines parameters for UpdateProduct.
type UpdateProductJSONBodyBillingFrequency string

// UpdateProductJSONBodyVisibleTo defines parameters for UpdateProduct.
type UpdateProductJSONBodyVisibleTo float32

// GetProductFollowersParams defines parameters for GetProductFollowers.
type GetProductFollowersParams struct {
	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// AddProductFollowerJSONBody defines parameters for AddProductFollower.
type AddProductFollowerJSONBody struct {
	// UserId The ID of the user to add as a follower
	UserId int `json:"user_id"`
}

// GetProductFollowersChangelogParams defines parameters for GetProductFollowersChangelog.
type GetProductFollowersChangelogParams struct {
	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// UploadProductImageMultipartBody defines parameters for UploadProductImage.
type UploadProductImageMultipartBody struct {
	// Data One image supplied in the multipart/form-data encoding
	Data openapi_types.File `json:"data"`
}

// UpdateProductImageMultipartBody defines parameters for UpdateProductImage.
type UpdateProductImageMultipartBody struct {
	// Data One image supplied in the multipart/form-data encoding
	Data openapi_types.File `json:"data"`
}

// GetProductVariationsParams defines parameters for GetProductVariations.
type GetProductVariationsParams struct {
	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddProductVariationJSONBody defines parameters for AddProductVariation.
type AddProductVariationJSONBody struct {
	// Name The name of the product variation. The maximum length is 255 characters.
	Name string `json:"name"`

	// Prices Array of objects, each containing: currency (string), price (number), cost (number, optional), direct_cost (number, optional), notes (string, optional). When prices is omitted altogether, a default price of 0, a default cost of 0, a default direct_cost of 0 and the user's default currency will be assigned.
	Prices *[]map[string]interface{} `json:"prices,omitempty"`
}

// UpdateProductVariationJSONBody defines parameters for UpdateProductVariation.
type UpdateProductVariationJSONBody struct {
	// Name The name of the product variation. The maximum length is 255 characters.
	Name *string `json:"name,omitempty"`

	// Prices Array of objects, each containing: currency (string), price (number), cost (number, optional), direct_cost (number, optional), notes (string, optional). When prices is omitted altogether, a default price of 0, a default cost of 0, a default direct_cost of 0 and the user's default currency will be assigned.
	Prices *[]map[string]interface{} `json:"prices,omitempty"`
}

// GetStagesParams defines parameters for GetStages.
type GetStagesParams struct {
	// PipelineId The ID of the pipeline to fetch stages for. If omitted, stages for all pipelines will be fetched.
	PipelineId *int `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty"`

	// SortBy The field to sort by. Supported fields: `id`, `update_time`, `add_time`, `order_nr`.
	SortBy *GetStagesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection The sorting direction. Supported values: `asc`, `desc`.
	SortDirection *GetStagesParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`

	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetStagesParamsSortBy defines parameters for GetStages.
type GetStagesParamsSortBy string

// GetStagesParamsSortDirection defines parameters for GetStages.
type GetStagesParamsSortDirection string

// AddStageJSONBody defines parameters for AddStage.
type AddStageJSONBody struct {
	// DaysToRotten The number of days the deals not updated in this stage would become rotten. Applies only if the `is_deal_rot_enabled` is set.
	DaysToRotten *int `json:"days_to_rotten,omitempty"`

	// DealProbability The success probability percentage of the deal. Used/shown when deal weighted values are used.
	DealProbability *int `json:"deal_probability,omitempty"`

	// IsDealRotEnabled Whether deals in this stage can become rotten
	IsDealRotEnabled *bool `json:"is_deal_rot_enabled,omitempty"`

	// Name The name of the stage
	Name string `json:"name"`

	// PipelineId The ID of the pipeline to add stage to
	PipelineId int `json:"pipeline_id"`
}

// UpdateStageJSONBody defines parameters for UpdateStage.
type UpdateStageJSONBody struct {
	// DaysToRotten The number of days the deals not updated in this stage would become rotten. Applies only if the `is_deal_rot_enabled` is set.
	DaysToRotten *int `json:"days_to_rotten,omitempty"`

	// DealProbability The success probability percentage of the deal. Used/shown when deal weighted values are used.
	DealProbability *int `json:"deal_probability,omitempty"`

	// IsDealRotEnabled Whether deals in this stage can become rotten
	IsDealRotEnabled *bool `json:"is_deal_rot_enabled,omitempty"`

	// Name The name of the stage
	Name *string `json:"name,omitempty"`

	// PipelineId The ID of the pipeline to add stage to
	PipelineId *int `json:"pipeline_id,omitempty"`
}

// GetUserFollowersParams defines parameters for GetUserFollowers.
type GetUserFollowersParams struct {
	// Limit For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor For pagination, the marker (an opaque string value) representing the first item on the next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// AddActivityJSONRequestBody defines body for AddActivity for application/json ContentType.
type AddActivityJSONRequestBody AddActivityJSONBody

// UpdateActivityJSONRequestBody defines body for UpdateActivity for application/json ContentType.
type UpdateActivityJSONRequestBody UpdateActivityJSONBody

// AddDealFieldJSONRequestBody defines body for AddDealField for application/json ContentType.
type AddDealFieldJSONRequestBody AddDealFieldJSONBody

// UpdateDealFieldJSONRequestBody defines body for UpdateDealField for application/json ContentType.
type UpdateDealFieldJSONRequestBody UpdateDealFieldJSONBody

// DeleteDealFieldOptionsJSONRequestBody defines body for DeleteDealFieldOptions for application/json ContentType.
type DeleteDealFieldOptionsJSONRequestBody = DeleteDealFieldOptionsJSONBody

// UpdateDealFieldOptionsJSONRequestBody defines body for UpdateDealFieldOptions for application/json ContentType.
type UpdateDealFieldOptionsJSONRequestBody = UpdateDealFieldOptionsJSONBody

// AddDealFieldOptionsJSONRequestBody defines body for AddDealFieldOptions for application/json ContentType.
type AddDealFieldOptionsJSONRequestBody = AddDealFieldOptionsJSONBody

// AddDealJSONRequestBody defines body for AddDeal for application/json ContentType.
type AddDealJSONRequestBody AddDealJSONBody

// UpdateDealJSONRequestBody defines body for UpdateDeal for application/json ContentType.
type UpdateDealJSONRequestBody UpdateDealJSONBody

// PostAdditionalDiscountJSONRequestBody defines body for PostAdditionalDiscount for application/json ContentType.
type PostAdditionalDiscountJSONRequestBody PostAdditionalDiscountJSONBody

// UpdateAdditionalDiscountJSONRequestBody defines body for UpdateAdditionalDiscount for application/json ContentType.
type UpdateAdditionalDiscountJSONRequestBody UpdateAdditionalDiscountJSONBody

// AddDealFollowerJSONRequestBody defines body for AddDealFollower for application/json ContentType.
type AddDealFollowerJSONRequestBody AddDealFollowerJSONBody

// PostInstallmentJSONRequestBody defines body for PostInstallment for application/json ContentType.
type PostInstallmentJSONRequestBody PostInstallmentJSONBody

// UpdateInstallmentJSONRequestBody defines body for UpdateInstallment for application/json ContentType.
type UpdateInstallmentJSONRequestBody UpdateInstallmentJSONBody

// AddDealProductJSONRequestBody defines body for AddDealProduct for application/json ContentType.
type AddDealProductJSONRequestBody AddDealProductJSONBody

// AddManyDealProductsJSONRequestBody defines body for AddManyDealProducts for application/json ContentType.
type AddManyDealProductsJSONRequestBody AddManyDealProductsJSONBody

// UpdateDealProductJSONRequestBody defines body for UpdateDealProduct for application/json ContentType.
type UpdateDealProductJSONRequestBody UpdateDealProductJSONBody

// ConvertLeadToDealJSONRequestBody defines body for ConvertLeadToDeal for application/json ContentType.
type ConvertLeadToDealJSONRequestBody ConvertLeadToDealJSONBody

// AddOrganizationFieldJSONRequestBody defines body for AddOrganizationField for application/json ContentType.
type AddOrganizationFieldJSONRequestBody AddOrganizationFieldJSONBody

// UpdateOrganizationFieldJSONRequestBody defines body for UpdateOrganizationField for application/json ContentType.
type UpdateOrganizationFieldJSONRequestBody UpdateOrganizationFieldJSONBody

// DeleteOrganizationFieldOptionsJSONRequestBody defines body for DeleteOrganizationFieldOptions for application/json ContentType.
type DeleteOrganizationFieldOptionsJSONRequestBody = DeleteOrganizationFieldOptionsJSONBody

// UpdateOrganizationFieldOptionsJSONRequestBody defines body for UpdateOrganizationFieldOptions for application/json ContentType.
type UpdateOrganizationFieldOptionsJSONRequestBody = UpdateOrganizationFieldOptionsJSONBody

// AddOrganizationFieldOptionsJSONRequestBody defines body for AddOrganizationFieldOptions for application/json ContentType.
type AddOrganizationFieldOptionsJSONRequestBody = AddOrganizationFieldOptionsJSONBody

// AddOrganizationJSONRequestBody defines body for AddOrganization for application/json ContentType.
type AddOrganizationJSONRequestBody AddOrganizationJSONBody

// UpdateOrganizationJSONRequestBody defines body for UpdateOrganization for application/json ContentType.
type UpdateOrganizationJSONRequestBody UpdateOrganizationJSONBody

// AddOrganizationFollowerJSONRequestBody defines body for AddOrganizationFollower for application/json ContentType.
type AddOrganizationFollowerJSONRequestBody AddOrganizationFollowerJSONBody

// AddPersonFieldJSONRequestBody defines body for AddPersonField for application/json ContentType.
type AddPersonFieldJSONRequestBody AddPersonFieldJSONBody

// UpdatePersonFieldJSONRequestBody defines body for UpdatePersonField for application/json ContentType.
type UpdatePersonFieldJSONRequestBody UpdatePersonFieldJSONBody

// DeletePersonFieldOptionsJSONRequestBody defines body for DeletePersonFieldOptions for application/json ContentType.
type DeletePersonFieldOptionsJSONRequestBody = DeletePersonFieldOptionsJSONBody

// UpdatePersonFieldOptionsJSONRequestBody defines body for UpdatePersonFieldOptions for application/json ContentType.
type UpdatePersonFieldOptionsJSONRequestBody = UpdatePersonFieldOptionsJSONBody

// AddPersonFieldOptionsJSONRequestBody defines body for AddPersonFieldOptions for application/json ContentType.
type AddPersonFieldOptionsJSONRequestBody = AddPersonFieldOptionsJSONBody

// AddPersonJSONRequestBody defines body for AddPerson for application/json ContentType.
type AddPersonJSONRequestBody AddPersonJSONBody

// UpdatePersonJSONRequestBody defines body for UpdatePerson for application/json ContentType.
type UpdatePersonJSONRequestBody UpdatePersonJSONBody

// AddPersonFollowerJSONRequestBody defines body for AddPersonFollower for application/json ContentType.
type AddPersonFollowerJSONRequestBody AddPersonFollowerJSONBody

// AddPipelineJSONRequestBody defines body for AddPipeline for application/json ContentType.
type AddPipelineJSONRequestBody AddPipelineJSONBody

// UpdatePipelineJSONRequestBody defines body for UpdatePipeline for application/json ContentType.
type UpdatePipelineJSONRequestBody UpdatePipelineJSONBody

// AddProductFieldJSONRequestBody defines body for AddProductField for application/json ContentType.
type AddProductFieldJSONRequestBody AddProductFieldJSONBody

// UpdateProductFieldJSONRequestBody defines body for UpdateProductField for application/json ContentType.
type UpdateProductFieldJSONRequestBody UpdateProductFieldJSONBody

// DeleteProductFieldOptionsJSONRequestBody defines body for DeleteProductFieldOptions for application/json ContentType.
type DeleteProductFieldOptionsJSONRequestBody = DeleteProductFieldOptionsJSONBody

// UpdateProductFieldOptionsJSONRequestBody defines body for UpdateProductFieldOptions for application/json ContentType.
type UpdateProductFieldOptionsJSONRequestBody = UpdateProductFieldOptionsJSONBody

// AddProductFieldOptionsJSONRequestBody defines body for AddProductFieldOptions for application/json ContentType.
type AddProductFieldOptionsJSONRequestBody = AddProductFieldOptionsJSONBody

// AddProductJSONRequestBody defines body for AddProduct for application/json ContentType.
type AddProductJSONRequestBody AddProductJSONBody

// UpdateProductJSONRequestBody defines body for UpdateProduct for application/json ContentType.
type UpdateProductJSONRequestBody UpdateProductJSONBody

// AddProductFollowerJSONRequestBody defines body for AddProductFollower for application/json ContentType.
type AddProductFollowerJSONRequestBody AddProductFollowerJSONBody

// UploadProductImageMultipartRequestBody defines body for UploadProductImage for multipart/form-data ContentType.
type UploadProductImageMultipartRequestBody UploadProductImageMultipartBody

// UpdateProductImageMultipartRequestBody defines body for UpdateProductImage for multipart/form-data ContentType.
type UpdateProductImageMultipartRequestBody UpdateProductImageMultipartBody

// AddProductVariationJSONRequestBody defines body for AddProductVariation for application/json ContentType.
type AddProductVariationJSONRequestBody AddProductVariationJSONBody

// UpdateProductVariationJSONRequestBody defines body for UpdateProductVariation for application/json ContentType.
type UpdateProductVariationJSONRequestBody UpdateProductVariationJSONBody

// AddStageJSONRequestBody defines body for AddStage for application/json ContentType.
type AddStageJSONRequestBody AddStageJSONBody

// UpdateStageJSONRequestBody defines body for UpdateStage for application/json ContentType.
type UpdateStageJSONRequestBody UpdateStageJSONBody

// Getter for additional properties for AddDealFieldJSONBody_ImportantFields. Returns the specified
// element and whether it was found
func (a AddDealFieldJSONBody_ImportantFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AddDealFieldJSONBody_ImportantFields
func (a *AddDealFieldJSONBody_ImportantFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AddDealFieldJSONBody_ImportantFields to handle AdditionalProperties
func (a *AddDealFieldJSONBody_ImportantFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stage_ids"]; found {
		err = json.Unmarshal(raw, &a.StageIds)
		if err != nil {
			return fmt.Errorf("error reading 'stage_ids': %w", err)
		}
		delete(object, "stage_ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AddDealFieldJSONBody_ImportantFields to handle AdditionalProperties
func (a AddDealFieldJSONBody_ImportantFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.StageIds != nil {
		object["stage_ids"], err = json.Marshal(a.StageIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AddDealFieldJSONBody_RequiredFields. Returns the specified
// element and whether it was found
func (a AddDealFieldJSONBody_RequiredFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AddDealFieldJSONBody_RequiredFields
func (a *AddDealFieldJSONBody_RequiredFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AddDealFieldJSONBody_RequiredFields to handle AdditionalProperties
func (a *AddDealFieldJSONBody_RequiredFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stage_ids"]; found {
		err = json.Unmarshal(raw, &a.StageIds)
		if err != nil {
			return fmt.Errorf("error reading 'stage_ids': %w", err)
		}
		delete(object, "stage_ids")
	}

	if raw, found := object["statuses"]; found {
		err = json.Unmarshal(raw, &a.Statuses)
		if err != nil {
			return fmt.Errorf("error reading 'statuses': %w", err)
		}
		delete(object, "statuses")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AddDealFieldJSONBody_RequiredFields to handle AdditionalProperties
func (a AddDealFieldJSONBody_RequiredFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.StageIds != nil {
		object["stage_ids"], err = json.Marshal(a.StageIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_ids': %w", err)
		}
	}

	if a.Statuses != nil {
		object["statuses"], err = json.Marshal(a.Statuses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'statuses': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AddDealFieldJSONBody_UiVisibility. Returns the specified
// element and whether it was found
func (a AddDealFieldJSONBody_UiVisibility) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AddDealFieldJSONBody_UiVisibility
func (a *AddDealFieldJSONBody_UiVisibility) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AddDealFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a *AddDealFieldJSONBody_UiVisibility) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["add_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.AddVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'add_visible_flag': %w", err)
		}
		delete(object, "add_visible_flag")
	}

	if raw, found := object["details_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.DetailsVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'details_visible_flag': %w", err)
		}
		delete(object, "details_visible_flag")
	}

	if raw, found := object["projects_detail_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.ProjectsDetailVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'projects_detail_visible_flag': %w", err)
		}
		delete(object, "projects_detail_visible_flag")
	}

	if raw, found := object["show_in_pipelines"]; found {
		err = json.Unmarshal(raw, &a.ShowInPipelines)
		if err != nil {
			return fmt.Errorf("error reading 'show_in_pipelines': %w", err)
		}
		delete(object, "show_in_pipelines")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AddDealFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a AddDealFieldJSONBody_UiVisibility) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AddVisibleFlag != nil {
		object["add_visible_flag"], err = json.Marshal(a.AddVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_visible_flag': %w", err)
		}
	}

	if a.DetailsVisibleFlag != nil {
		object["details_visible_flag"], err = json.Marshal(a.DetailsVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'details_visible_flag': %w", err)
		}
	}

	if a.ProjectsDetailVisibleFlag != nil {
		object["projects_detail_visible_flag"], err = json.Marshal(a.ProjectsDetailVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'projects_detail_visible_flag': %w", err)
		}
	}

	if a.ShowInPipelines != nil {
		object["show_in_pipelines"], err = json.Marshal(a.ShowInPipelines)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'show_in_pipelines': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateDealFieldJSONBody_ImportantFields. Returns the specified
// element and whether it was found
func (a UpdateDealFieldJSONBody_ImportantFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateDealFieldJSONBody_ImportantFields
func (a *UpdateDealFieldJSONBody_ImportantFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateDealFieldJSONBody_ImportantFields to handle AdditionalProperties
func (a *UpdateDealFieldJSONBody_ImportantFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stage_ids"]; found {
		err = json.Unmarshal(raw, &a.StageIds)
		if err != nil {
			return fmt.Errorf("error reading 'stage_ids': %w", err)
		}
		delete(object, "stage_ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateDealFieldJSONBody_ImportantFields to handle AdditionalProperties
func (a UpdateDealFieldJSONBody_ImportantFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.StageIds != nil {
		object["stage_ids"], err = json.Marshal(a.StageIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateDealFieldJSONBody_RequiredFields. Returns the specified
// element and whether it was found
func (a UpdateDealFieldJSONBody_RequiredFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateDealFieldJSONBody_RequiredFields
func (a *UpdateDealFieldJSONBody_RequiredFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateDealFieldJSONBody_RequiredFields to handle AdditionalProperties
func (a *UpdateDealFieldJSONBody_RequiredFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stage_ids"]; found {
		err = json.Unmarshal(raw, &a.StageIds)
		if err != nil {
			return fmt.Errorf("error reading 'stage_ids': %w", err)
		}
		delete(object, "stage_ids")
	}

	if raw, found := object["statuses"]; found {
		err = json.Unmarshal(raw, &a.Statuses)
		if err != nil {
			return fmt.Errorf("error reading 'statuses': %w", err)
		}
		delete(object, "statuses")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateDealFieldJSONBody_RequiredFields to handle AdditionalProperties
func (a UpdateDealFieldJSONBody_RequiredFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.StageIds != nil {
		object["stage_ids"], err = json.Marshal(a.StageIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_ids': %w", err)
		}
	}

	if a.Statuses != nil {
		object["statuses"], err = json.Marshal(a.Statuses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'statuses': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateDealFieldJSONBody_UiVisibility. Returns the specified
// element and whether it was found
func (a UpdateDealFieldJSONBody_UiVisibility) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateDealFieldJSONBody_UiVisibility
func (a *UpdateDealFieldJSONBody_UiVisibility) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateDealFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a *UpdateDealFieldJSONBody_UiVisibility) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["add_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.AddVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'add_visible_flag': %w", err)
		}
		delete(object, "add_visible_flag")
	}

	if raw, found := object["details_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.DetailsVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'details_visible_flag': %w", err)
		}
		delete(object, "details_visible_flag")
	}

	if raw, found := object["projects_detail_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.ProjectsDetailVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'projects_detail_visible_flag': %w", err)
		}
		delete(object, "projects_detail_visible_flag")
	}

	if raw, found := object["show_in_pipelines"]; found {
		err = json.Unmarshal(raw, &a.ShowInPipelines)
		if err != nil {
			return fmt.Errorf("error reading 'show_in_pipelines': %w", err)
		}
		delete(object, "show_in_pipelines")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateDealFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a UpdateDealFieldJSONBody_UiVisibility) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AddVisibleFlag != nil {
		object["add_visible_flag"], err = json.Marshal(a.AddVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_visible_flag': %w", err)
		}
	}

	if a.DetailsVisibleFlag != nil {
		object["details_visible_flag"], err = json.Marshal(a.DetailsVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'details_visible_flag': %w", err)
		}
	}

	if a.ProjectsDetailVisibleFlag != nil {
		object["projects_detail_visible_flag"], err = json.Marshal(a.ProjectsDetailVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'projects_detail_visible_flag': %w", err)
		}
	}

	if a.ShowInPipelines != nil {
		object["show_in_pipelines"], err = json.Marshal(a.ShowInPipelines)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'show_in_pipelines': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AddOrganizationFieldJSONBody_ImportantFields. Returns the specified
// element and whether it was found
func (a AddOrganizationFieldJSONBody_ImportantFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AddOrganizationFieldJSONBody_ImportantFields
func (a *AddOrganizationFieldJSONBody_ImportantFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AddOrganizationFieldJSONBody_ImportantFields to handle AdditionalProperties
func (a *AddOrganizationFieldJSONBody_ImportantFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stage_ids"]; found {
		err = json.Unmarshal(raw, &a.StageIds)
		if err != nil {
			return fmt.Errorf("error reading 'stage_ids': %w", err)
		}
		delete(object, "stage_ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AddOrganizationFieldJSONBody_ImportantFields to handle AdditionalProperties
func (a AddOrganizationFieldJSONBody_ImportantFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.StageIds != nil {
		object["stage_ids"], err = json.Marshal(a.StageIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AddOrganizationFieldJSONBody_RequiredFields. Returns the specified
// element and whether it was found
func (a AddOrganizationFieldJSONBody_RequiredFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AddOrganizationFieldJSONBody_RequiredFields
func (a *AddOrganizationFieldJSONBody_RequiredFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AddOrganizationFieldJSONBody_RequiredFields to handle AdditionalProperties
func (a *AddOrganizationFieldJSONBody_RequiredFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AddOrganizationFieldJSONBody_RequiredFields to handle AdditionalProperties
func (a AddOrganizationFieldJSONBody_RequiredFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AddOrganizationFieldJSONBody_UiVisibility. Returns the specified
// element and whether it was found
func (a AddOrganizationFieldJSONBody_UiVisibility) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AddOrganizationFieldJSONBody_UiVisibility
func (a *AddOrganizationFieldJSONBody_UiVisibility) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AddOrganizationFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a *AddOrganizationFieldJSONBody_UiVisibility) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["add_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.AddVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'add_visible_flag': %w", err)
		}
		delete(object, "add_visible_flag")
	}

	if raw, found := object["details_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.DetailsVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'details_visible_flag': %w", err)
		}
		delete(object, "details_visible_flag")
	}

	if raw, found := object["show_in_add_deal_dialog"]; found {
		err = json.Unmarshal(raw, &a.ShowInAddDealDialog)
		if err != nil {
			return fmt.Errorf("error reading 'show_in_add_deal_dialog': %w", err)
		}
		delete(object, "show_in_add_deal_dialog")
	}

	if raw, found := object["show_in_add_person_dialog"]; found {
		err = json.Unmarshal(raw, &a.ShowInAddPersonDialog)
		if err != nil {
			return fmt.Errorf("error reading 'show_in_add_person_dialog': %w", err)
		}
		delete(object, "show_in_add_person_dialog")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AddOrganizationFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a AddOrganizationFieldJSONBody_UiVisibility) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AddVisibleFlag != nil {
		object["add_visible_flag"], err = json.Marshal(a.AddVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_visible_flag': %w", err)
		}
	}

	if a.DetailsVisibleFlag != nil {
		object["details_visible_flag"], err = json.Marshal(a.DetailsVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'details_visible_flag': %w", err)
		}
	}

	if a.ShowInAddDealDialog != nil {
		object["show_in_add_deal_dialog"], err = json.Marshal(a.ShowInAddDealDialog)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'show_in_add_deal_dialog': %w", err)
		}
	}

	if a.ShowInAddPersonDialog != nil {
		object["show_in_add_person_dialog"], err = json.Marshal(a.ShowInAddPersonDialog)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'show_in_add_person_dialog': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateOrganizationFieldJSONBody_ImportantFields. Returns the specified
// element and whether it was found
func (a UpdateOrganizationFieldJSONBody_ImportantFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateOrganizationFieldJSONBody_ImportantFields
func (a *UpdateOrganizationFieldJSONBody_ImportantFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateOrganizationFieldJSONBody_ImportantFields to handle AdditionalProperties
func (a *UpdateOrganizationFieldJSONBody_ImportantFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stage_ids"]; found {
		err = json.Unmarshal(raw, &a.StageIds)
		if err != nil {
			return fmt.Errorf("error reading 'stage_ids': %w", err)
		}
		delete(object, "stage_ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateOrganizationFieldJSONBody_ImportantFields to handle AdditionalProperties
func (a UpdateOrganizationFieldJSONBody_ImportantFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.StageIds != nil {
		object["stage_ids"], err = json.Marshal(a.StageIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateOrganizationFieldJSONBody_RequiredFields. Returns the specified
// element and whether it was found
func (a UpdateOrganizationFieldJSONBody_RequiredFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateOrganizationFieldJSONBody_RequiredFields
func (a *UpdateOrganizationFieldJSONBody_RequiredFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateOrganizationFieldJSONBody_RequiredFields to handle AdditionalProperties
func (a *UpdateOrganizationFieldJSONBody_RequiredFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateOrganizationFieldJSONBody_RequiredFields to handle AdditionalProperties
func (a UpdateOrganizationFieldJSONBody_RequiredFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateOrganizationFieldJSONBody_UiVisibility. Returns the specified
// element and whether it was found
func (a UpdateOrganizationFieldJSONBody_UiVisibility) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateOrganizationFieldJSONBody_UiVisibility
func (a *UpdateOrganizationFieldJSONBody_UiVisibility) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateOrganizationFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a *UpdateOrganizationFieldJSONBody_UiVisibility) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["add_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.AddVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'add_visible_flag': %w", err)
		}
		delete(object, "add_visible_flag")
	}

	if raw, found := object["details_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.DetailsVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'details_visible_flag': %w", err)
		}
		delete(object, "details_visible_flag")
	}

	if raw, found := object["show_in_add_deal_dialog"]; found {
		err = json.Unmarshal(raw, &a.ShowInAddDealDialog)
		if err != nil {
			return fmt.Errorf("error reading 'show_in_add_deal_dialog': %w", err)
		}
		delete(object, "show_in_add_deal_dialog")
	}

	if raw, found := object["show_in_add_person_dialog"]; found {
		err = json.Unmarshal(raw, &a.ShowInAddPersonDialog)
		if err != nil {
			return fmt.Errorf("error reading 'show_in_add_person_dialog': %w", err)
		}
		delete(object, "show_in_add_person_dialog")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateOrganizationFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a UpdateOrganizationFieldJSONBody_UiVisibility) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AddVisibleFlag != nil {
		object["add_visible_flag"], err = json.Marshal(a.AddVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_visible_flag': %w", err)
		}
	}

	if a.DetailsVisibleFlag != nil {
		object["details_visible_flag"], err = json.Marshal(a.DetailsVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'details_visible_flag': %w", err)
		}
	}

	if a.ShowInAddDealDialog != nil {
		object["show_in_add_deal_dialog"], err = json.Marshal(a.ShowInAddDealDialog)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'show_in_add_deal_dialog': %w", err)
		}
	}

	if a.ShowInAddPersonDialog != nil {
		object["show_in_add_person_dialog"], err = json.Marshal(a.ShowInAddPersonDialog)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'show_in_add_person_dialog': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AddPersonFieldJSONBody_ImportantFields. Returns the specified
// element and whether it was found
func (a AddPersonFieldJSONBody_ImportantFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AddPersonFieldJSONBody_ImportantFields
func (a *AddPersonFieldJSONBody_ImportantFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AddPersonFieldJSONBody_ImportantFields to handle AdditionalProperties
func (a *AddPersonFieldJSONBody_ImportantFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stage_ids"]; found {
		err = json.Unmarshal(raw, &a.StageIds)
		if err != nil {
			return fmt.Errorf("error reading 'stage_ids': %w", err)
		}
		delete(object, "stage_ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AddPersonFieldJSONBody_ImportantFields to handle AdditionalProperties
func (a AddPersonFieldJSONBody_ImportantFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.StageIds != nil {
		object["stage_ids"], err = json.Marshal(a.StageIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AddPersonFieldJSONBody_RequiredFields. Returns the specified
// element and whether it was found
func (a AddPersonFieldJSONBody_RequiredFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AddPersonFieldJSONBody_RequiredFields
func (a *AddPersonFieldJSONBody_RequiredFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AddPersonFieldJSONBody_RequiredFields to handle AdditionalProperties
func (a *AddPersonFieldJSONBody_RequiredFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AddPersonFieldJSONBody_RequiredFields to handle AdditionalProperties
func (a AddPersonFieldJSONBody_RequiredFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AddPersonFieldJSONBody_UiVisibility. Returns the specified
// element and whether it was found
func (a AddPersonFieldJSONBody_UiVisibility) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AddPersonFieldJSONBody_UiVisibility
func (a *AddPersonFieldJSONBody_UiVisibility) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AddPersonFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a *AddPersonFieldJSONBody_UiVisibility) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["add_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.AddVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'add_visible_flag': %w", err)
		}
		delete(object, "add_visible_flag")
	}

	if raw, found := object["details_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.DetailsVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'details_visible_flag': %w", err)
		}
		delete(object, "details_visible_flag")
	}

	if raw, found := object["show_in_add_deal_dialog"]; found {
		err = json.Unmarshal(raw, &a.ShowInAddDealDialog)
		if err != nil {
			return fmt.Errorf("error reading 'show_in_add_deal_dialog': %w", err)
		}
		delete(object, "show_in_add_deal_dialog")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AddPersonFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a AddPersonFieldJSONBody_UiVisibility) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AddVisibleFlag != nil {
		object["add_visible_flag"], err = json.Marshal(a.AddVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_visible_flag': %w", err)
		}
	}

	if a.DetailsVisibleFlag != nil {
		object["details_visible_flag"], err = json.Marshal(a.DetailsVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'details_visible_flag': %w", err)
		}
	}

	if a.ShowInAddDealDialog != nil {
		object["show_in_add_deal_dialog"], err = json.Marshal(a.ShowInAddDealDialog)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'show_in_add_deal_dialog': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdatePersonFieldJSONBody_ImportantFields. Returns the specified
// element and whether it was found
func (a UpdatePersonFieldJSONBody_ImportantFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdatePersonFieldJSONBody_ImportantFields
func (a *UpdatePersonFieldJSONBody_ImportantFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdatePersonFieldJSONBody_ImportantFields to handle AdditionalProperties
func (a *UpdatePersonFieldJSONBody_ImportantFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stage_ids"]; found {
		err = json.Unmarshal(raw, &a.StageIds)
		if err != nil {
			return fmt.Errorf("error reading 'stage_ids': %w", err)
		}
		delete(object, "stage_ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdatePersonFieldJSONBody_ImportantFields to handle AdditionalProperties
func (a UpdatePersonFieldJSONBody_ImportantFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.StageIds != nil {
		object["stage_ids"], err = json.Marshal(a.StageIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdatePersonFieldJSONBody_RequiredFields. Returns the specified
// element and whether it was found
func (a UpdatePersonFieldJSONBody_RequiredFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdatePersonFieldJSONBody_RequiredFields
func (a *UpdatePersonFieldJSONBody_RequiredFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdatePersonFieldJSONBody_RequiredFields to handle AdditionalProperties
func (a *UpdatePersonFieldJSONBody_RequiredFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdatePersonFieldJSONBody_RequiredFields to handle AdditionalProperties
func (a UpdatePersonFieldJSONBody_RequiredFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdatePersonFieldJSONBody_UiVisibility. Returns the specified
// element and whether it was found
func (a UpdatePersonFieldJSONBody_UiVisibility) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdatePersonFieldJSONBody_UiVisibility
func (a *UpdatePersonFieldJSONBody_UiVisibility) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdatePersonFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a *UpdatePersonFieldJSONBody_UiVisibility) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["add_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.AddVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'add_visible_flag': %w", err)
		}
		delete(object, "add_visible_flag")
	}

	if raw, found := object["details_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.DetailsVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'details_visible_flag': %w", err)
		}
		delete(object, "details_visible_flag")
	}

	if raw, found := object["show_in_add_deal_dialog"]; found {
		err = json.Unmarshal(raw, &a.ShowInAddDealDialog)
		if err != nil {
			return fmt.Errorf("error reading 'show_in_add_deal_dialog': %w", err)
		}
		delete(object, "show_in_add_deal_dialog")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdatePersonFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a UpdatePersonFieldJSONBody_UiVisibility) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AddVisibleFlag != nil {
		object["add_visible_flag"], err = json.Marshal(a.AddVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_visible_flag': %w", err)
		}
	}

	if a.DetailsVisibleFlag != nil {
		object["details_visible_flag"], err = json.Marshal(a.DetailsVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'details_visible_flag': %w", err)
		}
	}

	if a.ShowInAddDealDialog != nil {
		object["show_in_add_deal_dialog"], err = json.Marshal(a.ShowInAddDealDialog)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'show_in_add_deal_dialog': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AddProductFieldJSONBody_UiVisibility. Returns the specified
// element and whether it was found
func (a AddProductFieldJSONBody_UiVisibility) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AddProductFieldJSONBody_UiVisibility
func (a *AddProductFieldJSONBody_UiVisibility) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AddProductFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a *AddProductFieldJSONBody_UiVisibility) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["add_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.AddVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'add_visible_flag': %w", err)
		}
		delete(object, "add_visible_flag")
	}

	if raw, found := object["details_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.DetailsVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'details_visible_flag': %w", err)
		}
		delete(object, "details_visible_flag")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AddProductFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a AddProductFieldJSONBody_UiVisibility) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AddVisibleFlag != nil {
		object["add_visible_flag"], err = json.Marshal(a.AddVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_visible_flag': %w", err)
		}
	}

	if a.DetailsVisibleFlag != nil {
		object["details_visible_flag"], err = json.Marshal(a.DetailsVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'details_visible_flag': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateProductFieldJSONBody_UiVisibility. Returns the specified
// element and whether it was found
func (a UpdateProductFieldJSONBody_UiVisibility) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateProductFieldJSONBody_UiVisibility
func (a *UpdateProductFieldJSONBody_UiVisibility) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateProductFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a *UpdateProductFieldJSONBody_UiVisibility) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["add_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.AddVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'add_visible_flag': %w", err)
		}
		delete(object, "add_visible_flag")
	}

	if raw, found := object["details_visible_flag"]; found {
		err = json.Unmarshal(raw, &a.DetailsVisibleFlag)
		if err != nil {
			return fmt.Errorf("error reading 'details_visible_flag': %w", err)
		}
		delete(object, "details_visible_flag")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateProductFieldJSONBody_UiVisibility to handle AdditionalProperties
func (a UpdateProductFieldJSONBody_UiVisibility) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AddVisibleFlag != nil {
		object["add_visible_flag"], err = json.Marshal(a.AddVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_visible_flag': %w", err)
		}
	}

	if a.DetailsVisibleFlag != nil {
		object["details_visible_flag"], err = json.Marshal(a.DetailsVisibleFlag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'details_visible_flag': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetActivities request
	GetActivities(ctx context.Context, params *GetActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddActivityWithBody request with any body
	AddActivityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddActivity(ctx context.Context, body AddActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteActivity request
	DeleteActivity(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivity request
	GetActivity(ctx context.Context, id int, params *GetActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateActivityWithBody request with any body
	UpdateActivityWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateActivity(ctx context.Context, id int, body UpdateActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityFields request
	GetActivityFields(ctx context.Context, params *GetActivityFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityField request
	GetActivityField(ctx context.Context, fieldCode string, params *GetActivityFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealFields request
	GetDealFields(ctx context.Context, params *GetDealFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDealFieldWithBody request with any body
	AddDealFieldWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDealField(ctx context.Context, body AddDealFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDealField request
	DeleteDealField(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealField request
	GetDealField(ctx context.Context, fieldCode string, params *GetDealFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDealFieldWithBody request with any body
	UpdateDealFieldWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDealField(ctx context.Context, fieldCode string, body UpdateDealFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDealFieldOptionsWithBody request with any body
	DeleteDealFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteDealFieldOptions(ctx context.Context, fieldCode string, body DeleteDealFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDealFieldOptionsWithBody request with any body
	UpdateDealFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDealFieldOptions(ctx context.Context, fieldCode string, body UpdateDealFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDealFieldOptionsWithBody request with any body
	AddDealFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDealFieldOptions(ctx context.Context, fieldCode string, body AddDealFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeals request
	GetDeals(ctx context.Context, params *GetDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDealWithBody request with any body
	AddDealWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDeal(ctx context.Context, body AddDealJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArchivedDeals request
	GetArchivedDeals(ctx context.Context, params *GetArchivedDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstallments request
	GetInstallments(ctx context.Context, params *GetInstallmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealsProducts request
	GetDealsProducts(ctx context.Context, params *GetDealsProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDeals request
	SearchDeals(ctx context.Context, params *SearchDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDeal request
	DeleteDeal(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeal request
	GetDeal(ctx context.Context, id int, params *GetDealParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDealWithBody request with any body
	UpdateDealWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDeal(ctx context.Context, id int, body UpdateDealJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertDealToLead request
	ConvertDealToLead(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealConversionStatus request
	GetDealConversionStatus(ctx context.Context, id int, conversionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAdditionalDiscounts request
	GetAdditionalDiscounts(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAdditionalDiscountWithBody request with any body
	PostAdditionalDiscountWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAdditionalDiscount(ctx context.Context, id int, body PostAdditionalDiscountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAdditionalDiscount request
	DeleteAdditionalDiscount(ctx context.Context, id int, discountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAdditionalDiscountWithBody request with any body
	UpdateAdditionalDiscountWithBody(ctx context.Context, id int, discountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAdditionalDiscount(ctx context.Context, id int, discountId openapi_types.UUID, body UpdateAdditionalDiscountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealFollowers request
	GetDealFollowers(ctx context.Context, id int, params *GetDealFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDealFollowerWithBody request with any body
	AddDealFollowerWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDealFollower(ctx context.Context, id int, body AddDealFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealFollowersChangelog request
	GetDealFollowersChangelog(ctx context.Context, id int, params *GetDealFollowersChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDealFollower request
	DeleteDealFollower(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInstallmentWithBody request with any body
	PostInstallmentWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInstallment(ctx context.Context, id int, body PostInstallmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInstallment request
	DeleteInstallment(ctx context.Context, id int, installmentId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateInstallmentWithBody request with any body
	UpdateInstallmentWithBody(ctx context.Context, id int, installmentId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInstallment(ctx context.Context, id int, installmentId int, body UpdateInstallmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteManyDealProducts request
	DeleteManyDealProducts(ctx context.Context, id int, params *DeleteManyDealProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealProducts request
	GetDealProducts(ctx context.Context, id int, params *GetDealProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDealProductWithBody request with any body
	AddDealProductWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDealProduct(ctx context.Context, id int, body AddDealProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddManyDealProductsWithBody request with any body
	AddManyDealProductsWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddManyDealProducts(ctx context.Context, id int, body AddManyDealProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDealProduct request
	DeleteDealProduct(ctx context.Context, id int, productAttachmentId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDealProductWithBody request with any body
	UpdateDealProductWithBody(ctx context.Context, id int, productAttachmentId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDealProduct(ctx context.Context, id int, productAttachmentId int, body UpdateDealProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchItem request
	SearchItem(ctx context.Context, params *SearchItemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchItemByField request
	SearchItemByField(ctx context.Context, params *SearchItemByFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchLeads request
	SearchLeads(ctx context.Context, params *SearchLeadsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertLeadToDealWithBody request with any body
	ConvertLeadToDealWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConvertLeadToDeal(ctx context.Context, id openapi_types.UUID, body ConvertLeadToDealJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeadConversionStatus request
	GetLeadConversionStatus(ctx context.Context, id openapi_types.UUID, conversionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationFields request
	GetOrganizationFields(ctx context.Context, params *GetOrganizationFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationFieldWithBody request with any body
	AddOrganizationFieldWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrganizationField(ctx context.Context, body AddOrganizationFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationField request
	DeleteOrganizationField(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationField request
	GetOrganizationField(ctx context.Context, fieldCode string, params *GetOrganizationFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrganizationFieldWithBody request with any body
	UpdateOrganizationFieldWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrganizationField(ctx context.Context, fieldCode string, body UpdateOrganizationFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationFieldOptionsWithBody request with any body
	DeleteOrganizationFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteOrganizationFieldOptions(ctx context.Context, fieldCode string, body DeleteOrganizationFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrganizationFieldOptionsWithBody request with any body
	UpdateOrganizationFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrganizationFieldOptions(ctx context.Context, fieldCode string, body UpdateOrganizationFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationFieldOptionsWithBody request with any body
	AddOrganizationFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrganizationFieldOptions(ctx context.Context, fieldCode string, body AddOrganizationFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizations request
	GetOrganizations(ctx context.Context, params *GetOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationWithBody request with any body
	AddOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrganization(ctx context.Context, body AddOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchOrganization request
	SearchOrganization(ctx context.Context, params *SearchOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganization request
	DeleteOrganization(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganization request
	GetOrganization(ctx context.Context, id int, params *GetOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrganizationWithBody request with any body
	UpdateOrganizationWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrganization(ctx context.Context, id int, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationFollowers request
	GetOrganizationFollowers(ctx context.Context, id int, params *GetOrganizationFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationFollowerWithBody request with any body
	AddOrganizationFollowerWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrganizationFollower(ctx context.Context, id int, body AddOrganizationFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationFollowersChangelog request
	GetOrganizationFollowersChangelog(ctx context.Context, id int, params *GetOrganizationFollowersChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationFollower request
	DeleteOrganizationFollower(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonFields request
	GetPersonFields(ctx context.Context, params *GetPersonFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPersonFieldWithBody request with any body
	AddPersonFieldWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPersonField(ctx context.Context, body AddPersonFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersonField request
	DeletePersonField(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonField request
	GetPersonField(ctx context.Context, fieldCode string, params *GetPersonFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePersonFieldWithBody request with any body
	UpdatePersonFieldWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePersonField(ctx context.Context, fieldCode string, body UpdatePersonFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersonFieldOptionsWithBody request with any body
	DeletePersonFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePersonFieldOptions(ctx context.Context, fieldCode string, body DeletePersonFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePersonFieldOptionsWithBody request with any body
	UpdatePersonFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePersonFieldOptions(ctx context.Context, fieldCode string, body UpdatePersonFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPersonFieldOptionsWithBody request with any body
	AddPersonFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPersonFieldOptions(ctx context.Context, fieldCode string, body AddPersonFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersons request
	GetPersons(ctx context.Context, params *GetPersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPersonWithBody request with any body
	AddPersonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPerson(ctx context.Context, body AddPersonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchPersons request
	SearchPersons(ctx context.Context, params *SearchPersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePerson request
	DeletePerson(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPerson request
	GetPerson(ctx context.Context, id int, params *GetPersonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePersonWithBody request with any body
	UpdatePersonWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePerson(ctx context.Context, id int, body UpdatePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonFollowers request
	GetPersonFollowers(ctx context.Context, id int, params *GetPersonFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPersonFollowerWithBody request with any body
	AddPersonFollowerWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPersonFollower(ctx context.Context, id int, body AddPersonFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonFollowersChangelog request
	GetPersonFollowersChangelog(ctx context.Context, id int, params *GetPersonFollowersChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersonFollower request
	DeletePersonFollower(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonPicture request
	GetPersonPicture(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelines request
	GetPipelines(ctx context.Context, params *GetPipelinesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPipelineWithBody request with any body
	AddPipelineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPipeline(ctx context.Context, body AddPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePipeline request
	DeletePipeline(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipeline request
	GetPipeline(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePipelineWithBody request with any body
	UpdatePipelineWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePipeline(ctx context.Context, id int, body UpdatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductFields request
	GetProductFields(ctx context.Context, params *GetProductFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddProductFieldWithBody request with any body
	AddProductFieldWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddProductField(ctx context.Context, body AddProductFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductField request
	DeleteProductField(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductField request
	GetProductField(ctx context.Context, fieldCode string, params *GetProductFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProductFieldWithBody request with any body
	UpdateProductFieldWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProductField(ctx context.Context, fieldCode string, body UpdateProductFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductFieldOptionsWithBody request with any body
	DeleteProductFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteProductFieldOptions(ctx context.Context, fieldCode string, body DeleteProductFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProductFieldOptionsWithBody request with any body
	UpdateProductFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProductFieldOptions(ctx context.Context, fieldCode string, body UpdateProductFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddProductFieldOptionsWithBody request with any body
	AddProductFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddProductFieldOptions(ctx context.Context, fieldCode string, body AddProductFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProducts request
	GetProducts(ctx context.Context, params *GetProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddProductWithBody request with any body
	AddProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddProduct(ctx context.Context, body AddProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchProducts request
	SearchProducts(ctx context.Context, params *SearchProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProduct request
	DeleteProduct(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProduct request
	GetProduct(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProductWithBody request with any body
	UpdateProductWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProduct(ctx context.Context, id int, body UpdateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DuplicateProduct request
	DuplicateProduct(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductFollowers request
	GetProductFollowers(ctx context.Context, id int, params *GetProductFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddProductFollowerWithBody request with any body
	AddProductFollowerWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddProductFollower(ctx context.Context, id int, body AddProductFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductFollowersChangelog request
	GetProductFollowersChangelog(ctx context.Context, id int, params *GetProductFollowersChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductFollower request
	DeleteProductFollower(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductImage request
	DeleteProductImage(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductImage request
	GetProductImage(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadProductImageWithBody request with any body
	UploadProductImageWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProductImageWithBody request with any body
	UpdateProductImageWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductVariations request
	GetProductVariations(ctx context.Context, id int, params *GetProductVariationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddProductVariationWithBody request with any body
	AddProductVariationWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddProductVariation(ctx context.Context, id int, body AddProductVariationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductVariation request
	DeleteProductVariation(ctx context.Context, id int, productVariationId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProductVariationWithBody request with any body
	UpdateProductVariationWithBody(ctx context.Context, id int, productVariationId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProductVariation(ctx context.Context, id int, productVariationId int, body UpdateProductVariationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStages request
	GetStages(ctx context.Context, params *GetStagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddStageWithBody request with any body
	AddStageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddStage(ctx context.Context, body AddStageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStage request
	DeleteStage(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStage request
	GetStage(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateStageWithBody request with any body
	UpdateStageWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateStage(ctx context.Context, id int, body UpdateStageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFollowers request
	GetUserFollowers(ctx context.Context, id int, params *GetUserFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetActivities(ctx context.Context, params *GetActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddActivityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddActivityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddActivity(ctx context.Context, body AddActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddActivityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteActivity(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteActivityRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivity(ctx context.Context, id int, params *GetActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateActivityWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateActivityRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateActivity(ctx context.Context, id int, body UpdateActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateActivityRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityFields(ctx context.Context, params *GetActivityFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityFieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityField(ctx context.Context, fieldCode string, params *GetActivityFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityFieldRequest(c.Server, fieldCode, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealFields(ctx context.Context, params *GetDealFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealFieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDealFieldWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDealFieldRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDealField(ctx context.Context, body AddDealFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDealFieldRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDealField(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDealFieldRequest(c.Server, fieldCode)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealField(ctx context.Context, fieldCode string, params *GetDealFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealFieldRequest(c.Server, fieldCode, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDealFieldWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDealFieldRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDealField(ctx context.Context, fieldCode string, body UpdateDealFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDealFieldRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDealFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDealFieldOptionsRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDealFieldOptions(ctx context.Context, fieldCode string, body DeleteDealFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDealFieldOptionsRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDealFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDealFieldOptionsRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDealFieldOptions(ctx context.Context, fieldCode string, body UpdateDealFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDealFieldOptionsRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDealFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDealFieldOptionsRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDealFieldOptions(ctx context.Context, fieldCode string, body AddDealFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDealFieldOptionsRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeals(ctx context.Context, params *GetDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDealWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDealRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDeal(ctx context.Context, body AddDealJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDealRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArchivedDeals(ctx context.Context, params *GetArchivedDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArchivedDealsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstallments(ctx context.Context, params *GetInstallmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstallmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealsProducts(ctx context.Context, params *GetDealsProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealsProductsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDeals(ctx context.Context, params *SearchDealsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDealsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDeal(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDealRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeal(ctx context.Context, id int, params *GetDealParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDealWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDealRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeal(ctx context.Context, id int, body UpdateDealJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDealRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertDealToLead(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertDealToLeadRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealConversionStatus(ctx context.Context, id int, conversionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealConversionStatusRequest(c.Server, id, conversionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAdditionalDiscounts(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAdditionalDiscountsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAdditionalDiscountWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAdditionalDiscountRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAdditionalDiscount(ctx context.Context, id int, body PostAdditionalDiscountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAdditionalDiscountRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAdditionalDiscount(ctx context.Context, id int, discountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAdditionalDiscountRequest(c.Server, id, discountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAdditionalDiscountWithBody(ctx context.Context, id int, discountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAdditionalDiscountRequestWithBody(c.Server, id, discountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAdditionalDiscount(ctx context.Context, id int, discountId openapi_types.UUID, body UpdateAdditionalDiscountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAdditionalDiscountRequest(c.Server, id, discountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealFollowers(ctx context.Context, id int, params *GetDealFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealFollowersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDealFollowerWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDealFollowerRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDealFollower(ctx context.Context, id int, body AddDealFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDealFollowerRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealFollowersChangelog(ctx context.Context, id int, params *GetDealFollowersChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealFollowersChangelogRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDealFollower(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDealFollowerRequest(c.Server, id, followerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInstallmentWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInstallmentRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInstallment(ctx context.Context, id int, body PostInstallmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInstallmentRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInstallment(ctx context.Context, id int, installmentId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInstallmentRequest(c.Server, id, installmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInstallmentWithBody(ctx context.Context, id int, installmentId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInstallmentRequestWithBody(c.Server, id, installmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInstallment(ctx context.Context, id int, installmentId int, body UpdateInstallmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInstallmentRequest(c.Server, id, installmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyDealProducts(ctx context.Context, id int, params *DeleteManyDealProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyDealProductsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealProducts(ctx context.Context, id int, params *GetDealProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealProductsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDealProductWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDealProductRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDealProduct(ctx context.Context, id int, body AddDealProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDealProductRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddManyDealProductsWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddManyDealProductsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddManyDealProducts(ctx context.Context, id int, body AddManyDealProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddManyDealProductsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDealProduct(ctx context.Context, id int, productAttachmentId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDealProductRequest(c.Server, id, productAttachmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDealProductWithBody(ctx context.Context, id int, productAttachmentId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDealProductRequestWithBody(c.Server, id, productAttachmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDealProduct(ctx context.Context, id int, productAttachmentId int, body UpdateDealProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDealProductRequest(c.Server, id, productAttachmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchItem(ctx context.Context, params *SearchItemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchItemRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchItemByField(ctx context.Context, params *SearchItemByFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchItemByFieldRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchLeads(ctx context.Context, params *SearchLeadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchLeadsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertLeadToDealWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertLeadToDealRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertLeadToDeal(ctx context.Context, id openapi_types.UUID, body ConvertLeadToDealJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertLeadToDealRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLeadConversionStatus(ctx context.Context, id openapi_types.UUID, conversionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeadConversionStatusRequest(c.Server, id, conversionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationFields(ctx context.Context, params *GetOrganizationFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationFieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationFieldWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationFieldRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationField(ctx context.Context, body AddOrganizationFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationFieldRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationField(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationFieldRequest(c.Server, fieldCode)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationField(ctx context.Context, fieldCode string, params *GetOrganizationFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationFieldRequest(c.Server, fieldCode, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationFieldWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationFieldRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationField(ctx context.Context, fieldCode string, body UpdateOrganizationFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationFieldRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationFieldOptionsRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationFieldOptions(ctx context.Context, fieldCode string, body DeleteOrganizationFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationFieldOptionsRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationFieldOptionsRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationFieldOptions(ctx context.Context, fieldCode string, body UpdateOrganizationFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationFieldOptionsRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationFieldOptionsRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationFieldOptions(ctx context.Context, fieldCode string, body AddOrganizationFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationFieldOptionsRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizations(ctx context.Context, params *GetOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganization(ctx context.Context, body AddOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchOrganization(ctx context.Context, params *SearchOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchOrganizationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganization(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganization(ctx context.Context, id int, params *GetOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganization(ctx context.Context, id int, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationFollowers(ctx context.Context, id int, params *GetOrganizationFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationFollowersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationFollowerWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationFollowerRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationFollower(ctx context.Context, id int, body AddOrganizationFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationFollowerRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationFollowersChangelog(ctx context.Context, id int, params *GetOrganizationFollowersChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationFollowersChangelogRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationFollower(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationFollowerRequest(c.Server, id, followerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonFields(ctx context.Context, params *GetPersonFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonFieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPersonFieldWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPersonFieldRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPersonField(ctx context.Context, body AddPersonFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPersonFieldRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersonField(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersonFieldRequest(c.Server, fieldCode)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonField(ctx context.Context, fieldCode string, params *GetPersonFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonFieldRequest(c.Server, fieldCode, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePersonFieldWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePersonFieldRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePersonField(ctx context.Context, fieldCode string, body UpdatePersonFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePersonFieldRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersonFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersonFieldOptionsRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersonFieldOptions(ctx context.Context, fieldCode string, body DeletePersonFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersonFieldOptionsRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePersonFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePersonFieldOptionsRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePersonFieldOptions(ctx context.Context, fieldCode string, body UpdatePersonFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePersonFieldOptionsRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPersonFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPersonFieldOptionsRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPersonFieldOptions(ctx context.Context, fieldCode string, body AddPersonFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPersonFieldOptionsRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersons(ctx context.Context, params *GetPersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPersonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPersonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPerson(ctx context.Context, body AddPersonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPersonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPersons(ctx context.Context, params *SearchPersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPersonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePerson(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersonRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPerson(ctx context.Context, id int, params *GetPersonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePersonWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePersonRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePerson(ctx context.Context, id int, body UpdatePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePersonRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonFollowers(ctx context.Context, id int, params *GetPersonFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonFollowersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPersonFollowerWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPersonFollowerRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPersonFollower(ctx context.Context, id int, body AddPersonFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPersonFollowerRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonFollowersChangelog(ctx context.Context, id int, params *GetPersonFollowersChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonFollowersChangelogRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersonFollower(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersonFollowerRequest(c.Server, id, followerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonPicture(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonPictureRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelines(ctx context.Context, params *GetPipelinesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelinesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPipelineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPipelineRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPipeline(ctx context.Context, body AddPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPipelineRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePipeline(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePipelineRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipeline(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePipelineWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePipelineRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePipeline(ctx context.Context, id int, body UpdatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePipelineRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductFields(ctx context.Context, params *GetProductFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductFieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProductFieldWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProductFieldRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProductField(ctx context.Context, body AddProductFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProductFieldRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductField(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductFieldRequest(c.Server, fieldCode)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductField(ctx context.Context, fieldCode string, params *GetProductFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductFieldRequest(c.Server, fieldCode, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductFieldWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductFieldRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductField(ctx context.Context, fieldCode string, body UpdateProductFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductFieldRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductFieldOptionsRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductFieldOptions(ctx context.Context, fieldCode string, body DeleteProductFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductFieldOptionsRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductFieldOptionsRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductFieldOptions(ctx context.Context, fieldCode string, body UpdateProductFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductFieldOptionsRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProductFieldOptionsWithBody(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProductFieldOptionsRequestWithBody(c.Server, fieldCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProductFieldOptions(ctx context.Context, fieldCode string, body AddProductFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProductFieldOptionsRequest(c.Server, fieldCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProducts(ctx context.Context, params *GetProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProductRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProduct(ctx context.Context, body AddProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProductRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProducts(ctx context.Context, params *SearchProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProductsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProduct(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProduct(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProduct(ctx context.Context, id int, body UpdateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuplicateProduct(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuplicateProductRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductFollowers(ctx context.Context, id int, params *GetProductFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductFollowersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProductFollowerWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProductFollowerRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProductFollower(ctx context.Context, id int, body AddProductFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProductFollowerRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductFollowersChangelog(ctx context.Context, id int, params *GetProductFollowersChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductFollowersChangelogRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductFollower(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductFollowerRequest(c.Server, id, followerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductImage(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductImageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductImage(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductImageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadProductImageWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadProductImageRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductImageWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductImageRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductVariations(ctx context.Context, id int, params *GetProductVariationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductVariationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProductVariationWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProductVariationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProductVariation(ctx context.Context, id int, body AddProductVariationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProductVariationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductVariation(ctx context.Context, id int, productVariationId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductVariationRequest(c.Server, id, productVariationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductVariationWithBody(ctx context.Context, id int, productVariationId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductVariationRequestWithBody(c.Server, id, productVariationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductVariation(ctx context.Context, id int, productVariationId int, body UpdateProductVariationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductVariationRequest(c.Server, id, productVariationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStages(ctx context.Context, params *GetStagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddStageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddStageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddStage(ctx context.Context, body AddStageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddStageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStage(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStage(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStageWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStageRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStage(ctx context.Context, id int, body UpdateStageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStageRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFollowers(ctx context.Context, id int, params *GetUserFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFollowersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetActivitiesRequest generates requests for GetActivities
func NewGetActivitiesRequest(server string, params *GetActivitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_id", runtime.ParamLocationQuery, *params.OwnerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DealId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deal_id", runtime.ParamLocationQuery, *params.DealId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeadId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lead_id", runtime.ParamLocationQuery, *params.LeadId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person_id", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrgId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org_id", runtime.ParamLocationQuery, *params.OrgId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Done != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "done", runtime.ParamLocationQuery, *params.Done); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedUntil != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_until", runtime.ParamLocationQuery, *params.UpdatedUntil); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddActivityRequest calls the generic AddActivity builder with application/json body
func NewAddActivityRequest(server string, body AddActivityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddActivityRequestWithBody(server, "application/json", bodyReader)
}

// NewAddActivityRequestWithBody generates requests for AddActivity with any type of body
func NewAddActivityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteActivityRequest generates requests for DeleteActivity
func NewDeleteActivityRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivityRequest generates requests for GetActivity
func NewGetActivityRequest(server string, id int, params *GetActivityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateActivityRequest calls the generic UpdateActivity builder with application/json body
func NewUpdateActivityRequest(server string, id int, body UpdateActivityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateActivityRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateActivityRequestWithBody generates requests for UpdateActivity with any type of body
func NewUpdateActivityRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetActivityFieldsRequest generates requests for GetActivityFields
func NewGetActivityFieldsRequest(server string, params *GetActivityFieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activityFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivityFieldRequest generates requests for GetActivityField
func NewGetActivityFieldRequest(server string, fieldCode string, params *GetActivityFieldParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activityFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealFieldsRequest generates requests for GetDealFields
func NewGetDealFieldsRequest(server string, params *GetDealFieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dealFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddDealFieldRequest calls the generic AddDealField builder with application/json body
func NewAddDealFieldRequest(server string, body AddDealFieldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDealFieldRequestWithBody(server, "application/json", bodyReader)
}

// NewAddDealFieldRequestWithBody generates requests for AddDealField with any type of body
func NewAddDealFieldRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dealFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDealFieldRequest generates requests for DeleteDealField
func NewDeleteDealFieldRequest(server string, fieldCode string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dealFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealFieldRequest generates requests for GetDealField
func NewGetDealFieldRequest(server string, fieldCode string, params *GetDealFieldParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dealFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDealFieldRequest calls the generic UpdateDealField builder with application/json body
func NewUpdateDealFieldRequest(server string, fieldCode string, body UpdateDealFieldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDealFieldRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewUpdateDealFieldRequestWithBody generates requests for UpdateDealField with any type of body
func NewUpdateDealFieldRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dealFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDealFieldOptionsRequest calls the generic DeleteDealFieldOptions builder with application/json body
func NewDeleteDealFieldOptionsRequest(server string, fieldCode string, body DeleteDealFieldOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteDealFieldOptionsRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewDeleteDealFieldOptionsRequestWithBody generates requests for DeleteDealFieldOptions with any type of body
func NewDeleteDealFieldOptionsRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dealFields/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateDealFieldOptionsRequest calls the generic UpdateDealFieldOptions builder with application/json body
func NewUpdateDealFieldOptionsRequest(server string, fieldCode string, body UpdateDealFieldOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDealFieldOptionsRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewUpdateDealFieldOptionsRequestWithBody generates requests for UpdateDealFieldOptions with any type of body
func NewUpdateDealFieldOptionsRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dealFields/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddDealFieldOptionsRequest calls the generic AddDealFieldOptions builder with application/json body
func NewAddDealFieldOptionsRequest(server string, fieldCode string, body AddDealFieldOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDealFieldOptionsRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewAddDealFieldOptionsRequestWithBody generates requests for AddDealFieldOptions with any type of body
func NewAddDealFieldOptionsRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dealFields/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDealsRequest generates requests for GetDeals
func NewGetDealsRequest(server string, params *GetDealsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_id", runtime.ParamLocationQuery, *params.OwnerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person_id", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrgId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org_id", runtime.ParamLocationQuery, *params.OrgId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PipelineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pipeline_id", runtime.ParamLocationQuery, *params.PipelineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stage_id", runtime.ParamLocationQuery, *params.StageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedUntil != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_until", runtime.ParamLocationQuery, *params.UpdatedUntil); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddDealRequest calls the generic AddDeal builder with application/json body
func NewAddDealRequest(server string, body AddDealJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDealRequestWithBody(server, "application/json", bodyReader)
}

// NewAddDealRequestWithBody generates requests for AddDeal with any type of body
func NewAddDealRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetArchivedDealsRequest generates requests for GetArchivedDeals
func NewGetArchivedDealsRequest(server string, params *GetArchivedDealsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/archived")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_id", runtime.ParamLocationQuery, *params.OwnerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person_id", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrgId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org_id", runtime.ParamLocationQuery, *params.OrgId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PipelineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pipeline_id", runtime.ParamLocationQuery, *params.PipelineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stage_id", runtime.ParamLocationQuery, *params.StageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedUntil != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_until", runtime.ParamLocationQuery, *params.UpdatedUntil); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstallmentsRequest generates requests for GetInstallments
func NewGetInstallmentsRequest(server string, params *GetInstallmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/installments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deal_ids", runtime.ParamLocationQuery, params.DealIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealsProductsRequest generates requests for GetDealsProducts
func NewGetDealsProductsRequest(server string, params *GetDealsProductsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deal_ids", runtime.ParamLocationQuery, params.DealIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchDealsRequest generates requests for SearchDeals
func NewSearchDealsRequest(server string, params *SearchDealsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "term", runtime.ParamLocationQuery, params.Term); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exact_match", runtime.ParamLocationQuery, *params.ExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person_id", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDealRequest generates requests for DeleteDeal
func NewDeleteDealRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealRequest generates requests for GetDeal
func NewGetDealRequest(server string, id int, params *GetDealParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDealRequest calls the generic UpdateDeal builder with application/json body
func NewUpdateDealRequest(server string, id int, body UpdateDealJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDealRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateDealRequestWithBody generates requests for UpdateDeal with any type of body
func NewUpdateDealRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConvertDealToLeadRequest generates requests for ConvertDealToLead
func NewConvertDealToLeadRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/convert/lead", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealConversionStatusRequest generates requests for GetDealConversionStatus
func NewGetDealConversionStatusRequest(server string, id int, conversionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "conversion_id", runtime.ParamLocationPath, conversionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/convert/status/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAdditionalDiscountsRequest generates requests for GetAdditionalDiscounts
func NewGetAdditionalDiscountsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/discounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAdditionalDiscountRequest calls the generic PostAdditionalDiscount builder with application/json body
func NewPostAdditionalDiscountRequest(server string, id int, body PostAdditionalDiscountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAdditionalDiscountRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostAdditionalDiscountRequestWithBody generates requests for PostAdditionalDiscount with any type of body
func NewPostAdditionalDiscountRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/discounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAdditionalDiscountRequest generates requests for DeleteAdditionalDiscount
func NewDeleteAdditionalDiscountRequest(server string, id int, discountId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discount_id", runtime.ParamLocationPath, discountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/discounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAdditionalDiscountRequest calls the generic UpdateAdditionalDiscount builder with application/json body
func NewUpdateAdditionalDiscountRequest(server string, id int, discountId openapi_types.UUID, body UpdateAdditionalDiscountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAdditionalDiscountRequestWithBody(server, id, discountId, "application/json", bodyReader)
}

// NewUpdateAdditionalDiscountRequestWithBody generates requests for UpdateAdditionalDiscount with any type of body
func NewUpdateAdditionalDiscountRequestWithBody(server string, id int, discountId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discount_id", runtime.ParamLocationPath, discountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/discounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDealFollowersRequest generates requests for GetDealFollowers
func NewGetDealFollowersRequest(server string, id int, params *GetDealFollowersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddDealFollowerRequest calls the generic AddDealFollower builder with application/json body
func NewAddDealFollowerRequest(server string, id int, body AddDealFollowerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDealFollowerRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddDealFollowerRequestWithBody generates requests for AddDealFollower with any type of body
func NewAddDealFollowerRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDealFollowersChangelogRequest generates requests for GetDealFollowersChangelog
func NewGetDealFollowersChangelogRequest(server string, id int, params *GetDealFollowersChangelogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/followers/changelog", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDealFollowerRequest generates requests for DeleteDealFollower
func NewDeleteDealFollowerRequest(server string, id int, followerId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "follower_id", runtime.ParamLocationPath, followerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/followers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInstallmentRequest calls the generic PostInstallment builder with application/json body
func NewPostInstallmentRequest(server string, id int, body PostInstallmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInstallmentRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostInstallmentRequestWithBody generates requests for PostInstallment with any type of body
func NewPostInstallmentRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/installments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInstallmentRequest generates requests for DeleteInstallment
func NewDeleteInstallmentRequest(server string, id int, installmentId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "installment_id", runtime.ParamLocationPath, installmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/installments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateInstallmentRequest calls the generic UpdateInstallment builder with application/json body
func NewUpdateInstallmentRequest(server string, id int, installmentId int, body UpdateInstallmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInstallmentRequestWithBody(server, id, installmentId, "application/json", bodyReader)
}

// NewUpdateInstallmentRequestWithBody generates requests for UpdateInstallment with any type of body
func NewUpdateInstallmentRequestWithBody(server string, id int, installmentId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "installment_id", runtime.ParamLocationPath, installmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/installments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyDealProductsRequest generates requests for DeleteManyDealProducts
func NewDeleteManyDealProductsRequest(server string, id int, params *DeleteManyDealProductsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/products", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDealProductsRequest generates requests for GetDealProducts
func NewGetDealProductsRequest(server string, id int, params *GetDealProductsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/products", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddDealProductRequest calls the generic AddDealProduct builder with application/json body
func NewAddDealProductRequest(server string, id int, body AddDealProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDealProductRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddDealProductRequestWithBody generates requests for AddDealProduct with any type of body
func NewAddDealProductRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/products", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddManyDealProductsRequest calls the generic AddManyDealProducts builder with application/json body
func NewAddManyDealProductsRequest(server string, id int, body AddManyDealProductsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddManyDealProductsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddManyDealProductsRequestWithBody generates requests for AddManyDealProducts with any type of body
func NewAddManyDealProductsRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/products/bulk", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDealProductRequest generates requests for DeleteDealProduct
func NewDeleteDealProductRequest(server string, id int, productAttachmentId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "product_attachment_id", runtime.ParamLocationPath, productAttachmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/products/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDealProductRequest calls the generic UpdateDealProduct builder with application/json body
func NewUpdateDealProductRequest(server string, id int, productAttachmentId int, body UpdateDealProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDealProductRequestWithBody(server, id, productAttachmentId, "application/json", bodyReader)
}

// NewUpdateDealProductRequestWithBody generates requests for UpdateDealProduct with any type of body
func NewUpdateDealProductRequestWithBody(server string, id int, productAttachmentId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "product_attachment_id", runtime.ParamLocationPath, productAttachmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deals/%s/products/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchItemRequest generates requests for SearchItem
func NewSearchItemRequest(server string, params *SearchItemParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/itemSearch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "term", runtime.ParamLocationQuery, params.Term); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "item_types", runtime.ParamLocationQuery, *params.ItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchForRelatedItems != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_for_related_items", runtime.ParamLocationQuery, *params.SearchForRelatedItems); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exact_match", runtime.ParamLocationQuery, *params.ExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchItemByFieldRequest generates requests for SearchItemByField
func NewSearchItemByFieldRequest(server string, params *SearchItemByFieldParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/itemSearch/field")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "term", runtime.ParamLocationQuery, params.Term); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entity_type", runtime.ParamLocationQuery, params.EntityType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Match != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "match", runtime.ParamLocationQuery, *params.Match); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "field", runtime.ParamLocationQuery, params.Field); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchLeadsRequest generates requests for SearchLeads
func NewSearchLeadsRequest(server string, params *SearchLeadsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leads/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "term", runtime.ParamLocationQuery, params.Term); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exact_match", runtime.ParamLocationQuery, *params.ExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person_id", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConvertLeadToDealRequest calls the generic ConvertLeadToDeal builder with application/json body
func NewConvertLeadToDealRequest(server string, id openapi_types.UUID, body ConvertLeadToDealJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConvertLeadToDealRequestWithBody(server, id, "application/json", bodyReader)
}

// NewConvertLeadToDealRequestWithBody generates requests for ConvertLeadToDeal with any type of body
func NewConvertLeadToDealRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leads/%s/convert/deal", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLeadConversionStatusRequest generates requests for GetLeadConversionStatus
func NewGetLeadConversionStatusRequest(server string, id openapi_types.UUID, conversionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "conversion_id", runtime.ParamLocationPath, conversionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leads/%s/convert/status/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationFieldsRequest generates requests for GetOrganizationFields
func NewGetOrganizationFieldsRequest(server string, params *GetOrganizationFieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrganizationFieldRequest calls the generic AddOrganizationField builder with application/json body
func NewAddOrganizationFieldRequest(server string, body AddOrganizationFieldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrganizationFieldRequestWithBody(server, "application/json", bodyReader)
}

// NewAddOrganizationFieldRequestWithBody generates requests for AddOrganizationField with any type of body
func NewAddOrganizationFieldRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationFieldRequest generates requests for DeleteOrganizationField
func NewDeleteOrganizationFieldRequest(server string, fieldCode string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationFieldRequest generates requests for GetOrganizationField
func NewGetOrganizationFieldRequest(server string, fieldCode string, params *GetOrganizationFieldParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrganizationFieldRequest calls the generic UpdateOrganizationField builder with application/json body
func NewUpdateOrganizationFieldRequest(server string, fieldCode string, body UpdateOrganizationFieldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrganizationFieldRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewUpdateOrganizationFieldRequestWithBody generates requests for UpdateOrganizationField with any type of body
func NewUpdateOrganizationFieldRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationFieldOptionsRequest calls the generic DeleteOrganizationFieldOptions builder with application/json body
func NewDeleteOrganizationFieldOptionsRequest(server string, fieldCode string, body DeleteOrganizationFieldOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteOrganizationFieldOptionsRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewDeleteOrganizationFieldOptionsRequestWithBody generates requests for DeleteOrganizationFieldOptions with any type of body
func NewDeleteOrganizationFieldOptionsRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationFields/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateOrganizationFieldOptionsRequest calls the generic UpdateOrganizationFieldOptions builder with application/json body
func NewUpdateOrganizationFieldOptionsRequest(server string, fieldCode string, body UpdateOrganizationFieldOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrganizationFieldOptionsRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewUpdateOrganizationFieldOptionsRequestWithBody generates requests for UpdateOrganizationFieldOptions with any type of body
func NewUpdateOrganizationFieldOptionsRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationFields/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddOrganizationFieldOptionsRequest calls the generic AddOrganizationFieldOptions builder with application/json body
func NewAddOrganizationFieldOptionsRequest(server string, fieldCode string, body AddOrganizationFieldOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrganizationFieldOptionsRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewAddOrganizationFieldOptionsRequestWithBody generates requests for AddOrganizationFieldOptions with any type of body
func NewAddOrganizationFieldOptionsRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizationFields/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrganizationsRequest generates requests for GetOrganizations
func NewGetOrganizationsRequest(server string, params *GetOrganizationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_id", runtime.ParamLocationQuery, *params.OwnerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedUntil != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_until", runtime.ParamLocationQuery, *params.UpdatedUntil); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrganizationRequest calls the generic AddOrganization builder with application/json body
func NewAddOrganizationRequest(server string, body AddOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrganizationRequestWithBody(server, "application/json", bodyReader)
}

// NewAddOrganizationRequestWithBody generates requests for AddOrganization with any type of body
func NewAddOrganizationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchOrganizationRequest generates requests for SearchOrganization
func NewSearchOrganizationRequest(server string, params *SearchOrganizationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "term", runtime.ParamLocationQuery, params.Term); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exact_match", runtime.ParamLocationQuery, *params.ExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteOrganizationRequest generates requests for DeleteOrganization
func NewDeleteOrganizationRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRequest generates requests for GetOrganization
func NewGetOrganizationRequest(server string, id int, params *GetOrganizationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrganizationRequest calls the generic UpdateOrganization builder with application/json body
func NewUpdateOrganizationRequest(server string, id int, body UpdateOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrganizationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateOrganizationRequestWithBody generates requests for UpdateOrganization with any type of body
func NewUpdateOrganizationRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrganizationFollowersRequest generates requests for GetOrganizationFollowers
func NewGetOrganizationFollowersRequest(server string, id int, params *GetOrganizationFollowersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrganizationFollowerRequest calls the generic AddOrganizationFollower builder with application/json body
func NewAddOrganizationFollowerRequest(server string, id int, body AddOrganizationFollowerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrganizationFollowerRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddOrganizationFollowerRequestWithBody generates requests for AddOrganizationFollower with any type of body
func NewAddOrganizationFollowerRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrganizationFollowersChangelogRequest generates requests for GetOrganizationFollowersChangelog
func NewGetOrganizationFollowersChangelogRequest(server string, id int, params *GetOrganizationFollowersChangelogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/followers/changelog", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteOrganizationFollowerRequest generates requests for DeleteOrganizationFollower
func NewDeleteOrganizationFollowerRequest(server string, id int, followerId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "follower_id", runtime.ParamLocationPath, followerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/followers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonFieldsRequest generates requests for GetPersonFields
func NewGetPersonFieldsRequest(server string, params *GetPersonFieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPersonFieldRequest calls the generic AddPersonField builder with application/json body
func NewAddPersonFieldRequest(server string, body AddPersonFieldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPersonFieldRequestWithBody(server, "application/json", bodyReader)
}

// NewAddPersonFieldRequestWithBody generates requests for AddPersonField with any type of body
func NewAddPersonFieldRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePersonFieldRequest generates requests for DeletePersonField
func NewDeletePersonFieldRequest(server string, fieldCode string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonFieldRequest generates requests for GetPersonField
func NewGetPersonFieldRequest(server string, fieldCode string, params *GetPersonFieldParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePersonFieldRequest calls the generic UpdatePersonField builder with application/json body
func NewUpdatePersonFieldRequest(server string, fieldCode string, body UpdatePersonFieldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePersonFieldRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewUpdatePersonFieldRequestWithBody generates requests for UpdatePersonField with any type of body
func NewUpdatePersonFieldRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePersonFieldOptionsRequest calls the generic DeletePersonFieldOptions builder with application/json body
func NewDeletePersonFieldOptionsRequest(server string, fieldCode string, body DeletePersonFieldOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePersonFieldOptionsRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewDeletePersonFieldOptionsRequestWithBody generates requests for DeletePersonFieldOptions with any type of body
func NewDeletePersonFieldOptionsRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personFields/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdatePersonFieldOptionsRequest calls the generic UpdatePersonFieldOptions builder with application/json body
func NewUpdatePersonFieldOptionsRequest(server string, fieldCode string, body UpdatePersonFieldOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePersonFieldOptionsRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewUpdatePersonFieldOptionsRequestWithBody generates requests for UpdatePersonFieldOptions with any type of body
func NewUpdatePersonFieldOptionsRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personFields/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddPersonFieldOptionsRequest calls the generic AddPersonFieldOptions builder with application/json body
func NewAddPersonFieldOptionsRequest(server string, fieldCode string, body AddPersonFieldOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPersonFieldOptionsRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewAddPersonFieldOptionsRequestWithBody generates requests for AddPersonFieldOptions with any type of body
func NewAddPersonFieldOptionsRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personFields/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersonsRequest generates requests for GetPersons
func NewGetPersonsRequest(server string, params *GetPersonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_id", runtime.ParamLocationQuery, *params.OwnerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrgId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org_id", runtime.ParamLocationQuery, *params.OrgId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DealId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deal_id", runtime.ParamLocationQuery, *params.DealId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedUntil != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_until", runtime.ParamLocationQuery, *params.UpdatedUntil); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPersonRequest calls the generic AddPerson builder with application/json body
func NewAddPersonRequest(server string, body AddPersonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPersonRequestWithBody(server, "application/json", bodyReader)
}

// NewAddPersonRequestWithBody generates requests for AddPerson with any type of body
func NewAddPersonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchPersonsRequest generates requests for SearchPersons
func NewSearchPersonsRequest(server string, params *SearchPersonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "term", runtime.ParamLocationQuery, params.Term); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exact_match", runtime.ParamLocationQuery, *params.ExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePersonRequest generates requests for DeletePerson
func NewDeletePersonRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonRequest generates requests for GetPerson
func NewGetPersonRequest(server string, id int, params *GetPersonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePersonRequest calls the generic UpdatePerson builder with application/json body
func NewUpdatePersonRequest(server string, id int, body UpdatePersonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePersonRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdatePersonRequestWithBody generates requests for UpdatePerson with any type of body
func NewUpdatePersonRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersonFollowersRequest generates requests for GetPersonFollowers
func NewGetPersonFollowersRequest(server string, id int, params *GetPersonFollowersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPersonFollowerRequest calls the generic AddPersonFollower builder with application/json body
func NewAddPersonFollowerRequest(server string, id int, body AddPersonFollowerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPersonFollowerRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddPersonFollowerRequestWithBody generates requests for AddPersonFollower with any type of body
func NewAddPersonFollowerRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersonFollowersChangelogRequest generates requests for GetPersonFollowersChangelog
func NewGetPersonFollowersChangelogRequest(server string, id int, params *GetPersonFollowersChangelogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/followers/changelog", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePersonFollowerRequest generates requests for DeletePersonFollower
func NewDeletePersonFollowerRequest(server string, id int, followerId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "follower_id", runtime.ParamLocationPath, followerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/followers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonPictureRequest generates requests for GetPersonPicture
func NewGetPersonPictureRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s/picture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelinesRequest generates requests for GetPipelines
func NewGetPipelinesRequest(server string, params *GetPipelinesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPipelineRequest calls the generic AddPipeline builder with application/json body
func NewAddPipelineRequest(server string, body AddPipelineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPipelineRequestWithBody(server, "application/json", bodyReader)
}

// NewAddPipelineRequestWithBody generates requests for AddPipeline with any type of body
func NewAddPipelineRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePipelineRequest generates requests for DeletePipeline
func NewDeletePipelineRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineRequest generates requests for GetPipeline
func NewGetPipelineRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePipelineRequest calls the generic UpdatePipeline builder with application/json body
func NewUpdatePipelineRequest(server string, id int, body UpdatePipelineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePipelineRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdatePipelineRequestWithBody generates requests for UpdatePipeline with any type of body
func NewUpdatePipelineRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductFieldsRequest generates requests for GetProductFields
func NewGetProductFieldsRequest(server string, params *GetProductFieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/productFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddProductFieldRequest calls the generic AddProductField builder with application/json body
func NewAddProductFieldRequest(server string, body AddProductFieldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddProductFieldRequestWithBody(server, "application/json", bodyReader)
}

// NewAddProductFieldRequestWithBody generates requests for AddProductField with any type of body
func NewAddProductFieldRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/productFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductFieldRequest generates requests for DeleteProductField
func NewDeleteProductFieldRequest(server string, fieldCode string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/productFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductFieldRequest generates requests for GetProductField
func NewGetProductFieldRequest(server string, fieldCode string, params *GetProductFieldParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/productFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProductFieldRequest calls the generic UpdateProductField builder with application/json body
func NewUpdateProductFieldRequest(server string, fieldCode string, body UpdateProductFieldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProductFieldRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewUpdateProductFieldRequestWithBody generates requests for UpdateProductField with any type of body
func NewUpdateProductFieldRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/productFields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductFieldOptionsRequest calls the generic DeleteProductFieldOptions builder with application/json body
func NewDeleteProductFieldOptionsRequest(server string, fieldCode string, body DeleteProductFieldOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteProductFieldOptionsRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewDeleteProductFieldOptionsRequestWithBody generates requests for DeleteProductFieldOptions with any type of body
func NewDeleteProductFieldOptionsRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/productFields/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateProductFieldOptionsRequest calls the generic UpdateProductFieldOptions builder with application/json body
func NewUpdateProductFieldOptionsRequest(server string, fieldCode string, body UpdateProductFieldOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProductFieldOptionsRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewUpdateProductFieldOptionsRequestWithBody generates requests for UpdateProductFieldOptions with any type of body
func NewUpdateProductFieldOptionsRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/productFields/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddProductFieldOptionsRequest calls the generic AddProductFieldOptions builder with application/json body
func NewAddProductFieldOptionsRequest(server string, fieldCode string, body AddProductFieldOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddProductFieldOptionsRequestWithBody(server, fieldCode, "application/json", bodyReader)
}

// NewAddProductFieldOptionsRequestWithBody generates requests for AddProductFieldOptions with any type of body
func NewAddProductFieldOptionsRequestWithBody(server string, fieldCode string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "field_code", runtime.ParamLocationPath, fieldCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/productFields/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductsRequest generates requests for GetProducts
func NewGetProductsRequest(server string, params *GetProductsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OwnerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_id", runtime.ParamLocationQuery, *params.OwnerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_id", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddProductRequest calls the generic AddProduct builder with application/json body
func NewAddProductRequest(server string, body AddProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddProductRequestWithBody(server, "application/json", bodyReader)
}

// NewAddProductRequestWithBody generates requests for AddProduct with any type of body
func NewAddProductRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchProductsRequest generates requests for SearchProducts
func NewSearchProductsRequest(server string, params *SearchProductsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "term", runtime.ParamLocationQuery, params.Term); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExactMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exact_match", runtime.ParamLocationQuery, *params.ExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProductRequest generates requests for DeleteProduct
func NewDeleteProductRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductRequest generates requests for GetProduct
func NewGetProductRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProductRequest calls the generic UpdateProduct builder with application/json body
func NewUpdateProductRequest(server string, id int, body UpdateProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProductRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateProductRequestWithBody generates requests for UpdateProduct with any type of body
func NewUpdateProductRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDuplicateProductRequest generates requests for DuplicateProduct
func NewDuplicateProductRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/duplicate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductFollowersRequest generates requests for GetProductFollowers
func NewGetProductFollowersRequest(server string, id int, params *GetProductFollowersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddProductFollowerRequest calls the generic AddProductFollower builder with application/json body
func NewAddProductFollowerRequest(server string, id int, body AddProductFollowerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddProductFollowerRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddProductFollowerRequestWithBody generates requests for AddProductFollower with any type of body
func NewAddProductFollowerRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductFollowersChangelogRequest generates requests for GetProductFollowersChangelog
func NewGetProductFollowersChangelogRequest(server string, id int, params *GetProductFollowersChangelogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/followers/changelog", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProductFollowerRequest generates requests for DeleteProductFollower
func NewDeleteProductFollowerRequest(server string, id int, followerId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "follower_id", runtime.ParamLocationPath, followerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/followers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProductImageRequest generates requests for DeleteProductImage
func NewDeleteProductImageRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductImageRequest generates requests for GetProductImage
func NewGetProductImageRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadProductImageRequestWithBody generates requests for UploadProductImage with any type of body
func NewUploadProductImageRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateProductImageRequestWithBody generates requests for UpdateProductImage with any type of body
func NewUpdateProductImageRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductVariationsRequest generates requests for GetProductVariations
func NewGetProductVariationsRequest(server string, id int, params *GetProductVariationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/variations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddProductVariationRequest calls the generic AddProductVariation builder with application/json body
func NewAddProductVariationRequest(server string, id int, body AddProductVariationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddProductVariationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddProductVariationRequestWithBody generates requests for AddProductVariation with any type of body
func NewAddProductVariationRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/variations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductVariationRequest generates requests for DeleteProductVariation
func NewDeleteProductVariationRequest(server string, id int, productVariationId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "product_variation_id", runtime.ParamLocationPath, productVariationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/variations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProductVariationRequest calls the generic UpdateProductVariation builder with application/json body
func NewUpdateProductVariationRequest(server string, id int, productVariationId int, body UpdateProductVariationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProductVariationRequestWithBody(server, id, productVariationId, "application/json", bodyReader)
}

// NewUpdateProductVariationRequestWithBody generates requests for UpdateProductVariation with any type of body
func NewUpdateProductVariationRequestWithBody(server string, id int, productVariationId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "product_variation_id", runtime.ParamLocationPath, productVariationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/variations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStagesRequest generates requests for GetStages
func NewGetStagesRequest(server string, params *GetStagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PipelineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pipeline_id", runtime.ParamLocationQuery, *params.PipelineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddStageRequest calls the generic AddStage builder with application/json body
func NewAddStageRequest(server string, body AddStageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddStageRequestWithBody(server, "application/json", bodyReader)
}

// NewAddStageRequestWithBody generates requests for AddStage with any type of body
func NewAddStageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStageRequest generates requests for DeleteStage
func NewDeleteStageRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStageRequest generates requests for GetStage
func NewGetStageRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateStageRequest calls the generic UpdateStage builder with application/json body
func NewUpdateStageRequest(server string, id int, body UpdateStageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateStageRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateStageRequestWithBody generates requests for UpdateStage with any type of body
func NewUpdateStageRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserFollowersRequest generates requests for GetUserFollowers
func NewGetUserFollowersRequest(server string, id int, params *GetUserFollowersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetActivitiesWithResponse request
	GetActivitiesWithResponse(ctx context.Context, params *GetActivitiesParams, reqEditors ...RequestEditorFn) (*GetActivitiesResponse, error)

	// AddActivityWithBodyWithResponse request with any body
	AddActivityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddActivityResponse, error)

	AddActivityWithResponse(ctx context.Context, body AddActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*AddActivityResponse, error)

	// DeleteActivityWithResponse request
	DeleteActivityWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteActivityResponse, error)

	// GetActivityWithResponse request
	GetActivityWithResponse(ctx context.Context, id int, params *GetActivityParams, reqEditors ...RequestEditorFn) (*GetActivityResponse, error)

	// UpdateActivityWithBodyWithResponse request with any body
	UpdateActivityWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateActivityResponse, error)

	UpdateActivityWithResponse(ctx context.Context, id int, body UpdateActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateActivityResponse, error)

	// GetActivityFieldsWithResponse request
	GetActivityFieldsWithResponse(ctx context.Context, params *GetActivityFieldsParams, reqEditors ...RequestEditorFn) (*GetActivityFieldsResponse, error)

	// GetActivityFieldWithResponse request
	GetActivityFieldWithResponse(ctx context.Context, fieldCode string, params *GetActivityFieldParams, reqEditors ...RequestEditorFn) (*GetActivityFieldResponse, error)

	// GetDealFieldsWithResponse request
	GetDealFieldsWithResponse(ctx context.Context, params *GetDealFieldsParams, reqEditors ...RequestEditorFn) (*GetDealFieldsResponse, error)

	// AddDealFieldWithBodyWithResponse request with any body
	AddDealFieldWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDealFieldResponse, error)

	AddDealFieldWithResponse(ctx context.Context, body AddDealFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDealFieldResponse, error)

	// DeleteDealFieldWithResponse request
	DeleteDealFieldWithResponse(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*DeleteDealFieldResponse, error)

	// GetDealFieldWithResponse request
	GetDealFieldWithResponse(ctx context.Context, fieldCode string, params *GetDealFieldParams, reqEditors ...RequestEditorFn) (*GetDealFieldResponse, error)

	// UpdateDealFieldWithBodyWithResponse request with any body
	UpdateDealFieldWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDealFieldResponse, error)

	UpdateDealFieldWithResponse(ctx context.Context, fieldCode string, body UpdateDealFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDealFieldResponse, error)

	// DeleteDealFieldOptionsWithBodyWithResponse request with any body
	DeleteDealFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteDealFieldOptionsResponse, error)

	DeleteDealFieldOptionsWithResponse(ctx context.Context, fieldCode string, body DeleteDealFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteDealFieldOptionsResponse, error)

	// UpdateDealFieldOptionsWithBodyWithResponse request with any body
	UpdateDealFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDealFieldOptionsResponse, error)

	UpdateDealFieldOptionsWithResponse(ctx context.Context, fieldCode string, body UpdateDealFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDealFieldOptionsResponse, error)

	// AddDealFieldOptionsWithBodyWithResponse request with any body
	AddDealFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDealFieldOptionsResponse, error)

	AddDealFieldOptionsWithResponse(ctx context.Context, fieldCode string, body AddDealFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDealFieldOptionsResponse, error)

	// GetDealsWithResponse request
	GetDealsWithResponse(ctx context.Context, params *GetDealsParams, reqEditors ...RequestEditorFn) (*GetDealsResponse, error)

	// AddDealWithBodyWithResponse request with any body
	AddDealWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDealResponse, error)

	AddDealWithResponse(ctx context.Context, body AddDealJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDealResponse, error)

	// GetArchivedDealsWithResponse request
	GetArchivedDealsWithResponse(ctx context.Context, params *GetArchivedDealsParams, reqEditors ...RequestEditorFn) (*GetArchivedDealsResponse, error)

	// GetInstallmentsWithResponse request
	GetInstallmentsWithResponse(ctx context.Context, params *GetInstallmentsParams, reqEditors ...RequestEditorFn) (*GetInstallmentsResponse, error)

	// GetDealsProductsWithResponse request
	GetDealsProductsWithResponse(ctx context.Context, params *GetDealsProductsParams, reqEditors ...RequestEditorFn) (*GetDealsProductsResponse, error)

	// SearchDealsWithResponse request
	SearchDealsWithResponse(ctx context.Context, params *SearchDealsParams, reqEditors ...RequestEditorFn) (*SearchDealsResponse, error)

	// DeleteDealWithResponse request
	DeleteDealWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteDealResponse, error)

	// GetDealWithResponse request
	GetDealWithResponse(ctx context.Context, id int, params *GetDealParams, reqEditors ...RequestEditorFn) (*GetDealResponse, error)

	// UpdateDealWithBodyWithResponse request with any body
	UpdateDealWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDealResponse, error)

	UpdateDealWithResponse(ctx context.Context, id int, body UpdateDealJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDealResponse, error)

	// ConvertDealToLeadWithResponse request
	ConvertDealToLeadWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ConvertDealToLeadResponse, error)

	// GetDealConversionStatusWithResponse request
	GetDealConversionStatusWithResponse(ctx context.Context, id int, conversionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDealConversionStatusResponse, error)

	// GetAdditionalDiscountsWithResponse request
	GetAdditionalDiscountsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAdditionalDiscountsResponse, error)

	// PostAdditionalDiscountWithBodyWithResponse request with any body
	PostAdditionalDiscountWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAdditionalDiscountResponse, error)

	PostAdditionalDiscountWithResponse(ctx context.Context, id int, body PostAdditionalDiscountJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAdditionalDiscountResponse, error)

	// DeleteAdditionalDiscountWithResponse request
	DeleteAdditionalDiscountWithResponse(ctx context.Context, id int, discountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteAdditionalDiscountResponse, error)

	// UpdateAdditionalDiscountWithBodyWithResponse request with any body
	UpdateAdditionalDiscountWithBodyWithResponse(ctx context.Context, id int, discountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAdditionalDiscountResponse, error)

	UpdateAdditionalDiscountWithResponse(ctx context.Context, id int, discountId openapi_types.UUID, body UpdateAdditionalDiscountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAdditionalDiscountResponse, error)

	// GetDealFollowersWithResponse request
	GetDealFollowersWithResponse(ctx context.Context, id int, params *GetDealFollowersParams, reqEditors ...RequestEditorFn) (*GetDealFollowersResponse, error)

	// AddDealFollowerWithBodyWithResponse request with any body
	AddDealFollowerWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDealFollowerResponse, error)

	AddDealFollowerWithResponse(ctx context.Context, id int, body AddDealFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDealFollowerResponse, error)

	// GetDealFollowersChangelogWithResponse request
	GetDealFollowersChangelogWithResponse(ctx context.Context, id int, params *GetDealFollowersChangelogParams, reqEditors ...RequestEditorFn) (*GetDealFollowersChangelogResponse, error)

	// DeleteDealFollowerWithResponse request
	DeleteDealFollowerWithResponse(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*DeleteDealFollowerResponse, error)

	// PostInstallmentWithBodyWithResponse request with any body
	PostInstallmentWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInstallmentResponse, error)

	PostInstallmentWithResponse(ctx context.Context, id int, body PostInstallmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInstallmentResponse, error)

	// DeleteInstallmentWithResponse request
	DeleteInstallmentWithResponse(ctx context.Context, id int, installmentId int, reqEditors ...RequestEditorFn) (*DeleteInstallmentResponse, error)

	// UpdateInstallmentWithBodyWithResponse request with any body
	UpdateInstallmentWithBodyWithResponse(ctx context.Context, id int, installmentId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInstallmentResponse, error)

	UpdateInstallmentWithResponse(ctx context.Context, id int, installmentId int, body UpdateInstallmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInstallmentResponse, error)

	// DeleteManyDealProductsWithResponse request
	DeleteManyDealProductsWithResponse(ctx context.Context, id int, params *DeleteManyDealProductsParams, reqEditors ...RequestEditorFn) (*DeleteManyDealProductsResponse, error)

	// GetDealProductsWithResponse request
	GetDealProductsWithResponse(ctx context.Context, id int, params *GetDealProductsParams, reqEditors ...RequestEditorFn) (*GetDealProductsResponse, error)

	// AddDealProductWithBodyWithResponse request with any body
	AddDealProductWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDealProductResponse, error)

	AddDealProductWithResponse(ctx context.Context, id int, body AddDealProductJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDealProductResponse, error)

	// AddManyDealProductsWithBodyWithResponse request with any body
	AddManyDealProductsWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddManyDealProductsResponse, error)

	AddManyDealProductsWithResponse(ctx context.Context, id int, body AddManyDealProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddManyDealProductsResponse, error)

	// DeleteDealProductWithResponse request
	DeleteDealProductWithResponse(ctx context.Context, id int, productAttachmentId int, reqEditors ...RequestEditorFn) (*DeleteDealProductResponse, error)

	// UpdateDealProductWithBodyWithResponse request with any body
	UpdateDealProductWithBodyWithResponse(ctx context.Context, id int, productAttachmentId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDealProductResponse, error)

	UpdateDealProductWithResponse(ctx context.Context, id int, productAttachmentId int, body UpdateDealProductJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDealProductResponse, error)

	// SearchItemWithResponse request
	SearchItemWithResponse(ctx context.Context, params *SearchItemParams, reqEditors ...RequestEditorFn) (*SearchItemResponse, error)

	// SearchItemByFieldWithResponse request
	SearchItemByFieldWithResponse(ctx context.Context, params *SearchItemByFieldParams, reqEditors ...RequestEditorFn) (*SearchItemByFieldResponse, error)

	// SearchLeadsWithResponse request
	SearchLeadsWithResponse(ctx context.Context, params *SearchLeadsParams, reqEditors ...RequestEditorFn) (*SearchLeadsResponse, error)

	// ConvertLeadToDealWithBodyWithResponse request with any body
	ConvertLeadToDealWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertLeadToDealResponse, error)

	ConvertLeadToDealWithResponse(ctx context.Context, id openapi_types.UUID, body ConvertLeadToDealJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertLeadToDealResponse, error)

	// GetLeadConversionStatusWithResponse request
	GetLeadConversionStatusWithResponse(ctx context.Context, id openapi_types.UUID, conversionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetLeadConversionStatusResponse, error)

	// GetOrganizationFieldsWithResponse request
	GetOrganizationFieldsWithResponse(ctx context.Context, params *GetOrganizationFieldsParams, reqEditors ...RequestEditorFn) (*GetOrganizationFieldsResponse, error)

	// AddOrganizationFieldWithBodyWithResponse request with any body
	AddOrganizationFieldWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationFieldResponse, error)

	AddOrganizationFieldWithResponse(ctx context.Context, body AddOrganizationFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationFieldResponse, error)

	// DeleteOrganizationFieldWithResponse request
	DeleteOrganizationFieldWithResponse(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*DeleteOrganizationFieldResponse, error)

	// GetOrganizationFieldWithResponse request
	GetOrganizationFieldWithResponse(ctx context.Context, fieldCode string, params *GetOrganizationFieldParams, reqEditors ...RequestEditorFn) (*GetOrganizationFieldResponse, error)

	// UpdateOrganizationFieldWithBodyWithResponse request with any body
	UpdateOrganizationFieldWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationFieldResponse, error)

	UpdateOrganizationFieldWithResponse(ctx context.Context, fieldCode string, body UpdateOrganizationFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationFieldResponse, error)

	// DeleteOrganizationFieldOptionsWithBodyWithResponse request with any body
	DeleteOrganizationFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteOrganizationFieldOptionsResponse, error)

	DeleteOrganizationFieldOptionsWithResponse(ctx context.Context, fieldCode string, body DeleteOrganizationFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteOrganizationFieldOptionsResponse, error)

	// UpdateOrganizationFieldOptionsWithBodyWithResponse request with any body
	UpdateOrganizationFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationFieldOptionsResponse, error)

	UpdateOrganizationFieldOptionsWithResponse(ctx context.Context, fieldCode string, body UpdateOrganizationFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationFieldOptionsResponse, error)

	// AddOrganizationFieldOptionsWithBodyWithResponse request with any body
	AddOrganizationFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationFieldOptionsResponse, error)

	AddOrganizationFieldOptionsWithResponse(ctx context.Context, fieldCode string, body AddOrganizationFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationFieldOptionsResponse, error)

	// GetOrganizationsWithResponse request
	GetOrganizationsWithResponse(ctx context.Context, params *GetOrganizationsParams, reqEditors ...RequestEditorFn) (*GetOrganizationsResponse, error)

	// AddOrganizationWithBodyWithResponse request with any body
	AddOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationResponse, error)

	AddOrganizationWithResponse(ctx context.Context, body AddOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationResponse, error)

	// SearchOrganizationWithResponse request
	SearchOrganizationWithResponse(ctx context.Context, params *SearchOrganizationParams, reqEditors ...RequestEditorFn) (*SearchOrganizationResponse, error)

	// DeleteOrganizationWithResponse request
	DeleteOrganizationWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteOrganizationResponse, error)

	// GetOrganizationWithResponse request
	GetOrganizationWithResponse(ctx context.Context, id int, params *GetOrganizationParams, reqEditors ...RequestEditorFn) (*GetOrganizationResponse, error)

	// UpdateOrganizationWithBodyWithResponse request with any body
	UpdateOrganizationWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error)

	UpdateOrganizationWithResponse(ctx context.Context, id int, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error)

	// GetOrganizationFollowersWithResponse request
	GetOrganizationFollowersWithResponse(ctx context.Context, id int, params *GetOrganizationFollowersParams, reqEditors ...RequestEditorFn) (*GetOrganizationFollowersResponse, error)

	// AddOrganizationFollowerWithBodyWithResponse request with any body
	AddOrganizationFollowerWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationFollowerResponse, error)

	AddOrganizationFollowerWithResponse(ctx context.Context, id int, body AddOrganizationFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationFollowerResponse, error)

	// GetOrganizationFollowersChangelogWithResponse request
	GetOrganizationFollowersChangelogWithResponse(ctx context.Context, id int, params *GetOrganizationFollowersChangelogParams, reqEditors ...RequestEditorFn) (*GetOrganizationFollowersChangelogResponse, error)

	// DeleteOrganizationFollowerWithResponse request
	DeleteOrganizationFollowerWithResponse(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*DeleteOrganizationFollowerResponse, error)

	// GetPersonFieldsWithResponse request
	GetPersonFieldsWithResponse(ctx context.Context, params *GetPersonFieldsParams, reqEditors ...RequestEditorFn) (*GetPersonFieldsResponse, error)

	// AddPersonFieldWithBodyWithResponse request with any body
	AddPersonFieldWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPersonFieldResponse, error)

	AddPersonFieldWithResponse(ctx context.Context, body AddPersonFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPersonFieldResponse, error)

	// DeletePersonFieldWithResponse request
	DeletePersonFieldWithResponse(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*DeletePersonFieldResponse, error)

	// GetPersonFieldWithResponse request
	GetPersonFieldWithResponse(ctx context.Context, fieldCode string, params *GetPersonFieldParams, reqEditors ...RequestEditorFn) (*GetPersonFieldResponse, error)

	// UpdatePersonFieldWithBodyWithResponse request with any body
	UpdatePersonFieldWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePersonFieldResponse, error)

	UpdatePersonFieldWithResponse(ctx context.Context, fieldCode string, body UpdatePersonFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePersonFieldResponse, error)

	// DeletePersonFieldOptionsWithBodyWithResponse request with any body
	DeletePersonFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePersonFieldOptionsResponse, error)

	DeletePersonFieldOptionsWithResponse(ctx context.Context, fieldCode string, body DeletePersonFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePersonFieldOptionsResponse, error)

	// UpdatePersonFieldOptionsWithBodyWithResponse request with any body
	UpdatePersonFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePersonFieldOptionsResponse, error)

	UpdatePersonFieldOptionsWithResponse(ctx context.Context, fieldCode string, body UpdatePersonFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePersonFieldOptionsResponse, error)

	// AddPersonFieldOptionsWithBodyWithResponse request with any body
	AddPersonFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPersonFieldOptionsResponse, error)

	AddPersonFieldOptionsWithResponse(ctx context.Context, fieldCode string, body AddPersonFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPersonFieldOptionsResponse, error)

	// GetPersonsWithResponse request
	GetPersonsWithResponse(ctx context.Context, params *GetPersonsParams, reqEditors ...RequestEditorFn) (*GetPersonsResponse, error)

	// AddPersonWithBodyWithResponse request with any body
	AddPersonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPersonResponse, error)

	AddPersonWithResponse(ctx context.Context, body AddPersonJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPersonResponse, error)

	// SearchPersonsWithResponse request
	SearchPersonsWithResponse(ctx context.Context, params *SearchPersonsParams, reqEditors ...RequestEditorFn) (*SearchPersonsResponse, error)

	// DeletePersonWithResponse request
	DeletePersonWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeletePersonResponse, error)

	// GetPersonWithResponse request
	GetPersonWithResponse(ctx context.Context, id int, params *GetPersonParams, reqEditors ...RequestEditorFn) (*GetPersonResponse, error)

	// UpdatePersonWithBodyWithResponse request with any body
	UpdatePersonWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePersonResponse, error)

	UpdatePersonWithResponse(ctx context.Context, id int, body UpdatePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePersonResponse, error)

	// GetPersonFollowersWithResponse request
	GetPersonFollowersWithResponse(ctx context.Context, id int, params *GetPersonFollowersParams, reqEditors ...RequestEditorFn) (*GetPersonFollowersResponse, error)

	// AddPersonFollowerWithBodyWithResponse request with any body
	AddPersonFollowerWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPersonFollowerResponse, error)

	AddPersonFollowerWithResponse(ctx context.Context, id int, body AddPersonFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPersonFollowerResponse, error)

	// GetPersonFollowersChangelogWithResponse request
	GetPersonFollowersChangelogWithResponse(ctx context.Context, id int, params *GetPersonFollowersChangelogParams, reqEditors ...RequestEditorFn) (*GetPersonFollowersChangelogResponse, error)

	// DeletePersonFollowerWithResponse request
	DeletePersonFollowerWithResponse(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*DeletePersonFollowerResponse, error)

	// GetPersonPictureWithResponse request
	GetPersonPictureWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonPictureResponse, error)

	// GetPipelinesWithResponse request
	GetPipelinesWithResponse(ctx context.Context, params *GetPipelinesParams, reqEditors ...RequestEditorFn) (*GetPipelinesResponse, error)

	// AddPipelineWithBodyWithResponse request with any body
	AddPipelineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPipelineResponse, error)

	AddPipelineWithResponse(ctx context.Context, body AddPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPipelineResponse, error)

	// DeletePipelineWithResponse request
	DeletePipelineWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeletePipelineResponse, error)

	// GetPipelineWithResponse request
	GetPipelineWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPipelineResponse, error)

	// UpdatePipelineWithBodyWithResponse request with any body
	UpdatePipelineWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePipelineResponse, error)

	UpdatePipelineWithResponse(ctx context.Context, id int, body UpdatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePipelineResponse, error)

	// GetProductFieldsWithResponse request
	GetProductFieldsWithResponse(ctx context.Context, params *GetProductFieldsParams, reqEditors ...RequestEditorFn) (*GetProductFieldsResponse, error)

	// AddProductFieldWithBodyWithResponse request with any body
	AddProductFieldWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProductFieldResponse, error)

	AddProductFieldWithResponse(ctx context.Context, body AddProductFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProductFieldResponse, error)

	// DeleteProductFieldWithResponse request
	DeleteProductFieldWithResponse(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*DeleteProductFieldResponse, error)

	// GetProductFieldWithResponse request
	GetProductFieldWithResponse(ctx context.Context, fieldCode string, params *GetProductFieldParams, reqEditors ...RequestEditorFn) (*GetProductFieldResponse, error)

	// UpdateProductFieldWithBodyWithResponse request with any body
	UpdateProductFieldWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductFieldResponse, error)

	UpdateProductFieldWithResponse(ctx context.Context, fieldCode string, body UpdateProductFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductFieldResponse, error)

	// DeleteProductFieldOptionsWithBodyWithResponse request with any body
	DeleteProductFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteProductFieldOptionsResponse, error)

	DeleteProductFieldOptionsWithResponse(ctx context.Context, fieldCode string, body DeleteProductFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteProductFieldOptionsResponse, error)

	// UpdateProductFieldOptionsWithBodyWithResponse request with any body
	UpdateProductFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductFieldOptionsResponse, error)

	UpdateProductFieldOptionsWithResponse(ctx context.Context, fieldCode string, body UpdateProductFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductFieldOptionsResponse, error)

	// AddProductFieldOptionsWithBodyWithResponse request with any body
	AddProductFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProductFieldOptionsResponse, error)

	AddProductFieldOptionsWithResponse(ctx context.Context, fieldCode string, body AddProductFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProductFieldOptionsResponse, error)

	// GetProductsWithResponse request
	GetProductsWithResponse(ctx context.Context, params *GetProductsParams, reqEditors ...RequestEditorFn) (*GetProductsResponse, error)

	// AddProductWithBodyWithResponse request with any body
	AddProductWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProductResponse, error)

	AddProductWithResponse(ctx context.Context, body AddProductJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProductResponse, error)

	// SearchProductsWithResponse request
	SearchProductsWithResponse(ctx context.Context, params *SearchProductsParams, reqEditors ...RequestEditorFn) (*SearchProductsResponse, error)

	// DeleteProductWithResponse request
	DeleteProductWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteProductResponse, error)

	// GetProductWithResponse request
	GetProductWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProductResponse, error)

	// UpdateProductWithBodyWithResponse request with any body
	UpdateProductWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductResponse, error)

	UpdateProductWithResponse(ctx context.Context, id int, body UpdateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductResponse, error)

	// DuplicateProductWithResponse request
	DuplicateProductWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DuplicateProductResponse, error)

	// GetProductFollowersWithResponse request
	GetProductFollowersWithResponse(ctx context.Context, id int, params *GetProductFollowersParams, reqEditors ...RequestEditorFn) (*GetProductFollowersResponse, error)

	// AddProductFollowerWithBodyWithResponse request with any body
	AddProductFollowerWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProductFollowerResponse, error)

	AddProductFollowerWithResponse(ctx context.Context, id int, body AddProductFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProductFollowerResponse, error)

	// GetProductFollowersChangelogWithResponse request
	GetProductFollowersChangelogWithResponse(ctx context.Context, id int, params *GetProductFollowersChangelogParams, reqEditors ...RequestEditorFn) (*GetProductFollowersChangelogResponse, error)

	// DeleteProductFollowerWithResponse request
	DeleteProductFollowerWithResponse(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*DeleteProductFollowerResponse, error)

	// DeleteProductImageWithResponse request
	DeleteProductImageWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteProductImageResponse, error)

	// GetProductImageWithResponse request
	GetProductImageWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProductImageResponse, error)

	// UploadProductImageWithBodyWithResponse request with any body
	UploadProductImageWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadProductImageResponse, error)

	// UpdateProductImageWithBodyWithResponse request with any body
	UpdateProductImageWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductImageResponse, error)

	// GetProductVariationsWithResponse request
	GetProductVariationsWithResponse(ctx context.Context, id int, params *GetProductVariationsParams, reqEditors ...RequestEditorFn) (*GetProductVariationsResponse, error)

	// AddProductVariationWithBodyWithResponse request with any body
	AddProductVariationWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProductVariationResponse, error)

	AddProductVariationWithResponse(ctx context.Context, id int, body AddProductVariationJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProductVariationResponse, error)

	// DeleteProductVariationWithResponse request
	DeleteProductVariationWithResponse(ctx context.Context, id int, productVariationId int, reqEditors ...RequestEditorFn) (*DeleteProductVariationResponse, error)

	// UpdateProductVariationWithBodyWithResponse request with any body
	UpdateProductVariationWithBodyWithResponse(ctx context.Context, id int, productVariationId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductVariationResponse, error)

	UpdateProductVariationWithResponse(ctx context.Context, id int, productVariationId int, body UpdateProductVariationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductVariationResponse, error)

	// GetStagesWithResponse request
	GetStagesWithResponse(ctx context.Context, params *GetStagesParams, reqEditors ...RequestEditorFn) (*GetStagesResponse, error)

	// AddStageWithBodyWithResponse request with any body
	AddStageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddStageResponse, error)

	AddStageWithResponse(ctx context.Context, body AddStageJSONRequestBody, reqEditors ...RequestEditorFn) (*AddStageResponse, error)

	// DeleteStageWithResponse request
	DeleteStageWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteStageResponse, error)

	// GetStageWithResponse request
	GetStageWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetStageResponse, error)

	// UpdateStageWithBodyWithResponse request with any body
	UpdateStageWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStageResponse, error)

	UpdateStageWithResponse(ctx context.Context, id int, body UpdateStageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStageResponse, error)

	// GetUserFollowersWithResponse request
	GetUserFollowersWithResponse(ctx context.Context, id int, params *GetUserFollowersParams, reqEditors ...RequestEditorFn) (*GetUserFollowersResponse, error)
}

type GetActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Activities array
		Data *[]struct {
			// AddTime The creation date and time of the activity
			AddTime *string `json:"add_time,omitempty"`

			// Attendees The attendees of the activity
			Attendees *[]struct {
				// Email The email address of the attendee
				Email *string `json:"email,omitempty"`

				// IsOrganizer Whether the attendee is the organizer or not
				IsOrganizer *bool `json:"is_organizer,omitempty"`

				// Name The name of the attendee
				Name *string `json:"name,omitempty"`

				// PersonId The ID of the person if the attendee has a person record
				PersonId *int `json:"person_id,omitempty"`

				// Status The status of the attendee
				Status *string `json:"status,omitempty"`

				// UserId The ID of the user if the attendee is a user
				UserId *int `json:"user_id,omitempty"`
			} `json:"attendees,omitempty"`

			// Busy Whether the activity marks the assignee as busy or not in their calendar
			Busy *bool `json:"busy,omitempty"`

			// ConferenceMeetingClient The client used for the conference meeting
			ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

			// ConferenceMeetingId The ID of the conference meeting
			ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

			// ConferenceMeetingUrl The URL of the conference meeting
			ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

			// CreatorUserId The ID of the user who created the activity
			CreatorUserId *int `json:"creator_user_id,omitempty"`

			// DealId The ID of the deal linked to the activity
			DealId *int `json:"deal_id,omitempty"`

			// Done Whether the activity is marked as done or not
			Done *bool `json:"done,omitempty"`

			// DueDate The due date of the activity
			DueDate *string `json:"due_date,omitempty"`

			// DueTime The due time of the activity
			DueTime *string `json:"due_time,omitempty"`

			// Duration The duration of the activity
			Duration *string `json:"duration,omitempty"`

			// Id The ID of the activity
			Id *int `json:"id,omitempty"`

			// IsDeleted Whether the activity is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LeadId The ID of the lead linked to the activity
			LeadId *string `json:"lead_id,omitempty"`

			// Location Location of the activity
			Location *struct {
				// AdminAreaLevel1 Admin area level 1 (e.g. state) of the activity
				AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

				// AdminAreaLevel2 Admin area level 2 (e.g. county) of the activity
				AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

				// Country Country of the activity
				Country *string `json:"country,omitempty"`

				// Locality Locality (e.g. city) of the activity
				Locality *string `json:"locality,omitempty"`

				// PostalCode Postal code of the activity
				PostalCode *string `json:"postal_code,omitempty"`

				// Route Route (e.g. street) of the activity
				Route *string `json:"route,omitempty"`

				// StreetNumber Street number of the activity
				StreetNumber *string `json:"street_number,omitempty"`

				// Sublocality Sublocality (e.g. neighborhood) of the activity
				Sublocality *string `json:"sublocality,omitempty"`

				// Subpremise Subpremise (e.g. apartment/suite number) of the activity
				Subpremise *string `json:"subpremise,omitempty"`

				// Value The full address of the activity
				Value *string `json:"value,omitempty"`
			} `json:"location,omitempty"`

			// MarkedAsDoneTime The date and time when the activity was marked as done
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// Note The note of the activity
			Note *string `json:"note,omitempty"`

			// OrgId The ID of the organization linked to the activity
			OrgId *int `json:"org_id,omitempty"`

			// OwnerId The ID of the user who owns the activity
			OwnerId *int `json:"owner_id,omitempty"`

			// Participants The participants of the activity
			Participants *[]struct {
				// PersonId The ID of the person
				PersonId *int `json:"person_id,omitempty"`

				// Primary Whether the person is the primary participant or not
				Primary *bool `json:"primary,omitempty"`
			} `json:"participants,omitempty"`

			// PersonId The ID of the person linked to the activity
			PersonId *int `json:"person_id,omitempty"`

			// Priority The priority of the activity. Mappable to a specific string using activityFields API.
			Priority *int `json:"priority,omitempty"`

			// ProjectId The ID of the project linked to the activity
			ProjectId *int `json:"project_id,omitempty"`

			// PublicDescription The public description of the activity
			PublicDescription *string `json:"public_description,omitempty"`

			// Subject The subject of the activity
			Subject *string `json:"subject,omitempty"`

			// Type The type of the activity
			Type *string `json:"type,omitempty"`

			// UpdateTime The last updated date and time of the activity
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The activity object
		Data *struct {
			// AddTime The creation date and time of the activity
			AddTime *string `json:"add_time,omitempty"`

			// Attendees The attendees of the activity
			Attendees *[]struct {
				// Email The email address of the attendee
				Email *string `json:"email,omitempty"`

				// IsOrganizer Whether the attendee is the organizer or not
				IsOrganizer *bool `json:"is_organizer,omitempty"`

				// Name The name of the attendee
				Name *string `json:"name,omitempty"`

				// PersonId The ID of the person if the attendee has a person record
				PersonId *int `json:"person_id,omitempty"`

				// Status The status of the attendee
				Status *string `json:"status,omitempty"`

				// UserId The ID of the user if the attendee is a user
				UserId *int `json:"user_id,omitempty"`
			} `json:"attendees,omitempty"`

			// Busy Whether the activity marks the assignee as busy or not in their calendar
			Busy *bool `json:"busy,omitempty"`

			// ConferenceMeetingClient The client used for the conference meeting
			ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

			// ConferenceMeetingId The ID of the conference meeting
			ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

			// ConferenceMeetingUrl The URL of the conference meeting
			ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

			// CreatorUserId The ID of the user who created the activity
			CreatorUserId *int `json:"creator_user_id,omitempty"`

			// DealId The ID of the deal linked to the activity
			DealId *int `json:"deal_id,omitempty"`

			// Done Whether the activity is marked as done or not
			Done *bool `json:"done,omitempty"`

			// DueDate The due date of the activity
			DueDate *string `json:"due_date,omitempty"`

			// DueTime The due time of the activity
			DueTime *string `json:"due_time,omitempty"`

			// Duration The duration of the activity
			Duration *string `json:"duration,omitempty"`

			// Id The ID of the activity
			Id *int `json:"id,omitempty"`

			// IsDeleted Whether the activity is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LeadId The ID of the lead linked to the activity
			LeadId *string `json:"lead_id,omitempty"`

			// Location Location of the activity
			Location *struct {
				// AdminAreaLevel1 Admin area level 1 (e.g. state) of the activity
				AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

				// AdminAreaLevel2 Admin area level 2 (e.g. county) of the activity
				AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

				// Country Country of the activity
				Country *string `json:"country,omitempty"`

				// Locality Locality (e.g. city) of the activity
				Locality *string `json:"locality,omitempty"`

				// PostalCode Postal code of the activity
				PostalCode *string `json:"postal_code,omitempty"`

				// Route Route (e.g. street) of the activity
				Route *string `json:"route,omitempty"`

				// StreetNumber Street number of the activity
				StreetNumber *string `json:"street_number,omitempty"`

				// Sublocality Sublocality (e.g. neighborhood) of the activity
				Sublocality *string `json:"sublocality,omitempty"`

				// Subpremise Subpremise (e.g. apartment/suite number) of the activity
				Subpremise *string `json:"subpremise,omitempty"`

				// Value The full address of the activity
				Value *string `json:"value,omitempty"`
			} `json:"location,omitempty"`

			// MarkedAsDoneTime The date and time when the activity was marked as done
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// Note The note of the activity
			Note *string `json:"note,omitempty"`

			// OrgId The ID of the organization linked to the activity
			OrgId *int `json:"org_id,omitempty"`

			// OwnerId The ID of the user who owns the activity
			OwnerId *int `json:"owner_id,omitempty"`

			// Participants The participants of the activity
			Participants *[]struct {
				// PersonId The ID of the person
				PersonId *int `json:"person_id,omitempty"`

				// Primary Whether the person is the primary participant or not
				Primary *bool `json:"primary,omitempty"`
			} `json:"participants,omitempty"`

			// PersonId The ID of the person linked to the activity
			PersonId *int `json:"person_id,omitempty"`

			// Priority The priority of the activity. Mappable to a specific string using activityFields API.
			Priority *int `json:"priority,omitempty"`

			// ProjectId The ID of the project linked to the activity
			ProjectId *int `json:"project_id,omitempty"`

			// PublicDescription The public description of the activity
			PublicDescription *string `json:"public_description,omitempty"`

			// Subject The subject of the activity
			Subject *string `json:"subject,omitempty"`

			// Type The type of the activity
			Type *string `json:"type,omitempty"`

			// UpdateTime The last updated date and time of the activity
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id Deleted activity ID
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The activity object
		Data *struct {
			// AddTime The creation date and time of the activity
			AddTime *string `json:"add_time,omitempty"`

			// Attendees The attendees of the activity
			Attendees *[]struct {
				// Email The email address of the attendee
				Email *string `json:"email,omitempty"`

				// IsOrganizer Whether the attendee is the organizer or not
				IsOrganizer *bool `json:"is_organizer,omitempty"`

				// Name The name of the attendee
				Name *string `json:"name,omitempty"`

				// PersonId The ID of the person if the attendee has a person record
				PersonId *int `json:"person_id,omitempty"`

				// Status The status of the attendee
				Status *string `json:"status,omitempty"`

				// UserId The ID of the user if the attendee is a user
				UserId *int `json:"user_id,omitempty"`
			} `json:"attendees,omitempty"`

			// Busy Whether the activity marks the assignee as busy or not in their calendar
			Busy *bool `json:"busy,omitempty"`

			// ConferenceMeetingClient The client used for the conference meeting
			ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

			// ConferenceMeetingId The ID of the conference meeting
			ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

			// ConferenceMeetingUrl The URL of the conference meeting
			ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

			// CreatorUserId The ID of the user who created the activity
			CreatorUserId *int `json:"creator_user_id,omitempty"`

			// DealId The ID of the deal linked to the activity
			DealId *int `json:"deal_id,omitempty"`

			// Done Whether the activity is marked as done or not
			Done *bool `json:"done,omitempty"`

			// DueDate The due date of the activity
			DueDate *string `json:"due_date,omitempty"`

			// DueTime The due time of the activity
			DueTime *string `json:"due_time,omitempty"`

			// Duration The duration of the activity
			Duration *string `json:"duration,omitempty"`

			// Id The ID of the activity
			Id *int `json:"id,omitempty"`

			// IsDeleted Whether the activity is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LeadId The ID of the lead linked to the activity
			LeadId *string `json:"lead_id,omitempty"`

			// Location Location of the activity
			Location *struct {
				// AdminAreaLevel1 Admin area level 1 (e.g. state) of the activity
				AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

				// AdminAreaLevel2 Admin area level 2 (e.g. county) of the activity
				AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

				// Country Country of the activity
				Country *string `json:"country,omitempty"`

				// Locality Locality (e.g. city) of the activity
				Locality *string `json:"locality,omitempty"`

				// PostalCode Postal code of the activity
				PostalCode *string `json:"postal_code,omitempty"`

				// Route Route (e.g. street) of the activity
				Route *string `json:"route,omitempty"`

				// StreetNumber Street number of the activity
				StreetNumber *string `json:"street_number,omitempty"`

				// Sublocality Sublocality (e.g. neighborhood) of the activity
				Sublocality *string `json:"sublocality,omitempty"`

				// Subpremise Subpremise (e.g. apartment/suite number) of the activity
				Subpremise *string `json:"subpremise,omitempty"`

				// Value The full address of the activity
				Value *string `json:"value,omitempty"`
			} `json:"location,omitempty"`

			// MarkedAsDoneTime The date and time when the activity was marked as done
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// Note The note of the activity
			Note *string `json:"note,omitempty"`

			// OrgId The ID of the organization linked to the activity
			OrgId *int `json:"org_id,omitempty"`

			// OwnerId The ID of the user who owns the activity
			OwnerId *int `json:"owner_id,omitempty"`

			// Participants The participants of the activity
			Participants *[]struct {
				// PersonId The ID of the person
				PersonId *int `json:"person_id,omitempty"`

				// Primary Whether the person is the primary participant or not
				Primary *bool `json:"primary,omitempty"`
			} `json:"participants,omitempty"`

			// PersonId The ID of the person linked to the activity
			PersonId *int `json:"person_id,omitempty"`

			// Priority The priority of the activity. Mappable to a specific string using activityFields API.
			Priority *int `json:"priority,omitempty"`

			// ProjectId The ID of the project linked to the activity
			ProjectId *int `json:"project_id,omitempty"`

			// PublicDescription The public description of the activity
			PublicDescription *string `json:"public_description,omitempty"`

			// Subject The subject of the activity
			Subject *string `json:"subject,omitempty"`

			// Type The type of the activity
			Type *string `json:"type,omitempty"`

			// UpdateTime The last updated date and time of the activity
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The activity object
		Data *struct {
			// AddTime The creation date and time of the activity
			AddTime *string `json:"add_time,omitempty"`

			// Attendees The attendees of the activity
			Attendees *[]struct {
				// Email The email address of the attendee
				Email *string `json:"email,omitempty"`

				// IsOrganizer Whether the attendee is the organizer or not
				IsOrganizer *bool `json:"is_organizer,omitempty"`

				// Name The name of the attendee
				Name *string `json:"name,omitempty"`

				// PersonId The ID of the person if the attendee has a person record
				PersonId *int `json:"person_id,omitempty"`

				// Status The status of the attendee
				Status *string `json:"status,omitempty"`

				// UserId The ID of the user if the attendee is a user
				UserId *int `json:"user_id,omitempty"`
			} `json:"attendees,omitempty"`

			// Busy Whether the activity marks the assignee as busy or not in their calendar
			Busy *bool `json:"busy,omitempty"`

			// ConferenceMeetingClient The client used for the conference meeting
			ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

			// ConferenceMeetingId The ID of the conference meeting
			ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

			// ConferenceMeetingUrl The URL of the conference meeting
			ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

			// CreatorUserId The ID of the user who created the activity
			CreatorUserId *int `json:"creator_user_id,omitempty"`

			// DealId The ID of the deal linked to the activity
			DealId *int `json:"deal_id,omitempty"`

			// Done Whether the activity is marked as done or not
			Done *bool `json:"done,omitempty"`

			// DueDate The due date of the activity
			DueDate *string `json:"due_date,omitempty"`

			// DueTime The due time of the activity
			DueTime *string `json:"due_time,omitempty"`

			// Duration The duration of the activity
			Duration *string `json:"duration,omitempty"`

			// Id The ID of the activity
			Id *int `json:"id,omitempty"`

			// IsDeleted Whether the activity is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LeadId The ID of the lead linked to the activity
			LeadId *string `json:"lead_id,omitempty"`

			// Location Location of the activity
			Location *struct {
				// AdminAreaLevel1 Admin area level 1 (e.g. state) of the activity
				AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

				// AdminAreaLevel2 Admin area level 2 (e.g. county) of the activity
				AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

				// Country Country of the activity
				Country *string `json:"country,omitempty"`

				// Locality Locality (e.g. city) of the activity
				Locality *string `json:"locality,omitempty"`

				// PostalCode Postal code of the activity
				PostalCode *string `json:"postal_code,omitempty"`

				// Route Route (e.g. street) of the activity
				Route *string `json:"route,omitempty"`

				// StreetNumber Street number of the activity
				StreetNumber *string `json:"street_number,omitempty"`

				// Sublocality Sublocality (e.g. neighborhood) of the activity
				Sublocality *string `json:"sublocality,omitempty"`

				// Subpremise Subpremise (e.g. apartment/suite number) of the activity
				Subpremise *string `json:"subpremise,omitempty"`

				// Value The full address of the activity
				Value *string `json:"value,omitempty"`
			} `json:"location,omitempty"`

			// MarkedAsDoneTime The date and time when the activity was marked as done
			MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

			// Note The note of the activity
			Note *string `json:"note,omitempty"`

			// OrgId The ID of the organization linked to the activity
			OrgId *int `json:"org_id,omitempty"`

			// OwnerId The ID of the user who owns the activity
			OwnerId *int `json:"owner_id,omitempty"`

			// Participants The participants of the activity
			Participants *[]struct {
				// PersonId The ID of the person
				PersonId *int `json:"person_id,omitempty"`

				// Primary Whether the person is the primary participant or not
				Primary *bool `json:"primary,omitempty"`
			} `json:"participants,omitempty"`

			// PersonId The ID of the person linked to the activity
			PersonId *int `json:"person_id,omitempty"`

			// Priority The priority of the activity. Mappable to a specific string using activityFields API.
			Priority *int `json:"priority,omitempty"`

			// ProjectId The ID of the project linked to the activity
			ProjectId *int `json:"project_id,omitempty"`

			// PublicDescription The public description of the activity
			PublicDescription *string `json:"public_description,omitempty"`

			// Subject The subject of the activity
			Subject *string `json:"subject,omitempty"`

			// Type The type of the activity
			Type *string `json:"type,omitempty"`

			// UpdateTime The last updated date and time of the activity
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// NextCursor Base64url-encoded cursor for fetching the next page of results, null if no more pages
			NextCursor *string `json:"next_cursor"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType GetActivityFields200DataFieldType `json:"field_type"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view (read-only)
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type GetActivityFields200DataFieldType string

// Status returns HTTPResponse.Status
func (r GetActivityFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType GetActivityField200DataFieldType `json:"field_type"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view (read-only)
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type GetActivityField200DataFieldType string

// Status returns HTTPResponse.Status
func (r GetActivityFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// NextCursor Base64url-encoded cursor for fetching the next page of results, null if no more pages
			NextCursor *string `json:"next_cursor"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// Description The description of the field
			Description string `json:"description"`

			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType GetDealFields200DataFieldType `json:"field_type"`

			// ImportantFields Important fields configuration
			ImportantFields *struct {
				// Enabled Whether the field is marked as important
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of stage IDs where the field is important
				StageIds *[]int `json:"stage_ids,omitempty"`
			} `json:"important_fields,omitempty"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// RequiredFields Required fields configuration
			RequiredFields *struct {
				// Enabled Whether the field is required
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of stage IDs where the field is required
				StageIds *[]int `json:"stage_ids,omitempty"`

				// Statuses Pipeline-specific status requirements, mapping pipeline ID to array of statuses
				Statuses *map[string][]GetDealFields200DataRequiredFieldsStatuses `json:"statuses,omitempty"`
			} `json:"required_fields,omitempty"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// ProjectsDetailVisibleFlag Whether the field is shown in project details view
				ProjectsDetailVisibleFlag *bool `json:"projects_detail_visible_flag,omitempty"`

				// ShowInPipelines Pipeline visibility configuration
				ShowInPipelines *struct {
					// PipelineIds Specific pipeline IDs where the field is shown (if show_in_all is false)
					PipelineIds *[]int `json:"pipeline_ids,omitempty"`

					// ShowInAll Whether the field is shown in all pipelines
					ShowInAll *bool `json:"show_in_all,omitempty"`
				} `json:"show_in_pipelines,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type GetDealFields200DataFieldType string
type GetDealFields200DataRequiredFieldsStatuses string

// Status returns HTTPResponse.Status
func (r GetDealFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDealFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Description The description of the field
			Description string `json:"description"`

			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType AddDealField200DataFieldType `json:"field_type"`

			// ImportantFields Important fields configuration
			ImportantFields *struct {
				// Enabled Whether the field is marked as important
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of stage IDs where the field is important
				StageIds *[]int `json:"stage_ids,omitempty"`
			} `json:"important_fields,omitempty"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// RequiredFields Required fields configuration
			RequiredFields *struct {
				// Enabled Whether the field is required
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of stage IDs where the field is required
				StageIds *[]int `json:"stage_ids,omitempty"`

				// Statuses Pipeline-specific status requirements, mapping pipeline ID to array of statuses
				Statuses *map[string][]AddDealField200DataRequiredFieldsStatuses `json:"statuses,omitempty"`
			} `json:"required_fields,omitempty"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// ProjectsDetailVisibleFlag Whether the field is shown in project details view
				ProjectsDetailVisibleFlag *bool `json:"projects_detail_visible_flag,omitempty"`

				// ShowInPipelines Pipeline visibility configuration
				ShowInPipelines *struct {
					// PipelineIds Specific pipeline IDs where the field is shown (if show_in_all is false)
					PipelineIds *[]int `json:"pipeline_ids,omitempty"`

					// ShowInAll Whether the field is shown in all pipelines
					ShowInAll *bool `json:"show_in_all,omitempty"`
				} `json:"show_in_pipelines,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type AddDealField200DataFieldType string
type AddDealField200DataRequiredFieldsStatuses string

// Status returns HTTPResponse.Status
func (r AddDealFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDealFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDealFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Description The description of the field
			Description string `json:"description"`

			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType string `json:"field_type"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]map[string]interface{} `json:"options"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]map[string]interface{} `json:"subfields"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDealFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDealFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Description The description of the field
			Description string `json:"description"`

			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType GetDealField200DataFieldType `json:"field_type"`

			// ImportantFields Important fields configuration
			ImportantFields *struct {
				// Enabled Whether the field is marked as important
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of stage IDs where the field is important
				StageIds *[]int `json:"stage_ids,omitempty"`
			} `json:"important_fields,omitempty"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// RequiredFields Required fields configuration
			RequiredFields *struct {
				// Enabled Whether the field is required
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of stage IDs where the field is required
				StageIds *[]int `json:"stage_ids,omitempty"`

				// Statuses Pipeline-specific status requirements, mapping pipeline ID to array of statuses
				Statuses *map[string][]GetDealField200DataRequiredFieldsStatuses `json:"statuses,omitempty"`
			} `json:"required_fields,omitempty"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// ProjectsDetailVisibleFlag Whether the field is shown in project details view
				ProjectsDetailVisibleFlag *bool `json:"projects_detail_visible_flag,omitempty"`

				// ShowInPipelines Pipeline visibility configuration
				ShowInPipelines *struct {
					// PipelineIds Specific pipeline IDs where the field is shown (if show_in_all is false)
					PipelineIds *[]int `json:"pipeline_ids,omitempty"`

					// ShowInAll Whether the field is shown in all pipelines
					ShowInAll *bool `json:"show_in_all,omitempty"`
				} `json:"show_in_pipelines,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type GetDealField200DataFieldType string
type GetDealField200DataRequiredFieldsStatuses string

// Status returns HTTPResponse.Status
func (r GetDealFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDealFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Description The description of the field
			Description string `json:"description"`

			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType UpdateDealField200DataFieldType `json:"field_type"`

			// ImportantFields Important fields configuration
			ImportantFields *struct {
				// Enabled Whether the field is marked as important
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of stage IDs where the field is important
				StageIds *[]int `json:"stage_ids,omitempty"`
			} `json:"important_fields,omitempty"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// RequiredFields Required fields configuration
			RequiredFields *struct {
				// Enabled Whether the field is required
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of stage IDs where the field is required
				StageIds *[]int `json:"stage_ids,omitempty"`

				// Statuses Pipeline-specific status requirements, mapping pipeline ID to array of statuses
				Statuses *map[string][]UpdateDealField200DataRequiredFieldsStatuses `json:"statuses,omitempty"`
			} `json:"required_fields,omitempty"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// ProjectsDetailVisibleFlag Whether the field is shown in project details view
				ProjectsDetailVisibleFlag *bool `json:"projects_detail_visible_flag,omitempty"`

				// ShowInPipelines Pipeline visibility configuration
				ShowInPipelines *struct {
					// PipelineIds Specific pipeline IDs where the field is shown (if show_in_all is false)
					PipelineIds *[]int `json:"pipeline_ids,omitempty"`

					// ShowInAll Whether the field is shown in all pipelines
					ShowInAll *bool `json:"show_in_all,omitempty"`
				} `json:"show_in_pipelines,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type UpdateDealField200DataFieldType string
type UpdateDealField200DataRequiredFieldsStatuses string

// Status returns HTTPResponse.Status
func (r UpdateDealFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDealFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDealFieldOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id The unique identifier of the option
			Id int `json:"id"`

			// Label The display label of the option
			Label string `json:"label"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDealFieldOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDealFieldOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDealFieldOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id The unique identifier of the option
			Id int `json:"id"`

			// Label The display label of the option
			Label string `json:"label"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateDealFieldOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDealFieldOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDealFieldOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id The unique identifier of the option
			Id int `json:"id"`

			// Label The display label of the option
			Label string `json:"label"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddDealFieldOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDealFieldOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Deals array
		Data *[]struct {
			// Acv Only available in Growth and above plans
			//
			// The Annual Contract Value of the deal
			//
			// Null if there are no products attached to the deal
			Acv *float32 `json:"acv"`

			// AddTime The creation date and time of the deal
			AddTime *string `json:"add_time,omitempty"`

			// Arr Only available in Growth and above plans
			//
			// The Annual Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Arr *float32 `json:"arr"`

			// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CloseTime The date and time of closing the deal
			CloseTime *string `json:"close_time"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// IsArchived Whether the deal is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// IsDeleted Whether the deal is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LabelIds The IDs of labels assigned to the deal
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status as lost
			LostTime *string `json:"lost_time,omitempty"`

			// Mrr Only available in Growth and above plans
			//
			// The Monthly Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Mrr *float32 `json:"mrr"`

			// OrgId The ID of the organization linked to the deal
			OrgId *int `json:"org_id,omitempty"`

			// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
			OriginId *string `json:"origin_id"`

			// OwnerId The ID of the user who owns the deal
			OwnerId *int `json:"owner_id,omitempty"`

			// PersonId The ID of the person linked to the deal
			PersonId *int `json:"person_id,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// StageChangeTime The last updated date and time of the deal stage
			StageChangeTime *string `json:"stage_change_time,omitempty"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UpdateTime The last updated date and time of the deal
			UpdateTime *string `json:"update_time,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *int `json:"visible_to,omitempty"`

			// WonTime The date and time of changing the deal status as won
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDealResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The deal object
		Data *struct {
			// Acv Only available in Growth and above plans
			//
			// The Annual Contract Value of the deal
			//
			// Null if there are no products attached to the deal
			Acv *float32 `json:"acv"`

			// AddTime The creation date and time of the deal
			AddTime *string `json:"add_time,omitempty"`

			// Arr Only available in Growth and above plans
			//
			// The Annual Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Arr *float32 `json:"arr"`

			// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CloseTime The date and time of closing the deal
			CloseTime *string `json:"close_time"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// IsArchived Whether the deal is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// IsDeleted Whether the deal is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LabelIds The IDs of labels assigned to the deal
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status as lost
			LostTime *string `json:"lost_time,omitempty"`

			// Mrr Only available in Growth and above plans
			//
			// The Monthly Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Mrr *float32 `json:"mrr"`

			// OrgId The ID of the organization linked to the deal
			OrgId *int `json:"org_id,omitempty"`

			// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
			OriginId *string `json:"origin_id"`

			// OwnerId The ID of the user who owns the deal
			OwnerId *int `json:"owner_id,omitempty"`

			// PersonId The ID of the person linked to the deal
			PersonId *int `json:"person_id,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// StageChangeTime The last updated date and time of the deal stage
			StageChangeTime *string `json:"stage_change_time,omitempty"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UpdateTime The last updated date and time of the deal
			UpdateTime *string `json:"update_time,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *int `json:"visible_to,omitempty"`

			// WonTime The date and time of changing the deal status as won
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddDealResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDealResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArchivedDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Deals array
		Data *[]struct {
			// Acv Only available in Growth and above plans
			//
			// The Annual Contract Value of the deal
			//
			// Null if there are no products attached to the deal
			Acv *float32 `json:"acv"`

			// AddTime The creation date and time of the deal
			AddTime *string `json:"add_time,omitempty"`

			// Arr Only available in Growth and above plans
			//
			// The Annual Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Arr *float32 `json:"arr"`

			// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CloseTime The date and time of closing the deal
			CloseTime *string `json:"close_time"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// IsArchived Whether the deal is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// IsDeleted Whether the deal is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LabelIds The IDs of labels assigned to the deal
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status as lost
			LostTime *string `json:"lost_time,omitempty"`

			// Mrr Only available in Growth and above plans
			//
			// The Monthly Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Mrr *float32 `json:"mrr"`

			// OrgId The ID of the organization linked to the deal
			OrgId *int `json:"org_id,omitempty"`

			// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
			OriginId *string `json:"origin_id"`

			// OwnerId The ID of the user who owns the deal
			OwnerId *int `json:"owner_id,omitempty"`

			// PersonId The ID of the person linked to the deal
			PersonId *int `json:"person_id,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// StageChangeTime The last updated date and time of the deal stage
			StageChangeTime *string `json:"stage_change_time,omitempty"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UpdateTime The last updated date and time of the deal
			UpdateTime *string `json:"update_time,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *int `json:"visible_to,omitempty"`

			// WonTime The date and time of changing the deal status as won
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetArchivedDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArchivedDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstallmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Array containing data for all installments added to a deal
		Data *[]struct {
			// Amount The installment amount.
			Amount *float32 `json:"amount,omitempty"`

			// BillingDate The date which the installment will be charged.
			BillingDate *string `json:"billing_date,omitempty"`

			// DealId The ID of the deal the installment was added to.
			DealId *int `json:"deal_id,omitempty"`

			// Description The name of installment.
			Description *string `json:"description,omitempty"`

			// Id The ID of the installment
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInstallmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstallmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealsProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData Pagination related data
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Array containing data for all products attached to deals
		Data *[]struct {
			// AddTime The date and time when the product was added to the deal
			AddTime *string `json:"add_time,omitempty"`

			// BillingFrequency Only available in Growth and above plans
			//
			// How often a customer is billed for access to a service or product
			//
			// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
			//
			// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
			BillingFrequency *GetDealsProducts200DataBillingFrequency `json:"billing_frequency,omitempty"`

			// BillingFrequencyCycles Only available in Growth and above plans
			//
			// The number of times the billing frequency repeats for a product in a deal
			//
			// When `billing_frequency` is set to `one-time`, this field must be `null`
			//
			// When `billing_frequency` is set to `weekly`, this field cannot be `null`
			//
			// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
			//
			// Must be a positive integer less or equal to 208
			BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

			// BillingStartDate Only available in Growth and above plans
			//
			// The billing start date. Must be between 10 years in the past and 10 years in the future
			BillingStartDate *string `json:"billing_start_date"`

			// Comments The comments of the product
			Comments *string `json:"comments,omitempty"`

			// Currency The currency associated with the deal product
			Currency *string `json:"currency,omitempty"`

			// DealId The ID of the deal
			DealId *int `json:"deal_id,omitempty"`

			// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
			Discount *float32 `json:"discount,omitempty"`

			// DiscountType The type of the discount's value
			DiscountType *GetDealsProducts200DataDiscountType `json:"discount_type,omitempty"`

			// Id The ID of the deal-product (the ID of the product attached to the deal)
			Id *int `json:"id,omitempty"`

			// IsEnabled Whether this product is enabled for the deal
			IsEnabled *bool `json:"is_enabled,omitempty"`

			// ItemPrice The price value of the product
			ItemPrice *float32 `json:"item_price,omitempty"`

			// Name The product name
			Name *string `json:"name,omitempty"`

			// OrderNr The order number of the product within the deal
			OrderNr *int `json:"order_nr"`

			// ProductId The ID of the product
			ProductId *int `json:"product_id,omitempty"`

			// ProductVariationId The ID of the product variation
			ProductVariationId *int `json:"product_variation_id"`

			// Quantity The quantity of the product
			Quantity *int `json:"quantity,omitempty"`

			// Sum The sum of all the products attached to the deal
			Sum *float32 `json:"sum,omitempty"`

			// Tax The product tax
			Tax *float32 `json:"tax,omitempty"`

			// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
			TaxMethod *GetDealsProducts200DataTaxMethod `json:"tax_method,omitempty"`

			// UpdateTime The date and time when the deal product was last updated
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetDealsProducts200DataBillingFrequency string
type GetDealsProducts200DataDiscountType string
type GetDealsProducts200DataTaxMethod string

// Status returns HTTPResponse.Status
func (r GetDealsProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealsProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData Pagination related data
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *struct {
			// Items The array of deals
			Items *[]struct {
				Item *struct {
					// Currency The currency of the deal
					Currency *string `json:"currency,omitempty"`

					// CustomFields Custom fields
					CustomFields *[]string `json:"custom_fields,omitempty"`

					// Id The ID of the deal
					Id *int `json:"id,omitempty"`

					// IsArchived A flag indicating whether the deal is archived or not
					IsArchived *bool `json:"is_archived,omitempty"`

					// Notes An array of notes
					Notes        *[]string `json:"notes,omitempty"`
					Organization *struct {
						// Id The ID of the organization the deal is associated with
						Id *int `json:"id,omitempty"`

						// Name The name of the organization the deal is associated with
						Name *string `json:"name,omitempty"`
					} `json:"organization"`
					Owner *struct {
						// Id The ID of the owner of the deal
						Id *int `json:"id,omitempty"`
					} `json:"owner,omitempty"`
					Person *struct {
						// Id The ID of the person the deal is associated with
						Id *int `json:"id,omitempty"`

						// Name The name of the person the deal is associated with
						Name *string `json:"name,omitempty"`
					} `json:"person"`
					Stage *struct {
						// Id The ID of the stage of the deal
						Id *int `json:"id,omitempty"`

						// Name The name of the stage of the deal
						Name *string `json:"name,omitempty"`
					} `json:"stage,omitempty"`

					// Status The status of the deal
					Status *string `json:"status,omitempty"`

					// Title The title of the deal
					Title *string `json:"title,omitempty"`

					// Type The type of the item
					Type *string `json:"type,omitempty"`

					// Value The value of the deal
					Value *int `json:"value,omitempty"`

					// VisibleTo The visibility of the deal
					VisibleTo *int `json:"visible_to,omitempty"`
				} `json:"item,omitempty"`

				// ResultScore Search result relevancy
				ResultScore *float32 `json:"result_score,omitempty"`
			} `json:"items,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchDealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDealResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id Deleted deal ID
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDealResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDealResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The deal object
		Data *struct {
			// Acv Only available in Growth and above plans
			//
			// The Annual Contract Value of the deal
			//
			// Null if there are no products attached to the deal
			Acv *float32 `json:"acv"`

			// AddTime The creation date and time of the deal
			AddTime *string `json:"add_time,omitempty"`

			// Arr Only available in Growth and above plans
			//
			// The Annual Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Arr *float32 `json:"arr"`

			// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CloseTime The date and time of closing the deal
			CloseTime *string `json:"close_time"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// IsArchived Whether the deal is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// IsDeleted Whether the deal is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LabelIds The IDs of labels assigned to the deal
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status as lost
			LostTime *string `json:"lost_time,omitempty"`

			// Mrr Only available in Growth and above plans
			//
			// The Monthly Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Mrr *float32 `json:"mrr"`

			// OrgId The ID of the organization linked to the deal
			OrgId *int `json:"org_id,omitempty"`

			// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
			OriginId *string `json:"origin_id"`

			// OwnerId The ID of the user who owns the deal
			OwnerId *int `json:"owner_id,omitempty"`

			// PersonId The ID of the person linked to the deal
			PersonId *int `json:"person_id,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// StageChangeTime The last updated date and time of the deal stage
			StageChangeTime *string `json:"stage_change_time,omitempty"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UpdateTime The last updated date and time of the deal
			UpdateTime *string `json:"update_time,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *int `json:"visible_to,omitempty"`

			// WonTime The date and time of changing the deal status as won
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDealResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The deal object
		Data *struct {
			// Acv Only available in Growth and above plans
			//
			// The Annual Contract Value of the deal
			//
			// Null if there are no products attached to the deal
			Acv *float32 `json:"acv"`

			// AddTime The creation date and time of the deal
			AddTime *string `json:"add_time,omitempty"`

			// Arr Only available in Growth and above plans
			//
			// The Annual Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Arr *float32 `json:"arr"`

			// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
			Channel *int `json:"channel"`

			// ChannelId The optional ID to further distinguish the Marketing channel.
			ChannelId *string `json:"channel_id"`

			// CloseTime The date and time of closing the deal
			CloseTime *string `json:"close_time"`

			// Currency The currency associated with the deal
			Currency *string `json:"currency,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// ExpectedCloseDate The expected close date of the deal
			ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

			// Id The ID of the deal
			Id *int `json:"id,omitempty"`

			// IsArchived Whether the deal is archived or not
			IsArchived *bool `json:"is_archived,omitempty"`

			// IsDeleted Whether the deal is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LabelIds The IDs of labels assigned to the deal
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LostReason The reason for losing the deal
			LostReason *string `json:"lost_reason"`

			// LostTime The date and time of changing the deal status as lost
			LostTime *string `json:"lost_time,omitempty"`

			// Mrr Only available in Growth and above plans
			//
			// The Monthly Recurring Revenue of the deal
			//
			// Null if there are no products attached to the deal
			Mrr *float32 `json:"mrr"`

			// OrgId The ID of the organization linked to the deal
			OrgId *int `json:"org_id,omitempty"`

			// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
			Origin *string `json:"origin,omitempty"`

			// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
			OriginId *string `json:"origin_id"`

			// OwnerId The ID of the user who owns the deal
			OwnerId *int `json:"owner_id,omitempty"`

			// PersonId The ID of the person linked to the deal
			PersonId *int `json:"person_id,omitempty"`

			// PipelineId The ID of the pipeline associated with the deal
			PipelineId *int `json:"pipeline_id,omitempty"`

			// Probability The success probability percentage of the deal
			Probability *float32 `json:"probability"`

			// StageChangeTime The last updated date and time of the deal stage
			StageChangeTime *string `json:"stage_change_time,omitempty"`

			// StageId The ID of the deal stage
			StageId *int `json:"stage_id,omitempty"`

			// Status The status of the deal
			Status *string `json:"status,omitempty"`

			// Title The title of the deal
			Title *string `json:"title,omitempty"`

			// UpdateTime The last updated date and time of the deal
			UpdateTime *string `json:"update_time,omitempty"`

			// Value The value of the deal
			Value *float32 `json:"value,omitempty"`

			// VisibleTo The visibility of the deal
			VisibleTo *int `json:"visible_to,omitempty"`

			// WonTime The date and time of changing the deal status as won
			WonTime *string `json:"won_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateDealResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDealResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertDealToLeadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`

		// Data An object containing conversion job id that performs the conversion
		Data *struct {
			// ConversionId The ID of the conversion job that can be used to retrieve conversion status and details. The ID has UUID format.
			ConversionId openapi_types.UUID `json:"conversion_id"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ConvertDealToLeadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertDealToLeadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealConversionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`

		// Data An object containing conversion status. After successful conversion the converted entity ID is also present.
		Data struct {
			// ConversionId The ID of the conversion job. The ID can be used to retrieve conversion status and details. The ID has UUID format.
			ConversionId openapi_types.UUID `json:"conversion_id"`

			// DealId The ID of the new deal.
			DealId *int `json:"deal_id,omitempty"`

			// LeadId The ID of the new lead.
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// Status Status of the conversion job.
			Status GetDealConversionStatus200DataStatus `json:"status"`
		} `json:"data"`
		Success bool `json:"success"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}
type GetDealConversionStatus200DataStatus string

// Status returns HTTPResponse.Status
func (r GetDealConversionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealConversionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAdditionalDiscountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Array containing data for all discounts added to a deal
		Data *[]struct {
			// Amount The discount amount.
			Amount *float32 `json:"amount,omitempty"`

			// CreatedAt The date and time of when the discount was created in the ISO 8601 format.
			CreatedAt *string `json:"created_at,omitempty"`

			// CreatedBy The ID of the user that created the discount.
			CreatedBy *int `json:"created_by,omitempty"`

			// DealId The ID of the deal the discount was added to.
			DealId *int `json:"deal_id,omitempty"`

			// Description The name of the discount.
			Description *string `json:"description,omitempty"`

			// Id The ID of the additional discount
			Id *string `json:"id,omitempty"`

			// Type Determines whether the discount is applied as a percentage or a fixed amount.
			Type *GetAdditionalDiscounts200DataType `json:"type,omitempty"`

			// UpdatedAt The date and time of when the discount was created in the ISO 8601 format.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// UpdatedBy The ID of the user that last updated the discount.
			UpdatedBy *int `json:"updated_by,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetAdditionalDiscounts200DataType string

// Status returns HTTPResponse.Status
func (r GetAdditionalDiscountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAdditionalDiscountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAdditionalDiscountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// Amount The discount amount.
			Amount *float32 `json:"amount,omitempty"`

			// CreatedAt The date and time of when the discount was created in the ISO 8601 format.
			CreatedAt *string `json:"created_at,omitempty"`

			// CreatedBy The ID of the user that created the discount.
			CreatedBy *int `json:"created_by,omitempty"`

			// DealId The ID of the deal the discount was added to.
			DealId *int `json:"deal_id,omitempty"`

			// Description The name of the discount.
			Description *string `json:"description,omitempty"`

			// Id The ID of the additional discount
			Id *string `json:"id,omitempty"`

			// Type Determines whether the discount is applied as a percentage or a fixed amount.
			Type *PostAdditionalDiscount201DataType `json:"type,omitempty"`

			// UpdatedAt The date and time of when the discount was created in the ISO 8601 format.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// UpdatedBy The ID of the user that last updated the discount.
			UpdatedBy *int `json:"updated_by,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type PostAdditionalDiscount201DataType string

// Status returns HTTPResponse.Status
func (r PostAdditionalDiscountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAdditionalDiscountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAdditionalDiscountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of the discount that was deleted from the deal
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAdditionalDiscountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAdditionalDiscountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAdditionalDiscountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Amount The discount amount.
			Amount *float32 `json:"amount,omitempty"`

			// CreatedAt The date and time of when the discount was created in the ISO 8601 format.
			CreatedAt *string `json:"created_at,omitempty"`

			// CreatedBy The ID of the user that created the discount.
			CreatedBy *int `json:"created_by,omitempty"`

			// DealId The ID of the deal the discount was added to.
			DealId *int `json:"deal_id,omitempty"`

			// Description The name of the discount.
			Description *string `json:"description,omitempty"`

			// Id The ID of the additional discount
			Id *string `json:"id,omitempty"`

			// Type Determines whether the discount is applied as a percentage or a fixed amount.
			Type *UpdateAdditionalDiscount200DataType `json:"type,omitempty"`

			// UpdatedAt The date and time of when the discount was created in the ISO 8601 format.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// UpdatedBy The ID of the user that last updated the discount.
			UpdatedBy *int `json:"updated_by,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type UpdateAdditionalDiscount200DataType string

// Status returns HTTPResponse.Status
func (r UpdateAdditionalDiscountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAdditionalDiscountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealFollowersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Followers array
		Data *[]struct {
			// AddTime The add time of the following
			AddTime *string `json:"add_time,omitempty"`

			// UserId The ID of the user following the entity
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealFollowersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealFollowersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDealFollowerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data The follower object
		Data *struct {
			// AddTime The add time of the following
			AddTime *string `json:"add_time,omitempty"`

			// UserId The ID of the user following the entity
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddDealFollowerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDealFollowerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealFollowersChangelogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Follower changelogs array
		Data *[]struct {
			// Action The type of change
			Action *string `json:"action,omitempty"`

			// ActorUserId The ID of the user who did the change
			ActorUserId *int `json:"actor_user_id,omitempty"`

			// FollowerUserId The ID of the user who was following the entity
			FollowerUserId *int `json:"follower_user_id,omitempty"`

			// Time The time at which the change happened
			Time *string `json:"time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDealFollowersChangelogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealFollowersChangelogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDealFollowerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UserId Deleted follower user ID
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDealFollowerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDealFollowerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInstallmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Amount The installment amount.
			Amount *float32 `json:"amount,omitempty"`

			// BillingDate The date which the installment will be charged.
			BillingDate *string `json:"billing_date,omitempty"`

			// DealId The ID of the deal the installment was added to.
			DealId *int `json:"deal_id,omitempty"`

			// Description The name of installment.
			Description *string `json:"description,omitempty"`

			// Id The ID of the installment
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostInstallmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInstallmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInstallmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of the installment that was deleted from the deal
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteInstallmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInstallmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInstallmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Amount The installment amount.
			Amount *float32 `json:"amount,omitempty"`

			// BillingDate The date which the installment will be charged.
			BillingDate *string `json:"billing_date,omitempty"`

			// DealId The ID of the deal the installment was added to.
			DealId *int `json:"deal_id,omitempty"`

			// Description The name of installment.
			Description *string `json:"description,omitempty"`

			// Id The ID of the installment
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateInstallmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInstallmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyDealProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// MoreItemsInCollection Whether there are more products to delete (when the deal has more than 100 products)
			MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`
		} `json:"additional_data"`
		Data *struct {
			// Ids Array of IDs of products that were deleted from the deal
			Ids *[]int `json:"ids,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteManyDealProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyDealProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData Pagination related data
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Array containing data for all products attached to deals
		Data *[]struct {
			// AddTime The date and time when the product was added to the deal
			AddTime *string `json:"add_time,omitempty"`

			// BillingFrequency Only available in Growth and above plans
			//
			// How often a customer is billed for access to a service or product
			//
			// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
			//
			// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
			BillingFrequency *GetDealProducts200DataBillingFrequency `json:"billing_frequency,omitempty"`

			// BillingFrequencyCycles Only available in Growth and above plans
			//
			// The number of times the billing frequency repeats for a product in a deal
			//
			// When `billing_frequency` is set to `one-time`, this field must be `null`
			//
			// When `billing_frequency` is set to `weekly`, this field cannot be `null`
			//
			// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
			//
			// Must be a positive integer less or equal to 208
			BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

			// BillingStartDate Only available in Growth and above plans
			//
			// The billing start date. Must be between 10 years in the past and 10 years in the future
			BillingStartDate *string `json:"billing_start_date"`

			// Comments The comments of the product
			Comments *string `json:"comments,omitempty"`

			// Currency The currency associated with the deal product
			Currency *string `json:"currency,omitempty"`

			// DealId The ID of the deal
			DealId *int `json:"deal_id,omitempty"`

			// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
			Discount *float32 `json:"discount,omitempty"`

			// DiscountType The type of the discount's value
			DiscountType *GetDealProducts200DataDiscountType `json:"discount_type,omitempty"`

			// Id The ID of the deal-product (the ID of the product attached to the deal)
			Id *int `json:"id,omitempty"`

			// IsEnabled Whether this product is enabled for the deal
			IsEnabled *bool `json:"is_enabled,omitempty"`

			// ItemPrice The price value of the product
			ItemPrice *float32 `json:"item_price,omitempty"`

			// Name The product name
			Name *string `json:"name,omitempty"`

			// OrderNr The order number of the product within the deal
			OrderNr *int `json:"order_nr"`

			// ProductId The ID of the product
			ProductId *int `json:"product_id,omitempty"`

			// ProductVariationId The ID of the product variation
			ProductVariationId *int `json:"product_variation_id"`

			// Quantity The quantity of the product
			Quantity *int `json:"quantity,omitempty"`

			// Sum The sum of all the products attached to the deal
			Sum *float32 `json:"sum,omitempty"`

			// Tax The product tax
			Tax *float32 `json:"tax,omitempty"`

			// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
			TaxMethod *GetDealProducts200DataTaxMethod `json:"tax_method,omitempty"`

			// UpdateTime The date and time when the deal product was last updated
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetDealProducts200DataBillingFrequency string
type GetDealProducts200DataDiscountType string
type GetDealProducts200DataTaxMethod string

// Status returns HTTPResponse.Status
func (r GetDealProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDealProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// AddTime The date and time when the product was added to the deal
			AddTime *string `json:"add_time,omitempty"`

			// BillingFrequency Only available in Growth and above plans
			//
			// How often a customer is billed for access to a service or product
			//
			// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
			//
			// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
			BillingFrequency *AddDealProduct201DataBillingFrequency `json:"billing_frequency,omitempty"`

			// BillingFrequencyCycles Only available in Growth and above plans
			//
			// The number of times the billing frequency repeats for a product in a deal
			//
			// When `billing_frequency` is set to `one-time`, this field must be `null`
			//
			// When `billing_frequency` is set to `weekly`, this field cannot be `null`
			//
			// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
			//
			// Must be a positive integer less or equal to 208
			BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

			// BillingStartDate Only available in Growth and above plans
			//
			// The billing start date. Must be between 10 years in the past and 10 years in the future
			BillingStartDate *string `json:"billing_start_date"`

			// Comments The comments of the product
			Comments *string `json:"comments,omitempty"`

			// Currency The currency associated with the deal product
			Currency *string `json:"currency,omitempty"`

			// DealId The ID of the deal
			DealId *int `json:"deal_id,omitempty"`

			// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
			Discount *float32 `json:"discount,omitempty"`

			// DiscountType The type of the discount's value
			DiscountType *AddDealProduct201DataDiscountType `json:"discount_type,omitempty"`

			// Id The ID of the deal-product (the ID of the product attached to the deal)
			Id *int `json:"id,omitempty"`

			// IsEnabled Whether this product is enabled for the deal
			IsEnabled *bool `json:"is_enabled,omitempty"`

			// ItemPrice The price value of the product
			ItemPrice *float32 `json:"item_price,omitempty"`

			// Name The product name
			Name *string `json:"name,omitempty"`

			// OrderNr The order number of the product within the deal
			OrderNr *int `json:"order_nr"`

			// ProductId The ID of the product
			ProductId *int `json:"product_id,omitempty"`

			// ProductVariationId The ID of the product variation
			ProductVariationId *int `json:"product_variation_id"`

			// Quantity The quantity of the product
			Quantity *int `json:"quantity,omitempty"`

			// Sum The sum of all the products attached to the deal
			Sum *float32 `json:"sum,omitempty"`

			// Tax The product tax
			Tax *float32 `json:"tax,omitempty"`

			// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
			TaxMethod *AddDealProduct201DataTaxMethod `json:"tax_method,omitempty"`

			// UpdateTime The date and time when the deal product was last updated
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type AddDealProduct201DataBillingFrequency string
type AddDealProduct201DataDiscountType string
type AddDealProduct201DataTaxMethod string

// Status returns HTTPResponse.Status
func (r AddDealProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDealProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddManyDealProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Array of created deal products
		Data *[]struct {
			// AddTime The date and time when the product was added to the deal
			AddTime *string `json:"add_time,omitempty"`

			// BillingFrequency Only available in Growth and above plans
			//
			// How often a customer is billed for access to a service or product
			//
			// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
			//
			// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
			BillingFrequency *AddManyDealProducts201DataBillingFrequency `json:"billing_frequency,omitempty"`

			// BillingFrequencyCycles Only available in Growth and above plans
			//
			// The number of times the billing frequency repeats for a product in a deal
			//
			// When `billing_frequency` is set to `one-time`, this field must be `null`
			//
			// When `billing_frequency` is set to `weekly`, this field cannot be `null`
			//
			// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
			//
			// Must be a positive integer less or equal to 208
			BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

			// BillingStartDate Only available in Growth and above plans
			//
			// The billing start date. Must be between 10 years in the past and 10 years in the future
			BillingStartDate *string `json:"billing_start_date"`

			// Comments The comments of the product
			Comments *string `json:"comments,omitempty"`

			// Currency The currency associated with the deal product
			Currency *string `json:"currency,omitempty"`

			// DealId The ID of the deal
			DealId *int `json:"deal_id,omitempty"`

			// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
			Discount *float32 `json:"discount,omitempty"`

			// DiscountType The type of the discount's value
			DiscountType *AddManyDealProducts201DataDiscountType `json:"discount_type,omitempty"`

			// Id The ID of the deal-product (the ID of the product attached to the deal)
			Id *int `json:"id,omitempty"`

			// IsEnabled Whether this product is enabled for the deal
			IsEnabled *bool `json:"is_enabled,omitempty"`

			// ItemPrice The price value of the product
			ItemPrice *float32 `json:"item_price,omitempty"`

			// Name The product name
			Name *string `json:"name,omitempty"`

			// OrderNr The order number of the product within the deal
			OrderNr *int `json:"order_nr"`

			// ProductId The ID of the product
			ProductId *int `json:"product_id,omitempty"`

			// ProductVariationId The ID of the product variation
			ProductVariationId *int `json:"product_variation_id"`

			// Quantity The quantity of the product
			Quantity *int `json:"quantity,omitempty"`

			// Sum The sum of all the products attached to the deal
			Sum *float32 `json:"sum,omitempty"`

			// Tax The product tax
			Tax *float32 `json:"tax,omitempty"`

			// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
			TaxMethod *AddManyDealProducts201DataTaxMethod `json:"tax_method,omitempty"`

			// UpdateTime The date and time when the deal product was last updated
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type AddManyDealProducts201DataBillingFrequency string
type AddManyDealProducts201DataDiscountType string
type AddManyDealProducts201DataTaxMethod string

// Status returns HTTPResponse.Status
func (r AddManyDealProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddManyDealProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDealProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of an attached product that was deleted from the deal
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDealProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDealProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDealProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// AddTime The date and time when the product was added to the deal
			AddTime *string `json:"add_time,omitempty"`

			// BillingFrequency Only available in Growth and above plans
			//
			// How often a customer is billed for access to a service or product
			//
			// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
			//
			// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
			BillingFrequency *UpdateDealProduct200DataBillingFrequency `json:"billing_frequency,omitempty"`

			// BillingFrequencyCycles Only available in Growth and above plans
			//
			// The number of times the billing frequency repeats for a product in a deal
			//
			// When `billing_frequency` is set to `one-time`, this field must be `null`
			//
			// When `billing_frequency` is set to `weekly`, this field cannot be `null`
			//
			// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
			//
			// Must be a positive integer less or equal to 208
			BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

			// BillingStartDate Only available in Growth and above plans
			//
			// The billing start date. Must be between 10 years in the past and 10 years in the future
			BillingStartDate *string `json:"billing_start_date"`

			// Comments The comments of the product
			Comments *string `json:"comments,omitempty"`

			// Currency The currency associated with the deal product
			Currency *string `json:"currency,omitempty"`

			// DealId The ID of the deal
			DealId *int `json:"deal_id,omitempty"`

			// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
			Discount *float32 `json:"discount,omitempty"`

			// DiscountType The type of the discount's value
			DiscountType *UpdateDealProduct200DataDiscountType `json:"discount_type,omitempty"`

			// Id The ID of the deal-product (the ID of the product attached to the deal)
			Id *int `json:"id,omitempty"`

			// IsEnabled Whether this product is enabled for the deal
			IsEnabled *bool `json:"is_enabled,omitempty"`

			// ItemPrice The price value of the product
			ItemPrice *float32 `json:"item_price,omitempty"`

			// Name The product name
			Name *string `json:"name,omitempty"`

			// OrderNr The order number of the product within the deal
			OrderNr *int `json:"order_nr"`

			// ProductId The ID of the product
			ProductId *int `json:"product_id,omitempty"`

			// ProductVariationId The ID of the product variation
			ProductVariationId *int `json:"product_variation_id"`

			// Quantity The quantity of the product
			Quantity *int `json:"quantity,omitempty"`

			// Sum The sum of all the products attached to the deal
			Sum *float32 `json:"sum,omitempty"`

			// Tax The product tax
			Tax *float32 `json:"tax,omitempty"`

			// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
			TaxMethod *UpdateDealProduct200DataTaxMethod `json:"tax_method,omitempty"`

			// UpdateTime The date and time when the deal product was last updated
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type UpdateDealProduct200DataBillingFrequency string
type UpdateDealProduct200DataDiscountType string
type UpdateDealProduct200DataTaxMethod string

// Status returns HTTPResponse.Status
func (r UpdateDealProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDealProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData Pagination related data
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *struct {
			// Items The array of found items
			Items *[]struct {
				// Item Item
				Item *map[string]interface{} `json:"item,omitempty"`

				// ResultScore Search result relevancy
				ResultScore *float32 `json:"result_score,omitempty"`
			} `json:"items,omitempty"`

			// RelatedItems The array of related items if `search_for_related_items` was enabled
			RelatedItems *[]struct {
				// Item Item
				Item *map[string]interface{} `json:"item,omitempty"`

				// ResultScore Search result relevancy
				ResultScore *float32 `json:"result_score,omitempty"`
			} `json:"related_items,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchItemByFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData Pagination related data
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of found fields
		Data *[]struct {
			// Item Item
			Item *map[string]interface{} `json:"item,omitempty"`

			// ResultScore Search result relevancy
			ResultScore *float32 `json:"result_score,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchItemByFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchItemByFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchLeadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData Pagination related data
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *struct {
			// Items The array of leads
			Items *[]struct {
				Item *struct {
					// Currency The currency of the lead
					Currency *string `json:"currency,omitempty"`

					// CustomFields Custom fields
					CustomFields *[]string `json:"custom_fields,omitempty"`
					Emails       *[]string `json:"emails,omitempty"`

					// Id The ID of the lead
					Id *string `json:"id,omitempty"`

					// IsArchived A flag indicating whether the lead is archived or not
					IsArchived *bool `json:"is_archived,omitempty"`

					// Notes An array of notes
					Notes        *[]string `json:"notes,omitempty"`
					Organization *struct {
						// Id The ID of the organization the lead is associated with
						Id *int `json:"id,omitempty"`

						// Name The name of the organization the lead is associated with
						Name *string `json:"name,omitempty"`
					} `json:"organization,omitempty"`
					Owner *struct {
						// Id The ID of the owner of the lead
						Id *int `json:"id,omitempty"`
					} `json:"owner,omitempty"`
					Person *struct {
						// Id The ID of the person the lead is associated with
						Id *int `json:"id,omitempty"`

						// Name The name of the person the lead is associated with
						Name *string `json:"name,omitempty"`
					} `json:"person,omitempty"`
					Phones *[]string `json:"phones,omitempty"`

					// Title The title of the lead
					Title *string `json:"title,omitempty"`

					// Type The type of the item
					Type *string `json:"type,omitempty"`

					// Value The value of the lead
					Value *int `json:"value,omitempty"`

					// VisibleTo The visibility of the lead
					VisibleTo *int `json:"visible_to,omitempty"`
				} `json:"item,omitempty"`

				// ResultScore Search result relevancy
				ResultScore *float32 `json:"result_score,omitempty"`
			} `json:"items,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchLeadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchLeadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertLeadToDealResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`

		// Data An object containing conversion job id that performs the conversion
		Data *struct {
			// ConversionId The ID of the conversion job that can be used to retrieve conversion status and details. The ID has UUID format.
			ConversionId openapi_types.UUID `json:"conversion_id"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ConvertLeadToDealResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertLeadToDealResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeadConversionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`

		// Data An object containing conversion status. After successful conversion the converted entity ID is also present.
		Data struct {
			// ConversionId The ID of the conversion job. The ID can be used to retrieve conversion status and details. The ID has UUID format.
			ConversionId openapi_types.UUID `json:"conversion_id"`

			// DealId The ID of the new deal.
			DealId *int `json:"deal_id,omitempty"`

			// LeadId The ID of the new lead.
			LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

			// Status Status of the conversion job.
			Status GetLeadConversionStatus200DataStatus `json:"status"`
		} `json:"data"`
		Success bool `json:"success"`
	}
	JSON404 *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *map[string]interface{} `json:"data"`

		// Error The description of the error
		Error *string `json:"error,omitempty"`

		// ErrorInfo A message describing how to solve the problem
		ErrorInfo *string `json:"error_info,omitempty"`
		Success   *bool   `json:"success,omitempty"`
	}
}
type GetLeadConversionStatus200DataStatus string

// Status returns HTTPResponse.Status
func (r GetLeadConversionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeadConversionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// NextCursor Base64url-encoded cursor for fetching the next page of results, null if no more pages
			NextCursor *string `json:"next_cursor"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType GetOrganizationFields200DataFieldType `json:"field_type"`

			// ImportantFields Important fields configuration
			ImportantFields *struct {
				// Enabled Whether the field is marked as important
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of deal stage IDs where the field is important
				StageIds *[]int `json:"stage_ids,omitempty"`
			} `json:"important_fields,omitempty"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// RequiredFields Required fields configuration
			RequiredFields *struct {
				// Enabled Whether the field is required
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"required_fields,omitempty"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
				ShowInAddDealDialog *struct {
					// Order Display order in the add deal dialog (null if not shown)
					Order *int `json:"order"`

					// Show Whether the field is shown in the add deal dialog
					Show *bool `json:"show,omitempty"`
				} `json:"show_in_add_deal_dialog,omitempty"`

				// ShowInAddPersonDialog Configuration for showing the field in the add person dialog
				ShowInAddPersonDialog *struct {
					// Order Display order in the add person dialog (null if not shown)
					Order *int `json:"order"`

					// Show Whether the field is shown in the add person dialog
					Show *bool `json:"show,omitempty"`
				} `json:"show_in_add_person_dialog,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type GetOrganizationFields200DataFieldType string

// Status returns HTTPResponse.Status
func (r GetOrganizationFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType AddOrganizationField200DataFieldType `json:"field_type"`

			// ImportantFields Important fields configuration
			ImportantFields *struct {
				// Enabled Whether the field is marked as important
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of deal stage IDs where the field is important
				StageIds *[]int `json:"stage_ids,omitempty"`
			} `json:"important_fields,omitempty"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// RequiredFields Required fields configuration
			RequiredFields *struct {
				// Enabled Whether the field is required
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"required_fields,omitempty"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
				ShowInAddDealDialog *struct {
					// Order Display order in the add deal dialog (null if not shown)
					Order *int `json:"order"`

					// Show Whether the field is shown in the add deal dialog
					Show *bool `json:"show,omitempty"`
				} `json:"show_in_add_deal_dialog,omitempty"`

				// ShowInAddPersonDialog Configuration for showing the field in the add person dialog
				ShowInAddPersonDialog *struct {
					// Order Display order in the add person dialog (null if not shown)
					Order *int `json:"order"`

					// Show Whether the field is shown in the add person dialog
					Show *bool `json:"show,omitempty"`
				} `json:"show_in_add_person_dialog,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type AddOrganizationField200DataFieldType string

// Status returns HTTPResponse.Status
func (r AddOrganizationFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType string `json:"field_type"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]map[string]interface{} `json:"options"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]map[string]interface{} `json:"subfields"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType GetOrganizationField200DataFieldType `json:"field_type"`

			// ImportantFields Important fields configuration
			ImportantFields *struct {
				// Enabled Whether the field is marked as important
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of deal stage IDs where the field is important
				StageIds *[]int `json:"stage_ids,omitempty"`
			} `json:"important_fields,omitempty"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// RequiredFields Required fields configuration
			RequiredFields *struct {
				// Enabled Whether the field is required
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"required_fields,omitempty"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
				ShowInAddDealDialog *struct {
					// Order Display order in the add deal dialog (null if not shown)
					Order *int `json:"order"`

					// Show Whether the field is shown in the add deal dialog
					Show *bool `json:"show,omitempty"`
				} `json:"show_in_add_deal_dialog,omitempty"`

				// ShowInAddPersonDialog Configuration for showing the field in the add person dialog
				ShowInAddPersonDialog *struct {
					// Order Display order in the add person dialog (null if not shown)
					Order *int `json:"order"`

					// Show Whether the field is shown in the add person dialog
					Show *bool `json:"show,omitempty"`
				} `json:"show_in_add_person_dialog,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type GetOrganizationField200DataFieldType string

// Status returns HTTPResponse.Status
func (r GetOrganizationFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrganizationFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType UpdateOrganizationField200DataFieldType `json:"field_type"`

			// ImportantFields Important fields configuration
			ImportantFields *struct {
				// Enabled Whether the field is marked as important
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of deal stage IDs where the field is important
				StageIds *[]int `json:"stage_ids,omitempty"`
			} `json:"important_fields,omitempty"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// RequiredFields Required fields configuration
			RequiredFields *struct {
				// Enabled Whether the field is required
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"required_fields,omitempty"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
				ShowInAddDealDialog *struct {
					// Order Display order in the add deal dialog (null if not shown)
					Order *int `json:"order"`

					// Show Whether the field is shown in the add deal dialog
					Show *bool `json:"show,omitempty"`
				} `json:"show_in_add_deal_dialog,omitempty"`

				// ShowInAddPersonDialog Configuration for showing the field in the add person dialog
				ShowInAddPersonDialog *struct {
					// Order Display order in the add person dialog (null if not shown)
					Order *int `json:"order"`

					// Show Whether the field is shown in the add person dialog
					Show *bool `json:"show,omitempty"`
				} `json:"show_in_add_person_dialog,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type UpdateOrganizationField200DataFieldType string

// Status returns HTTPResponse.Status
func (r UpdateOrganizationFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrganizationFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationFieldOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id The unique identifier of the option
			Id int `json:"id"`

			// Label The display label of the option
			Label string `json:"label"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationFieldOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationFieldOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrganizationFieldOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id The unique identifier of the option
			Id int `json:"id"`

			// Label The display label of the option
			Label string `json:"label"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateOrganizationFieldOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrganizationFieldOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationFieldOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id The unique identifier of the option
			Id int `json:"id"`

			// Label The display label of the option
			Label string `json:"label"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddOrganizationFieldOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationFieldOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Organizations array
		Data *[]struct {
			// AddTime The creation date and time of the organization
			AddTime *string `json:"add_time,omitempty"`

			// Address The address of the organization
			Address *struct {
				// AdminAreaLevel1 Admin area level 1 (e.g. state) of the organization
				AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

				// AdminAreaLevel2 Admin area level 2 (e.g. county) of the organization
				AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

				// Country Country of the organization
				Country *string `json:"country,omitempty"`

				// Locality Locality (e.g. city) of the organization
				Locality *string `json:"locality,omitempty"`

				// PostalCode Postal code of the organization
				PostalCode *string `json:"postal_code,omitempty"`

				// Route Route (e.g. street) of the organization
				Route *string `json:"route,omitempty"`

				// StreetNumber Street number of the organization
				StreetNumber *string `json:"street_number,omitempty"`

				// Sublocality Sublocality (e.g. neighborhood) of the organization
				Sublocality *string `json:"sublocality,omitempty"`

				// Subpremise Subpremise (e.g. apartment/suite number) of the organization
				Subpremise *string `json:"subpremise,omitempty"`

				// Value The full address of the organization
				Value *string `json:"value,omitempty"`
			} `json:"address,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// Id The ID of the organization
			Id *int `json:"id,omitempty"`

			// IsDeleted Whether the organization is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LabelIds The IDs of labels assigned to the organization
			LabelIds *[]int `json:"label_ids,omitempty"`

			// Name The name of the organization
			Name *string `json:"name,omitempty"`

			// OwnerId The ID of the user who owns the organization
			OwnerId *int `json:"owner_id,omitempty"`

			// UpdateTime The last updated date and time of the organization
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility of the organization
			VisibleTo *int `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The organization object
		Data *struct {
			// AddTime The creation date and time of the organization
			AddTime *string `json:"add_time,omitempty"`

			// Address The address of the organization
			Address *struct {
				// AdminAreaLevel1 Admin area level 1 (e.g. state) of the organization
				AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

				// AdminAreaLevel2 Admin area level 2 (e.g. county) of the organization
				AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

				// Country Country of the organization
				Country *string `json:"country,omitempty"`

				// Locality Locality (e.g. city) of the organization
				Locality *string `json:"locality,omitempty"`

				// PostalCode Postal code of the organization
				PostalCode *string `json:"postal_code,omitempty"`

				// Route Route (e.g. street) of the organization
				Route *string `json:"route,omitempty"`

				// StreetNumber Street number of the organization
				StreetNumber *string `json:"street_number,omitempty"`

				// Sublocality Sublocality (e.g. neighborhood) of the organization
				Sublocality *string `json:"sublocality,omitempty"`

				// Subpremise Subpremise (e.g. apartment/suite number) of the organization
				Subpremise *string `json:"subpremise,omitempty"`

				// Value The full address of the organization
				Value *string `json:"value,omitempty"`
			} `json:"address,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// Id The ID of the organization
			Id *int `json:"id,omitempty"`

			// IsDeleted Whether the organization is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LabelIds The IDs of labels assigned to the organization
			LabelIds *[]int `json:"label_ids,omitempty"`

			// Name The name of the organization
			Name *string `json:"name,omitempty"`

			// OwnerId The ID of the user who owns the organization
			OwnerId *int `json:"owner_id,omitempty"`

			// UpdateTime The last updated date and time of the organization
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility of the organization
			VisibleTo *int `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData Pagination related data
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *struct {
			// Items The array of found items
			Items *[]struct {
				Item *struct {
					// Address The address of the organization
					Address *string `json:"address,omitempty"`

					// CustomFields Custom fields
					CustomFields *[]string `json:"custom_fields,omitempty"`

					// Id The ID of the organization
					Id *int `json:"id,omitempty"`

					// Name The name of the organization
					Name *string `json:"name,omitempty"`

					// Notes An array of notes
					Notes *[]string `json:"notes,omitempty"`
					Owner *struct {
						// Id The ID of the owner of the deal
						Id *int `json:"id,omitempty"`
					} `json:"owner,omitempty"`

					// Type The type of the item
					Type *string `json:"type,omitempty"`

					// VisibleTo The visibility of the organization
					VisibleTo *int `json:"visible_to,omitempty"`
				} `json:"item,omitempty"`

				// ResultScore Search result relevancy
				ResultScore *float32 `json:"result_score,omitempty"`
			} `json:"items,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id Deleted organization ID
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The organization object
		Data *struct {
			// AddTime The creation date and time of the organization
			AddTime *string `json:"add_time,omitempty"`

			// Address The address of the organization
			Address *struct {
				// AdminAreaLevel1 Admin area level 1 (e.g. state) of the organization
				AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

				// AdminAreaLevel2 Admin area level 2 (e.g. county) of the organization
				AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

				// Country Country of the organization
				Country *string `json:"country,omitempty"`

				// Locality Locality (e.g. city) of the organization
				Locality *string `json:"locality,omitempty"`

				// PostalCode Postal code of the organization
				PostalCode *string `json:"postal_code,omitempty"`

				// Route Route (e.g. street) of the organization
				Route *string `json:"route,omitempty"`

				// StreetNumber Street number of the organization
				StreetNumber *string `json:"street_number,omitempty"`

				// Sublocality Sublocality (e.g. neighborhood) of the organization
				Sublocality *string `json:"sublocality,omitempty"`

				// Subpremise Subpremise (e.g. apartment/suite number) of the organization
				Subpremise *string `json:"subpremise,omitempty"`

				// Value The full address of the organization
				Value *string `json:"value,omitempty"`
			} `json:"address,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// Id The ID of the organization
			Id *int `json:"id,omitempty"`

			// IsDeleted Whether the organization is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LabelIds The IDs of labels assigned to the organization
			LabelIds *[]int `json:"label_ids,omitempty"`

			// Name The name of the organization
			Name *string `json:"name,omitempty"`

			// OwnerId The ID of the user who owns the organization
			OwnerId *int `json:"owner_id,omitempty"`

			// UpdateTime The last updated date and time of the organization
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility of the organization
			VisibleTo *int `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The organization object
		Data *struct {
			// AddTime The creation date and time of the organization
			AddTime *string `json:"add_time,omitempty"`

			// Address The address of the organization
			Address *struct {
				// AdminAreaLevel1 Admin area level 1 (e.g. state) of the organization
				AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

				// AdminAreaLevel2 Admin area level 2 (e.g. county) of the organization
				AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

				// Country Country of the organization
				Country *string `json:"country,omitempty"`

				// Locality Locality (e.g. city) of the organization
				Locality *string `json:"locality,omitempty"`

				// PostalCode Postal code of the organization
				PostalCode *string `json:"postal_code,omitempty"`

				// Route Route (e.g. street) of the organization
				Route *string `json:"route,omitempty"`

				// StreetNumber Street number of the organization
				StreetNumber *string `json:"street_number,omitempty"`

				// Sublocality Sublocality (e.g. neighborhood) of the organization
				Sublocality *string `json:"sublocality,omitempty"`

				// Subpremise Subpremise (e.g. apartment/suite number) of the organization
				Subpremise *string `json:"subpremise,omitempty"`

				// Value The full address of the organization
				Value *string `json:"value,omitempty"`
			} `json:"address,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// Id The ID of the organization
			Id *int `json:"id,omitempty"`

			// IsDeleted Whether the organization is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// LabelIds The IDs of labels assigned to the organization
			LabelIds *[]int `json:"label_ids,omitempty"`

			// Name The name of the organization
			Name *string `json:"name,omitempty"`

			// OwnerId The ID of the user who owns the organization
			OwnerId *int `json:"owner_id,omitempty"`

			// UpdateTime The last updated date and time of the organization
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility of the organization
			VisibleTo *int `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationFollowersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Followers array
		Data *[]struct {
			// AddTime The add time of the following
			AddTime *string `json:"add_time,omitempty"`

			// UserId The ID of the user following the entity
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationFollowersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationFollowersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationFollowerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data The follower object
		Data *struct {
			// AddTime The add time of the following
			AddTime *string `json:"add_time,omitempty"`

			// UserId The ID of the user following the entity
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddOrganizationFollowerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationFollowerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationFollowersChangelogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Follower changelogs array
		Data *[]struct {
			// Action The type of change
			Action *string `json:"action,omitempty"`

			// ActorUserId The ID of the user who did the change
			ActorUserId *int `json:"actor_user_id,omitempty"`

			// FollowerUserId The ID of the user who was following the entity
			FollowerUserId *int `json:"follower_user_id,omitempty"`

			// Time The time at which the change happened
			Time *string `json:"time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationFollowersChangelogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationFollowersChangelogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationFollowerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UserId Deleted follower user ID
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationFollowerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationFollowerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// NextCursor Base64url-encoded cursor for fetching the next page of results, null if no more pages
			NextCursor *string `json:"next_cursor"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType GetPersonFields200DataFieldType `json:"field_type"`

			// ImportantFields Important fields configuration
			ImportantFields *struct {
				// Enabled Whether the field is marked as important
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of deal stage IDs where the field is important
				StageIds *[]int `json:"stage_ids,omitempty"`
			} `json:"important_fields,omitempty"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// RequiredFields Required fields configuration
			RequiredFields *struct {
				// Enabled Whether the field is required
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"required_fields,omitempty"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
				ShowInAddDealDialog *struct {
					// Order Display order in the add deal dialog (null if not shown)
					Order *int `json:"order"`

					// Show Whether the field is shown in the add deal dialog
					Show *bool `json:"show,omitempty"`
				} `json:"show_in_add_deal_dialog,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type GetPersonFields200DataFieldType string

// Status returns HTTPResponse.Status
func (r GetPersonFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPersonFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType AddPersonField200DataFieldType `json:"field_type"`

			// ImportantFields Important fields configuration
			ImportantFields *struct {
				// Enabled Whether the field is marked as important
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of deal stage IDs where the field is important
				StageIds *[]int `json:"stage_ids,omitempty"`
			} `json:"important_fields,omitempty"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// RequiredFields Required fields configuration
			RequiredFields *struct {
				// Enabled Whether the field is required
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"required_fields,omitempty"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
				ShowInAddDealDialog *struct {
					// Order Display order in the add deal dialog (null if not shown)
					Order *int `json:"order"`

					// Show Whether the field is shown in the add deal dialog
					Show *bool `json:"show,omitempty"`
				} `json:"show_in_add_deal_dialog,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type AddPersonField200DataFieldType string

// Status returns HTTPResponse.Status
func (r AddPersonFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPersonFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersonFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType string `json:"field_type"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]map[string]interface{} `json:"options"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]map[string]interface{} `json:"subfields"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePersonFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersonFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType GetPersonField200DataFieldType `json:"field_type"`

			// ImportantFields Important fields configuration
			ImportantFields *struct {
				// Enabled Whether the field is marked as important
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of deal stage IDs where the field is important
				StageIds *[]int `json:"stage_ids,omitempty"`
			} `json:"important_fields,omitempty"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// RequiredFields Required fields configuration
			RequiredFields *struct {
				// Enabled Whether the field is required
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"required_fields,omitempty"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
				ShowInAddDealDialog *struct {
					// Order Display order in the add deal dialog (null if not shown)
					Order *int `json:"order"`

					// Show Whether the field is shown in the add deal dialog
					Show *bool `json:"show,omitempty"`
				} `json:"show_in_add_deal_dialog,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type GetPersonField200DataFieldType string

// Status returns HTTPResponse.Status
func (r GetPersonFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePersonFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType UpdatePersonField200DataFieldType `json:"field_type"`

			// ImportantFields Important fields configuration
			ImportantFields *struct {
				// Enabled Whether the field is marked as important
				Enabled *bool `json:"enabled,omitempty"`

				// StageIds Array of deal stage IDs where the field is important
				StageIds *[]int `json:"stage_ids,omitempty"`
			} `json:"important_fields,omitempty"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// RequiredFields Required fields configuration
			RequiredFields *struct {
				// Enabled Whether the field is required
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"required_fields,omitempty"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

				// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
				ShowInAddDealDialog *struct {
					// Order Display order in the add deal dialog (null if not shown)
					Order *int `json:"order"`

					// Show Whether the field is shown in the add deal dialog
					Show *bool `json:"show,omitempty"`
				} `json:"show_in_add_deal_dialog,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type UpdatePersonField200DataFieldType string

// Status returns HTTPResponse.Status
func (r UpdatePersonFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePersonFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersonFieldOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id The unique identifier of the option
			Id int `json:"id"`

			// Label The display label of the option
			Label string `json:"label"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePersonFieldOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersonFieldOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePersonFieldOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id The unique identifier of the option
			Id int `json:"id"`

			// Label The display label of the option
			Label string `json:"label"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePersonFieldOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePersonFieldOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPersonFieldOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id The unique identifier of the option
			Id int `json:"id"`

			// Label The display label of the option
			Label string `json:"label"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddPersonFieldOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPersonFieldOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Persons array
		Data *[]struct {
			// AddTime The creation date and time of the person
			AddTime *string `json:"add_time,omitempty"`

			// Birthday The birthday of the person, included if contact sync is enabled for the company
			Birthday *string `json:"birthday,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// Emails The emails of the person
			Emails *[]struct {
				// Label The email address classification label
				Label *string `json:"label,omitempty"`

				// Primary Whether the email is primary or not
				Primary *bool `json:"primary,omitempty"`

				// Value The email address of the person
				Value *string `json:"value,omitempty"`
			} `json:"emails,omitempty"`

			// FirstName The first name of the person
			FirstName *string `json:"first_name,omitempty"`

			// Id The ID of the person
			Id *int `json:"id,omitempty"`

			// Im The instant messaging accounts of the person, included if contact sync is enabled for the company
			Im *[]struct {
				// Label The instant messaging account classification label
				Label *string `json:"label,omitempty"`

				// Primary Whether the instant messaging account is primary or not
				Primary *bool `json:"primary,omitempty"`

				// Value The instant messaging account of the person
				Value *string `json:"value,omitempty"`
			} `json:"im,omitempty"`

			// IsDeleted Whether the person is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// JobTitle The job title of the person, included if contact sync is enabled for the company
			JobTitle *string `json:"job_title,omitempty"`

			// LabelIds The IDs of labels assigned to the person
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LastName The last name of the person
			LastName *string `json:"last_name,omitempty"`

			// Name The name of the person
			Name *string `json:"name,omitempty"`

			// Notes Contact sync notes of the person, maximum 10 000 characters, included if contact sync is enabled for the company
			Notes *string `json:"notes,omitempty"`

			// OrgId The ID of the organization linked to the person
			OrgId *int `json:"org_id,omitempty"`

			// OwnerId The ID of the user who owns the person
			OwnerId *int `json:"owner_id,omitempty"`

			// Phones The phones of the person
			Phones *[]struct {
				// Label The phone number classification label
				Label *string `json:"label,omitempty"`

				// Primary Whether the phone number is primary or not
				Primary *bool `json:"primary,omitempty"`

				// Value The phone number of the person
				Value *string `json:"value,omitempty"`
			} `json:"phones,omitempty"`

			// PictureId The ID of the picture associated with the person
			PictureId *int `json:"picture_id,omitempty"`

			// PostalAddress Postal address of the person, included if contact sync is enabled for the company
			PostalAddress *struct {
				// AdminAreaLevel1 Admin area level 1 (e.g. state) of the person
				AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

				// AdminAreaLevel2 Admin area level 2 (e.g. county) of the person
				AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

				// Country Country of the person
				Country *string `json:"country,omitempty"`

				// Locality Locality (e.g. city) of the person
				Locality *string `json:"locality,omitempty"`

				// PostalCode Postal code of the person
				PostalCode *string `json:"postal_code,omitempty"`

				// Route Route (e.g. street) of the person
				Route *string `json:"route,omitempty"`

				// StreetNumber Street number of the person
				StreetNumber *string `json:"street_number,omitempty"`

				// Sublocality Sublocality (e.g. neighborhood) of the person
				Sublocality *string `json:"sublocality,omitempty"`

				// Subpremise Subpremise (e.g. apartment/suite number) of the person
				Subpremise *string `json:"subpremise,omitempty"`

				// Value The full address of the person
				Value *string `json:"value,omitempty"`
			} `json:"postal_address,omitempty"`

			// UpdateTime The last updated date and time of the person
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility of the person
			VisibleTo *int `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The person object
		Data *struct {
			// AddTime The creation date and time of the person
			AddTime *string `json:"add_time,omitempty"`

			// Birthday The birthday of the person, included if contact sync is enabled for the company
			Birthday *string `json:"birthday,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// Emails The emails of the person
			Emails *[]struct {
				// Label The email address classification label
				Label *string `json:"label,omitempty"`

				// Primary Whether the email is primary or not
				Primary *bool `json:"primary,omitempty"`

				// Value The email address of the person
				Value *string `json:"value,omitempty"`
			} `json:"emails,omitempty"`

			// FirstName The first name of the person
			FirstName *string `json:"first_name,omitempty"`

			// Id The ID of the person
			Id *int `json:"id,omitempty"`

			// Im The instant messaging accounts of the person, included if contact sync is enabled for the company
			Im *[]struct {
				// Label The instant messaging account classification label
				Label *string `json:"label,omitempty"`

				// Primary Whether the instant messaging account is primary or not
				Primary *bool `json:"primary,omitempty"`

				// Value The instant messaging account of the person
				Value *string `json:"value,omitempty"`
			} `json:"im,omitempty"`

			// IsDeleted Whether the person is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// JobTitle The job title of the person, included if contact sync is enabled for the company
			JobTitle *string `json:"job_title,omitempty"`

			// LabelIds The IDs of labels assigned to the person
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LastName The last name of the person
			LastName *string `json:"last_name,omitempty"`

			// Name The name of the person
			Name *string `json:"name,omitempty"`

			// Notes Contact sync notes of the person, maximum 10 000 characters, included if contact sync is enabled for the company
			Notes *string `json:"notes,omitempty"`

			// OrgId The ID of the organization linked to the person
			OrgId *int `json:"org_id,omitempty"`

			// OwnerId The ID of the user who owns the person
			OwnerId *int `json:"owner_id,omitempty"`

			// Phones The phones of the person
			Phones *[]struct {
				// Label The phone number classification label
				Label *string `json:"label,omitempty"`

				// Primary Whether the phone number is primary or not
				Primary *bool `json:"primary,omitempty"`

				// Value The phone number of the person
				Value *string `json:"value,omitempty"`
			} `json:"phones,omitempty"`

			// PictureId The ID of the picture associated with the person
			PictureId *int `json:"picture_id,omitempty"`

			// PostalAddress Postal address of the person, included if contact sync is enabled for the company
			PostalAddress *struct {
				// AdminAreaLevel1 Admin area level 1 (e.g. state) of the person
				AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

				// AdminAreaLevel2 Admin area level 2 (e.g. county) of the person
				AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

				// Country Country of the person
				Country *string `json:"country,omitempty"`

				// Locality Locality (e.g. city) of the person
				Locality *string `json:"locality,omitempty"`

				// PostalCode Postal code of the person
				PostalCode *string `json:"postal_code,omitempty"`

				// Route Route (e.g. street) of the person
				Route *string `json:"route,omitempty"`

				// StreetNumber Street number of the person
				StreetNumber *string `json:"street_number,omitempty"`

				// Sublocality Sublocality (e.g. neighborhood) of the person
				Sublocality *string `json:"sublocality,omitempty"`

				// Subpremise Subpremise (e.g. apartment/suite number) of the person
				Subpremise *string `json:"subpremise,omitempty"`

				// Value The full address of the person
				Value *string `json:"value,omitempty"`
			} `json:"postal_address,omitempty"`

			// UpdateTime The last updated date and time of the person
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility of the person
			VisibleTo *int `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddPersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchPersonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData Pagination related data
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *struct {
			// Items The array of found items
			Items *[]struct {
				Item *struct {
					// CustomFields Custom fields
					CustomFields *[]string `json:"custom_fields,omitempty"`

					// Emails An array of email addresses
					Emails *[]string `json:"emails,omitempty"`

					// Id The ID of the person
					Id *int `json:"id,omitempty"`

					// Name The name of the person
					Name *string `json:"name,omitempty"`

					// Notes An array of notes
					Notes        *[]string `json:"notes,omitempty"`
					Organization *struct {
						// Id The ID of the organization the person is associated with
						Id *int `json:"id,omitempty"`

						// Name The name of the organization the person is associated with
						Name *string `json:"name,omitempty"`
					} `json:"organization,omitempty"`
					Owner *struct {
						// Id The ID of the owner of the person
						Id *int `json:"id,omitempty"`
					} `json:"owner,omitempty"`

					// Phones An array of phone numbers
					Phones *[]string `json:"phones,omitempty"`

					// Type The type of the item
					Type *string `json:"type,omitempty"`

					// VisibleTo The visibility of the person
					VisibleTo *int `json:"visible_to,omitempty"`
				} `json:"item,omitempty"`

				// ResultScore Search result relevancy
				ResultScore *float32 `json:"result_score,omitempty"`
			} `json:"items,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchPersonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchPersonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id Deleted person ID
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The person object
		Data *struct {
			// AddTime The creation date and time of the person
			AddTime *string `json:"add_time,omitempty"`

			// Birthday The birthday of the person, included if contact sync is enabled for the company
			Birthday *string `json:"birthday,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// Emails The emails of the person
			Emails *[]struct {
				// Label The email address classification label
				Label *string `json:"label,omitempty"`

				// Primary Whether the email is primary or not
				Primary *bool `json:"primary,omitempty"`

				// Value The email address of the person
				Value *string `json:"value,omitempty"`
			} `json:"emails,omitempty"`

			// FirstName The first name of the person
			FirstName *string `json:"first_name,omitempty"`

			// Id The ID of the person
			Id *int `json:"id,omitempty"`

			// Im The instant messaging accounts of the person, included if contact sync is enabled for the company
			Im *[]struct {
				// Label The instant messaging account classification label
				Label *string `json:"label,omitempty"`

				// Primary Whether the instant messaging account is primary or not
				Primary *bool `json:"primary,omitempty"`

				// Value The instant messaging account of the person
				Value *string `json:"value,omitempty"`
			} `json:"im,omitempty"`

			// IsDeleted Whether the person is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// JobTitle The job title of the person, included if contact sync is enabled for the company
			JobTitle *string `json:"job_title,omitempty"`

			// LabelIds The IDs of labels assigned to the person
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LastName The last name of the person
			LastName *string `json:"last_name,omitempty"`

			// Name The name of the person
			Name *string `json:"name,omitempty"`

			// Notes Contact sync notes of the person, maximum 10 000 characters, included if contact sync is enabled for the company
			Notes *string `json:"notes,omitempty"`

			// OrgId The ID of the organization linked to the person
			OrgId *int `json:"org_id,omitempty"`

			// OwnerId The ID of the user who owns the person
			OwnerId *int `json:"owner_id,omitempty"`

			// Phones The phones of the person
			Phones *[]struct {
				// Label The phone number classification label
				Label *string `json:"label,omitempty"`

				// Primary Whether the phone number is primary or not
				Primary *bool `json:"primary,omitempty"`

				// Value The phone number of the person
				Value *string `json:"value,omitempty"`
			} `json:"phones,omitempty"`

			// PictureId The ID of the picture associated with the person
			PictureId *int `json:"picture_id,omitempty"`

			// PostalAddress Postal address of the person, included if contact sync is enabled for the company
			PostalAddress *struct {
				// AdminAreaLevel1 Admin area level 1 (e.g. state) of the person
				AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

				// AdminAreaLevel2 Admin area level 2 (e.g. county) of the person
				AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

				// Country Country of the person
				Country *string `json:"country,omitempty"`

				// Locality Locality (e.g. city) of the person
				Locality *string `json:"locality,omitempty"`

				// PostalCode Postal code of the person
				PostalCode *string `json:"postal_code,omitempty"`

				// Route Route (e.g. street) of the person
				Route *string `json:"route,omitempty"`

				// StreetNumber Street number of the person
				StreetNumber *string `json:"street_number,omitempty"`

				// Sublocality Sublocality (e.g. neighborhood) of the person
				Sublocality *string `json:"sublocality,omitempty"`

				// Subpremise Subpremise (e.g. apartment/suite number) of the person
				Subpremise *string `json:"subpremise,omitempty"`

				// Value The full address of the person
				Value *string `json:"value,omitempty"`
			} `json:"postal_address,omitempty"`

			// UpdateTime The last updated date and time of the person
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility of the person
			VisibleTo *int `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The person object
		Data *struct {
			// AddTime The creation date and time of the person
			AddTime *string `json:"add_time,omitempty"`

			// Birthday The birthday of the person, included if contact sync is enabled for the company
			Birthday *string `json:"birthday,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// Emails The emails of the person
			Emails *[]struct {
				// Label The email address classification label
				Label *string `json:"label,omitempty"`

				// Primary Whether the email is primary or not
				Primary *bool `json:"primary,omitempty"`

				// Value The email address of the person
				Value *string `json:"value,omitempty"`
			} `json:"emails,omitempty"`

			// FirstName The first name of the person
			FirstName *string `json:"first_name,omitempty"`

			// Id The ID of the person
			Id *int `json:"id,omitempty"`

			// Im The instant messaging accounts of the person, included if contact sync is enabled for the company
			Im *[]struct {
				// Label The instant messaging account classification label
				Label *string `json:"label,omitempty"`

				// Primary Whether the instant messaging account is primary or not
				Primary *bool `json:"primary,omitempty"`

				// Value The instant messaging account of the person
				Value *string `json:"value,omitempty"`
			} `json:"im,omitempty"`

			// IsDeleted Whether the person is deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// JobTitle The job title of the person, included if contact sync is enabled for the company
			JobTitle *string `json:"job_title,omitempty"`

			// LabelIds The IDs of labels assigned to the person
			LabelIds *[]int `json:"label_ids,omitempty"`

			// LastName The last name of the person
			LastName *string `json:"last_name,omitempty"`

			// Name The name of the person
			Name *string `json:"name,omitempty"`

			// Notes Contact sync notes of the person, maximum 10 000 characters, included if contact sync is enabled for the company
			Notes *string `json:"notes,omitempty"`

			// OrgId The ID of the organization linked to the person
			OrgId *int `json:"org_id,omitempty"`

			// OwnerId The ID of the user who owns the person
			OwnerId *int `json:"owner_id,omitempty"`

			// Phones The phones of the person
			Phones *[]struct {
				// Label The phone number classification label
				Label *string `json:"label,omitempty"`

				// Primary Whether the phone number is primary or not
				Primary *bool `json:"primary,omitempty"`

				// Value The phone number of the person
				Value *string `json:"value,omitempty"`
			} `json:"phones,omitempty"`

			// PictureId The ID of the picture associated with the person
			PictureId *int `json:"picture_id,omitempty"`

			// PostalAddress Postal address of the person, included if contact sync is enabled for the company
			PostalAddress *struct {
				// AdminAreaLevel1 Admin area level 1 (e.g. state) of the person
				AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

				// AdminAreaLevel2 Admin area level 2 (e.g. county) of the person
				AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

				// Country Country of the person
				Country *string `json:"country,omitempty"`

				// Locality Locality (e.g. city) of the person
				Locality *string `json:"locality,omitempty"`

				// PostalCode Postal code of the person
				PostalCode *string `json:"postal_code,omitempty"`

				// Route Route (e.g. street) of the person
				Route *string `json:"route,omitempty"`

				// StreetNumber Street number of the person
				StreetNumber *string `json:"street_number,omitempty"`

				// Sublocality Sublocality (e.g. neighborhood) of the person
				Sublocality *string `json:"sublocality,omitempty"`

				// Subpremise Subpremise (e.g. apartment/suite number) of the person
				Subpremise *string `json:"subpremise,omitempty"`

				// Value The full address of the person
				Value *string `json:"value,omitempty"`
			} `json:"postal_address,omitempty"`

			// UpdateTime The last updated date and time of the person
			UpdateTime *string `json:"update_time,omitempty"`

			// VisibleTo The visibility of the person
			VisibleTo *int `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonFollowersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Followers array
		Data *[]struct {
			// AddTime The add time of the following
			AddTime *string `json:"add_time,omitempty"`

			// UserId The ID of the user following the entity
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonFollowersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonFollowersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPersonFollowerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data The follower object
		Data *struct {
			// AddTime The add time of the following
			AddTime *string `json:"add_time,omitempty"`

			// UserId The ID of the user following the entity
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddPersonFollowerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPersonFollowerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonFollowersChangelogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Follower changelogs array
		Data *[]struct {
			// Action The type of change
			Action *string `json:"action,omitempty"`

			// ActorUserId The ID of the user who did the change
			ActorUserId *int `json:"actor_user_id,omitempty"`

			// FollowerUserId The ID of the user who was following the entity
			FollowerUserId *int `json:"follower_user_id,omitempty"`

			// Time The time at which the change happened
			Time *string `json:"time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonFollowersChangelogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonFollowersChangelogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersonFollowerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UserId Deleted follower user ID
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePersonFollowerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersonFollowerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonPictureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ActiveFlag Whether the picture is active or not.
			ActiveFlag *bool `json:"active_flag,omitempty"`

			// AddedByUserId The ID of the user who added the picture.
			AddedByUserId *int `json:"added_by_user_id,omitempty"`

			// FileSize The file size in bytes.
			FileSize *int `json:"file_size,omitempty"`

			// Id The ID of the picture.
			Id *int `json:"id,omitempty"`

			// ItemId The ID of the person this picture belongs to.
			ItemId *int `json:"item_id,omitempty"`

			// ItemType The type of item the picture is associated with.
			ItemType *string `json:"item_type,omitempty"`

			// Pictures Picture URLs indexed by size.
			Pictures *struct {
				// N128 The URL of the 128x128 picture.
				N128 *string `json:"128,omitempty"`

				// N512 The URL of the 512x512 picture.
				N512 *string `json:"512,omitempty"`
			} `json:"pictures,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonPictureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonPictureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Pipelines array
		Data *[]struct {
			// AddTime The pipeline creation time
			AddTime *string `json:"add_time,omitempty"`

			// Id The ID of the pipeline
			Id *int `json:"id,omitempty"`

			// IsDealProbabilityEnabled Whether deal probability is disabled or enabled for this pipeline
			IsDealProbabilityEnabled *bool `json:"is_deal_probability_enabled,omitempty"`

			// IsDeleted Whether this pipeline is marked as deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// Name The name of the pipeline
			Name *string `json:"name,omitempty"`

			// OrderNr Defines the order of pipelines. The pipeline with the lowest `order_nr` is considered the default.
			OrderNr *int `json:"order_nr,omitempty"`

			// UpdateTime The pipeline update time
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The pipeline object
		Data *struct {
			// AddTime The pipeline creation time
			AddTime *string `json:"add_time,omitempty"`

			// Id The ID of the pipeline
			Id *int `json:"id,omitempty"`

			// IsDealProbabilityEnabled Whether deal probability is disabled or enabled for this pipeline
			IsDealProbabilityEnabled *bool `json:"is_deal_probability_enabled,omitempty"`

			// IsDeleted Whether this pipeline is marked as deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// Name The name of the pipeline
			Name *string `json:"name,omitempty"`

			// OrderNr Defines the order of pipelines. The pipeline with the lowest `order_nr` is considered the default.
			OrderNr *int `json:"order_nr,omitempty"`

			// UpdateTime The pipeline update time
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddPipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id Deleted Pipeline ID
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The pipeline object
		Data *struct {
			// AddTime The pipeline creation time
			AddTime *string `json:"add_time,omitempty"`

			// Id The ID of the pipeline
			Id *int `json:"id,omitempty"`

			// IsDealProbabilityEnabled Whether deal probability is disabled or enabled for this pipeline
			IsDealProbabilityEnabled *bool `json:"is_deal_probability_enabled,omitempty"`

			// IsDeleted Whether this pipeline is marked as deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// Name The name of the pipeline
			Name *string `json:"name,omitempty"`

			// OrderNr Defines the order of pipelines. The pipeline with the lowest `order_nr` is considered the default.
			OrderNr *int `json:"order_nr,omitempty"`

			// UpdateTime The pipeline update time
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The pipeline object
		Data *struct {
			// AddTime The pipeline creation time
			AddTime *string `json:"add_time,omitempty"`

			// Id The ID of the pipeline
			Id *int `json:"id,omitempty"`

			// IsDealProbabilityEnabled Whether deal probability is disabled or enabled for this pipeline
			IsDealProbabilityEnabled *bool `json:"is_deal_probability_enabled,omitempty"`

			// IsDeleted Whether this pipeline is marked as deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// Name The name of the pipeline
			Name *string `json:"name,omitempty"`

			// OrderNr Defines the order of pipelines. The pipeline with the lowest `order_nr` is considered the default.
			OrderNr *int `json:"order_nr,omitempty"`

			// UpdateTime The pipeline update time
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *struct {
			// NextCursor Base64url-encoded cursor for fetching the next page of results, null if no more pages
			NextCursor *string `json:"next_cursor"`
		} `json:"additional_data,omitempty"`
		Data *[]struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType GetProductFields200DataFieldType `json:"field_type"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view (read-only)
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type GetProductFields200DataFieldType string

// Status returns HTTPResponse.Status
func (r GetProductFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddProductFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType AddProductField200DataFieldType `json:"field_type"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view (read-only)
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type AddProductField200DataFieldType string

// Status returns HTTPResponse.Status
func (r AddProductFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddProductFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType string `json:"field_type"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]map[string]interface{} `json:"options"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]map[string]interface{} `json:"subfields"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteProductFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType GetProductField200DataFieldType `json:"field_type"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view (read-only)
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type GetProductField200DataFieldType string

// Status returns HTTPResponse.Status
func (r GetProductFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProductFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FieldCode The unique identifier for the field (40-character hash for custom fields)
			FieldCode string `json:"field_code"`

			// FieldName The display name/label of the field
			FieldName string `json:"field_name"`

			// FieldType The type of the field
			FieldType UpdateProductField200DataFieldType `json:"field_type"`

			// IsCustomField Whether this is a user-created custom field
			IsCustomField bool `json:"is_custom_field"`

			// IsOptionalResponseField Whether this field is not returned by default in entity responses
			IsOptionalResponseField bool `json:"is_optional_response_field"`

			// Options Array of available options for enum/set fields, null for other field types
			Options *[]struct {
				// AddTime When the option was created
				AddTime *time.Time `json:"add_time"`

				// Color Optional color code for the option
				Color *string `json:"color"`

				// Id The option ID
				Id *int `json:"id,omitempty"`

				// Label The option display label
				Label *string `json:"label,omitempty"`

				// UpdateTime When the option was last updated
				UpdateTime *time.Time `json:"update_time"`
			} `json:"options"`

			// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
			Subfields *[]struct {
				// FieldCode The subfield identifier
				FieldCode *string `json:"field_code,omitempty"`

				// FieldName The subfield display name
				FieldName *string `json:"field_name,omitempty"`

				// FieldType The subfield type
				FieldType *string `json:"field_type,omitempty"`
			} `json:"subfields"`

			// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
			UiVisibility *struct {
				// AddVisibleFlag Whether the field is shown in the add modal
				AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

				// DetailsVisibleFlag Whether the field is shown in the details view (read-only)
				DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`
			} `json:"ui_visibility,omitempty"`
		} `json:"data,omitempty"`

		// Success Whether the request was successful
		Success *bool `json:"success,omitempty"`
	}
}
type UpdateProductField200DataFieldType string

// Status returns HTTPResponse.Status
func (r UpdateProductFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProductFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductFieldOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id The unique identifier of the option
			Id int `json:"id"`

			// Label The display label of the option
			Label string `json:"label"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteProductFieldOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductFieldOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProductFieldOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id The unique identifier of the option
			Id int `json:"id"`

			// Label The display label of the option
			Label string `json:"label"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateProductFieldOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProductFieldOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddProductFieldOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalData *map[string]interface{} `json:"additional_data"`
		Data           *[]struct {
			// Id The unique identifier of the option
			Id int `json:"id"`

			// Label The display label of the option
			Label string `json:"label"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddProductFieldOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddProductFieldOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData Pagination related data
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Array containing data for all products
		Data *[]struct {
			Data *struct {
				// BillingFrequency Only available in Growth and above plans
				//
				// How often a customer is billed for access to a service or product
				BillingFrequency *GetProducts200DataDataBillingFrequency `json:"billing_frequency,omitempty"`

				// BillingFrequencyCycles Only available in Growth and above plans
				//
				// The number of times the billing frequency repeats for a product in a deal
				//
				// When `billing_frequency` is set to `one-time`, this field must be `null`
				//
				// When `billing_frequency` is set to `weekly`, this field cannot be `null`
				//
				// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
				//
				// Must be a positive integer less or equal to 208
				BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

				// Code The product code
				Code *string `json:"code,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Id The ID of the product
				Id *float32 `json:"id,omitempty"`

				// IsDeleted Whether this product will be made marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// IsLinkable Whether this product can be added to a deal or not
				IsLinkable *bool `json:"is_linkable,omitempty"`

				// Name The name of the product
				Name *string `json:"name,omitempty"`

				// OwnerId Information about the Pipedrive user who owns the product
				OwnerId *int `json:"owner_id,omitempty"`

				// Prices Array of objects, each containing: product_id (number), currency (string), price (number), cost (number), direct_cost (number | null), notes (string)
				Prices *[]map[string]interface{} `json:"prices,omitempty"`

				// Tax The tax percentage
				Tax *float32 `json:"tax,omitempty"`

				// Unit The unit in which this product is sold
				Unit *string `json:"unit,omitempty"`

				// VisibleTo Visibility of the product
				VisibleTo *GetProducts200DataDataVisibleTo `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetProducts200DataDataBillingFrequency string
type GetProducts200DataDataVisibleTo float32

// Status returns HTTPResponse.Status
func (r GetProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// BillingFrequency Only available in Growth and above plans
			//
			// How often a customer is billed for access to a service or product
			BillingFrequency *AddProduct201DataBillingFrequency `json:"billing_frequency,omitempty"`

			// BillingFrequencyCycles Only available in Growth and above plans
			//
			// The number of times the billing frequency repeats for a product in a deal
			//
			// When `billing_frequency` is set to `one-time`, this field must be `null`
			//
			// When `billing_frequency` is set to `weekly`, this field cannot be `null`
			//
			// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
			//
			// Must be a positive integer less or equal to 208
			BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

			// Code The product code
			Code *string `json:"code,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// Id The ID of the product
			Id *float32 `json:"id,omitempty"`

			// IsDeleted Whether this product will be made marked as deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// IsLinkable Whether this product can be added to a deal or not
			IsLinkable *bool `json:"is_linkable,omitempty"`

			// Name The name of the product
			Name *string `json:"name,omitempty"`

			// OwnerId Information about the Pipedrive user who owns the product
			OwnerId *int `json:"owner_id,omitempty"`

			// Prices Array of objects, each containing: product_id (number), currency (string), price (number), cost (number), direct_cost (number | null), notes (string)
			Prices *[]map[string]interface{} `json:"prices,omitempty"`

			// Tax The tax percentage
			Tax *float32 `json:"tax,omitempty"`

			// Unit The unit in which this product is sold
			Unit *string `json:"unit,omitempty"`

			// VisibleTo Visibility of the product
			VisibleTo *AddProduct201DataVisibleTo `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type AddProduct201DataBillingFrequency string
type AddProduct201DataVisibleTo float32

// Status returns HTTPResponse.Status
func (r AddProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData Pagination related data
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`
		Data *struct {
			// Items The array of found items
			Items *[]struct {
				Item *struct {
					// Code The code of the product
					Code *int `json:"code,omitempty"`

					// CustomFields The custom fields
					CustomFields *[]string `json:"custom_fields,omitempty"`

					// Id The ID of the product
					Id *int `json:"id,omitempty"`

					// Name The name of the product
					Name  *string `json:"name,omitempty"`
					Owner *struct {
						// Id The ID of the owner of the product
						Id *int `json:"id,omitempty"`
					} `json:"owner,omitempty"`

					// Type The type of the item
					Type *string `json:"type,omitempty"`

					// VisibleTo The visibility of the product
					VisibleTo *int `json:"visible_to,omitempty"`
				} `json:"item,omitempty"`

				// ResultScore Search result relevancy
				ResultScore *float32 `json:"result_score,omitempty"`
			} `json:"items,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of the removed product
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// BillingFrequency Only available in Growth and above plans
			//
			// How often a customer is billed for access to a service or product
			BillingFrequency *GetProduct200DataBillingFrequency `json:"billing_frequency,omitempty"`

			// BillingFrequencyCycles Only available in Growth and above plans
			//
			// The number of times the billing frequency repeats for a product in a deal
			//
			// When `billing_frequency` is set to `one-time`, this field must be `null`
			//
			// When `billing_frequency` is set to `weekly`, this field cannot be `null`
			//
			// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
			//
			// Must be a positive integer less or equal to 208
			BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

			// Code The product code
			Code *string `json:"code,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// Id The ID of the product
			Id *float32 `json:"id,omitempty"`

			// IsDeleted Whether this product will be made marked as deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// IsLinkable Whether this product can be added to a deal or not
			IsLinkable *bool `json:"is_linkable,omitempty"`

			// Name The name of the product
			Name *string `json:"name,omitempty"`

			// OwnerId Information about the Pipedrive user who owns the product
			OwnerId *int `json:"owner_id,omitempty"`

			// Prices Array of objects, each containing: product_id (number), currency (string), price (number), cost (number), direct_cost (number | null), notes (string)
			Prices *[]map[string]interface{} `json:"prices,omitempty"`

			// Tax The tax percentage
			Tax *float32 `json:"tax,omitempty"`

			// Unit The unit in which this product is sold
			Unit *string `json:"unit,omitempty"`

			// VisibleTo Visibility of the product
			VisibleTo *GetProduct200DataVisibleTo `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type GetProduct200DataBillingFrequency string
type GetProduct200DataVisibleTo float32

// Status returns HTTPResponse.Status
func (r GetProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// BillingFrequency Only available in Growth and above plans
			//
			// How often a customer is billed for access to a service or product
			BillingFrequency *UpdateProduct200DataBillingFrequency `json:"billing_frequency,omitempty"`

			// BillingFrequencyCycles Only available in Growth and above plans
			//
			// The number of times the billing frequency repeats for a product in a deal
			//
			// When `billing_frequency` is set to `one-time`, this field must be `null`
			//
			// When `billing_frequency` is set to `weekly`, this field cannot be `null`
			//
			// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
			//
			// Must be a positive integer less or equal to 208
			BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

			// Code The product code
			Code *string `json:"code,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// Id The ID of the product
			Id *float32 `json:"id,omitempty"`

			// IsDeleted Whether this product will be made marked as deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// IsLinkable Whether this product can be added to a deal or not
			IsLinkable *bool `json:"is_linkable,omitempty"`

			// Name The name of the product
			Name *string `json:"name,omitempty"`

			// OwnerId Information about the Pipedrive user who owns the product
			OwnerId *int `json:"owner_id,omitempty"`

			// Prices Array of objects, each containing: product_id (number), currency (string), price (number), cost (number), direct_cost (number | null), notes (string)
			Prices *[]map[string]interface{} `json:"prices,omitempty"`

			// Tax The tax percentage
			Tax *float32 `json:"tax,omitempty"`

			// Unit The unit in which this product is sold
			Unit *string `json:"unit,omitempty"`

			// VisibleTo Visibility of the product
			VisibleTo *UpdateProduct200DataVisibleTo `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type UpdateProduct200DataBillingFrequency string
type UpdateProduct200DataVisibleTo float32

// Status returns HTTPResponse.Status
func (r UpdateProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DuplicateProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// BillingFrequency Only available in Growth and above plans
			//
			// How often a customer is billed for access to a service or product
			BillingFrequency *DuplicateProduct201DataBillingFrequency `json:"billing_frequency,omitempty"`

			// BillingFrequencyCycles Only available in Growth and above plans
			//
			// The number of times the billing frequency repeats for a product in a deal
			//
			// When `billing_frequency` is set to `one-time`, this field must be `null`
			//
			// When `billing_frequency` is set to `weekly`, this field cannot be `null`
			//
			// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
			//
			// Must be a positive integer less or equal to 208
			BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

			// Code The product code
			Code *string `json:"code,omitempty"`

			// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
			CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

			// Id The ID of the product
			Id *float32 `json:"id,omitempty"`

			// IsDeleted Whether this product will be made marked as deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// IsLinkable Whether this product can be added to a deal or not
			IsLinkable *bool `json:"is_linkable,omitempty"`

			// Name The name of the product
			Name *string `json:"name,omitempty"`

			// OwnerId Information about the Pipedrive user who owns the product
			OwnerId *int `json:"owner_id,omitempty"`

			// Prices Array of objects, each containing: product_id (number), currency (string), price (number), cost (number), direct_cost (number | null), notes (string)
			Prices *[]map[string]interface{} `json:"prices,omitempty"`

			// Tax The tax percentage
			Tax *float32 `json:"tax,omitempty"`

			// Unit The unit in which this product is sold
			Unit *string `json:"unit,omitempty"`

			// VisibleTo Visibility of the product
			VisibleTo *DuplicateProduct201DataVisibleTo `json:"visible_to,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}
type DuplicateProduct201DataBillingFrequency string
type DuplicateProduct201DataVisibleTo float32

// Status returns HTTPResponse.Status
func (r DuplicateProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DuplicateProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductFollowersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Followers array
		Data *[]struct {
			// AddTime The add time of the following
			AddTime *string `json:"add_time,omitempty"`

			// UserId The ID of the user following the entity
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProductFollowersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductFollowersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddProductFollowerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data The follower object
		Data *struct {
			// AddTime The add time of the following
			AddTime *string `json:"add_time,omitempty"`

			// UserId The ID of the user following the entity
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddProductFollowerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddProductFollowerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductFollowersChangelogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Follower changelogs array
		Data *[]struct {
			// Action The type of change
			Action *string `json:"action,omitempty"`

			// ActorUserId The ID of the user who did the change
			ActorUserId *int `json:"actor_user_id,omitempty"`

			// FollowerUserId The ID of the user who was following the entity
			FollowerUserId *int `json:"follower_user_id,omitempty"`

			// Time The time at which the change happened
			Time *string `json:"time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProductFollowersChangelogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductFollowersChangelogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductFollowerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UserId Deleted follower user ID
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteProductFollowerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductFollowerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of the image that was deleted from the product.
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteProductImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The product image data and the respective public URL
		Data *struct {
			// AddTime The date of image upload.
			AddTime *string `json:"add_time,omitempty"`

			// CompanyId The ID of the company
			CompanyId *string `json:"company_id,omitempty"`

			// Id The ID of the product image
			Id *int `json:"id,omitempty"`

			// MimeType The MIME type of the product image
			MimeType *string `json:"mime_type,omitempty"`

			// Name The name of the product image file
			Name *string `json:"name,omitempty"`

			// ProductId The ID of the product associated
			ProductId *int `json:"product_id,omitempty"`

			// PublicUrl The public URL of the product image
			PublicUrl *string `json:"public_url,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProductImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadProductImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// AddTime The date of image upload.
			AddTime *string `json:"add_time,omitempty"`

			// CompanyId The ID of the company
			CompanyId *string `json:"company_id,omitempty"`

			// Id The ID of the product image
			Id *int `json:"id,omitempty"`

			// ProductId The ID of the product associated
			ProductId *float32 `json:"product_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UploadProductImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadProductImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProductImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// AddTime The date of image upload.
			AddTime *string `json:"add_time,omitempty"`

			// CompanyId The ID of the company
			CompanyId *string `json:"company_id,omitempty"`

			// Id The ID of the product image
			Id *int `json:"id,omitempty"`

			// ProductId The ID of the product associated
			ProductId *float32 `json:"product_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateProductImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProductImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductVariationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData Pagination related data
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Array containing data for all products
		Data *[]struct {
			// Id The ID of the product variation
			Id *float32 `json:"id,omitempty"`

			// Name The name of the product variation
			Name *string `json:"name,omitempty"`

			// Prices Array of objects, each containing: product_variation_id (number), currency (string), price (number), cost (number), direct_cost (number) , notes (string)
			Prices *[]map[string]interface{} `json:"prices,omitempty"`

			// ProductId The ID of the product
			ProductId *int `json:"product_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProductVariationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductVariationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddProductVariationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// Id The ID of the product variation
			Id *float32 `json:"id,omitempty"`

			// Name The name of the product variation
			Name *string `json:"name,omitempty"`

			// Prices Array of objects, each containing: product_variation_id (number), currency (string), price (number), cost (number), direct_cost (number) , notes (string)
			Prices *[]map[string]interface{} `json:"prices,omitempty"`

			// ProductId The ID of the product
			ProductId *int `json:"product_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddProductVariationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddProductVariationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductVariationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of a deleted product variant
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteProductVariationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductVariationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProductVariationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id The ID of the product variation
			Id *float32 `json:"id,omitempty"`

			// Name The name of the product variation
			Name *string `json:"name,omitempty"`

			// Prices Array of objects, each containing: product_variation_id (number), currency (string), price (number), cost (number), direct_cost (number) , notes (string)
			Prices *[]map[string]interface{} `json:"prices,omitempty"`

			// ProductId The ID of the product
			ProductId *int `json:"product_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateProductVariationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProductVariationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data The array of stages
		Data *[]struct {
			// AddTime The stage creation time
			AddTime *string `json:"add_time,omitempty"`

			// DaysToRotten The number of days the deals not updated in this stage would become rotten. Applies only if the `is_deal_rot_enabled` is set.
			DaysToRotten *int `json:"days_to_rotten"`

			// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
			DealProbability *int `json:"deal_probability,omitempty"`

			// Id The ID of the stage
			Id *int `json:"id,omitempty"`

			// IsDealRotEnabled Whether deals in this stage can become rotten
			IsDealRotEnabled *bool `json:"is_deal_rot_enabled,omitempty"`

			// IsDeleted Whether the stage is marked as deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// Name The name of the stage
			Name *string `json:"name,omitempty"`

			// OrderNr Defines the order of the stage
			OrderNr *int `json:"order_nr,omitempty"`

			// PipelineId The ID of the pipeline to add the stage to
			PipelineId *int `json:"pipeline_id,omitempty"`

			// UpdateTime The stage update time
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddStageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The stage object
		Data *struct {
			// AddTime The stage creation time
			AddTime *string `json:"add_time,omitempty"`

			// DaysToRotten The number of days the deals not updated in this stage would become rotten. Applies only if the `is_deal_rot_enabled` is set.
			DaysToRotten *int `json:"days_to_rotten"`

			// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
			DealProbability *int `json:"deal_probability,omitempty"`

			// Id The ID of the stage
			Id *int `json:"id,omitempty"`

			// IsDealRotEnabled Whether deals in this stage can become rotten
			IsDealRotEnabled *bool `json:"is_deal_rot_enabled,omitempty"`

			// IsDeleted Whether the stage is marked as deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// Name The name of the stage
			Name *string `json:"name,omitempty"`

			// OrderNr Defines the order of the stage
			OrderNr *int `json:"order_nr,omitempty"`

			// PipelineId The ID of the pipeline to add the stage to
			PipelineId *int `json:"pipeline_id,omitempty"`

			// UpdateTime The stage update time
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddStageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddStageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Id Deleted stage ID
			Id *int `json:"id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteStageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The stage object
		Data *struct {
			// AddTime The stage creation time
			AddTime *string `json:"add_time,omitempty"`

			// DaysToRotten The number of days the deals not updated in this stage would become rotten. Applies only if the `is_deal_rot_enabled` is set.
			DaysToRotten *int `json:"days_to_rotten"`

			// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
			DealProbability *int `json:"deal_probability,omitempty"`

			// Id The ID of the stage
			Id *int `json:"id,omitempty"`

			// IsDealRotEnabled Whether deals in this stage can become rotten
			IsDealRotEnabled *bool `json:"is_deal_rot_enabled,omitempty"`

			// IsDeleted Whether the stage is marked as deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// Name The name of the stage
			Name *string `json:"name,omitempty"`

			// OrderNr Defines the order of the stage
			OrderNr *int `json:"order_nr,omitempty"`

			// PipelineId The ID of the pipeline to add the stage to
			PipelineId *int `json:"pipeline_id,omitempty"`

			// UpdateTime The stage update time
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateStageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The stage object
		Data *struct {
			// AddTime The stage creation time
			AddTime *string `json:"add_time,omitempty"`

			// DaysToRotten The number of days the deals not updated in this stage would become rotten. Applies only if the `is_deal_rot_enabled` is set.
			DaysToRotten *int `json:"days_to_rotten"`

			// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
			DealProbability *int `json:"deal_probability,omitempty"`

			// Id The ID of the stage
			Id *int `json:"id,omitempty"`

			// IsDealRotEnabled Whether deals in this stage can become rotten
			IsDealRotEnabled *bool `json:"is_deal_rot_enabled,omitempty"`

			// IsDeleted Whether the stage is marked as deleted or not
			IsDeleted *bool `json:"is_deleted,omitempty"`

			// Name The name of the stage
			Name *string `json:"name,omitempty"`

			// OrderNr Defines the order of the stage
			OrderNr *int `json:"order_nr,omitempty"`

			// PipelineId The ID of the pipeline to add the stage to
			PipelineId *int `json:"pipeline_id,omitempty"`

			// UpdateTime The stage update time
			UpdateTime *string `json:"update_time,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateStageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateStageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFollowersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AdditionalData The additional data of the list
		AdditionalData *struct {
			// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
			NextCursor *string `json:"next_cursor,omitempty"`
		} `json:"additional_data,omitempty"`

		// Data Followers array
		Data *[]struct {
			// AddTime The add time of the following
			AddTime *string `json:"add_time,omitempty"`

			// UserId The ID of the user following the entity
			UserId *int `json:"user_id,omitempty"`
		} `json:"data,omitempty"`

		// Success If the response is successful or not
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserFollowersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFollowersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetActivitiesWithResponse request returning *GetActivitiesResponse
func (c *ClientWithResponses) GetActivitiesWithResponse(ctx context.Context, params *GetActivitiesParams, reqEditors ...RequestEditorFn) (*GetActivitiesResponse, error) {
	rsp, err := c.GetActivities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivitiesResponse(rsp)
}

// AddActivityWithBodyWithResponse request with arbitrary body returning *AddActivityResponse
func (c *ClientWithResponses) AddActivityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddActivityResponse, error) {
	rsp, err := c.AddActivityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddActivityResponse(rsp)
}

func (c *ClientWithResponses) AddActivityWithResponse(ctx context.Context, body AddActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*AddActivityResponse, error) {
	rsp, err := c.AddActivity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddActivityResponse(rsp)
}

// DeleteActivityWithResponse request returning *DeleteActivityResponse
func (c *ClientWithResponses) DeleteActivityWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteActivityResponse, error) {
	rsp, err := c.DeleteActivity(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteActivityResponse(rsp)
}

// GetActivityWithResponse request returning *GetActivityResponse
func (c *ClientWithResponses) GetActivityWithResponse(ctx context.Context, id int, params *GetActivityParams, reqEditors ...RequestEditorFn) (*GetActivityResponse, error) {
	rsp, err := c.GetActivity(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityResponse(rsp)
}

// UpdateActivityWithBodyWithResponse request with arbitrary body returning *UpdateActivityResponse
func (c *ClientWithResponses) UpdateActivityWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateActivityResponse, error) {
	rsp, err := c.UpdateActivityWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateActivityResponse(rsp)
}

func (c *ClientWithResponses) UpdateActivityWithResponse(ctx context.Context, id int, body UpdateActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateActivityResponse, error) {
	rsp, err := c.UpdateActivity(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateActivityResponse(rsp)
}

// GetActivityFieldsWithResponse request returning *GetActivityFieldsResponse
func (c *ClientWithResponses) GetActivityFieldsWithResponse(ctx context.Context, params *GetActivityFieldsParams, reqEditors ...RequestEditorFn) (*GetActivityFieldsResponse, error) {
	rsp, err := c.GetActivityFields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityFieldsResponse(rsp)
}

// GetActivityFieldWithResponse request returning *GetActivityFieldResponse
func (c *ClientWithResponses) GetActivityFieldWithResponse(ctx context.Context, fieldCode string, params *GetActivityFieldParams, reqEditors ...RequestEditorFn) (*GetActivityFieldResponse, error) {
	rsp, err := c.GetActivityField(ctx, fieldCode, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityFieldResponse(rsp)
}

// GetDealFieldsWithResponse request returning *GetDealFieldsResponse
func (c *ClientWithResponses) GetDealFieldsWithResponse(ctx context.Context, params *GetDealFieldsParams, reqEditors ...RequestEditorFn) (*GetDealFieldsResponse, error) {
	rsp, err := c.GetDealFields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealFieldsResponse(rsp)
}

// AddDealFieldWithBodyWithResponse request with arbitrary body returning *AddDealFieldResponse
func (c *ClientWithResponses) AddDealFieldWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDealFieldResponse, error) {
	rsp, err := c.AddDealFieldWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDealFieldResponse(rsp)
}

func (c *ClientWithResponses) AddDealFieldWithResponse(ctx context.Context, body AddDealFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDealFieldResponse, error) {
	rsp, err := c.AddDealField(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDealFieldResponse(rsp)
}

// DeleteDealFieldWithResponse request returning *DeleteDealFieldResponse
func (c *ClientWithResponses) DeleteDealFieldWithResponse(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*DeleteDealFieldResponse, error) {
	rsp, err := c.DeleteDealField(ctx, fieldCode, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDealFieldResponse(rsp)
}

// GetDealFieldWithResponse request returning *GetDealFieldResponse
func (c *ClientWithResponses) GetDealFieldWithResponse(ctx context.Context, fieldCode string, params *GetDealFieldParams, reqEditors ...RequestEditorFn) (*GetDealFieldResponse, error) {
	rsp, err := c.GetDealField(ctx, fieldCode, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealFieldResponse(rsp)
}

// UpdateDealFieldWithBodyWithResponse request with arbitrary body returning *UpdateDealFieldResponse
func (c *ClientWithResponses) UpdateDealFieldWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDealFieldResponse, error) {
	rsp, err := c.UpdateDealFieldWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDealFieldResponse(rsp)
}

func (c *ClientWithResponses) UpdateDealFieldWithResponse(ctx context.Context, fieldCode string, body UpdateDealFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDealFieldResponse, error) {
	rsp, err := c.UpdateDealField(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDealFieldResponse(rsp)
}

// DeleteDealFieldOptionsWithBodyWithResponse request with arbitrary body returning *DeleteDealFieldOptionsResponse
func (c *ClientWithResponses) DeleteDealFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteDealFieldOptionsResponse, error) {
	rsp, err := c.DeleteDealFieldOptionsWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDealFieldOptionsResponse(rsp)
}

func (c *ClientWithResponses) DeleteDealFieldOptionsWithResponse(ctx context.Context, fieldCode string, body DeleteDealFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteDealFieldOptionsResponse, error) {
	rsp, err := c.DeleteDealFieldOptions(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDealFieldOptionsResponse(rsp)
}

// UpdateDealFieldOptionsWithBodyWithResponse request with arbitrary body returning *UpdateDealFieldOptionsResponse
func (c *ClientWithResponses) UpdateDealFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDealFieldOptionsResponse, error) {
	rsp, err := c.UpdateDealFieldOptionsWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDealFieldOptionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateDealFieldOptionsWithResponse(ctx context.Context, fieldCode string, body UpdateDealFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDealFieldOptionsResponse, error) {
	rsp, err := c.UpdateDealFieldOptions(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDealFieldOptionsResponse(rsp)
}

// AddDealFieldOptionsWithBodyWithResponse request with arbitrary body returning *AddDealFieldOptionsResponse
func (c *ClientWithResponses) AddDealFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDealFieldOptionsResponse, error) {
	rsp, err := c.AddDealFieldOptionsWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDealFieldOptionsResponse(rsp)
}

func (c *ClientWithResponses) AddDealFieldOptionsWithResponse(ctx context.Context, fieldCode string, body AddDealFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDealFieldOptionsResponse, error) {
	rsp, err := c.AddDealFieldOptions(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDealFieldOptionsResponse(rsp)
}

// GetDealsWithResponse request returning *GetDealsResponse
func (c *ClientWithResponses) GetDealsWithResponse(ctx context.Context, params *GetDealsParams, reqEditors ...RequestEditorFn) (*GetDealsResponse, error) {
	rsp, err := c.GetDeals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealsResponse(rsp)
}

// AddDealWithBodyWithResponse request with arbitrary body returning *AddDealResponse
func (c *ClientWithResponses) AddDealWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDealResponse, error) {
	rsp, err := c.AddDealWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDealResponse(rsp)
}

func (c *ClientWithResponses) AddDealWithResponse(ctx context.Context, body AddDealJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDealResponse, error) {
	rsp, err := c.AddDeal(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDealResponse(rsp)
}

// GetArchivedDealsWithResponse request returning *GetArchivedDealsResponse
func (c *ClientWithResponses) GetArchivedDealsWithResponse(ctx context.Context, params *GetArchivedDealsParams, reqEditors ...RequestEditorFn) (*GetArchivedDealsResponse, error) {
	rsp, err := c.GetArchivedDeals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArchivedDealsResponse(rsp)
}

// GetInstallmentsWithResponse request returning *GetInstallmentsResponse
func (c *ClientWithResponses) GetInstallmentsWithResponse(ctx context.Context, params *GetInstallmentsParams, reqEditors ...RequestEditorFn) (*GetInstallmentsResponse, error) {
	rsp, err := c.GetInstallments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstallmentsResponse(rsp)
}

// GetDealsProductsWithResponse request returning *GetDealsProductsResponse
func (c *ClientWithResponses) GetDealsProductsWithResponse(ctx context.Context, params *GetDealsProductsParams, reqEditors ...RequestEditorFn) (*GetDealsProductsResponse, error) {
	rsp, err := c.GetDealsProducts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealsProductsResponse(rsp)
}

// SearchDealsWithResponse request returning *SearchDealsResponse
func (c *ClientWithResponses) SearchDealsWithResponse(ctx context.Context, params *SearchDealsParams, reqEditors ...RequestEditorFn) (*SearchDealsResponse, error) {
	rsp, err := c.SearchDeals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDealsResponse(rsp)
}

// DeleteDealWithResponse request returning *DeleteDealResponse
func (c *ClientWithResponses) DeleteDealWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteDealResponse, error) {
	rsp, err := c.DeleteDeal(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDealResponse(rsp)
}

// GetDealWithResponse request returning *GetDealResponse
func (c *ClientWithResponses) GetDealWithResponse(ctx context.Context, id int, params *GetDealParams, reqEditors ...RequestEditorFn) (*GetDealResponse, error) {
	rsp, err := c.GetDeal(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealResponse(rsp)
}

// UpdateDealWithBodyWithResponse request with arbitrary body returning *UpdateDealResponse
func (c *ClientWithResponses) UpdateDealWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDealResponse, error) {
	rsp, err := c.UpdateDealWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDealResponse(rsp)
}

func (c *ClientWithResponses) UpdateDealWithResponse(ctx context.Context, id int, body UpdateDealJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDealResponse, error) {
	rsp, err := c.UpdateDeal(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDealResponse(rsp)
}

// ConvertDealToLeadWithResponse request returning *ConvertDealToLeadResponse
func (c *ClientWithResponses) ConvertDealToLeadWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ConvertDealToLeadResponse, error) {
	rsp, err := c.ConvertDealToLead(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertDealToLeadResponse(rsp)
}

// GetDealConversionStatusWithResponse request returning *GetDealConversionStatusResponse
func (c *ClientWithResponses) GetDealConversionStatusWithResponse(ctx context.Context, id int, conversionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDealConversionStatusResponse, error) {
	rsp, err := c.GetDealConversionStatus(ctx, id, conversionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealConversionStatusResponse(rsp)
}

// GetAdditionalDiscountsWithResponse request returning *GetAdditionalDiscountsResponse
func (c *ClientWithResponses) GetAdditionalDiscountsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAdditionalDiscountsResponse, error) {
	rsp, err := c.GetAdditionalDiscounts(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAdditionalDiscountsResponse(rsp)
}

// PostAdditionalDiscountWithBodyWithResponse request with arbitrary body returning *PostAdditionalDiscountResponse
func (c *ClientWithResponses) PostAdditionalDiscountWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAdditionalDiscountResponse, error) {
	rsp, err := c.PostAdditionalDiscountWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAdditionalDiscountResponse(rsp)
}

func (c *ClientWithResponses) PostAdditionalDiscountWithResponse(ctx context.Context, id int, body PostAdditionalDiscountJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAdditionalDiscountResponse, error) {
	rsp, err := c.PostAdditionalDiscount(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAdditionalDiscountResponse(rsp)
}

// DeleteAdditionalDiscountWithResponse request returning *DeleteAdditionalDiscountResponse
func (c *ClientWithResponses) DeleteAdditionalDiscountWithResponse(ctx context.Context, id int, discountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteAdditionalDiscountResponse, error) {
	rsp, err := c.DeleteAdditionalDiscount(ctx, id, discountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAdditionalDiscountResponse(rsp)
}

// UpdateAdditionalDiscountWithBodyWithResponse request with arbitrary body returning *UpdateAdditionalDiscountResponse
func (c *ClientWithResponses) UpdateAdditionalDiscountWithBodyWithResponse(ctx context.Context, id int, discountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAdditionalDiscountResponse, error) {
	rsp, err := c.UpdateAdditionalDiscountWithBody(ctx, id, discountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAdditionalDiscountResponse(rsp)
}

func (c *ClientWithResponses) UpdateAdditionalDiscountWithResponse(ctx context.Context, id int, discountId openapi_types.UUID, body UpdateAdditionalDiscountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAdditionalDiscountResponse, error) {
	rsp, err := c.UpdateAdditionalDiscount(ctx, id, discountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAdditionalDiscountResponse(rsp)
}

// GetDealFollowersWithResponse request returning *GetDealFollowersResponse
func (c *ClientWithResponses) GetDealFollowersWithResponse(ctx context.Context, id int, params *GetDealFollowersParams, reqEditors ...RequestEditorFn) (*GetDealFollowersResponse, error) {
	rsp, err := c.GetDealFollowers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealFollowersResponse(rsp)
}

// AddDealFollowerWithBodyWithResponse request with arbitrary body returning *AddDealFollowerResponse
func (c *ClientWithResponses) AddDealFollowerWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDealFollowerResponse, error) {
	rsp, err := c.AddDealFollowerWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDealFollowerResponse(rsp)
}

func (c *ClientWithResponses) AddDealFollowerWithResponse(ctx context.Context, id int, body AddDealFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDealFollowerResponse, error) {
	rsp, err := c.AddDealFollower(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDealFollowerResponse(rsp)
}

// GetDealFollowersChangelogWithResponse request returning *GetDealFollowersChangelogResponse
func (c *ClientWithResponses) GetDealFollowersChangelogWithResponse(ctx context.Context, id int, params *GetDealFollowersChangelogParams, reqEditors ...RequestEditorFn) (*GetDealFollowersChangelogResponse, error) {
	rsp, err := c.GetDealFollowersChangelog(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealFollowersChangelogResponse(rsp)
}

// DeleteDealFollowerWithResponse request returning *DeleteDealFollowerResponse
func (c *ClientWithResponses) DeleteDealFollowerWithResponse(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*DeleteDealFollowerResponse, error) {
	rsp, err := c.DeleteDealFollower(ctx, id, followerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDealFollowerResponse(rsp)
}

// PostInstallmentWithBodyWithResponse request with arbitrary body returning *PostInstallmentResponse
func (c *ClientWithResponses) PostInstallmentWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInstallmentResponse, error) {
	rsp, err := c.PostInstallmentWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInstallmentResponse(rsp)
}

func (c *ClientWithResponses) PostInstallmentWithResponse(ctx context.Context, id int, body PostInstallmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInstallmentResponse, error) {
	rsp, err := c.PostInstallment(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInstallmentResponse(rsp)
}

// DeleteInstallmentWithResponse request returning *DeleteInstallmentResponse
func (c *ClientWithResponses) DeleteInstallmentWithResponse(ctx context.Context, id int, installmentId int, reqEditors ...RequestEditorFn) (*DeleteInstallmentResponse, error) {
	rsp, err := c.DeleteInstallment(ctx, id, installmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInstallmentResponse(rsp)
}

// UpdateInstallmentWithBodyWithResponse request with arbitrary body returning *UpdateInstallmentResponse
func (c *ClientWithResponses) UpdateInstallmentWithBodyWithResponse(ctx context.Context, id int, installmentId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInstallmentResponse, error) {
	rsp, err := c.UpdateInstallmentWithBody(ctx, id, installmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInstallmentResponse(rsp)
}

func (c *ClientWithResponses) UpdateInstallmentWithResponse(ctx context.Context, id int, installmentId int, body UpdateInstallmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInstallmentResponse, error) {
	rsp, err := c.UpdateInstallment(ctx, id, installmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInstallmentResponse(rsp)
}

// DeleteManyDealProductsWithResponse request returning *DeleteManyDealProductsResponse
func (c *ClientWithResponses) DeleteManyDealProductsWithResponse(ctx context.Context, id int, params *DeleteManyDealProductsParams, reqEditors ...RequestEditorFn) (*DeleteManyDealProductsResponse, error) {
	rsp, err := c.DeleteManyDealProducts(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyDealProductsResponse(rsp)
}

// GetDealProductsWithResponse request returning *GetDealProductsResponse
func (c *ClientWithResponses) GetDealProductsWithResponse(ctx context.Context, id int, params *GetDealProductsParams, reqEditors ...RequestEditorFn) (*GetDealProductsResponse, error) {
	rsp, err := c.GetDealProducts(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealProductsResponse(rsp)
}

// AddDealProductWithBodyWithResponse request with arbitrary body returning *AddDealProductResponse
func (c *ClientWithResponses) AddDealProductWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDealProductResponse, error) {
	rsp, err := c.AddDealProductWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDealProductResponse(rsp)
}

func (c *ClientWithResponses) AddDealProductWithResponse(ctx context.Context, id int, body AddDealProductJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDealProductResponse, error) {
	rsp, err := c.AddDealProduct(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDealProductResponse(rsp)
}

// AddManyDealProductsWithBodyWithResponse request with arbitrary body returning *AddManyDealProductsResponse
func (c *ClientWithResponses) AddManyDealProductsWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddManyDealProductsResponse, error) {
	rsp, err := c.AddManyDealProductsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddManyDealProductsResponse(rsp)
}

func (c *ClientWithResponses) AddManyDealProductsWithResponse(ctx context.Context, id int, body AddManyDealProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddManyDealProductsResponse, error) {
	rsp, err := c.AddManyDealProducts(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddManyDealProductsResponse(rsp)
}

// DeleteDealProductWithResponse request returning *DeleteDealProductResponse
func (c *ClientWithResponses) DeleteDealProductWithResponse(ctx context.Context, id int, productAttachmentId int, reqEditors ...RequestEditorFn) (*DeleteDealProductResponse, error) {
	rsp, err := c.DeleteDealProduct(ctx, id, productAttachmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDealProductResponse(rsp)
}

// UpdateDealProductWithBodyWithResponse request with arbitrary body returning *UpdateDealProductResponse
func (c *ClientWithResponses) UpdateDealProductWithBodyWithResponse(ctx context.Context, id int, productAttachmentId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDealProductResponse, error) {
	rsp, err := c.UpdateDealProductWithBody(ctx, id, productAttachmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDealProductResponse(rsp)
}

func (c *ClientWithResponses) UpdateDealProductWithResponse(ctx context.Context, id int, productAttachmentId int, body UpdateDealProductJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDealProductResponse, error) {
	rsp, err := c.UpdateDealProduct(ctx, id, productAttachmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDealProductResponse(rsp)
}

// SearchItemWithResponse request returning *SearchItemResponse
func (c *ClientWithResponses) SearchItemWithResponse(ctx context.Context, params *SearchItemParams, reqEditors ...RequestEditorFn) (*SearchItemResponse, error) {
	rsp, err := c.SearchItem(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchItemResponse(rsp)
}

// SearchItemByFieldWithResponse request returning *SearchItemByFieldResponse
func (c *ClientWithResponses) SearchItemByFieldWithResponse(ctx context.Context, params *SearchItemByFieldParams, reqEditors ...RequestEditorFn) (*SearchItemByFieldResponse, error) {
	rsp, err := c.SearchItemByField(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchItemByFieldResponse(rsp)
}

// SearchLeadsWithResponse request returning *SearchLeadsResponse
func (c *ClientWithResponses) SearchLeadsWithResponse(ctx context.Context, params *SearchLeadsParams, reqEditors ...RequestEditorFn) (*SearchLeadsResponse, error) {
	rsp, err := c.SearchLeads(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchLeadsResponse(rsp)
}

// ConvertLeadToDealWithBodyWithResponse request with arbitrary body returning *ConvertLeadToDealResponse
func (c *ClientWithResponses) ConvertLeadToDealWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertLeadToDealResponse, error) {
	rsp, err := c.ConvertLeadToDealWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertLeadToDealResponse(rsp)
}

func (c *ClientWithResponses) ConvertLeadToDealWithResponse(ctx context.Context, id openapi_types.UUID, body ConvertLeadToDealJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertLeadToDealResponse, error) {
	rsp, err := c.ConvertLeadToDeal(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertLeadToDealResponse(rsp)
}

// GetLeadConversionStatusWithResponse request returning *GetLeadConversionStatusResponse
func (c *ClientWithResponses) GetLeadConversionStatusWithResponse(ctx context.Context, id openapi_types.UUID, conversionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetLeadConversionStatusResponse, error) {
	rsp, err := c.GetLeadConversionStatus(ctx, id, conversionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeadConversionStatusResponse(rsp)
}

// GetOrganizationFieldsWithResponse request returning *GetOrganizationFieldsResponse
func (c *ClientWithResponses) GetOrganizationFieldsWithResponse(ctx context.Context, params *GetOrganizationFieldsParams, reqEditors ...RequestEditorFn) (*GetOrganizationFieldsResponse, error) {
	rsp, err := c.GetOrganizationFields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationFieldsResponse(rsp)
}

// AddOrganizationFieldWithBodyWithResponse request with arbitrary body returning *AddOrganizationFieldResponse
func (c *ClientWithResponses) AddOrganizationFieldWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationFieldResponse, error) {
	rsp, err := c.AddOrganizationFieldWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationFieldResponse(rsp)
}

func (c *ClientWithResponses) AddOrganizationFieldWithResponse(ctx context.Context, body AddOrganizationFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationFieldResponse, error) {
	rsp, err := c.AddOrganizationField(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationFieldResponse(rsp)
}

// DeleteOrganizationFieldWithResponse request returning *DeleteOrganizationFieldResponse
func (c *ClientWithResponses) DeleteOrganizationFieldWithResponse(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*DeleteOrganizationFieldResponse, error) {
	rsp, err := c.DeleteOrganizationField(ctx, fieldCode, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationFieldResponse(rsp)
}

// GetOrganizationFieldWithResponse request returning *GetOrganizationFieldResponse
func (c *ClientWithResponses) GetOrganizationFieldWithResponse(ctx context.Context, fieldCode string, params *GetOrganizationFieldParams, reqEditors ...RequestEditorFn) (*GetOrganizationFieldResponse, error) {
	rsp, err := c.GetOrganizationField(ctx, fieldCode, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationFieldResponse(rsp)
}

// UpdateOrganizationFieldWithBodyWithResponse request with arbitrary body returning *UpdateOrganizationFieldResponse
func (c *ClientWithResponses) UpdateOrganizationFieldWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationFieldResponse, error) {
	rsp, err := c.UpdateOrganizationFieldWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationFieldResponse(rsp)
}

func (c *ClientWithResponses) UpdateOrganizationFieldWithResponse(ctx context.Context, fieldCode string, body UpdateOrganizationFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationFieldResponse, error) {
	rsp, err := c.UpdateOrganizationField(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationFieldResponse(rsp)
}

// DeleteOrganizationFieldOptionsWithBodyWithResponse request with arbitrary body returning *DeleteOrganizationFieldOptionsResponse
func (c *ClientWithResponses) DeleteOrganizationFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteOrganizationFieldOptionsResponse, error) {
	rsp, err := c.DeleteOrganizationFieldOptionsWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationFieldOptionsResponse(rsp)
}

func (c *ClientWithResponses) DeleteOrganizationFieldOptionsWithResponse(ctx context.Context, fieldCode string, body DeleteOrganizationFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteOrganizationFieldOptionsResponse, error) {
	rsp, err := c.DeleteOrganizationFieldOptions(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationFieldOptionsResponse(rsp)
}

// UpdateOrganizationFieldOptionsWithBodyWithResponse request with arbitrary body returning *UpdateOrganizationFieldOptionsResponse
func (c *ClientWithResponses) UpdateOrganizationFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationFieldOptionsResponse, error) {
	rsp, err := c.UpdateOrganizationFieldOptionsWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationFieldOptionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateOrganizationFieldOptionsWithResponse(ctx context.Context, fieldCode string, body UpdateOrganizationFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationFieldOptionsResponse, error) {
	rsp, err := c.UpdateOrganizationFieldOptions(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationFieldOptionsResponse(rsp)
}

// AddOrganizationFieldOptionsWithBodyWithResponse request with arbitrary body returning *AddOrganizationFieldOptionsResponse
func (c *ClientWithResponses) AddOrganizationFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationFieldOptionsResponse, error) {
	rsp, err := c.AddOrganizationFieldOptionsWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationFieldOptionsResponse(rsp)
}

func (c *ClientWithResponses) AddOrganizationFieldOptionsWithResponse(ctx context.Context, fieldCode string, body AddOrganizationFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationFieldOptionsResponse, error) {
	rsp, err := c.AddOrganizationFieldOptions(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationFieldOptionsResponse(rsp)
}

// GetOrganizationsWithResponse request returning *GetOrganizationsResponse
func (c *ClientWithResponses) GetOrganizationsWithResponse(ctx context.Context, params *GetOrganizationsParams, reqEditors ...RequestEditorFn) (*GetOrganizationsResponse, error) {
	rsp, err := c.GetOrganizations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationsResponse(rsp)
}

// AddOrganizationWithBodyWithResponse request with arbitrary body returning *AddOrganizationResponse
func (c *ClientWithResponses) AddOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationResponse, error) {
	rsp, err := c.AddOrganizationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationResponse(rsp)
}

func (c *ClientWithResponses) AddOrganizationWithResponse(ctx context.Context, body AddOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationResponse, error) {
	rsp, err := c.AddOrganization(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationResponse(rsp)
}

// SearchOrganizationWithResponse request returning *SearchOrganizationResponse
func (c *ClientWithResponses) SearchOrganizationWithResponse(ctx context.Context, params *SearchOrganizationParams, reqEditors ...RequestEditorFn) (*SearchOrganizationResponse, error) {
	rsp, err := c.SearchOrganization(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchOrganizationResponse(rsp)
}

// DeleteOrganizationWithResponse request returning *DeleteOrganizationResponse
func (c *ClientWithResponses) DeleteOrganizationWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteOrganizationResponse, error) {
	rsp, err := c.DeleteOrganization(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationResponse(rsp)
}

// GetOrganizationWithResponse request returning *GetOrganizationResponse
func (c *ClientWithResponses) GetOrganizationWithResponse(ctx context.Context, id int, params *GetOrganizationParams, reqEditors ...RequestEditorFn) (*GetOrganizationResponse, error) {
	rsp, err := c.GetOrganization(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationResponse(rsp)
}

// UpdateOrganizationWithBodyWithResponse request with arbitrary body returning *UpdateOrganizationResponse
func (c *ClientWithResponses) UpdateOrganizationWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error) {
	rsp, err := c.UpdateOrganizationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationResponse(rsp)
}

func (c *ClientWithResponses) UpdateOrganizationWithResponse(ctx context.Context, id int, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error) {
	rsp, err := c.UpdateOrganization(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationResponse(rsp)
}

// GetOrganizationFollowersWithResponse request returning *GetOrganizationFollowersResponse
func (c *ClientWithResponses) GetOrganizationFollowersWithResponse(ctx context.Context, id int, params *GetOrganizationFollowersParams, reqEditors ...RequestEditorFn) (*GetOrganizationFollowersResponse, error) {
	rsp, err := c.GetOrganizationFollowers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationFollowersResponse(rsp)
}

// AddOrganizationFollowerWithBodyWithResponse request with arbitrary body returning *AddOrganizationFollowerResponse
func (c *ClientWithResponses) AddOrganizationFollowerWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationFollowerResponse, error) {
	rsp, err := c.AddOrganizationFollowerWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationFollowerResponse(rsp)
}

func (c *ClientWithResponses) AddOrganizationFollowerWithResponse(ctx context.Context, id int, body AddOrganizationFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationFollowerResponse, error) {
	rsp, err := c.AddOrganizationFollower(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationFollowerResponse(rsp)
}

// GetOrganizationFollowersChangelogWithResponse request returning *GetOrganizationFollowersChangelogResponse
func (c *ClientWithResponses) GetOrganizationFollowersChangelogWithResponse(ctx context.Context, id int, params *GetOrganizationFollowersChangelogParams, reqEditors ...RequestEditorFn) (*GetOrganizationFollowersChangelogResponse, error) {
	rsp, err := c.GetOrganizationFollowersChangelog(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationFollowersChangelogResponse(rsp)
}

// DeleteOrganizationFollowerWithResponse request returning *DeleteOrganizationFollowerResponse
func (c *ClientWithResponses) DeleteOrganizationFollowerWithResponse(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*DeleteOrganizationFollowerResponse, error) {
	rsp, err := c.DeleteOrganizationFollower(ctx, id, followerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationFollowerResponse(rsp)
}

// GetPersonFieldsWithResponse request returning *GetPersonFieldsResponse
func (c *ClientWithResponses) GetPersonFieldsWithResponse(ctx context.Context, params *GetPersonFieldsParams, reqEditors ...RequestEditorFn) (*GetPersonFieldsResponse, error) {
	rsp, err := c.GetPersonFields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonFieldsResponse(rsp)
}

// AddPersonFieldWithBodyWithResponse request with arbitrary body returning *AddPersonFieldResponse
func (c *ClientWithResponses) AddPersonFieldWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPersonFieldResponse, error) {
	rsp, err := c.AddPersonFieldWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPersonFieldResponse(rsp)
}

func (c *ClientWithResponses) AddPersonFieldWithResponse(ctx context.Context, body AddPersonFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPersonFieldResponse, error) {
	rsp, err := c.AddPersonField(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPersonFieldResponse(rsp)
}

// DeletePersonFieldWithResponse request returning *DeletePersonFieldResponse
func (c *ClientWithResponses) DeletePersonFieldWithResponse(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*DeletePersonFieldResponse, error) {
	rsp, err := c.DeletePersonField(ctx, fieldCode, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersonFieldResponse(rsp)
}

// GetPersonFieldWithResponse request returning *GetPersonFieldResponse
func (c *ClientWithResponses) GetPersonFieldWithResponse(ctx context.Context, fieldCode string, params *GetPersonFieldParams, reqEditors ...RequestEditorFn) (*GetPersonFieldResponse, error) {
	rsp, err := c.GetPersonField(ctx, fieldCode, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonFieldResponse(rsp)
}

// UpdatePersonFieldWithBodyWithResponse request with arbitrary body returning *UpdatePersonFieldResponse
func (c *ClientWithResponses) UpdatePersonFieldWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePersonFieldResponse, error) {
	rsp, err := c.UpdatePersonFieldWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePersonFieldResponse(rsp)
}

func (c *ClientWithResponses) UpdatePersonFieldWithResponse(ctx context.Context, fieldCode string, body UpdatePersonFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePersonFieldResponse, error) {
	rsp, err := c.UpdatePersonField(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePersonFieldResponse(rsp)
}

// DeletePersonFieldOptionsWithBodyWithResponse request with arbitrary body returning *DeletePersonFieldOptionsResponse
func (c *ClientWithResponses) DeletePersonFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePersonFieldOptionsResponse, error) {
	rsp, err := c.DeletePersonFieldOptionsWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersonFieldOptionsResponse(rsp)
}

func (c *ClientWithResponses) DeletePersonFieldOptionsWithResponse(ctx context.Context, fieldCode string, body DeletePersonFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePersonFieldOptionsResponse, error) {
	rsp, err := c.DeletePersonFieldOptions(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersonFieldOptionsResponse(rsp)
}

// UpdatePersonFieldOptionsWithBodyWithResponse request with arbitrary body returning *UpdatePersonFieldOptionsResponse
func (c *ClientWithResponses) UpdatePersonFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePersonFieldOptionsResponse, error) {
	rsp, err := c.UpdatePersonFieldOptionsWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePersonFieldOptionsResponse(rsp)
}

func (c *ClientWithResponses) UpdatePersonFieldOptionsWithResponse(ctx context.Context, fieldCode string, body UpdatePersonFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePersonFieldOptionsResponse, error) {
	rsp, err := c.UpdatePersonFieldOptions(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePersonFieldOptionsResponse(rsp)
}

// AddPersonFieldOptionsWithBodyWithResponse request with arbitrary body returning *AddPersonFieldOptionsResponse
func (c *ClientWithResponses) AddPersonFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPersonFieldOptionsResponse, error) {
	rsp, err := c.AddPersonFieldOptionsWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPersonFieldOptionsResponse(rsp)
}

func (c *ClientWithResponses) AddPersonFieldOptionsWithResponse(ctx context.Context, fieldCode string, body AddPersonFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPersonFieldOptionsResponse, error) {
	rsp, err := c.AddPersonFieldOptions(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPersonFieldOptionsResponse(rsp)
}

// GetPersonsWithResponse request returning *GetPersonsResponse
func (c *ClientWithResponses) GetPersonsWithResponse(ctx context.Context, params *GetPersonsParams, reqEditors ...RequestEditorFn) (*GetPersonsResponse, error) {
	rsp, err := c.GetPersons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonsResponse(rsp)
}

// AddPersonWithBodyWithResponse request with arbitrary body returning *AddPersonResponse
func (c *ClientWithResponses) AddPersonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPersonResponse, error) {
	rsp, err := c.AddPersonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPersonResponse(rsp)
}

func (c *ClientWithResponses) AddPersonWithResponse(ctx context.Context, body AddPersonJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPersonResponse, error) {
	rsp, err := c.AddPerson(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPersonResponse(rsp)
}

// SearchPersonsWithResponse request returning *SearchPersonsResponse
func (c *ClientWithResponses) SearchPersonsWithResponse(ctx context.Context, params *SearchPersonsParams, reqEditors ...RequestEditorFn) (*SearchPersonsResponse, error) {
	rsp, err := c.SearchPersons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPersonsResponse(rsp)
}

// DeletePersonWithResponse request returning *DeletePersonResponse
func (c *ClientWithResponses) DeletePersonWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeletePersonResponse, error) {
	rsp, err := c.DeletePerson(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersonResponse(rsp)
}

// GetPersonWithResponse request returning *GetPersonResponse
func (c *ClientWithResponses) GetPersonWithResponse(ctx context.Context, id int, params *GetPersonParams, reqEditors ...RequestEditorFn) (*GetPersonResponse, error) {
	rsp, err := c.GetPerson(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonResponse(rsp)
}

// UpdatePersonWithBodyWithResponse request with arbitrary body returning *UpdatePersonResponse
func (c *ClientWithResponses) UpdatePersonWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePersonResponse, error) {
	rsp, err := c.UpdatePersonWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePersonResponse(rsp)
}

func (c *ClientWithResponses) UpdatePersonWithResponse(ctx context.Context, id int, body UpdatePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePersonResponse, error) {
	rsp, err := c.UpdatePerson(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePersonResponse(rsp)
}

// GetPersonFollowersWithResponse request returning *GetPersonFollowersResponse
func (c *ClientWithResponses) GetPersonFollowersWithResponse(ctx context.Context, id int, params *GetPersonFollowersParams, reqEditors ...RequestEditorFn) (*GetPersonFollowersResponse, error) {
	rsp, err := c.GetPersonFollowers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonFollowersResponse(rsp)
}

// AddPersonFollowerWithBodyWithResponse request with arbitrary body returning *AddPersonFollowerResponse
func (c *ClientWithResponses) AddPersonFollowerWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPersonFollowerResponse, error) {
	rsp, err := c.AddPersonFollowerWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPersonFollowerResponse(rsp)
}

func (c *ClientWithResponses) AddPersonFollowerWithResponse(ctx context.Context, id int, body AddPersonFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPersonFollowerResponse, error) {
	rsp, err := c.AddPersonFollower(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPersonFollowerResponse(rsp)
}

// GetPersonFollowersChangelogWithResponse request returning *GetPersonFollowersChangelogResponse
func (c *ClientWithResponses) GetPersonFollowersChangelogWithResponse(ctx context.Context, id int, params *GetPersonFollowersChangelogParams, reqEditors ...RequestEditorFn) (*GetPersonFollowersChangelogResponse, error) {
	rsp, err := c.GetPersonFollowersChangelog(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonFollowersChangelogResponse(rsp)
}

// DeletePersonFollowerWithResponse request returning *DeletePersonFollowerResponse
func (c *ClientWithResponses) DeletePersonFollowerWithResponse(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*DeletePersonFollowerResponse, error) {
	rsp, err := c.DeletePersonFollower(ctx, id, followerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersonFollowerResponse(rsp)
}

// GetPersonPictureWithResponse request returning *GetPersonPictureResponse
func (c *ClientWithResponses) GetPersonPictureWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonPictureResponse, error) {
	rsp, err := c.GetPersonPicture(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonPictureResponse(rsp)
}

// GetPipelinesWithResponse request returning *GetPipelinesResponse
func (c *ClientWithResponses) GetPipelinesWithResponse(ctx context.Context, params *GetPipelinesParams, reqEditors ...RequestEditorFn) (*GetPipelinesResponse, error) {
	rsp, err := c.GetPipelines(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelinesResponse(rsp)
}

// AddPipelineWithBodyWithResponse request with arbitrary body returning *AddPipelineResponse
func (c *ClientWithResponses) AddPipelineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPipelineResponse, error) {
	rsp, err := c.AddPipelineWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPipelineResponse(rsp)
}

func (c *ClientWithResponses) AddPipelineWithResponse(ctx context.Context, body AddPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPipelineResponse, error) {
	rsp, err := c.AddPipeline(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPipelineResponse(rsp)
}

// DeletePipelineWithResponse request returning *DeletePipelineResponse
func (c *ClientWithResponses) DeletePipelineWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeletePipelineResponse, error) {
	rsp, err := c.DeletePipeline(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePipelineResponse(rsp)
}

// GetPipelineWithResponse request returning *GetPipelineResponse
func (c *ClientWithResponses) GetPipelineWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPipelineResponse, error) {
	rsp, err := c.GetPipeline(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineResponse(rsp)
}

// UpdatePipelineWithBodyWithResponse request with arbitrary body returning *UpdatePipelineResponse
func (c *ClientWithResponses) UpdatePipelineWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePipelineResponse, error) {
	rsp, err := c.UpdatePipelineWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePipelineResponse(rsp)
}

func (c *ClientWithResponses) UpdatePipelineWithResponse(ctx context.Context, id int, body UpdatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePipelineResponse, error) {
	rsp, err := c.UpdatePipeline(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePipelineResponse(rsp)
}

// GetProductFieldsWithResponse request returning *GetProductFieldsResponse
func (c *ClientWithResponses) GetProductFieldsWithResponse(ctx context.Context, params *GetProductFieldsParams, reqEditors ...RequestEditorFn) (*GetProductFieldsResponse, error) {
	rsp, err := c.GetProductFields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductFieldsResponse(rsp)
}

// AddProductFieldWithBodyWithResponse request with arbitrary body returning *AddProductFieldResponse
func (c *ClientWithResponses) AddProductFieldWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProductFieldResponse, error) {
	rsp, err := c.AddProductFieldWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProductFieldResponse(rsp)
}

func (c *ClientWithResponses) AddProductFieldWithResponse(ctx context.Context, body AddProductFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProductFieldResponse, error) {
	rsp, err := c.AddProductField(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProductFieldResponse(rsp)
}

// DeleteProductFieldWithResponse request returning *DeleteProductFieldResponse
func (c *ClientWithResponses) DeleteProductFieldWithResponse(ctx context.Context, fieldCode string, reqEditors ...RequestEditorFn) (*DeleteProductFieldResponse, error) {
	rsp, err := c.DeleteProductField(ctx, fieldCode, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductFieldResponse(rsp)
}

// GetProductFieldWithResponse request returning *GetProductFieldResponse
func (c *ClientWithResponses) GetProductFieldWithResponse(ctx context.Context, fieldCode string, params *GetProductFieldParams, reqEditors ...RequestEditorFn) (*GetProductFieldResponse, error) {
	rsp, err := c.GetProductField(ctx, fieldCode, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductFieldResponse(rsp)
}

// UpdateProductFieldWithBodyWithResponse request with arbitrary body returning *UpdateProductFieldResponse
func (c *ClientWithResponses) UpdateProductFieldWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductFieldResponse, error) {
	rsp, err := c.UpdateProductFieldWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductFieldResponse(rsp)
}

func (c *ClientWithResponses) UpdateProductFieldWithResponse(ctx context.Context, fieldCode string, body UpdateProductFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductFieldResponse, error) {
	rsp, err := c.UpdateProductField(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductFieldResponse(rsp)
}

// DeleteProductFieldOptionsWithBodyWithResponse request with arbitrary body returning *DeleteProductFieldOptionsResponse
func (c *ClientWithResponses) DeleteProductFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteProductFieldOptionsResponse, error) {
	rsp, err := c.DeleteProductFieldOptionsWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductFieldOptionsResponse(rsp)
}

func (c *ClientWithResponses) DeleteProductFieldOptionsWithResponse(ctx context.Context, fieldCode string, body DeleteProductFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteProductFieldOptionsResponse, error) {
	rsp, err := c.DeleteProductFieldOptions(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductFieldOptionsResponse(rsp)
}

// UpdateProductFieldOptionsWithBodyWithResponse request with arbitrary body returning *UpdateProductFieldOptionsResponse
func (c *ClientWithResponses) UpdateProductFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductFieldOptionsResponse, error) {
	rsp, err := c.UpdateProductFieldOptionsWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductFieldOptionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateProductFieldOptionsWithResponse(ctx context.Context, fieldCode string, body UpdateProductFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductFieldOptionsResponse, error) {
	rsp, err := c.UpdateProductFieldOptions(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductFieldOptionsResponse(rsp)
}

// AddProductFieldOptionsWithBodyWithResponse request with arbitrary body returning *AddProductFieldOptionsResponse
func (c *ClientWithResponses) AddProductFieldOptionsWithBodyWithResponse(ctx context.Context, fieldCode string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProductFieldOptionsResponse, error) {
	rsp, err := c.AddProductFieldOptionsWithBody(ctx, fieldCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProductFieldOptionsResponse(rsp)
}

func (c *ClientWithResponses) AddProductFieldOptionsWithResponse(ctx context.Context, fieldCode string, body AddProductFieldOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProductFieldOptionsResponse, error) {
	rsp, err := c.AddProductFieldOptions(ctx, fieldCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProductFieldOptionsResponse(rsp)
}

// GetProductsWithResponse request returning *GetProductsResponse
func (c *ClientWithResponses) GetProductsWithResponse(ctx context.Context, params *GetProductsParams, reqEditors ...RequestEditorFn) (*GetProductsResponse, error) {
	rsp, err := c.GetProducts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsResponse(rsp)
}

// AddProductWithBodyWithResponse request with arbitrary body returning *AddProductResponse
func (c *ClientWithResponses) AddProductWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProductResponse, error) {
	rsp, err := c.AddProductWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProductResponse(rsp)
}

func (c *ClientWithResponses) AddProductWithResponse(ctx context.Context, body AddProductJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProductResponse, error) {
	rsp, err := c.AddProduct(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProductResponse(rsp)
}

// SearchProductsWithResponse request returning *SearchProductsResponse
func (c *ClientWithResponses) SearchProductsWithResponse(ctx context.Context, params *SearchProductsParams, reqEditors ...RequestEditorFn) (*SearchProductsResponse, error) {
	rsp, err := c.SearchProducts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProductsResponse(rsp)
}

// DeleteProductWithResponse request returning *DeleteProductResponse
func (c *ClientWithResponses) DeleteProductWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteProductResponse, error) {
	rsp, err := c.DeleteProduct(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductResponse(rsp)
}

// GetProductWithResponse request returning *GetProductResponse
func (c *ClientWithResponses) GetProductWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProductResponse, error) {
	rsp, err := c.GetProduct(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductResponse(rsp)
}

// UpdateProductWithBodyWithResponse request with arbitrary body returning *UpdateProductResponse
func (c *ClientWithResponses) UpdateProductWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductResponse, error) {
	rsp, err := c.UpdateProductWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductResponse(rsp)
}

func (c *ClientWithResponses) UpdateProductWithResponse(ctx context.Context, id int, body UpdateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductResponse, error) {
	rsp, err := c.UpdateProduct(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductResponse(rsp)
}

// DuplicateProductWithResponse request returning *DuplicateProductResponse
func (c *ClientWithResponses) DuplicateProductWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DuplicateProductResponse, error) {
	rsp, err := c.DuplicateProduct(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuplicateProductResponse(rsp)
}

// GetProductFollowersWithResponse request returning *GetProductFollowersResponse
func (c *ClientWithResponses) GetProductFollowersWithResponse(ctx context.Context, id int, params *GetProductFollowersParams, reqEditors ...RequestEditorFn) (*GetProductFollowersResponse, error) {
	rsp, err := c.GetProductFollowers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductFollowersResponse(rsp)
}

// AddProductFollowerWithBodyWithResponse request with arbitrary body returning *AddProductFollowerResponse
func (c *ClientWithResponses) AddProductFollowerWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProductFollowerResponse, error) {
	rsp, err := c.AddProductFollowerWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProductFollowerResponse(rsp)
}

func (c *ClientWithResponses) AddProductFollowerWithResponse(ctx context.Context, id int, body AddProductFollowerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProductFollowerResponse, error) {
	rsp, err := c.AddProductFollower(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProductFollowerResponse(rsp)
}

// GetProductFollowersChangelogWithResponse request returning *GetProductFollowersChangelogResponse
func (c *ClientWithResponses) GetProductFollowersChangelogWithResponse(ctx context.Context, id int, params *GetProductFollowersChangelogParams, reqEditors ...RequestEditorFn) (*GetProductFollowersChangelogResponse, error) {
	rsp, err := c.GetProductFollowersChangelog(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductFollowersChangelogResponse(rsp)
}

// DeleteProductFollowerWithResponse request returning *DeleteProductFollowerResponse
func (c *ClientWithResponses) DeleteProductFollowerWithResponse(ctx context.Context, id int, followerId int, reqEditors ...RequestEditorFn) (*DeleteProductFollowerResponse, error) {
	rsp, err := c.DeleteProductFollower(ctx, id, followerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductFollowerResponse(rsp)
}

// DeleteProductImageWithResponse request returning *DeleteProductImageResponse
func (c *ClientWithResponses) DeleteProductImageWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteProductImageResponse, error) {
	rsp, err := c.DeleteProductImage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductImageResponse(rsp)
}

// GetProductImageWithResponse request returning *GetProductImageResponse
func (c *ClientWithResponses) GetProductImageWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProductImageResponse, error) {
	rsp, err := c.GetProductImage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductImageResponse(rsp)
}

// UploadProductImageWithBodyWithResponse request with arbitrary body returning *UploadProductImageResponse
func (c *ClientWithResponses) UploadProductImageWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadProductImageResponse, error) {
	rsp, err := c.UploadProductImageWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadProductImageResponse(rsp)
}

// UpdateProductImageWithBodyWithResponse request with arbitrary body returning *UpdateProductImageResponse
func (c *ClientWithResponses) UpdateProductImageWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductImageResponse, error) {
	rsp, err := c.UpdateProductImageWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductImageResponse(rsp)
}

// GetProductVariationsWithResponse request returning *GetProductVariationsResponse
func (c *ClientWithResponses) GetProductVariationsWithResponse(ctx context.Context, id int, params *GetProductVariationsParams, reqEditors ...RequestEditorFn) (*GetProductVariationsResponse, error) {
	rsp, err := c.GetProductVariations(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductVariationsResponse(rsp)
}

// AddProductVariationWithBodyWithResponse request with arbitrary body returning *AddProductVariationResponse
func (c *ClientWithResponses) AddProductVariationWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProductVariationResponse, error) {
	rsp, err := c.AddProductVariationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProductVariationResponse(rsp)
}

func (c *ClientWithResponses) AddProductVariationWithResponse(ctx context.Context, id int, body AddProductVariationJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProductVariationResponse, error) {
	rsp, err := c.AddProductVariation(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProductVariationResponse(rsp)
}

// DeleteProductVariationWithResponse request returning *DeleteProductVariationResponse
func (c *ClientWithResponses) DeleteProductVariationWithResponse(ctx context.Context, id int, productVariationId int, reqEditors ...RequestEditorFn) (*DeleteProductVariationResponse, error) {
	rsp, err := c.DeleteProductVariation(ctx, id, productVariationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductVariationResponse(rsp)
}

// UpdateProductVariationWithBodyWithResponse request with arbitrary body returning *UpdateProductVariationResponse
func (c *ClientWithResponses) UpdateProductVariationWithBodyWithResponse(ctx context.Context, id int, productVariationId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductVariationResponse, error) {
	rsp, err := c.UpdateProductVariationWithBody(ctx, id, productVariationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductVariationResponse(rsp)
}

func (c *ClientWithResponses) UpdateProductVariationWithResponse(ctx context.Context, id int, productVariationId int, body UpdateProductVariationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductVariationResponse, error) {
	rsp, err := c.UpdateProductVariation(ctx, id, productVariationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductVariationResponse(rsp)
}

// GetStagesWithResponse request returning *GetStagesResponse
func (c *ClientWithResponses) GetStagesWithResponse(ctx context.Context, params *GetStagesParams, reqEditors ...RequestEditorFn) (*GetStagesResponse, error) {
	rsp, err := c.GetStages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStagesResponse(rsp)
}

// AddStageWithBodyWithResponse request with arbitrary body returning *AddStageResponse
func (c *ClientWithResponses) AddStageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddStageResponse, error) {
	rsp, err := c.AddStageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddStageResponse(rsp)
}

func (c *ClientWithResponses) AddStageWithResponse(ctx context.Context, body AddStageJSONRequestBody, reqEditors ...RequestEditorFn) (*AddStageResponse, error) {
	rsp, err := c.AddStage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddStageResponse(rsp)
}

// DeleteStageWithResponse request returning *DeleteStageResponse
func (c *ClientWithResponses) DeleteStageWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteStageResponse, error) {
	rsp, err := c.DeleteStage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStageResponse(rsp)
}

// GetStageWithResponse request returning *GetStageResponse
func (c *ClientWithResponses) GetStageWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetStageResponse, error) {
	rsp, err := c.GetStage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStageResponse(rsp)
}

// UpdateStageWithBodyWithResponse request with arbitrary body returning *UpdateStageResponse
func (c *ClientWithResponses) UpdateStageWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStageResponse, error) {
	rsp, err := c.UpdateStageWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStageResponse(rsp)
}

func (c *ClientWithResponses) UpdateStageWithResponse(ctx context.Context, id int, body UpdateStageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStageResponse, error) {
	rsp, err := c.UpdateStage(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStageResponse(rsp)
}

// GetUserFollowersWithResponse request returning *GetUserFollowersResponse
func (c *ClientWithResponses) GetUserFollowersWithResponse(ctx context.Context, id int, params *GetUserFollowersParams, reqEditors ...RequestEditorFn) (*GetUserFollowersResponse, error) {
	rsp, err := c.GetUserFollowers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFollowersResponse(rsp)
}

// ParseGetActivitiesResponse parses an HTTP response from a GetActivitiesWithResponse call
func ParseGetActivitiesResponse(rsp *http.Response) (*GetActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Activities array
			Data *[]struct {
				// AddTime The creation date and time of the activity
				AddTime *string `json:"add_time,omitempty"`

				// Attendees The attendees of the activity
				Attendees *[]struct {
					// Email The email address of the attendee
					Email *string `json:"email,omitempty"`

					// IsOrganizer Whether the attendee is the organizer or not
					IsOrganizer *bool `json:"is_organizer,omitempty"`

					// Name The name of the attendee
					Name *string `json:"name,omitempty"`

					// PersonId The ID of the person if the attendee has a person record
					PersonId *int `json:"person_id,omitempty"`

					// Status The status of the attendee
					Status *string `json:"status,omitempty"`

					// UserId The ID of the user if the attendee is a user
					UserId *int `json:"user_id,omitempty"`
				} `json:"attendees,omitempty"`

				// Busy Whether the activity marks the assignee as busy or not in their calendar
				Busy *bool `json:"busy,omitempty"`

				// ConferenceMeetingClient The client used for the conference meeting
				ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

				// ConferenceMeetingId The ID of the conference meeting
				ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

				// ConferenceMeetingUrl The URL of the conference meeting
				ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

				// CreatorUserId The ID of the user who created the activity
				CreatorUserId *int `json:"creator_user_id,omitempty"`

				// DealId The ID of the deal linked to the activity
				DealId *int `json:"deal_id,omitempty"`

				// Done Whether the activity is marked as done or not
				Done *bool `json:"done,omitempty"`

				// DueDate The due date of the activity
				DueDate *string `json:"due_date,omitempty"`

				// DueTime The due time of the activity
				DueTime *string `json:"due_time,omitempty"`

				// Duration The duration of the activity
				Duration *string `json:"duration,omitempty"`

				// Id The ID of the activity
				Id *int `json:"id,omitempty"`

				// IsDeleted Whether the activity is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LeadId The ID of the lead linked to the activity
				LeadId *string `json:"lead_id,omitempty"`

				// Location Location of the activity
				Location *struct {
					// AdminAreaLevel1 Admin area level 1 (e.g. state) of the activity
					AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

					// AdminAreaLevel2 Admin area level 2 (e.g. county) of the activity
					AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

					// Country Country of the activity
					Country *string `json:"country,omitempty"`

					// Locality Locality (e.g. city) of the activity
					Locality *string `json:"locality,omitempty"`

					// PostalCode Postal code of the activity
					PostalCode *string `json:"postal_code,omitempty"`

					// Route Route (e.g. street) of the activity
					Route *string `json:"route,omitempty"`

					// StreetNumber Street number of the activity
					StreetNumber *string `json:"street_number,omitempty"`

					// Sublocality Sublocality (e.g. neighborhood) of the activity
					Sublocality *string `json:"sublocality,omitempty"`

					// Subpremise Subpremise (e.g. apartment/suite number) of the activity
					Subpremise *string `json:"subpremise,omitempty"`

					// Value The full address of the activity
					Value *string `json:"value,omitempty"`
				} `json:"location,omitempty"`

				// MarkedAsDoneTime The date and time when the activity was marked as done
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// Note The note of the activity
				Note *string `json:"note,omitempty"`

				// OrgId The ID of the organization linked to the activity
				OrgId *int `json:"org_id,omitempty"`

				// OwnerId The ID of the user who owns the activity
				OwnerId *int `json:"owner_id,omitempty"`

				// Participants The participants of the activity
				Participants *[]struct {
					// PersonId The ID of the person
					PersonId *int `json:"person_id,omitempty"`

					// Primary Whether the person is the primary participant or not
					Primary *bool `json:"primary,omitempty"`
				} `json:"participants,omitempty"`

				// PersonId The ID of the person linked to the activity
				PersonId *int `json:"person_id,omitempty"`

				// Priority The priority of the activity. Mappable to a specific string using activityFields API.
				Priority *int `json:"priority,omitempty"`

				// ProjectId The ID of the project linked to the activity
				ProjectId *int `json:"project_id,omitempty"`

				// PublicDescription The public description of the activity
				PublicDescription *string `json:"public_description,omitempty"`

				// Subject The subject of the activity
				Subject *string `json:"subject,omitempty"`

				// Type The type of the activity
				Type *string `json:"type,omitempty"`

				// UpdateTime The last updated date and time of the activity
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddActivityResponse parses an HTTP response from a AddActivityWithResponse call
func ParseAddActivityResponse(rsp *http.Response) (*AddActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The activity object
			Data *struct {
				// AddTime The creation date and time of the activity
				AddTime *string `json:"add_time,omitempty"`

				// Attendees The attendees of the activity
				Attendees *[]struct {
					// Email The email address of the attendee
					Email *string `json:"email,omitempty"`

					// IsOrganizer Whether the attendee is the organizer or not
					IsOrganizer *bool `json:"is_organizer,omitempty"`

					// Name The name of the attendee
					Name *string `json:"name,omitempty"`

					// PersonId The ID of the person if the attendee has a person record
					PersonId *int `json:"person_id,omitempty"`

					// Status The status of the attendee
					Status *string `json:"status,omitempty"`

					// UserId The ID of the user if the attendee is a user
					UserId *int `json:"user_id,omitempty"`
				} `json:"attendees,omitempty"`

				// Busy Whether the activity marks the assignee as busy or not in their calendar
				Busy *bool `json:"busy,omitempty"`

				// ConferenceMeetingClient The client used for the conference meeting
				ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

				// ConferenceMeetingId The ID of the conference meeting
				ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

				// ConferenceMeetingUrl The URL of the conference meeting
				ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

				// CreatorUserId The ID of the user who created the activity
				CreatorUserId *int `json:"creator_user_id,omitempty"`

				// DealId The ID of the deal linked to the activity
				DealId *int `json:"deal_id,omitempty"`

				// Done Whether the activity is marked as done or not
				Done *bool `json:"done,omitempty"`

				// DueDate The due date of the activity
				DueDate *string `json:"due_date,omitempty"`

				// DueTime The due time of the activity
				DueTime *string `json:"due_time,omitempty"`

				// Duration The duration of the activity
				Duration *string `json:"duration,omitempty"`

				// Id The ID of the activity
				Id *int `json:"id,omitempty"`

				// IsDeleted Whether the activity is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LeadId The ID of the lead linked to the activity
				LeadId *string `json:"lead_id,omitempty"`

				// Location Location of the activity
				Location *struct {
					// AdminAreaLevel1 Admin area level 1 (e.g. state) of the activity
					AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

					// AdminAreaLevel2 Admin area level 2 (e.g. county) of the activity
					AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

					// Country Country of the activity
					Country *string `json:"country,omitempty"`

					// Locality Locality (e.g. city) of the activity
					Locality *string `json:"locality,omitempty"`

					// PostalCode Postal code of the activity
					PostalCode *string `json:"postal_code,omitempty"`

					// Route Route (e.g. street) of the activity
					Route *string `json:"route,omitempty"`

					// StreetNumber Street number of the activity
					StreetNumber *string `json:"street_number,omitempty"`

					// Sublocality Sublocality (e.g. neighborhood) of the activity
					Sublocality *string `json:"sublocality,omitempty"`

					// Subpremise Subpremise (e.g. apartment/suite number) of the activity
					Subpremise *string `json:"subpremise,omitempty"`

					// Value The full address of the activity
					Value *string `json:"value,omitempty"`
				} `json:"location,omitempty"`

				// MarkedAsDoneTime The date and time when the activity was marked as done
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// Note The note of the activity
				Note *string `json:"note,omitempty"`

				// OrgId The ID of the organization linked to the activity
				OrgId *int `json:"org_id,omitempty"`

				// OwnerId The ID of the user who owns the activity
				OwnerId *int `json:"owner_id,omitempty"`

				// Participants The participants of the activity
				Participants *[]struct {
					// PersonId The ID of the person
					PersonId *int `json:"person_id,omitempty"`

					// Primary Whether the person is the primary participant or not
					Primary *bool `json:"primary,omitempty"`
				} `json:"participants,omitempty"`

				// PersonId The ID of the person linked to the activity
				PersonId *int `json:"person_id,omitempty"`

				// Priority The priority of the activity. Mappable to a specific string using activityFields API.
				Priority *int `json:"priority,omitempty"`

				// ProjectId The ID of the project linked to the activity
				ProjectId *int `json:"project_id,omitempty"`

				// PublicDescription The public description of the activity
				PublicDescription *string `json:"public_description,omitempty"`

				// Subject The subject of the activity
				Subject *string `json:"subject,omitempty"`

				// Type The type of the activity
				Type *string `json:"type,omitempty"`

				// UpdateTime The last updated date and time of the activity
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteActivityResponse parses an HTTP response from a DeleteActivityWithResponse call
func ParseDeleteActivityResponse(rsp *http.Response) (*DeleteActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id Deleted activity ID
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetActivityResponse parses an HTTP response from a GetActivityWithResponse call
func ParseGetActivityResponse(rsp *http.Response) (*GetActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The activity object
			Data *struct {
				// AddTime The creation date and time of the activity
				AddTime *string `json:"add_time,omitempty"`

				// Attendees The attendees of the activity
				Attendees *[]struct {
					// Email The email address of the attendee
					Email *string `json:"email,omitempty"`

					// IsOrganizer Whether the attendee is the organizer or not
					IsOrganizer *bool `json:"is_organizer,omitempty"`

					// Name The name of the attendee
					Name *string `json:"name,omitempty"`

					// PersonId The ID of the person if the attendee has a person record
					PersonId *int `json:"person_id,omitempty"`

					// Status The status of the attendee
					Status *string `json:"status,omitempty"`

					// UserId The ID of the user if the attendee is a user
					UserId *int `json:"user_id,omitempty"`
				} `json:"attendees,omitempty"`

				// Busy Whether the activity marks the assignee as busy or not in their calendar
				Busy *bool `json:"busy,omitempty"`

				// ConferenceMeetingClient The client used for the conference meeting
				ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

				// ConferenceMeetingId The ID of the conference meeting
				ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

				// ConferenceMeetingUrl The URL of the conference meeting
				ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

				// CreatorUserId The ID of the user who created the activity
				CreatorUserId *int `json:"creator_user_id,omitempty"`

				// DealId The ID of the deal linked to the activity
				DealId *int `json:"deal_id,omitempty"`

				// Done Whether the activity is marked as done or not
				Done *bool `json:"done,omitempty"`

				// DueDate The due date of the activity
				DueDate *string `json:"due_date,omitempty"`

				// DueTime The due time of the activity
				DueTime *string `json:"due_time,omitempty"`

				// Duration The duration of the activity
				Duration *string `json:"duration,omitempty"`

				// Id The ID of the activity
				Id *int `json:"id,omitempty"`

				// IsDeleted Whether the activity is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LeadId The ID of the lead linked to the activity
				LeadId *string `json:"lead_id,omitempty"`

				// Location Location of the activity
				Location *struct {
					// AdminAreaLevel1 Admin area level 1 (e.g. state) of the activity
					AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

					// AdminAreaLevel2 Admin area level 2 (e.g. county) of the activity
					AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

					// Country Country of the activity
					Country *string `json:"country,omitempty"`

					// Locality Locality (e.g. city) of the activity
					Locality *string `json:"locality,omitempty"`

					// PostalCode Postal code of the activity
					PostalCode *string `json:"postal_code,omitempty"`

					// Route Route (e.g. street) of the activity
					Route *string `json:"route,omitempty"`

					// StreetNumber Street number of the activity
					StreetNumber *string `json:"street_number,omitempty"`

					// Sublocality Sublocality (e.g. neighborhood) of the activity
					Sublocality *string `json:"sublocality,omitempty"`

					// Subpremise Subpremise (e.g. apartment/suite number) of the activity
					Subpremise *string `json:"subpremise,omitempty"`

					// Value The full address of the activity
					Value *string `json:"value,omitempty"`
				} `json:"location,omitempty"`

				// MarkedAsDoneTime The date and time when the activity was marked as done
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// Note The note of the activity
				Note *string `json:"note,omitempty"`

				// OrgId The ID of the organization linked to the activity
				OrgId *int `json:"org_id,omitempty"`

				// OwnerId The ID of the user who owns the activity
				OwnerId *int `json:"owner_id,omitempty"`

				// Participants The participants of the activity
				Participants *[]struct {
					// PersonId The ID of the person
					PersonId *int `json:"person_id,omitempty"`

					// Primary Whether the person is the primary participant or not
					Primary *bool `json:"primary,omitempty"`
				} `json:"participants,omitempty"`

				// PersonId The ID of the person linked to the activity
				PersonId *int `json:"person_id,omitempty"`

				// Priority The priority of the activity. Mappable to a specific string using activityFields API.
				Priority *int `json:"priority,omitempty"`

				// ProjectId The ID of the project linked to the activity
				ProjectId *int `json:"project_id,omitempty"`

				// PublicDescription The public description of the activity
				PublicDescription *string `json:"public_description,omitempty"`

				// Subject The subject of the activity
				Subject *string `json:"subject,omitempty"`

				// Type The type of the activity
				Type *string `json:"type,omitempty"`

				// UpdateTime The last updated date and time of the activity
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateActivityResponse parses an HTTP response from a UpdateActivityWithResponse call
func ParseUpdateActivityResponse(rsp *http.Response) (*UpdateActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The activity object
			Data *struct {
				// AddTime The creation date and time of the activity
				AddTime *string `json:"add_time,omitempty"`

				// Attendees The attendees of the activity
				Attendees *[]struct {
					// Email The email address of the attendee
					Email *string `json:"email,omitempty"`

					// IsOrganizer Whether the attendee is the organizer or not
					IsOrganizer *bool `json:"is_organizer,omitempty"`

					// Name The name of the attendee
					Name *string `json:"name,omitempty"`

					// PersonId The ID of the person if the attendee has a person record
					PersonId *int `json:"person_id,omitempty"`

					// Status The status of the attendee
					Status *string `json:"status,omitempty"`

					// UserId The ID of the user if the attendee is a user
					UserId *int `json:"user_id,omitempty"`
				} `json:"attendees,omitempty"`

				// Busy Whether the activity marks the assignee as busy or not in their calendar
				Busy *bool `json:"busy,omitempty"`

				// ConferenceMeetingClient The client used for the conference meeting
				ConferenceMeetingClient *string `json:"conference_meeting_client,omitempty"`

				// ConferenceMeetingId The ID of the conference meeting
				ConferenceMeetingId *string `json:"conference_meeting_id,omitempty"`

				// ConferenceMeetingUrl The URL of the conference meeting
				ConferenceMeetingUrl *string `json:"conference_meeting_url,omitempty"`

				// CreatorUserId The ID of the user who created the activity
				CreatorUserId *int `json:"creator_user_id,omitempty"`

				// DealId The ID of the deal linked to the activity
				DealId *int `json:"deal_id,omitempty"`

				// Done Whether the activity is marked as done or not
				Done *bool `json:"done,omitempty"`

				// DueDate The due date of the activity
				DueDate *string `json:"due_date,omitempty"`

				// DueTime The due time of the activity
				DueTime *string `json:"due_time,omitempty"`

				// Duration The duration of the activity
				Duration *string `json:"duration,omitempty"`

				// Id The ID of the activity
				Id *int `json:"id,omitempty"`

				// IsDeleted Whether the activity is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LeadId The ID of the lead linked to the activity
				LeadId *string `json:"lead_id,omitempty"`

				// Location Location of the activity
				Location *struct {
					// AdminAreaLevel1 Admin area level 1 (e.g. state) of the activity
					AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

					// AdminAreaLevel2 Admin area level 2 (e.g. county) of the activity
					AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

					// Country Country of the activity
					Country *string `json:"country,omitempty"`

					// Locality Locality (e.g. city) of the activity
					Locality *string `json:"locality,omitempty"`

					// PostalCode Postal code of the activity
					PostalCode *string `json:"postal_code,omitempty"`

					// Route Route (e.g. street) of the activity
					Route *string `json:"route,omitempty"`

					// StreetNumber Street number of the activity
					StreetNumber *string `json:"street_number,omitempty"`

					// Sublocality Sublocality (e.g. neighborhood) of the activity
					Sublocality *string `json:"sublocality,omitempty"`

					// Subpremise Subpremise (e.g. apartment/suite number) of the activity
					Subpremise *string `json:"subpremise,omitempty"`

					// Value The full address of the activity
					Value *string `json:"value,omitempty"`
				} `json:"location,omitempty"`

				// MarkedAsDoneTime The date and time when the activity was marked as done
				MarkedAsDoneTime *string `json:"marked_as_done_time,omitempty"`

				// Note The note of the activity
				Note *string `json:"note,omitempty"`

				// OrgId The ID of the organization linked to the activity
				OrgId *int `json:"org_id,omitempty"`

				// OwnerId The ID of the user who owns the activity
				OwnerId *int `json:"owner_id,omitempty"`

				// Participants The participants of the activity
				Participants *[]struct {
					// PersonId The ID of the person
					PersonId *int `json:"person_id,omitempty"`

					// Primary Whether the person is the primary participant or not
					Primary *bool `json:"primary,omitempty"`
				} `json:"participants,omitempty"`

				// PersonId The ID of the person linked to the activity
				PersonId *int `json:"person_id,omitempty"`

				// Priority The priority of the activity. Mappable to a specific string using activityFields API.
				Priority *int `json:"priority,omitempty"`

				// ProjectId The ID of the project linked to the activity
				ProjectId *int `json:"project_id,omitempty"`

				// PublicDescription The public description of the activity
				PublicDescription *string `json:"public_description,omitempty"`

				// Subject The subject of the activity
				Subject *string `json:"subject,omitempty"`

				// Type The type of the activity
				Type *string `json:"type,omitempty"`

				// UpdateTime The last updated date and time of the activity
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetActivityFieldsResponse parses an HTTP response from a GetActivityFieldsWithResponse call
func ParseGetActivityFieldsResponse(rsp *http.Response) (*GetActivityFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// NextCursor Base64url-encoded cursor for fetching the next page of results, null if no more pages
				NextCursor *string `json:"next_cursor"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType GetActivityFields200DataFieldType `json:"field_type"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view (read-only)
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetActivityFieldResponse parses an HTTP response from a GetActivityFieldWithResponse call
func ParseGetActivityFieldResponse(rsp *http.Response) (*GetActivityFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType GetActivityField200DataFieldType `json:"field_type"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view (read-only)
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealFieldsResponse parses an HTTP response from a GetDealFieldsWithResponse call
func ParseGetDealFieldsResponse(rsp *http.Response) (*GetDealFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// NextCursor Base64url-encoded cursor for fetching the next page of results, null if no more pages
				NextCursor *string `json:"next_cursor"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// Description The description of the field
				Description string `json:"description"`

				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType GetDealFields200DataFieldType `json:"field_type"`

				// ImportantFields Important fields configuration
				ImportantFields *struct {
					// Enabled Whether the field is marked as important
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of stage IDs where the field is important
					StageIds *[]int `json:"stage_ids,omitempty"`
				} `json:"important_fields,omitempty"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// RequiredFields Required fields configuration
				RequiredFields *struct {
					// Enabled Whether the field is required
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of stage IDs where the field is required
					StageIds *[]int `json:"stage_ids,omitempty"`

					// Statuses Pipeline-specific status requirements, mapping pipeline ID to array of statuses
					Statuses *map[string][]GetDealFields200DataRequiredFieldsStatuses `json:"statuses,omitempty"`
				} `json:"required_fields,omitempty"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

					// ProjectsDetailVisibleFlag Whether the field is shown in project details view
					ProjectsDetailVisibleFlag *bool `json:"projects_detail_visible_flag,omitempty"`

					// ShowInPipelines Pipeline visibility configuration
					ShowInPipelines *struct {
						// PipelineIds Specific pipeline IDs where the field is shown (if show_in_all is false)
						PipelineIds *[]int `json:"pipeline_ids,omitempty"`

						// ShowInAll Whether the field is shown in all pipelines
						ShowInAll *bool `json:"show_in_all,omitempty"`
					} `json:"show_in_pipelines,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddDealFieldResponse parses an HTTP response from a AddDealFieldWithResponse call
func ParseAddDealFieldResponse(rsp *http.Response) (*AddDealFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDealFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Description The description of the field
				Description string `json:"description"`

				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType AddDealField200DataFieldType `json:"field_type"`

				// ImportantFields Important fields configuration
				ImportantFields *struct {
					// Enabled Whether the field is marked as important
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of stage IDs where the field is important
					StageIds *[]int `json:"stage_ids,omitempty"`
				} `json:"important_fields,omitempty"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// RequiredFields Required fields configuration
				RequiredFields *struct {
					// Enabled Whether the field is required
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of stage IDs where the field is required
					StageIds *[]int `json:"stage_ids,omitempty"`

					// Statuses Pipeline-specific status requirements, mapping pipeline ID to array of statuses
					Statuses *map[string][]AddDealField200DataRequiredFieldsStatuses `json:"statuses,omitempty"`
				} `json:"required_fields,omitempty"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

					// ProjectsDetailVisibleFlag Whether the field is shown in project details view
					ProjectsDetailVisibleFlag *bool `json:"projects_detail_visible_flag,omitempty"`

					// ShowInPipelines Pipeline visibility configuration
					ShowInPipelines *struct {
						// PipelineIds Specific pipeline IDs where the field is shown (if show_in_all is false)
						PipelineIds *[]int `json:"pipeline_ids,omitempty"`

						// ShowInAll Whether the field is shown in all pipelines
						ShowInAll *bool `json:"show_in_all,omitempty"`
					} `json:"show_in_pipelines,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDealFieldResponse parses an HTTP response from a DeleteDealFieldWithResponse call
func ParseDeleteDealFieldResponse(rsp *http.Response) (*DeleteDealFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDealFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Description The description of the field
				Description string `json:"description"`

				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType string `json:"field_type"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]map[string]interface{} `json:"options"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]map[string]interface{} `json:"subfields"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealFieldResponse parses an HTTP response from a GetDealFieldWithResponse call
func ParseGetDealFieldResponse(rsp *http.Response) (*GetDealFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Description The description of the field
				Description string `json:"description"`

				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType GetDealField200DataFieldType `json:"field_type"`

				// ImportantFields Important fields configuration
				ImportantFields *struct {
					// Enabled Whether the field is marked as important
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of stage IDs where the field is important
					StageIds *[]int `json:"stage_ids,omitempty"`
				} `json:"important_fields,omitempty"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// RequiredFields Required fields configuration
				RequiredFields *struct {
					// Enabled Whether the field is required
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of stage IDs where the field is required
					StageIds *[]int `json:"stage_ids,omitempty"`

					// Statuses Pipeline-specific status requirements, mapping pipeline ID to array of statuses
					Statuses *map[string][]GetDealField200DataRequiredFieldsStatuses `json:"statuses,omitempty"`
				} `json:"required_fields,omitempty"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

					// ProjectsDetailVisibleFlag Whether the field is shown in project details view
					ProjectsDetailVisibleFlag *bool `json:"projects_detail_visible_flag,omitempty"`

					// ShowInPipelines Pipeline visibility configuration
					ShowInPipelines *struct {
						// PipelineIds Specific pipeline IDs where the field is shown (if show_in_all is false)
						PipelineIds *[]int `json:"pipeline_ids,omitempty"`

						// ShowInAll Whether the field is shown in all pipelines
						ShowInAll *bool `json:"show_in_all,omitempty"`
					} `json:"show_in_pipelines,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDealFieldResponse parses an HTTP response from a UpdateDealFieldWithResponse call
func ParseUpdateDealFieldResponse(rsp *http.Response) (*UpdateDealFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDealFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Description The description of the field
				Description string `json:"description"`

				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType UpdateDealField200DataFieldType `json:"field_type"`

				// ImportantFields Important fields configuration
				ImportantFields *struct {
					// Enabled Whether the field is marked as important
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of stage IDs where the field is important
					StageIds *[]int `json:"stage_ids,omitempty"`
				} `json:"important_fields,omitempty"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// RequiredFields Required fields configuration
				RequiredFields *struct {
					// Enabled Whether the field is required
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of stage IDs where the field is required
					StageIds *[]int `json:"stage_ids,omitempty"`

					// Statuses Pipeline-specific status requirements, mapping pipeline ID to array of statuses
					Statuses *map[string][]UpdateDealField200DataRequiredFieldsStatuses `json:"statuses,omitempty"`
				} `json:"required_fields,omitempty"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

					// ProjectsDetailVisibleFlag Whether the field is shown in project details view
					ProjectsDetailVisibleFlag *bool `json:"projects_detail_visible_flag,omitempty"`

					// ShowInPipelines Pipeline visibility configuration
					ShowInPipelines *struct {
						// PipelineIds Specific pipeline IDs where the field is shown (if show_in_all is false)
						PipelineIds *[]int `json:"pipeline_ids,omitempty"`

						// ShowInAll Whether the field is shown in all pipelines
						ShowInAll *bool `json:"show_in_all,omitempty"`
					} `json:"show_in_pipelines,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDealFieldOptionsResponse parses an HTTP response from a DeleteDealFieldOptionsWithResponse call
func ParseDeleteDealFieldOptionsResponse(rsp *http.Response) (*DeleteDealFieldOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDealFieldOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id The unique identifier of the option
				Id int `json:"id"`

				// Label The display label of the option
				Label string `json:"label"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDealFieldOptionsResponse parses an HTTP response from a UpdateDealFieldOptionsWithResponse call
func ParseUpdateDealFieldOptionsResponse(rsp *http.Response) (*UpdateDealFieldOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDealFieldOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id The unique identifier of the option
				Id int `json:"id"`

				// Label The display label of the option
				Label string `json:"label"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddDealFieldOptionsResponse parses an HTTP response from a AddDealFieldOptionsWithResponse call
func ParseAddDealFieldOptionsResponse(rsp *http.Response) (*AddDealFieldOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDealFieldOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id The unique identifier of the option
				Id int `json:"id"`

				// Label The display label of the option
				Label string `json:"label"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealsResponse parses an HTTP response from a GetDealsWithResponse call
func ParseGetDealsResponse(rsp *http.Response) (*GetDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Deals array
			Data *[]struct {
				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// IsDeleted Whether the deal is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LabelIds The IDs of labels assigned to the deal
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// OrgId The ID of the organization linked to the deal
				OrgId *int `json:"org_id,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerId The ID of the user who owns the deal
				OwnerId *int `json:"owner_id,omitempty"`

				// PersonId The ID of the person linked to the deal
				PersonId *int `json:"person_id,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *int `json:"visible_to,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddDealResponse parses an HTTP response from a AddDealWithResponse call
func ParseAddDealResponse(rsp *http.Response) (*AddDealResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDealResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The deal object
			Data *struct {
				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// IsDeleted Whether the deal is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LabelIds The IDs of labels assigned to the deal
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// OrgId The ID of the organization linked to the deal
				OrgId *int `json:"org_id,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerId The ID of the user who owns the deal
				OwnerId *int `json:"owner_id,omitempty"`

				// PersonId The ID of the person linked to the deal
				PersonId *int `json:"person_id,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *int `json:"visible_to,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetArchivedDealsResponse parses an HTTP response from a GetArchivedDealsWithResponse call
func ParseGetArchivedDealsResponse(rsp *http.Response) (*GetArchivedDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArchivedDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Deals array
			Data *[]struct {
				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// IsDeleted Whether the deal is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LabelIds The IDs of labels assigned to the deal
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// OrgId The ID of the organization linked to the deal
				OrgId *int `json:"org_id,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerId The ID of the user who owns the deal
				OwnerId *int `json:"owner_id,omitempty"`

				// PersonId The ID of the person linked to the deal
				PersonId *int `json:"person_id,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *int `json:"visible_to,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInstallmentsResponse parses an HTTP response from a GetInstallmentsWithResponse call
func ParseGetInstallmentsResponse(rsp *http.Response) (*GetInstallmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstallmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Array containing data for all installments added to a deal
			Data *[]struct {
				// Amount The installment amount.
				Amount *float32 `json:"amount,omitempty"`

				// BillingDate The date which the installment will be charged.
				BillingDate *string `json:"billing_date,omitempty"`

				// DealId The ID of the deal the installment was added to.
				DealId *int `json:"deal_id,omitempty"`

				// Description The name of installment.
				Description *string `json:"description,omitempty"`

				// Id The ID of the installment
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealsProductsResponse parses an HTTP response from a GetDealsProductsWithResponse call
func ParseGetDealsProductsResponse(rsp *http.Response) (*GetDealsProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealsProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData Pagination related data
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Array containing data for all products attached to deals
			Data *[]struct {
				// AddTime The date and time when the product was added to the deal
				AddTime *string `json:"add_time,omitempty"`

				// BillingFrequency Only available in Growth and above plans
				//
				// How often a customer is billed for access to a service or product
				//
				// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
				//
				// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
				BillingFrequency *GetDealsProducts200DataBillingFrequency `json:"billing_frequency,omitempty"`

				// BillingFrequencyCycles Only available in Growth and above plans
				//
				// The number of times the billing frequency repeats for a product in a deal
				//
				// When `billing_frequency` is set to `one-time`, this field must be `null`
				//
				// When `billing_frequency` is set to `weekly`, this field cannot be `null`
				//
				// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
				//
				// Must be a positive integer less or equal to 208
				BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

				// BillingStartDate Only available in Growth and above plans
				//
				// The billing start date. Must be between 10 years in the past and 10 years in the future
				BillingStartDate *string `json:"billing_start_date"`

				// Comments The comments of the product
				Comments *string `json:"comments,omitempty"`

				// Currency The currency associated with the deal product
				Currency *string `json:"currency,omitempty"`

				// DealId The ID of the deal
				DealId *int `json:"deal_id,omitempty"`

				// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
				Discount *float32 `json:"discount,omitempty"`

				// DiscountType The type of the discount's value
				DiscountType *GetDealsProducts200DataDiscountType `json:"discount_type,omitempty"`

				// Id The ID of the deal-product (the ID of the product attached to the deal)
				Id *int `json:"id,omitempty"`

				// IsEnabled Whether this product is enabled for the deal
				IsEnabled *bool `json:"is_enabled,omitempty"`

				// ItemPrice The price value of the product
				ItemPrice *float32 `json:"item_price,omitempty"`

				// Name The product name
				Name *string `json:"name,omitempty"`

				// OrderNr The order number of the product within the deal
				OrderNr *int `json:"order_nr"`

				// ProductId The ID of the product
				ProductId *int `json:"product_id,omitempty"`

				// ProductVariationId The ID of the product variation
				ProductVariationId *int `json:"product_variation_id"`

				// Quantity The quantity of the product
				Quantity *int `json:"quantity,omitempty"`

				// Sum The sum of all the products attached to the deal
				Sum *float32 `json:"sum,omitempty"`

				// Tax The product tax
				Tax *float32 `json:"tax,omitempty"`

				// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
				TaxMethod *GetDealsProducts200DataTaxMethod `json:"tax_method,omitempty"`

				// UpdateTime The date and time when the deal product was last updated
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchDealsResponse parses an HTTP response from a SearchDealsWithResponse call
func ParseSearchDealsResponse(rsp *http.Response) (*SearchDealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData Pagination related data
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *struct {
				// Items The array of deals
				Items *[]struct {
					Item *struct {
						// Currency The currency of the deal
						Currency *string `json:"currency,omitempty"`

						// CustomFields Custom fields
						CustomFields *[]string `json:"custom_fields,omitempty"`

						// Id The ID of the deal
						Id *int `json:"id,omitempty"`

						// IsArchived A flag indicating whether the deal is archived or not
						IsArchived *bool `json:"is_archived,omitempty"`

						// Notes An array of notes
						Notes        *[]string `json:"notes,omitempty"`
						Organization *struct {
							// Id The ID of the organization the deal is associated with
							Id *int `json:"id,omitempty"`

							// Name The name of the organization the deal is associated with
							Name *string `json:"name,omitempty"`
						} `json:"organization"`
						Owner *struct {
							// Id The ID of the owner of the deal
							Id *int `json:"id,omitempty"`
						} `json:"owner,omitempty"`
						Person *struct {
							// Id The ID of the person the deal is associated with
							Id *int `json:"id,omitempty"`

							// Name The name of the person the deal is associated with
							Name *string `json:"name,omitempty"`
						} `json:"person"`
						Stage *struct {
							// Id The ID of the stage of the deal
							Id *int `json:"id,omitempty"`

							// Name The name of the stage of the deal
							Name *string `json:"name,omitempty"`
						} `json:"stage,omitempty"`

						// Status The status of the deal
						Status *string `json:"status,omitempty"`

						// Title The title of the deal
						Title *string `json:"title,omitempty"`

						// Type The type of the item
						Type *string `json:"type,omitempty"`

						// Value The value of the deal
						Value *int `json:"value,omitempty"`

						// VisibleTo The visibility of the deal
						VisibleTo *int `json:"visible_to,omitempty"`
					} `json:"item,omitempty"`

					// ResultScore Search result relevancy
					ResultScore *float32 `json:"result_score,omitempty"`
				} `json:"items,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDealResponse parses an HTTP response from a DeleteDealWithResponse call
func ParseDeleteDealResponse(rsp *http.Response) (*DeleteDealResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDealResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id Deleted deal ID
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealResponse parses an HTTP response from a GetDealWithResponse call
func ParseGetDealResponse(rsp *http.Response) (*GetDealResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The deal object
			Data *struct {
				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// IsDeleted Whether the deal is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LabelIds The IDs of labels assigned to the deal
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// OrgId The ID of the organization linked to the deal
				OrgId *int `json:"org_id,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerId The ID of the user who owns the deal
				OwnerId *int `json:"owner_id,omitempty"`

				// PersonId The ID of the person linked to the deal
				PersonId *int `json:"person_id,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *int `json:"visible_to,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDealResponse parses an HTTP response from a UpdateDealWithResponse call
func ParseUpdateDealResponse(rsp *http.Response) (*UpdateDealResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDealResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The deal object
			Data *struct {
				// Acv Only available in Growth and above plans
				//
				// The Annual Contract Value of the deal
				//
				// Null if there are no products attached to the deal
				Acv *float32 `json:"acv"`

				// AddTime The creation date and time of the deal
				AddTime *string `json:"add_time,omitempty"`

				// Arr Only available in Growth and above plans
				//
				// The Annual Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Arr *float32 `json:"arr"`

				// Channel The ID of your Marketing channel this Deal was created from. Recognized Marketing channels can be configured in your <a href="https://app.pipedrive.com/settings/fields" target="_blank" rel="noopener noreferrer">Company settings</a>.
				Channel *int `json:"channel"`

				// ChannelId The optional ID to further distinguish the Marketing channel.
				ChannelId *string `json:"channel_id"`

				// CloseTime The date and time of closing the deal
				CloseTime *string `json:"close_time"`

				// Currency The currency associated with the deal
				Currency *string `json:"currency,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// ExpectedCloseDate The expected close date of the deal
				ExpectedCloseDate *openapi_types.Date `json:"expected_close_date,omitempty"`

				// Id The ID of the deal
				Id *int `json:"id,omitempty"`

				// IsArchived Whether the deal is archived or not
				IsArchived *bool `json:"is_archived,omitempty"`

				// IsDeleted Whether the deal is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LabelIds The IDs of labels assigned to the deal
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LostReason The reason for losing the deal
				LostReason *string `json:"lost_reason"`

				// LostTime The date and time of changing the deal status as lost
				LostTime *string `json:"lost_time,omitempty"`

				// Mrr Only available in Growth and above plans
				//
				// The Monthly Recurring Revenue of the deal
				//
				// Null if there are no products attached to the deal
				Mrr *float32 `json:"mrr"`

				// OrgId The ID of the organization linked to the deal
				OrgId *int `json:"org_id,omitempty"`

				// Origin The way this Deal was created. `origin` field is set by Pipedrive when Deal is created and cannot be changed.
				Origin *string `json:"origin,omitempty"`

				// OriginId The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this Deal.
				OriginId *string `json:"origin_id"`

				// OwnerId The ID of the user who owns the deal
				OwnerId *int `json:"owner_id,omitempty"`

				// PersonId The ID of the person linked to the deal
				PersonId *int `json:"person_id,omitempty"`

				// PipelineId The ID of the pipeline associated with the deal
				PipelineId *int `json:"pipeline_id,omitempty"`

				// Probability The success probability percentage of the deal
				Probability *float32 `json:"probability"`

				// StageChangeTime The last updated date and time of the deal stage
				StageChangeTime *string `json:"stage_change_time,omitempty"`

				// StageId The ID of the deal stage
				StageId *int `json:"stage_id,omitempty"`

				// Status The status of the deal
				Status *string `json:"status,omitempty"`

				// Title The title of the deal
				Title *string `json:"title,omitempty"`

				// UpdateTime The last updated date and time of the deal
				UpdateTime *string `json:"update_time,omitempty"`

				// Value The value of the deal
				Value *float32 `json:"value,omitempty"`

				// VisibleTo The visibility of the deal
				VisibleTo *int `json:"visible_to,omitempty"`

				// WonTime The date and time of changing the deal status as won
				WonTime *string `json:"won_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConvertDealToLeadResponse parses an HTTP response from a ConvertDealToLeadWithResponse call
func ParseConvertDealToLeadResponse(rsp *http.Response) (*ConvertDealToLeadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertDealToLeadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`

			// Data An object containing conversion job id that performs the conversion
			Data *struct {
				// ConversionId The ID of the conversion job that can be used to retrieve conversion status and details. The ID has UUID format.
				ConversionId openapi_types.UUID `json:"conversion_id"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDealConversionStatusResponse parses an HTTP response from a GetDealConversionStatusWithResponse call
func ParseGetDealConversionStatusResponse(rsp *http.Response) (*GetDealConversionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealConversionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`

			// Data An object containing conversion status. After successful conversion the converted entity ID is also present.
			Data struct {
				// ConversionId The ID of the conversion job. The ID can be used to retrieve conversion status and details. The ID has UUID format.
				ConversionId openapi_types.UUID `json:"conversion_id"`

				// DealId The ID of the new deal.
				DealId *int `json:"deal_id,omitempty"`

				// LeadId The ID of the new lead.
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// Status Status of the conversion job.
				Status GetDealConversionStatus200DataStatus `json:"status"`
			} `json:"data"`
			Success bool `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAdditionalDiscountsResponse parses an HTTP response from a GetAdditionalDiscountsWithResponse call
func ParseGetAdditionalDiscountsResponse(rsp *http.Response) (*GetAdditionalDiscountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAdditionalDiscountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Array containing data for all discounts added to a deal
			Data *[]struct {
				// Amount The discount amount.
				Amount *float32 `json:"amount,omitempty"`

				// CreatedAt The date and time of when the discount was created in the ISO 8601 format.
				CreatedAt *string `json:"created_at,omitempty"`

				// CreatedBy The ID of the user that created the discount.
				CreatedBy *int `json:"created_by,omitempty"`

				// DealId The ID of the deal the discount was added to.
				DealId *int `json:"deal_id,omitempty"`

				// Description The name of the discount.
				Description *string `json:"description,omitempty"`

				// Id The ID of the additional discount
				Id *string `json:"id,omitempty"`

				// Type Determines whether the discount is applied as a percentage or a fixed amount.
				Type *GetAdditionalDiscounts200DataType `json:"type,omitempty"`

				// UpdatedAt The date and time of when the discount was created in the ISO 8601 format.
				UpdatedAt *string `json:"updated_at,omitempty"`

				// UpdatedBy The ID of the user that last updated the discount.
				UpdatedBy *int `json:"updated_by,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAdditionalDiscountResponse parses an HTTP response from a PostAdditionalDiscountWithResponse call
func ParsePostAdditionalDiscountResponse(rsp *http.Response) (*PostAdditionalDiscountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAdditionalDiscountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// Amount The discount amount.
				Amount *float32 `json:"amount,omitempty"`

				// CreatedAt The date and time of when the discount was created in the ISO 8601 format.
				CreatedAt *string `json:"created_at,omitempty"`

				// CreatedBy The ID of the user that created the discount.
				CreatedBy *int `json:"created_by,omitempty"`

				// DealId The ID of the deal the discount was added to.
				DealId *int `json:"deal_id,omitempty"`

				// Description The name of the discount.
				Description *string `json:"description,omitempty"`

				// Id The ID of the additional discount
				Id *string `json:"id,omitempty"`

				// Type Determines whether the discount is applied as a percentage or a fixed amount.
				Type *PostAdditionalDiscount201DataType `json:"type,omitempty"`

				// UpdatedAt The date and time of when the discount was created in the ISO 8601 format.
				UpdatedAt *string `json:"updated_at,omitempty"`

				// UpdatedBy The ID of the user that last updated the discount.
				UpdatedBy *int `json:"updated_by,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteAdditionalDiscountResponse parses an HTTP response from a DeleteAdditionalDiscountWithResponse call
func ParseDeleteAdditionalDiscountResponse(rsp *http.Response) (*DeleteAdditionalDiscountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAdditionalDiscountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of the discount that was deleted from the deal
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAdditionalDiscountResponse parses an HTTP response from a UpdateAdditionalDiscountWithResponse call
func ParseUpdateAdditionalDiscountResponse(rsp *http.Response) (*UpdateAdditionalDiscountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAdditionalDiscountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Amount The discount amount.
				Amount *float32 `json:"amount,omitempty"`

				// CreatedAt The date and time of when the discount was created in the ISO 8601 format.
				CreatedAt *string `json:"created_at,omitempty"`

				// CreatedBy The ID of the user that created the discount.
				CreatedBy *int `json:"created_by,omitempty"`

				// DealId The ID of the deal the discount was added to.
				DealId *int `json:"deal_id,omitempty"`

				// Description The name of the discount.
				Description *string `json:"description,omitempty"`

				// Id The ID of the additional discount
				Id *string `json:"id,omitempty"`

				// Type Determines whether the discount is applied as a percentage or a fixed amount.
				Type *UpdateAdditionalDiscount200DataType `json:"type,omitempty"`

				// UpdatedAt The date and time of when the discount was created in the ISO 8601 format.
				UpdatedAt *string `json:"updated_at,omitempty"`

				// UpdatedBy The ID of the user that last updated the discount.
				UpdatedBy *int `json:"updated_by,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealFollowersResponse parses an HTTP response from a GetDealFollowersWithResponse call
func ParseGetDealFollowersResponse(rsp *http.Response) (*GetDealFollowersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealFollowersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Followers array
			Data *[]struct {
				// AddTime The add time of the following
				AddTime *string `json:"add_time,omitempty"`

				// UserId The ID of the user following the entity
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddDealFollowerResponse parses an HTTP response from a AddDealFollowerWithResponse call
func ParseAddDealFollowerResponse(rsp *http.Response) (*AddDealFollowerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDealFollowerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data The follower object
			Data *struct {
				// AddTime The add time of the following
				AddTime *string `json:"add_time,omitempty"`

				// UserId The ID of the user following the entity
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetDealFollowersChangelogResponse parses an HTTP response from a GetDealFollowersChangelogWithResponse call
func ParseGetDealFollowersChangelogResponse(rsp *http.Response) (*GetDealFollowersChangelogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealFollowersChangelogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Follower changelogs array
			Data *[]struct {
				// Action The type of change
				Action *string `json:"action,omitempty"`

				// ActorUserId The ID of the user who did the change
				ActorUserId *int `json:"actor_user_id,omitempty"`

				// FollowerUserId The ID of the user who was following the entity
				FollowerUserId *int `json:"follower_user_id,omitempty"`

				// Time The time at which the change happened
				Time *string `json:"time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDealFollowerResponse parses an HTTP response from a DeleteDealFollowerWithResponse call
func ParseDeleteDealFollowerResponse(rsp *http.Response) (*DeleteDealFollowerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDealFollowerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UserId Deleted follower user ID
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostInstallmentResponse parses an HTTP response from a PostInstallmentWithResponse call
func ParsePostInstallmentResponse(rsp *http.Response) (*PostInstallmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInstallmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Amount The installment amount.
				Amount *float32 `json:"amount,omitempty"`

				// BillingDate The date which the installment will be charged.
				BillingDate *string `json:"billing_date,omitempty"`

				// DealId The ID of the deal the installment was added to.
				DealId *int `json:"deal_id,omitempty"`

				// Description The name of installment.
				Description *string `json:"description,omitempty"`

				// Id The ID of the installment
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteInstallmentResponse parses an HTTP response from a DeleteInstallmentWithResponse call
func ParseDeleteInstallmentResponse(rsp *http.Response) (*DeleteInstallmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInstallmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of the installment that was deleted from the deal
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateInstallmentResponse parses an HTTP response from a UpdateInstallmentWithResponse call
func ParseUpdateInstallmentResponse(rsp *http.Response) (*UpdateInstallmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInstallmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Amount The installment amount.
				Amount *float32 `json:"amount,omitempty"`

				// BillingDate The date which the installment will be charged.
				BillingDate *string `json:"billing_date,omitempty"`

				// DealId The ID of the deal the installment was added to.
				DealId *int `json:"deal_id,omitempty"`

				// Description The name of installment.
				Description *string `json:"description,omitempty"`

				// Id The ID of the installment
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteManyDealProductsResponse parses an HTTP response from a DeleteManyDealProductsWithResponse call
func ParseDeleteManyDealProductsResponse(rsp *http.Response) (*DeleteManyDealProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyDealProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// MoreItemsInCollection Whether there are more products to delete (when the deal has more than 100 products)
				MoreItemsInCollection *bool `json:"more_items_in_collection,omitempty"`
			} `json:"additional_data"`
			Data *struct {
				// Ids Array of IDs of products that were deleted from the deal
				Ids *[]int `json:"ids,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDealProductsResponse parses an HTTP response from a GetDealProductsWithResponse call
func ParseGetDealProductsResponse(rsp *http.Response) (*GetDealProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData Pagination related data
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Array containing data for all products attached to deals
			Data *[]struct {
				// AddTime The date and time when the product was added to the deal
				AddTime *string `json:"add_time,omitempty"`

				// BillingFrequency Only available in Growth and above plans
				//
				// How often a customer is billed for access to a service or product
				//
				// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
				//
				// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
				BillingFrequency *GetDealProducts200DataBillingFrequency `json:"billing_frequency,omitempty"`

				// BillingFrequencyCycles Only available in Growth and above plans
				//
				// The number of times the billing frequency repeats for a product in a deal
				//
				// When `billing_frequency` is set to `one-time`, this field must be `null`
				//
				// When `billing_frequency` is set to `weekly`, this field cannot be `null`
				//
				// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
				//
				// Must be a positive integer less or equal to 208
				BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

				// BillingStartDate Only available in Growth and above plans
				//
				// The billing start date. Must be between 10 years in the past and 10 years in the future
				BillingStartDate *string `json:"billing_start_date"`

				// Comments The comments of the product
				Comments *string `json:"comments,omitempty"`

				// Currency The currency associated with the deal product
				Currency *string `json:"currency,omitempty"`

				// DealId The ID of the deal
				DealId *int `json:"deal_id,omitempty"`

				// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
				Discount *float32 `json:"discount,omitempty"`

				// DiscountType The type of the discount's value
				DiscountType *GetDealProducts200DataDiscountType `json:"discount_type,omitempty"`

				// Id The ID of the deal-product (the ID of the product attached to the deal)
				Id *int `json:"id,omitempty"`

				// IsEnabled Whether this product is enabled for the deal
				IsEnabled *bool `json:"is_enabled,omitempty"`

				// ItemPrice The price value of the product
				ItemPrice *float32 `json:"item_price,omitempty"`

				// Name The product name
				Name *string `json:"name,omitempty"`

				// OrderNr The order number of the product within the deal
				OrderNr *int `json:"order_nr"`

				// ProductId The ID of the product
				ProductId *int `json:"product_id,omitempty"`

				// ProductVariationId The ID of the product variation
				ProductVariationId *int `json:"product_variation_id"`

				// Quantity The quantity of the product
				Quantity *int `json:"quantity,omitempty"`

				// Sum The sum of all the products attached to the deal
				Sum *float32 `json:"sum,omitempty"`

				// Tax The product tax
				Tax *float32 `json:"tax,omitempty"`

				// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
				TaxMethod *GetDealProducts200DataTaxMethod `json:"tax_method,omitempty"`

				// UpdateTime The date and time when the deal product was last updated
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddDealProductResponse parses an HTTP response from a AddDealProductWithResponse call
func ParseAddDealProductResponse(rsp *http.Response) (*AddDealProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDealProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// AddTime The date and time when the product was added to the deal
				AddTime *string `json:"add_time,omitempty"`

				// BillingFrequency Only available in Growth and above plans
				//
				// How often a customer is billed for access to a service or product
				//
				// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
				//
				// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
				BillingFrequency *AddDealProduct201DataBillingFrequency `json:"billing_frequency,omitempty"`

				// BillingFrequencyCycles Only available in Growth and above plans
				//
				// The number of times the billing frequency repeats for a product in a deal
				//
				// When `billing_frequency` is set to `one-time`, this field must be `null`
				//
				// When `billing_frequency` is set to `weekly`, this field cannot be `null`
				//
				// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
				//
				// Must be a positive integer less or equal to 208
				BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

				// BillingStartDate Only available in Growth and above plans
				//
				// The billing start date. Must be between 10 years in the past and 10 years in the future
				BillingStartDate *string `json:"billing_start_date"`

				// Comments The comments of the product
				Comments *string `json:"comments,omitempty"`

				// Currency The currency associated with the deal product
				Currency *string `json:"currency,omitempty"`

				// DealId The ID of the deal
				DealId *int `json:"deal_id,omitempty"`

				// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
				Discount *float32 `json:"discount,omitempty"`

				// DiscountType The type of the discount's value
				DiscountType *AddDealProduct201DataDiscountType `json:"discount_type,omitempty"`

				// Id The ID of the deal-product (the ID of the product attached to the deal)
				Id *int `json:"id,omitempty"`

				// IsEnabled Whether this product is enabled for the deal
				IsEnabled *bool `json:"is_enabled,omitempty"`

				// ItemPrice The price value of the product
				ItemPrice *float32 `json:"item_price,omitempty"`

				// Name The product name
				Name *string `json:"name,omitempty"`

				// OrderNr The order number of the product within the deal
				OrderNr *int `json:"order_nr"`

				// ProductId The ID of the product
				ProductId *int `json:"product_id,omitempty"`

				// ProductVariationId The ID of the product variation
				ProductVariationId *int `json:"product_variation_id"`

				// Quantity The quantity of the product
				Quantity *int `json:"quantity,omitempty"`

				// Sum The sum of all the products attached to the deal
				Sum *float32 `json:"sum,omitempty"`

				// Tax The product tax
				Tax *float32 `json:"tax,omitempty"`

				// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
				TaxMethod *AddDealProduct201DataTaxMethod `json:"tax_method,omitempty"`

				// UpdateTime The date and time when the deal product was last updated
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseAddManyDealProductsResponse parses an HTTP response from a AddManyDealProductsWithResponse call
func ParseAddManyDealProductsResponse(rsp *http.Response) (*AddManyDealProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddManyDealProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Array of created deal products
			Data *[]struct {
				// AddTime The date and time when the product was added to the deal
				AddTime *string `json:"add_time,omitempty"`

				// BillingFrequency Only available in Growth and above plans
				//
				// How often a customer is billed for access to a service or product
				//
				// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
				//
				// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
				BillingFrequency *AddManyDealProducts201DataBillingFrequency `json:"billing_frequency,omitempty"`

				// BillingFrequencyCycles Only available in Growth and above plans
				//
				// The number of times the billing frequency repeats for a product in a deal
				//
				// When `billing_frequency` is set to `one-time`, this field must be `null`
				//
				// When `billing_frequency` is set to `weekly`, this field cannot be `null`
				//
				// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
				//
				// Must be a positive integer less or equal to 208
				BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

				// BillingStartDate Only available in Growth and above plans
				//
				// The billing start date. Must be between 10 years in the past and 10 years in the future
				BillingStartDate *string `json:"billing_start_date"`

				// Comments The comments of the product
				Comments *string `json:"comments,omitempty"`

				// Currency The currency associated with the deal product
				Currency *string `json:"currency,omitempty"`

				// DealId The ID of the deal
				DealId *int `json:"deal_id,omitempty"`

				// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
				Discount *float32 `json:"discount,omitempty"`

				// DiscountType The type of the discount's value
				DiscountType *AddManyDealProducts201DataDiscountType `json:"discount_type,omitempty"`

				// Id The ID of the deal-product (the ID of the product attached to the deal)
				Id *int `json:"id,omitempty"`

				// IsEnabled Whether this product is enabled for the deal
				IsEnabled *bool `json:"is_enabled,omitempty"`

				// ItemPrice The price value of the product
				ItemPrice *float32 `json:"item_price,omitempty"`

				// Name The product name
				Name *string `json:"name,omitempty"`

				// OrderNr The order number of the product within the deal
				OrderNr *int `json:"order_nr"`

				// ProductId The ID of the product
				ProductId *int `json:"product_id,omitempty"`

				// ProductVariationId The ID of the product variation
				ProductVariationId *int `json:"product_variation_id"`

				// Quantity The quantity of the product
				Quantity *int `json:"quantity,omitempty"`

				// Sum The sum of all the products attached to the deal
				Sum *float32 `json:"sum,omitempty"`

				// Tax The product tax
				Tax *float32 `json:"tax,omitempty"`

				// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
				TaxMethod *AddManyDealProducts201DataTaxMethod `json:"tax_method,omitempty"`

				// UpdateTime The date and time when the deal product was last updated
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteDealProductResponse parses an HTTP response from a DeleteDealProductWithResponse call
func ParseDeleteDealProductResponse(rsp *http.Response) (*DeleteDealProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDealProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of an attached product that was deleted from the deal
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDealProductResponse parses an HTTP response from a UpdateDealProductWithResponse call
func ParseUpdateDealProductResponse(rsp *http.Response) (*UpdateDealProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDealProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// AddTime The date and time when the product was added to the deal
				AddTime *string `json:"add_time,omitempty"`

				// BillingFrequency Only available in Growth and above plans
				//
				// How often a customer is billed for access to a service or product
				//
				// To set `billing_frequency` different than `one-time`, the deal must not have installments associated
				//
				// A deal can have up to 20 products attached with `billing_frequency` different than `one-time`
				BillingFrequency *UpdateDealProduct200DataBillingFrequency `json:"billing_frequency,omitempty"`

				// BillingFrequencyCycles Only available in Growth and above plans
				//
				// The number of times the billing frequency repeats for a product in a deal
				//
				// When `billing_frequency` is set to `one-time`, this field must be `null`
				//
				// When `billing_frequency` is set to `weekly`, this field cannot be `null`
				//
				// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
				//
				// Must be a positive integer less or equal to 208
				BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

				// BillingStartDate Only available in Growth and above plans
				//
				// The billing start date. Must be between 10 years in the past and 10 years in the future
				BillingStartDate *string `json:"billing_start_date"`

				// Comments The comments of the product
				Comments *string `json:"comments,omitempty"`

				// Currency The currency associated with the deal product
				Currency *string `json:"currency,omitempty"`

				// DealId The ID of the deal
				DealId *int `json:"deal_id,omitempty"`

				// Discount The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage
				Discount *float32 `json:"discount,omitempty"`

				// DiscountType The type of the discount's value
				DiscountType *UpdateDealProduct200DataDiscountType `json:"discount_type,omitempty"`

				// Id The ID of the deal-product (the ID of the product attached to the deal)
				Id *int `json:"id,omitempty"`

				// IsEnabled Whether this product is enabled for the deal
				IsEnabled *bool `json:"is_enabled,omitempty"`

				// ItemPrice The price value of the product
				ItemPrice *float32 `json:"item_price,omitempty"`

				// Name The product name
				Name *string `json:"name,omitempty"`

				// OrderNr The order number of the product within the deal
				OrderNr *int `json:"order_nr"`

				// ProductId The ID of the product
				ProductId *int `json:"product_id,omitempty"`

				// ProductVariationId The ID of the product variation
				ProductVariationId *int `json:"product_variation_id"`

				// Quantity The quantity of the product
				Quantity *int `json:"quantity,omitempty"`

				// Sum The sum of all the products attached to the deal
				Sum *float32 `json:"sum,omitempty"`

				// Tax The product tax
				Tax *float32 `json:"tax,omitempty"`

				// TaxMethod The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal
				TaxMethod *UpdateDealProduct200DataTaxMethod `json:"tax_method,omitempty"`

				// UpdateTime The date and time when the deal product was last updated
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchItemResponse parses an HTTP response from a SearchItemWithResponse call
func ParseSearchItemResponse(rsp *http.Response) (*SearchItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData Pagination related data
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *struct {
				// Items The array of found items
				Items *[]struct {
					// Item Item
					Item *map[string]interface{} `json:"item,omitempty"`

					// ResultScore Search result relevancy
					ResultScore *float32 `json:"result_score,omitempty"`
				} `json:"items,omitempty"`

				// RelatedItems The array of related items if `search_for_related_items` was enabled
				RelatedItems *[]struct {
					// Item Item
					Item *map[string]interface{} `json:"item,omitempty"`

					// ResultScore Search result relevancy
					ResultScore *float32 `json:"result_score,omitempty"`
				} `json:"related_items,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchItemByFieldResponse parses an HTTP response from a SearchItemByFieldWithResponse call
func ParseSearchItemByFieldResponse(rsp *http.Response) (*SearchItemByFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchItemByFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData Pagination related data
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of found fields
			Data *[]struct {
				// Item Item
				Item *map[string]interface{} `json:"item,omitempty"`

				// ResultScore Search result relevancy
				ResultScore *float32 `json:"result_score,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchLeadsResponse parses an HTTP response from a SearchLeadsWithResponse call
func ParseSearchLeadsResponse(rsp *http.Response) (*SearchLeadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchLeadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData Pagination related data
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *struct {
				// Items The array of leads
				Items *[]struct {
					Item *struct {
						// Currency The currency of the lead
						Currency *string `json:"currency,omitempty"`

						// CustomFields Custom fields
						CustomFields *[]string `json:"custom_fields,omitempty"`
						Emails       *[]string `json:"emails,omitempty"`

						// Id The ID of the lead
						Id *string `json:"id,omitempty"`

						// IsArchived A flag indicating whether the lead is archived or not
						IsArchived *bool `json:"is_archived,omitempty"`

						// Notes An array of notes
						Notes        *[]string `json:"notes,omitempty"`
						Organization *struct {
							// Id The ID of the organization the lead is associated with
							Id *int `json:"id,omitempty"`

							// Name The name of the organization the lead is associated with
							Name *string `json:"name,omitempty"`
						} `json:"organization,omitempty"`
						Owner *struct {
							// Id The ID of the owner of the lead
							Id *int `json:"id,omitempty"`
						} `json:"owner,omitempty"`
						Person *struct {
							// Id The ID of the person the lead is associated with
							Id *int `json:"id,omitempty"`

							// Name The name of the person the lead is associated with
							Name *string `json:"name,omitempty"`
						} `json:"person,omitempty"`
						Phones *[]string `json:"phones,omitempty"`

						// Title The title of the lead
						Title *string `json:"title,omitempty"`

						// Type The type of the item
						Type *string `json:"type,omitempty"`

						// Value The value of the lead
						Value *int `json:"value,omitempty"`

						// VisibleTo The visibility of the lead
						VisibleTo *int `json:"visible_to,omitempty"`
					} `json:"item,omitempty"`

					// ResultScore Search result relevancy
					ResultScore *float32 `json:"result_score,omitempty"`
				} `json:"items,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConvertLeadToDealResponse parses an HTTP response from a ConvertLeadToDealWithResponse call
func ParseConvertLeadToDealResponse(rsp *http.Response) (*ConvertLeadToDealResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertLeadToDealResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`

			// Data An object containing conversion job id that performs the conversion
			Data *struct {
				// ConversionId The ID of the conversion job that can be used to retrieve conversion status and details. The ID has UUID format.
				ConversionId openapi_types.UUID `json:"conversion_id"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLeadConversionStatusResponse parses an HTTP response from a GetLeadConversionStatusWithResponse call
func ParseGetLeadConversionStatusResponse(rsp *http.Response) (*GetLeadConversionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeadConversionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`

			// Data An object containing conversion status. After successful conversion the converted entity ID is also present.
			Data struct {
				// ConversionId The ID of the conversion job. The ID can be used to retrieve conversion status and details. The ID has UUID format.
				ConversionId openapi_types.UUID `json:"conversion_id"`

				// DealId The ID of the new deal.
				DealId *int `json:"deal_id,omitempty"`

				// LeadId The ID of the new lead.
				LeadId *openapi_types.UUID `json:"lead_id,omitempty"`

				// Status Status of the conversion job.
				Status GetLeadConversionStatus200DataStatus `json:"status"`
			} `json:"data"`
			Success bool `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *map[string]interface{} `json:"data"`

			// Error The description of the error
			Error *string `json:"error,omitempty"`

			// ErrorInfo A message describing how to solve the problem
			ErrorInfo *string `json:"error_info,omitempty"`
			Success   *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetOrganizationFieldsResponse parses an HTTP response from a GetOrganizationFieldsWithResponse call
func ParseGetOrganizationFieldsResponse(rsp *http.Response) (*GetOrganizationFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// NextCursor Base64url-encoded cursor for fetching the next page of results, null if no more pages
				NextCursor *string `json:"next_cursor"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType GetOrganizationFields200DataFieldType `json:"field_type"`

				// ImportantFields Important fields configuration
				ImportantFields *struct {
					// Enabled Whether the field is marked as important
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of deal stage IDs where the field is important
					StageIds *[]int `json:"stage_ids,omitempty"`
				} `json:"important_fields,omitempty"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// RequiredFields Required fields configuration
				RequiredFields *struct {
					// Enabled Whether the field is required
					Enabled *bool `json:"enabled,omitempty"`
				} `json:"required_fields,omitempty"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

					// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
					ShowInAddDealDialog *struct {
						// Order Display order in the add deal dialog (null if not shown)
						Order *int `json:"order"`

						// Show Whether the field is shown in the add deal dialog
						Show *bool `json:"show,omitempty"`
					} `json:"show_in_add_deal_dialog,omitempty"`

					// ShowInAddPersonDialog Configuration for showing the field in the add person dialog
					ShowInAddPersonDialog *struct {
						// Order Display order in the add person dialog (null if not shown)
						Order *int `json:"order"`

						// Show Whether the field is shown in the add person dialog
						Show *bool `json:"show,omitempty"`
					} `json:"show_in_add_person_dialog,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddOrganizationFieldResponse parses an HTTP response from a AddOrganizationFieldWithResponse call
func ParseAddOrganizationFieldResponse(rsp *http.Response) (*AddOrganizationFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType AddOrganizationField200DataFieldType `json:"field_type"`

				// ImportantFields Important fields configuration
				ImportantFields *struct {
					// Enabled Whether the field is marked as important
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of deal stage IDs where the field is important
					StageIds *[]int `json:"stage_ids,omitempty"`
				} `json:"important_fields,omitempty"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// RequiredFields Required fields configuration
				RequiredFields *struct {
					// Enabled Whether the field is required
					Enabled *bool `json:"enabled,omitempty"`
				} `json:"required_fields,omitempty"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

					// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
					ShowInAddDealDialog *struct {
						// Order Display order in the add deal dialog (null if not shown)
						Order *int `json:"order"`

						// Show Whether the field is shown in the add deal dialog
						Show *bool `json:"show,omitempty"`
					} `json:"show_in_add_deal_dialog,omitempty"`

					// ShowInAddPersonDialog Configuration for showing the field in the add person dialog
					ShowInAddPersonDialog *struct {
						// Order Display order in the add person dialog (null if not shown)
						Order *int `json:"order"`

						// Show Whether the field is shown in the add person dialog
						Show *bool `json:"show,omitempty"`
					} `json:"show_in_add_person_dialog,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationFieldResponse parses an HTTP response from a DeleteOrganizationFieldWithResponse call
func ParseDeleteOrganizationFieldResponse(rsp *http.Response) (*DeleteOrganizationFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType string `json:"field_type"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]map[string]interface{} `json:"options"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]map[string]interface{} `json:"subfields"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationFieldResponse parses an HTTP response from a GetOrganizationFieldWithResponse call
func ParseGetOrganizationFieldResponse(rsp *http.Response) (*GetOrganizationFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType GetOrganizationField200DataFieldType `json:"field_type"`

				// ImportantFields Important fields configuration
				ImportantFields *struct {
					// Enabled Whether the field is marked as important
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of deal stage IDs where the field is important
					StageIds *[]int `json:"stage_ids,omitempty"`
				} `json:"important_fields,omitempty"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// RequiredFields Required fields configuration
				RequiredFields *struct {
					// Enabled Whether the field is required
					Enabled *bool `json:"enabled,omitempty"`
				} `json:"required_fields,omitempty"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

					// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
					ShowInAddDealDialog *struct {
						// Order Display order in the add deal dialog (null if not shown)
						Order *int `json:"order"`

						// Show Whether the field is shown in the add deal dialog
						Show *bool `json:"show,omitempty"`
					} `json:"show_in_add_deal_dialog,omitempty"`

					// ShowInAddPersonDialog Configuration for showing the field in the add person dialog
					ShowInAddPersonDialog *struct {
						// Order Display order in the add person dialog (null if not shown)
						Order *int `json:"order"`

						// Show Whether the field is shown in the add person dialog
						Show *bool `json:"show,omitempty"`
					} `json:"show_in_add_person_dialog,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateOrganizationFieldResponse parses an HTTP response from a UpdateOrganizationFieldWithResponse call
func ParseUpdateOrganizationFieldResponse(rsp *http.Response) (*UpdateOrganizationFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrganizationFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType UpdateOrganizationField200DataFieldType `json:"field_type"`

				// ImportantFields Important fields configuration
				ImportantFields *struct {
					// Enabled Whether the field is marked as important
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of deal stage IDs where the field is important
					StageIds *[]int `json:"stage_ids,omitempty"`
				} `json:"important_fields,omitempty"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// RequiredFields Required fields configuration
				RequiredFields *struct {
					// Enabled Whether the field is required
					Enabled *bool `json:"enabled,omitempty"`
				} `json:"required_fields,omitempty"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

					// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
					ShowInAddDealDialog *struct {
						// Order Display order in the add deal dialog (null if not shown)
						Order *int `json:"order"`

						// Show Whether the field is shown in the add deal dialog
						Show *bool `json:"show,omitempty"`
					} `json:"show_in_add_deal_dialog,omitempty"`

					// ShowInAddPersonDialog Configuration for showing the field in the add person dialog
					ShowInAddPersonDialog *struct {
						// Order Display order in the add person dialog (null if not shown)
						Order *int `json:"order"`

						// Show Whether the field is shown in the add person dialog
						Show *bool `json:"show,omitempty"`
					} `json:"show_in_add_person_dialog,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationFieldOptionsResponse parses an HTTP response from a DeleteOrganizationFieldOptionsWithResponse call
func ParseDeleteOrganizationFieldOptionsResponse(rsp *http.Response) (*DeleteOrganizationFieldOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationFieldOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id The unique identifier of the option
				Id int `json:"id"`

				// Label The display label of the option
				Label string `json:"label"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateOrganizationFieldOptionsResponse parses an HTTP response from a UpdateOrganizationFieldOptionsWithResponse call
func ParseUpdateOrganizationFieldOptionsResponse(rsp *http.Response) (*UpdateOrganizationFieldOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrganizationFieldOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id The unique identifier of the option
				Id int `json:"id"`

				// Label The display label of the option
				Label string `json:"label"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddOrganizationFieldOptionsResponse parses an HTTP response from a AddOrganizationFieldOptionsWithResponse call
func ParseAddOrganizationFieldOptionsResponse(rsp *http.Response) (*AddOrganizationFieldOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationFieldOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id The unique identifier of the option
				Id int `json:"id"`

				// Label The display label of the option
				Label string `json:"label"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationsResponse parses an HTTP response from a GetOrganizationsWithResponse call
func ParseGetOrganizationsResponse(rsp *http.Response) (*GetOrganizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Organizations array
			Data *[]struct {
				// AddTime The creation date and time of the organization
				AddTime *string `json:"add_time,omitempty"`

				// Address The address of the organization
				Address *struct {
					// AdminAreaLevel1 Admin area level 1 (e.g. state) of the organization
					AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

					// AdminAreaLevel2 Admin area level 2 (e.g. county) of the organization
					AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

					// Country Country of the organization
					Country *string `json:"country,omitempty"`

					// Locality Locality (e.g. city) of the organization
					Locality *string `json:"locality,omitempty"`

					// PostalCode Postal code of the organization
					PostalCode *string `json:"postal_code,omitempty"`

					// Route Route (e.g. street) of the organization
					Route *string `json:"route,omitempty"`

					// StreetNumber Street number of the organization
					StreetNumber *string `json:"street_number,omitempty"`

					// Sublocality Sublocality (e.g. neighborhood) of the organization
					Sublocality *string `json:"sublocality,omitempty"`

					// Subpremise Subpremise (e.g. apartment/suite number) of the organization
					Subpremise *string `json:"subpremise,omitempty"`

					// Value The full address of the organization
					Value *string `json:"value,omitempty"`
				} `json:"address,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Id The ID of the organization
				Id *int `json:"id,omitempty"`

				// IsDeleted Whether the organization is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LabelIds The IDs of labels assigned to the organization
				LabelIds *[]int `json:"label_ids,omitempty"`

				// Name The name of the organization
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the user who owns the organization
				OwnerId *int `json:"owner_id,omitempty"`

				// UpdateTime The last updated date and time of the organization
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility of the organization
				VisibleTo *int `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddOrganizationResponse parses an HTTP response from a AddOrganizationWithResponse call
func ParseAddOrganizationResponse(rsp *http.Response) (*AddOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The organization object
			Data *struct {
				// AddTime The creation date and time of the organization
				AddTime *string `json:"add_time,omitempty"`

				// Address The address of the organization
				Address *struct {
					// AdminAreaLevel1 Admin area level 1 (e.g. state) of the organization
					AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

					// AdminAreaLevel2 Admin area level 2 (e.g. county) of the organization
					AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

					// Country Country of the organization
					Country *string `json:"country,omitempty"`

					// Locality Locality (e.g. city) of the organization
					Locality *string `json:"locality,omitempty"`

					// PostalCode Postal code of the organization
					PostalCode *string `json:"postal_code,omitempty"`

					// Route Route (e.g. street) of the organization
					Route *string `json:"route,omitempty"`

					// StreetNumber Street number of the organization
					StreetNumber *string `json:"street_number,omitempty"`

					// Sublocality Sublocality (e.g. neighborhood) of the organization
					Sublocality *string `json:"sublocality,omitempty"`

					// Subpremise Subpremise (e.g. apartment/suite number) of the organization
					Subpremise *string `json:"subpremise,omitempty"`

					// Value The full address of the organization
					Value *string `json:"value,omitempty"`
				} `json:"address,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Id The ID of the organization
				Id *int `json:"id,omitempty"`

				// IsDeleted Whether the organization is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LabelIds The IDs of labels assigned to the organization
				LabelIds *[]int `json:"label_ids,omitempty"`

				// Name The name of the organization
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the user who owns the organization
				OwnerId *int `json:"owner_id,omitempty"`

				// UpdateTime The last updated date and time of the organization
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility of the organization
				VisibleTo *int `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchOrganizationResponse parses an HTTP response from a SearchOrganizationWithResponse call
func ParseSearchOrganizationResponse(rsp *http.Response) (*SearchOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData Pagination related data
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *struct {
				// Items The array of found items
				Items *[]struct {
					Item *struct {
						// Address The address of the organization
						Address *string `json:"address,omitempty"`

						// CustomFields Custom fields
						CustomFields *[]string `json:"custom_fields,omitempty"`

						// Id The ID of the organization
						Id *int `json:"id,omitempty"`

						// Name The name of the organization
						Name *string `json:"name,omitempty"`

						// Notes An array of notes
						Notes *[]string `json:"notes,omitempty"`
						Owner *struct {
							// Id The ID of the owner of the deal
							Id *int `json:"id,omitempty"`
						} `json:"owner,omitempty"`

						// Type The type of the item
						Type *string `json:"type,omitempty"`

						// VisibleTo The visibility of the organization
						VisibleTo *int `json:"visible_to,omitempty"`
					} `json:"item,omitempty"`

					// ResultScore Search result relevancy
					ResultScore *float32 `json:"result_score,omitempty"`
				} `json:"items,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationResponse parses an HTTP response from a DeleteOrganizationWithResponse call
func ParseDeleteOrganizationResponse(rsp *http.Response) (*DeleteOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id Deleted organization ID
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationResponse parses an HTTP response from a GetOrganizationWithResponse call
func ParseGetOrganizationResponse(rsp *http.Response) (*GetOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The organization object
			Data *struct {
				// AddTime The creation date and time of the organization
				AddTime *string `json:"add_time,omitempty"`

				// Address The address of the organization
				Address *struct {
					// AdminAreaLevel1 Admin area level 1 (e.g. state) of the organization
					AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

					// AdminAreaLevel2 Admin area level 2 (e.g. county) of the organization
					AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

					// Country Country of the organization
					Country *string `json:"country,omitempty"`

					// Locality Locality (e.g. city) of the organization
					Locality *string `json:"locality,omitempty"`

					// PostalCode Postal code of the organization
					PostalCode *string `json:"postal_code,omitempty"`

					// Route Route (e.g. street) of the organization
					Route *string `json:"route,omitempty"`

					// StreetNumber Street number of the organization
					StreetNumber *string `json:"street_number,omitempty"`

					// Sublocality Sublocality (e.g. neighborhood) of the organization
					Sublocality *string `json:"sublocality,omitempty"`

					// Subpremise Subpremise (e.g. apartment/suite number) of the organization
					Subpremise *string `json:"subpremise,omitempty"`

					// Value The full address of the organization
					Value *string `json:"value,omitempty"`
				} `json:"address,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Id The ID of the organization
				Id *int `json:"id,omitempty"`

				// IsDeleted Whether the organization is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LabelIds The IDs of labels assigned to the organization
				LabelIds *[]int `json:"label_ids,omitempty"`

				// Name The name of the organization
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the user who owns the organization
				OwnerId *int `json:"owner_id,omitempty"`

				// UpdateTime The last updated date and time of the organization
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility of the organization
				VisibleTo *int `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateOrganizationResponse parses an HTTP response from a UpdateOrganizationWithResponse call
func ParseUpdateOrganizationResponse(rsp *http.Response) (*UpdateOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The organization object
			Data *struct {
				// AddTime The creation date and time of the organization
				AddTime *string `json:"add_time,omitempty"`

				// Address The address of the organization
				Address *struct {
					// AdminAreaLevel1 Admin area level 1 (e.g. state) of the organization
					AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

					// AdminAreaLevel2 Admin area level 2 (e.g. county) of the organization
					AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

					// Country Country of the organization
					Country *string `json:"country,omitempty"`

					// Locality Locality (e.g. city) of the organization
					Locality *string `json:"locality,omitempty"`

					// PostalCode Postal code of the organization
					PostalCode *string `json:"postal_code,omitempty"`

					// Route Route (e.g. street) of the organization
					Route *string `json:"route,omitempty"`

					// StreetNumber Street number of the organization
					StreetNumber *string `json:"street_number,omitempty"`

					// Sublocality Sublocality (e.g. neighborhood) of the organization
					Sublocality *string `json:"sublocality,omitempty"`

					// Subpremise Subpremise (e.g. apartment/suite number) of the organization
					Subpremise *string `json:"subpremise,omitempty"`

					// Value The full address of the organization
					Value *string `json:"value,omitempty"`
				} `json:"address,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Id The ID of the organization
				Id *int `json:"id,omitempty"`

				// IsDeleted Whether the organization is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// LabelIds The IDs of labels assigned to the organization
				LabelIds *[]int `json:"label_ids,omitempty"`

				// Name The name of the organization
				Name *string `json:"name,omitempty"`

				// OwnerId The ID of the user who owns the organization
				OwnerId *int `json:"owner_id,omitempty"`

				// UpdateTime The last updated date and time of the organization
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility of the organization
				VisibleTo *int `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationFollowersResponse parses an HTTP response from a GetOrganizationFollowersWithResponse call
func ParseGetOrganizationFollowersResponse(rsp *http.Response) (*GetOrganizationFollowersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationFollowersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Followers array
			Data *[]struct {
				// AddTime The add time of the following
				AddTime *string `json:"add_time,omitempty"`

				// UserId The ID of the user following the entity
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddOrganizationFollowerResponse parses an HTTP response from a AddOrganizationFollowerWithResponse call
func ParseAddOrganizationFollowerResponse(rsp *http.Response) (*AddOrganizationFollowerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationFollowerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data The follower object
			Data *struct {
				// AddTime The add time of the following
				AddTime *string `json:"add_time,omitempty"`

				// UserId The ID of the user following the entity
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetOrganizationFollowersChangelogResponse parses an HTTP response from a GetOrganizationFollowersChangelogWithResponse call
func ParseGetOrganizationFollowersChangelogResponse(rsp *http.Response) (*GetOrganizationFollowersChangelogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationFollowersChangelogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Follower changelogs array
			Data *[]struct {
				// Action The type of change
				Action *string `json:"action,omitempty"`

				// ActorUserId The ID of the user who did the change
				ActorUserId *int `json:"actor_user_id,omitempty"`

				// FollowerUserId The ID of the user who was following the entity
				FollowerUserId *int `json:"follower_user_id,omitempty"`

				// Time The time at which the change happened
				Time *string `json:"time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationFollowerResponse parses an HTTP response from a DeleteOrganizationFollowerWithResponse call
func ParseDeleteOrganizationFollowerResponse(rsp *http.Response) (*DeleteOrganizationFollowerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationFollowerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UserId Deleted follower user ID
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonFieldsResponse parses an HTTP response from a GetPersonFieldsWithResponse call
func ParseGetPersonFieldsResponse(rsp *http.Response) (*GetPersonFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// NextCursor Base64url-encoded cursor for fetching the next page of results, null if no more pages
				NextCursor *string `json:"next_cursor"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType GetPersonFields200DataFieldType `json:"field_type"`

				// ImportantFields Important fields configuration
				ImportantFields *struct {
					// Enabled Whether the field is marked as important
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of deal stage IDs where the field is important
					StageIds *[]int `json:"stage_ids,omitempty"`
				} `json:"important_fields,omitempty"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// RequiredFields Required fields configuration
				RequiredFields *struct {
					// Enabled Whether the field is required
					Enabled *bool `json:"enabled,omitempty"`
				} `json:"required_fields,omitempty"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

					// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
					ShowInAddDealDialog *struct {
						// Order Display order in the add deal dialog (null if not shown)
						Order *int `json:"order"`

						// Show Whether the field is shown in the add deal dialog
						Show *bool `json:"show,omitempty"`
					} `json:"show_in_add_deal_dialog,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddPersonFieldResponse parses an HTTP response from a AddPersonFieldWithResponse call
func ParseAddPersonFieldResponse(rsp *http.Response) (*AddPersonFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPersonFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType AddPersonField200DataFieldType `json:"field_type"`

				// ImportantFields Important fields configuration
				ImportantFields *struct {
					// Enabled Whether the field is marked as important
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of deal stage IDs where the field is important
					StageIds *[]int `json:"stage_ids,omitempty"`
				} `json:"important_fields,omitempty"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// RequiredFields Required fields configuration
				RequiredFields *struct {
					// Enabled Whether the field is required
					Enabled *bool `json:"enabled,omitempty"`
				} `json:"required_fields,omitempty"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

					// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
					ShowInAddDealDialog *struct {
						// Order Display order in the add deal dialog (null if not shown)
						Order *int `json:"order"`

						// Show Whether the field is shown in the add deal dialog
						Show *bool `json:"show,omitempty"`
					} `json:"show_in_add_deal_dialog,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePersonFieldResponse parses an HTTP response from a DeletePersonFieldWithResponse call
func ParseDeletePersonFieldResponse(rsp *http.Response) (*DeletePersonFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersonFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType string `json:"field_type"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]map[string]interface{} `json:"options"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]map[string]interface{} `json:"subfields"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonFieldResponse parses an HTTP response from a GetPersonFieldWithResponse call
func ParseGetPersonFieldResponse(rsp *http.Response) (*GetPersonFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType GetPersonField200DataFieldType `json:"field_type"`

				// ImportantFields Important fields configuration
				ImportantFields *struct {
					// Enabled Whether the field is marked as important
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of deal stage IDs where the field is important
					StageIds *[]int `json:"stage_ids,omitempty"`
				} `json:"important_fields,omitempty"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// RequiredFields Required fields configuration
				RequiredFields *struct {
					// Enabled Whether the field is required
					Enabled *bool `json:"enabled,omitempty"`
				} `json:"required_fields,omitempty"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

					// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
					ShowInAddDealDialog *struct {
						// Order Display order in the add deal dialog (null if not shown)
						Order *int `json:"order"`

						// Show Whether the field is shown in the add deal dialog
						Show *bool `json:"show,omitempty"`
					} `json:"show_in_add_deal_dialog,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePersonFieldResponse parses an HTTP response from a UpdatePersonFieldWithResponse call
func ParseUpdatePersonFieldResponse(rsp *http.Response) (*UpdatePersonFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePersonFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType UpdatePersonField200DataFieldType `json:"field_type"`

				// ImportantFields Important fields configuration
				ImportantFields *struct {
					// Enabled Whether the field is marked as important
					Enabled *bool `json:"enabled,omitempty"`

					// StageIds Array of deal stage IDs where the field is important
					StageIds *[]int `json:"stage_ids,omitempty"`
				} `json:"important_fields,omitempty"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// RequiredFields Required fields configuration
				RequiredFields *struct {
					// Enabled Whether the field is required
					Enabled *bool `json:"enabled,omitempty"`
				} `json:"required_fields,omitempty"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`

					// ShowInAddDealDialog Configuration for showing the field in the add deal dialog
					ShowInAddDealDialog *struct {
						// Order Display order in the add deal dialog (null if not shown)
						Order *int `json:"order"`

						// Show Whether the field is shown in the add deal dialog
						Show *bool `json:"show,omitempty"`
					} `json:"show_in_add_deal_dialog,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePersonFieldOptionsResponse parses an HTTP response from a DeletePersonFieldOptionsWithResponse call
func ParseDeletePersonFieldOptionsResponse(rsp *http.Response) (*DeletePersonFieldOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersonFieldOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id The unique identifier of the option
				Id int `json:"id"`

				// Label The display label of the option
				Label string `json:"label"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePersonFieldOptionsResponse parses an HTTP response from a UpdatePersonFieldOptionsWithResponse call
func ParseUpdatePersonFieldOptionsResponse(rsp *http.Response) (*UpdatePersonFieldOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePersonFieldOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id The unique identifier of the option
				Id int `json:"id"`

				// Label The display label of the option
				Label string `json:"label"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddPersonFieldOptionsResponse parses an HTTP response from a AddPersonFieldOptionsWithResponse call
func ParseAddPersonFieldOptionsResponse(rsp *http.Response) (*AddPersonFieldOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPersonFieldOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id The unique identifier of the option
				Id int `json:"id"`

				// Label The display label of the option
				Label string `json:"label"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonsResponse parses an HTTP response from a GetPersonsWithResponse call
func ParseGetPersonsResponse(rsp *http.Response) (*GetPersonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Persons array
			Data *[]struct {
				// AddTime The creation date and time of the person
				AddTime *string `json:"add_time,omitempty"`

				// Birthday The birthday of the person, included if contact sync is enabled for the company
				Birthday *string `json:"birthday,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Emails The emails of the person
				Emails *[]struct {
					// Label The email address classification label
					Label *string `json:"label,omitempty"`

					// Primary Whether the email is primary or not
					Primary *bool `json:"primary,omitempty"`

					// Value The email address of the person
					Value *string `json:"value,omitempty"`
				} `json:"emails,omitempty"`

				// FirstName The first name of the person
				FirstName *string `json:"first_name,omitempty"`

				// Id The ID of the person
				Id *int `json:"id,omitempty"`

				// Im The instant messaging accounts of the person, included if contact sync is enabled for the company
				Im *[]struct {
					// Label The instant messaging account classification label
					Label *string `json:"label,omitempty"`

					// Primary Whether the instant messaging account is primary or not
					Primary *bool `json:"primary,omitempty"`

					// Value The instant messaging account of the person
					Value *string `json:"value,omitempty"`
				} `json:"im,omitempty"`

				// IsDeleted Whether the person is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// JobTitle The job title of the person, included if contact sync is enabled for the company
				JobTitle *string `json:"job_title,omitempty"`

				// LabelIds The IDs of labels assigned to the person
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LastName The last name of the person
				LastName *string `json:"last_name,omitempty"`

				// Name The name of the person
				Name *string `json:"name,omitempty"`

				// Notes Contact sync notes of the person, maximum 10 000 characters, included if contact sync is enabled for the company
				Notes *string `json:"notes,omitempty"`

				// OrgId The ID of the organization linked to the person
				OrgId *int `json:"org_id,omitempty"`

				// OwnerId The ID of the user who owns the person
				OwnerId *int `json:"owner_id,omitempty"`

				// Phones The phones of the person
				Phones *[]struct {
					// Label The phone number classification label
					Label *string `json:"label,omitempty"`

					// Primary Whether the phone number is primary or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number of the person
					Value *string `json:"value,omitempty"`
				} `json:"phones,omitempty"`

				// PictureId The ID of the picture associated with the person
				PictureId *int `json:"picture_id,omitempty"`

				// PostalAddress Postal address of the person, included if contact sync is enabled for the company
				PostalAddress *struct {
					// AdminAreaLevel1 Admin area level 1 (e.g. state) of the person
					AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

					// AdminAreaLevel2 Admin area level 2 (e.g. county) of the person
					AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

					// Country Country of the person
					Country *string `json:"country,omitempty"`

					// Locality Locality (e.g. city) of the person
					Locality *string `json:"locality,omitempty"`

					// PostalCode Postal code of the person
					PostalCode *string `json:"postal_code,omitempty"`

					// Route Route (e.g. street) of the person
					Route *string `json:"route,omitempty"`

					// StreetNumber Street number of the person
					StreetNumber *string `json:"street_number,omitempty"`

					// Sublocality Sublocality (e.g. neighborhood) of the person
					Sublocality *string `json:"sublocality,omitempty"`

					// Subpremise Subpremise (e.g. apartment/suite number) of the person
					Subpremise *string `json:"subpremise,omitempty"`

					// Value The full address of the person
					Value *string `json:"value,omitempty"`
				} `json:"postal_address,omitempty"`

				// UpdateTime The last updated date and time of the person
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility of the person
				VisibleTo *int `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddPersonResponse parses an HTTP response from a AddPersonWithResponse call
func ParseAddPersonResponse(rsp *http.Response) (*AddPersonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The person object
			Data *struct {
				// AddTime The creation date and time of the person
				AddTime *string `json:"add_time,omitempty"`

				// Birthday The birthday of the person, included if contact sync is enabled for the company
				Birthday *string `json:"birthday,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Emails The emails of the person
				Emails *[]struct {
					// Label The email address classification label
					Label *string `json:"label,omitempty"`

					// Primary Whether the email is primary or not
					Primary *bool `json:"primary,omitempty"`

					// Value The email address of the person
					Value *string `json:"value,omitempty"`
				} `json:"emails,omitempty"`

				// FirstName The first name of the person
				FirstName *string `json:"first_name,omitempty"`

				// Id The ID of the person
				Id *int `json:"id,omitempty"`

				// Im The instant messaging accounts of the person, included if contact sync is enabled for the company
				Im *[]struct {
					// Label The instant messaging account classification label
					Label *string `json:"label,omitempty"`

					// Primary Whether the instant messaging account is primary or not
					Primary *bool `json:"primary,omitempty"`

					// Value The instant messaging account of the person
					Value *string `json:"value,omitempty"`
				} `json:"im,omitempty"`

				// IsDeleted Whether the person is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// JobTitle The job title of the person, included if contact sync is enabled for the company
				JobTitle *string `json:"job_title,omitempty"`

				// LabelIds The IDs of labels assigned to the person
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LastName The last name of the person
				LastName *string `json:"last_name,omitempty"`

				// Name The name of the person
				Name *string `json:"name,omitempty"`

				// Notes Contact sync notes of the person, maximum 10 000 characters, included if contact sync is enabled for the company
				Notes *string `json:"notes,omitempty"`

				// OrgId The ID of the organization linked to the person
				OrgId *int `json:"org_id,omitempty"`

				// OwnerId The ID of the user who owns the person
				OwnerId *int `json:"owner_id,omitempty"`

				// Phones The phones of the person
				Phones *[]struct {
					// Label The phone number classification label
					Label *string `json:"label,omitempty"`

					// Primary Whether the phone number is primary or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number of the person
					Value *string `json:"value,omitempty"`
				} `json:"phones,omitempty"`

				// PictureId The ID of the picture associated with the person
				PictureId *int `json:"picture_id,omitempty"`

				// PostalAddress Postal address of the person, included if contact sync is enabled for the company
				PostalAddress *struct {
					// AdminAreaLevel1 Admin area level 1 (e.g. state) of the person
					AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

					// AdminAreaLevel2 Admin area level 2 (e.g. county) of the person
					AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

					// Country Country of the person
					Country *string `json:"country,omitempty"`

					// Locality Locality (e.g. city) of the person
					Locality *string `json:"locality,omitempty"`

					// PostalCode Postal code of the person
					PostalCode *string `json:"postal_code,omitempty"`

					// Route Route (e.g. street) of the person
					Route *string `json:"route,omitempty"`

					// StreetNumber Street number of the person
					StreetNumber *string `json:"street_number,omitempty"`

					// Sublocality Sublocality (e.g. neighborhood) of the person
					Sublocality *string `json:"sublocality,omitempty"`

					// Subpremise Subpremise (e.g. apartment/suite number) of the person
					Subpremise *string `json:"subpremise,omitempty"`

					// Value The full address of the person
					Value *string `json:"value,omitempty"`
				} `json:"postal_address,omitempty"`

				// UpdateTime The last updated date and time of the person
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility of the person
				VisibleTo *int `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchPersonsResponse parses an HTTP response from a SearchPersonsWithResponse call
func ParseSearchPersonsResponse(rsp *http.Response) (*SearchPersonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchPersonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData Pagination related data
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *struct {
				// Items The array of found items
				Items *[]struct {
					Item *struct {
						// CustomFields Custom fields
						CustomFields *[]string `json:"custom_fields,omitempty"`

						// Emails An array of email addresses
						Emails *[]string `json:"emails,omitempty"`

						// Id The ID of the person
						Id *int `json:"id,omitempty"`

						// Name The name of the person
						Name *string `json:"name,omitempty"`

						// Notes An array of notes
						Notes        *[]string `json:"notes,omitempty"`
						Organization *struct {
							// Id The ID of the organization the person is associated with
							Id *int `json:"id,omitempty"`

							// Name The name of the organization the person is associated with
							Name *string `json:"name,omitempty"`
						} `json:"organization,omitempty"`
						Owner *struct {
							// Id The ID of the owner of the person
							Id *int `json:"id,omitempty"`
						} `json:"owner,omitempty"`

						// Phones An array of phone numbers
						Phones *[]string `json:"phones,omitempty"`

						// Type The type of the item
						Type *string `json:"type,omitempty"`

						// VisibleTo The visibility of the person
						VisibleTo *int `json:"visible_to,omitempty"`
					} `json:"item,omitempty"`

					// ResultScore Search result relevancy
					ResultScore *float32 `json:"result_score,omitempty"`
				} `json:"items,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePersonResponse parses an HTTP response from a DeletePersonWithResponse call
func ParseDeletePersonResponse(rsp *http.Response) (*DeletePersonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id Deleted person ID
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonResponse parses an HTTP response from a GetPersonWithResponse call
func ParseGetPersonResponse(rsp *http.Response) (*GetPersonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The person object
			Data *struct {
				// AddTime The creation date and time of the person
				AddTime *string `json:"add_time,omitempty"`

				// Birthday The birthday of the person, included if contact sync is enabled for the company
				Birthday *string `json:"birthday,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Emails The emails of the person
				Emails *[]struct {
					// Label The email address classification label
					Label *string `json:"label,omitempty"`

					// Primary Whether the email is primary or not
					Primary *bool `json:"primary,omitempty"`

					// Value The email address of the person
					Value *string `json:"value,omitempty"`
				} `json:"emails,omitempty"`

				// FirstName The first name of the person
				FirstName *string `json:"first_name,omitempty"`

				// Id The ID of the person
				Id *int `json:"id,omitempty"`

				// Im The instant messaging accounts of the person, included if contact sync is enabled for the company
				Im *[]struct {
					// Label The instant messaging account classification label
					Label *string `json:"label,omitempty"`

					// Primary Whether the instant messaging account is primary or not
					Primary *bool `json:"primary,omitempty"`

					// Value The instant messaging account of the person
					Value *string `json:"value,omitempty"`
				} `json:"im,omitempty"`

				// IsDeleted Whether the person is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// JobTitle The job title of the person, included if contact sync is enabled for the company
				JobTitle *string `json:"job_title,omitempty"`

				// LabelIds The IDs of labels assigned to the person
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LastName The last name of the person
				LastName *string `json:"last_name,omitempty"`

				// Name The name of the person
				Name *string `json:"name,omitempty"`

				// Notes Contact sync notes of the person, maximum 10 000 characters, included if contact sync is enabled for the company
				Notes *string `json:"notes,omitempty"`

				// OrgId The ID of the organization linked to the person
				OrgId *int `json:"org_id,omitempty"`

				// OwnerId The ID of the user who owns the person
				OwnerId *int `json:"owner_id,omitempty"`

				// Phones The phones of the person
				Phones *[]struct {
					// Label The phone number classification label
					Label *string `json:"label,omitempty"`

					// Primary Whether the phone number is primary or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number of the person
					Value *string `json:"value,omitempty"`
				} `json:"phones,omitempty"`

				// PictureId The ID of the picture associated with the person
				PictureId *int `json:"picture_id,omitempty"`

				// PostalAddress Postal address of the person, included if contact sync is enabled for the company
				PostalAddress *struct {
					// AdminAreaLevel1 Admin area level 1 (e.g. state) of the person
					AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

					// AdminAreaLevel2 Admin area level 2 (e.g. county) of the person
					AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

					// Country Country of the person
					Country *string `json:"country,omitempty"`

					// Locality Locality (e.g. city) of the person
					Locality *string `json:"locality,omitempty"`

					// PostalCode Postal code of the person
					PostalCode *string `json:"postal_code,omitempty"`

					// Route Route (e.g. street) of the person
					Route *string `json:"route,omitempty"`

					// StreetNumber Street number of the person
					StreetNumber *string `json:"street_number,omitempty"`

					// Sublocality Sublocality (e.g. neighborhood) of the person
					Sublocality *string `json:"sublocality,omitempty"`

					// Subpremise Subpremise (e.g. apartment/suite number) of the person
					Subpremise *string `json:"subpremise,omitempty"`

					// Value The full address of the person
					Value *string `json:"value,omitempty"`
				} `json:"postal_address,omitempty"`

				// UpdateTime The last updated date and time of the person
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility of the person
				VisibleTo *int `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePersonResponse parses an HTTP response from a UpdatePersonWithResponse call
func ParseUpdatePersonResponse(rsp *http.Response) (*UpdatePersonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The person object
			Data *struct {
				// AddTime The creation date and time of the person
				AddTime *string `json:"add_time,omitempty"`

				// Birthday The birthday of the person, included if contact sync is enabled for the company
				Birthday *string `json:"birthday,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Emails The emails of the person
				Emails *[]struct {
					// Label The email address classification label
					Label *string `json:"label,omitempty"`

					// Primary Whether the email is primary or not
					Primary *bool `json:"primary,omitempty"`

					// Value The email address of the person
					Value *string `json:"value,omitempty"`
				} `json:"emails,omitempty"`

				// FirstName The first name of the person
				FirstName *string `json:"first_name,omitempty"`

				// Id The ID of the person
				Id *int `json:"id,omitempty"`

				// Im The instant messaging accounts of the person, included if contact sync is enabled for the company
				Im *[]struct {
					// Label The instant messaging account classification label
					Label *string `json:"label,omitempty"`

					// Primary Whether the instant messaging account is primary or not
					Primary *bool `json:"primary,omitempty"`

					// Value The instant messaging account of the person
					Value *string `json:"value,omitempty"`
				} `json:"im,omitempty"`

				// IsDeleted Whether the person is deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// JobTitle The job title of the person, included if contact sync is enabled for the company
				JobTitle *string `json:"job_title,omitempty"`

				// LabelIds The IDs of labels assigned to the person
				LabelIds *[]int `json:"label_ids,omitempty"`

				// LastName The last name of the person
				LastName *string `json:"last_name,omitempty"`

				// Name The name of the person
				Name *string `json:"name,omitempty"`

				// Notes Contact sync notes of the person, maximum 10 000 characters, included if contact sync is enabled for the company
				Notes *string `json:"notes,omitempty"`

				// OrgId The ID of the organization linked to the person
				OrgId *int `json:"org_id,omitempty"`

				// OwnerId The ID of the user who owns the person
				OwnerId *int `json:"owner_id,omitempty"`

				// Phones The phones of the person
				Phones *[]struct {
					// Label The phone number classification label
					Label *string `json:"label,omitempty"`

					// Primary Whether the phone number is primary or not
					Primary *bool `json:"primary,omitempty"`

					// Value The phone number of the person
					Value *string `json:"value,omitempty"`
				} `json:"phones,omitempty"`

				// PictureId The ID of the picture associated with the person
				PictureId *int `json:"picture_id,omitempty"`

				// PostalAddress Postal address of the person, included if contact sync is enabled for the company
				PostalAddress *struct {
					// AdminAreaLevel1 Admin area level 1 (e.g. state) of the person
					AdminAreaLevel1 *string `json:"admin_area_level_1,omitempty"`

					// AdminAreaLevel2 Admin area level 2 (e.g. county) of the person
					AdminAreaLevel2 *string `json:"admin_area_level_2,omitempty"`

					// Country Country of the person
					Country *string `json:"country,omitempty"`

					// Locality Locality (e.g. city) of the person
					Locality *string `json:"locality,omitempty"`

					// PostalCode Postal code of the person
					PostalCode *string `json:"postal_code,omitempty"`

					// Route Route (e.g. street) of the person
					Route *string `json:"route,omitempty"`

					// StreetNumber Street number of the person
					StreetNumber *string `json:"street_number,omitempty"`

					// Sublocality Sublocality (e.g. neighborhood) of the person
					Sublocality *string `json:"sublocality,omitempty"`

					// Subpremise Subpremise (e.g. apartment/suite number) of the person
					Subpremise *string `json:"subpremise,omitempty"`

					// Value The full address of the person
					Value *string `json:"value,omitempty"`
				} `json:"postal_address,omitempty"`

				// UpdateTime The last updated date and time of the person
				UpdateTime *string `json:"update_time,omitempty"`

				// VisibleTo The visibility of the person
				VisibleTo *int `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonFollowersResponse parses an HTTP response from a GetPersonFollowersWithResponse call
func ParseGetPersonFollowersResponse(rsp *http.Response) (*GetPersonFollowersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonFollowersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Followers array
			Data *[]struct {
				// AddTime The add time of the following
				AddTime *string `json:"add_time,omitempty"`

				// UserId The ID of the user following the entity
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddPersonFollowerResponse parses an HTTP response from a AddPersonFollowerWithResponse call
func ParseAddPersonFollowerResponse(rsp *http.Response) (*AddPersonFollowerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPersonFollowerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data The follower object
			Data *struct {
				// AddTime The add time of the following
				AddTime *string `json:"add_time,omitempty"`

				// UserId The ID of the user following the entity
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetPersonFollowersChangelogResponse parses an HTTP response from a GetPersonFollowersChangelogWithResponse call
func ParseGetPersonFollowersChangelogResponse(rsp *http.Response) (*GetPersonFollowersChangelogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonFollowersChangelogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Follower changelogs array
			Data *[]struct {
				// Action The type of change
				Action *string `json:"action,omitempty"`

				// ActorUserId The ID of the user who did the change
				ActorUserId *int `json:"actor_user_id,omitempty"`

				// FollowerUserId The ID of the user who was following the entity
				FollowerUserId *int `json:"follower_user_id,omitempty"`

				// Time The time at which the change happened
				Time *string `json:"time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePersonFollowerResponse parses an HTTP response from a DeletePersonFollowerWithResponse call
func ParseDeletePersonFollowerResponse(rsp *http.Response) (*DeletePersonFollowerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersonFollowerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UserId Deleted follower user ID
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonPictureResponse parses an HTTP response from a GetPersonPictureWithResponse call
func ParseGetPersonPictureResponse(rsp *http.Response) (*GetPersonPictureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonPictureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ActiveFlag Whether the picture is active or not.
				ActiveFlag *bool `json:"active_flag,omitempty"`

				// AddedByUserId The ID of the user who added the picture.
				AddedByUserId *int `json:"added_by_user_id,omitempty"`

				// FileSize The file size in bytes.
				FileSize *int `json:"file_size,omitempty"`

				// Id The ID of the picture.
				Id *int `json:"id,omitempty"`

				// ItemId The ID of the person this picture belongs to.
				ItemId *int `json:"item_id,omitempty"`

				// ItemType The type of item the picture is associated with.
				ItemType *string `json:"item_type,omitempty"`

				// Pictures Picture URLs indexed by size.
				Pictures *struct {
					// N128 The URL of the 128x128 picture.
					N128 *string `json:"128,omitempty"`

					// N512 The URL of the 512x512 picture.
					N512 *string `json:"512,omitempty"`
				} `json:"pictures,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPipelinesResponse parses an HTTP response from a GetPipelinesWithResponse call
func ParseGetPipelinesResponse(rsp *http.Response) (*GetPipelinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Pipelines array
			Data *[]struct {
				// AddTime The pipeline creation time
				AddTime *string `json:"add_time,omitempty"`

				// Id The ID of the pipeline
				Id *int `json:"id,omitempty"`

				// IsDealProbabilityEnabled Whether deal probability is disabled or enabled for this pipeline
				IsDealProbabilityEnabled *bool `json:"is_deal_probability_enabled,omitempty"`

				// IsDeleted Whether this pipeline is marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// Name The name of the pipeline
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of pipelines. The pipeline with the lowest `order_nr` is considered the default.
				OrderNr *int `json:"order_nr,omitempty"`

				// UpdateTime The pipeline update time
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddPipelineResponse parses an HTTP response from a AddPipelineWithResponse call
func ParseAddPipelineResponse(rsp *http.Response) (*AddPipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The pipeline object
			Data *struct {
				// AddTime The pipeline creation time
				AddTime *string `json:"add_time,omitempty"`

				// Id The ID of the pipeline
				Id *int `json:"id,omitempty"`

				// IsDealProbabilityEnabled Whether deal probability is disabled or enabled for this pipeline
				IsDealProbabilityEnabled *bool `json:"is_deal_probability_enabled,omitempty"`

				// IsDeleted Whether this pipeline is marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// Name The name of the pipeline
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of pipelines. The pipeline with the lowest `order_nr` is considered the default.
				OrderNr *int `json:"order_nr,omitempty"`

				// UpdateTime The pipeline update time
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePipelineResponse parses an HTTP response from a DeletePipelineWithResponse call
func ParseDeletePipelineResponse(rsp *http.Response) (*DeletePipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id Deleted Pipeline ID
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPipelineResponse parses an HTTP response from a GetPipelineWithResponse call
func ParseGetPipelineResponse(rsp *http.Response) (*GetPipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The pipeline object
			Data *struct {
				// AddTime The pipeline creation time
				AddTime *string `json:"add_time,omitempty"`

				// Id The ID of the pipeline
				Id *int `json:"id,omitempty"`

				// IsDealProbabilityEnabled Whether deal probability is disabled or enabled for this pipeline
				IsDealProbabilityEnabled *bool `json:"is_deal_probability_enabled,omitempty"`

				// IsDeleted Whether this pipeline is marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// Name The name of the pipeline
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of pipelines. The pipeline with the lowest `order_nr` is considered the default.
				OrderNr *int `json:"order_nr,omitempty"`

				// UpdateTime The pipeline update time
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePipelineResponse parses an HTTP response from a UpdatePipelineWithResponse call
func ParseUpdatePipelineResponse(rsp *http.Response) (*UpdatePipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The pipeline object
			Data *struct {
				// AddTime The pipeline creation time
				AddTime *string `json:"add_time,omitempty"`

				// Id The ID of the pipeline
				Id *int `json:"id,omitempty"`

				// IsDealProbabilityEnabled Whether deal probability is disabled or enabled for this pipeline
				IsDealProbabilityEnabled *bool `json:"is_deal_probability_enabled,omitempty"`

				// IsDeleted Whether this pipeline is marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// Name The name of the pipeline
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of pipelines. The pipeline with the lowest `order_nr` is considered the default.
				OrderNr *int `json:"order_nr,omitempty"`

				// UpdateTime The pipeline update time
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProductFieldsResponse parses an HTTP response from a GetProductFieldsWithResponse call
func ParseGetProductFieldsResponse(rsp *http.Response) (*GetProductFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *struct {
				// NextCursor Base64url-encoded cursor for fetching the next page of results, null if no more pages
				NextCursor *string `json:"next_cursor"`
			} `json:"additional_data,omitempty"`
			Data *[]struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType GetProductFields200DataFieldType `json:"field_type"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view (read-only)
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddProductFieldResponse parses an HTTP response from a AddProductFieldWithResponse call
func ParseAddProductFieldResponse(rsp *http.Response) (*AddProductFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddProductFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType AddProductField200DataFieldType `json:"field_type"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view (read-only)
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProductFieldResponse parses an HTTP response from a DeleteProductFieldWithResponse call
func ParseDeleteProductFieldResponse(rsp *http.Response) (*DeleteProductFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType string `json:"field_type"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]map[string]interface{} `json:"options"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]map[string]interface{} `json:"subfields"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProductFieldResponse parses an HTTP response from a GetProductFieldWithResponse call
func ParseGetProductFieldResponse(rsp *http.Response) (*GetProductFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType GetProductField200DataFieldType `json:"field_type"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view (read-only)
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProductFieldResponse parses an HTTP response from a UpdateProductFieldWithResponse call
func ParseUpdateProductFieldResponse(rsp *http.Response) (*UpdateProductFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProductFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FieldCode The unique identifier for the field (40-character hash for custom fields)
				FieldCode string `json:"field_code"`

				// FieldName The display name/label of the field
				FieldName string `json:"field_name"`

				// FieldType The type of the field
				FieldType UpdateProductField200DataFieldType `json:"field_type"`

				// IsCustomField Whether this is a user-created custom field
				IsCustomField bool `json:"is_custom_field"`

				// IsOptionalResponseField Whether this field is not returned by default in entity responses
				IsOptionalResponseField bool `json:"is_optional_response_field"`

				// Options Array of available options for enum/set fields, null for other field types
				Options *[]struct {
					// AddTime When the option was created
					AddTime *time.Time `json:"add_time"`

					// Color Optional color code for the option
					Color *string `json:"color"`

					// Id The option ID
					Id *int `json:"id,omitempty"`

					// Label The option display label
					Label *string `json:"label,omitempty"`

					// UpdateTime When the option was last updated
					UpdateTime *time.Time `json:"update_time"`
				} `json:"options"`

				// Subfields Array of subfields for complex field types (address, monetary), null for simple field types
				Subfields *[]struct {
					// FieldCode The subfield identifier
					FieldCode *string `json:"field_code,omitempty"`

					// FieldName The subfield display name
					FieldName *string `json:"field_name,omitempty"`

					// FieldType The subfield type
					FieldType *string `json:"field_type,omitempty"`
				} `json:"subfields"`

				// UiVisibility UI visibility settings (only included when requested via include_fields parameter)
				UiVisibility *struct {
					// AddVisibleFlag Whether the field is shown in the add modal
					AddVisibleFlag *bool `json:"add_visible_flag,omitempty"`

					// DetailsVisibleFlag Whether the field is shown in the details view (read-only)
					DetailsVisibleFlag *bool `json:"details_visible_flag,omitempty"`
				} `json:"ui_visibility,omitempty"`
			} `json:"data,omitempty"`

			// Success Whether the request was successful
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProductFieldOptionsResponse parses an HTTP response from a DeleteProductFieldOptionsWithResponse call
func ParseDeleteProductFieldOptionsResponse(rsp *http.Response) (*DeleteProductFieldOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductFieldOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id The unique identifier of the option
				Id int `json:"id"`

				// Label The display label of the option
				Label string `json:"label"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProductFieldOptionsResponse parses an HTTP response from a UpdateProductFieldOptionsWithResponse call
func ParseUpdateProductFieldOptionsResponse(rsp *http.Response) (*UpdateProductFieldOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProductFieldOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id The unique identifier of the option
				Id int `json:"id"`

				// Label The display label of the option
				Label string `json:"label"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddProductFieldOptionsResponse parses an HTTP response from a AddProductFieldOptionsWithResponse call
func ParseAddProductFieldOptionsResponse(rsp *http.Response) (*AddProductFieldOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddProductFieldOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalData *map[string]interface{} `json:"additional_data"`
			Data           *[]struct {
				// Id The unique identifier of the option
				Id int `json:"id"`

				// Label The display label of the option
				Label string `json:"label"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProductsResponse parses an HTTP response from a GetProductsWithResponse call
func ParseGetProductsResponse(rsp *http.Response) (*GetProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData Pagination related data
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Array containing data for all products
			Data *[]struct {
				Data *struct {
					// BillingFrequency Only available in Growth and above plans
					//
					// How often a customer is billed for access to a service or product
					BillingFrequency *GetProducts200DataDataBillingFrequency `json:"billing_frequency,omitempty"`

					// BillingFrequencyCycles Only available in Growth and above plans
					//
					// The number of times the billing frequency repeats for a product in a deal
					//
					// When `billing_frequency` is set to `one-time`, this field must be `null`
					//
					// When `billing_frequency` is set to `weekly`, this field cannot be `null`
					//
					// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
					//
					// Must be a positive integer less or equal to 208
					BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

					// Code The product code
					Code *string `json:"code,omitempty"`

					// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
					CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

					// Id The ID of the product
					Id *float32 `json:"id,omitempty"`

					// IsDeleted Whether this product will be made marked as deleted or not
					IsDeleted *bool `json:"is_deleted,omitempty"`

					// IsLinkable Whether this product can be added to a deal or not
					IsLinkable *bool `json:"is_linkable,omitempty"`

					// Name The name of the product
					Name *string `json:"name,omitempty"`

					// OwnerId Information about the Pipedrive user who owns the product
					OwnerId *int `json:"owner_id,omitempty"`

					// Prices Array of objects, each containing: product_id (number), currency (string), price (number), cost (number), direct_cost (number | null), notes (string)
					Prices *[]map[string]interface{} `json:"prices,omitempty"`

					// Tax The tax percentage
					Tax *float32 `json:"tax,omitempty"`

					// Unit The unit in which this product is sold
					Unit *string `json:"unit,omitempty"`

					// VisibleTo Visibility of the product
					VisibleTo *GetProducts200DataDataVisibleTo `json:"visible_to,omitempty"`
				} `json:"data,omitempty"`

				// Success If the response is successful or not
				Success *bool `json:"success,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddProductResponse parses an HTTP response from a AddProductWithResponse call
func ParseAddProductResponse(rsp *http.Response) (*AddProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// BillingFrequency Only available in Growth and above plans
				//
				// How often a customer is billed for access to a service or product
				BillingFrequency *AddProduct201DataBillingFrequency `json:"billing_frequency,omitempty"`

				// BillingFrequencyCycles Only available in Growth and above plans
				//
				// The number of times the billing frequency repeats for a product in a deal
				//
				// When `billing_frequency` is set to `one-time`, this field must be `null`
				//
				// When `billing_frequency` is set to `weekly`, this field cannot be `null`
				//
				// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
				//
				// Must be a positive integer less or equal to 208
				BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

				// Code The product code
				Code *string `json:"code,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Id The ID of the product
				Id *float32 `json:"id,omitempty"`

				// IsDeleted Whether this product will be made marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// IsLinkable Whether this product can be added to a deal or not
				IsLinkable *bool `json:"is_linkable,omitempty"`

				// Name The name of the product
				Name *string `json:"name,omitempty"`

				// OwnerId Information about the Pipedrive user who owns the product
				OwnerId *int `json:"owner_id,omitempty"`

				// Prices Array of objects, each containing: product_id (number), currency (string), price (number), cost (number), direct_cost (number | null), notes (string)
				Prices *[]map[string]interface{} `json:"prices,omitempty"`

				// Tax The tax percentage
				Tax *float32 `json:"tax,omitempty"`

				// Unit The unit in which this product is sold
				Unit *string `json:"unit,omitempty"`

				// VisibleTo Visibility of the product
				VisibleTo *AddProduct201DataVisibleTo `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSearchProductsResponse parses an HTTP response from a SearchProductsWithResponse call
func ParseSearchProductsResponse(rsp *http.Response) (*SearchProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData Pagination related data
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`
			Data *struct {
				// Items The array of found items
				Items *[]struct {
					Item *struct {
						// Code The code of the product
						Code *int `json:"code,omitempty"`

						// CustomFields The custom fields
						CustomFields *[]string `json:"custom_fields,omitempty"`

						// Id The ID of the product
						Id *int `json:"id,omitempty"`

						// Name The name of the product
						Name  *string `json:"name,omitempty"`
						Owner *struct {
							// Id The ID of the owner of the product
							Id *int `json:"id,omitempty"`
						} `json:"owner,omitempty"`

						// Type The type of the item
						Type *string `json:"type,omitempty"`

						// VisibleTo The visibility of the product
						VisibleTo *int `json:"visible_to,omitempty"`
					} `json:"item,omitempty"`

					// ResultScore Search result relevancy
					ResultScore *float32 `json:"result_score,omitempty"`
				} `json:"items,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProductResponse parses an HTTP response from a DeleteProductWithResponse call
func ParseDeleteProductResponse(rsp *http.Response) (*DeleteProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of the removed product
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProductResponse parses an HTTP response from a GetProductWithResponse call
func ParseGetProductResponse(rsp *http.Response) (*GetProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// BillingFrequency Only available in Growth and above plans
				//
				// How often a customer is billed for access to a service or product
				BillingFrequency *GetProduct200DataBillingFrequency `json:"billing_frequency,omitempty"`

				// BillingFrequencyCycles Only available in Growth and above plans
				//
				// The number of times the billing frequency repeats for a product in a deal
				//
				// When `billing_frequency` is set to `one-time`, this field must be `null`
				//
				// When `billing_frequency` is set to `weekly`, this field cannot be `null`
				//
				// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
				//
				// Must be a positive integer less or equal to 208
				BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

				// Code The product code
				Code *string `json:"code,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Id The ID of the product
				Id *float32 `json:"id,omitempty"`

				// IsDeleted Whether this product will be made marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// IsLinkable Whether this product can be added to a deal or not
				IsLinkable *bool `json:"is_linkable,omitempty"`

				// Name The name of the product
				Name *string `json:"name,omitempty"`

				// OwnerId Information about the Pipedrive user who owns the product
				OwnerId *int `json:"owner_id,omitempty"`

				// Prices Array of objects, each containing: product_id (number), currency (string), price (number), cost (number), direct_cost (number | null), notes (string)
				Prices *[]map[string]interface{} `json:"prices,omitempty"`

				// Tax The tax percentage
				Tax *float32 `json:"tax,omitempty"`

				// Unit The unit in which this product is sold
				Unit *string `json:"unit,omitempty"`

				// VisibleTo Visibility of the product
				VisibleTo *GetProduct200DataVisibleTo `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProductResponse parses an HTTP response from a UpdateProductWithResponse call
func ParseUpdateProductResponse(rsp *http.Response) (*UpdateProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// BillingFrequency Only available in Growth and above plans
				//
				// How often a customer is billed for access to a service or product
				BillingFrequency *UpdateProduct200DataBillingFrequency `json:"billing_frequency,omitempty"`

				// BillingFrequencyCycles Only available in Growth and above plans
				//
				// The number of times the billing frequency repeats for a product in a deal
				//
				// When `billing_frequency` is set to `one-time`, this field must be `null`
				//
				// When `billing_frequency` is set to `weekly`, this field cannot be `null`
				//
				// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
				//
				// Must be a positive integer less or equal to 208
				BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

				// Code The product code
				Code *string `json:"code,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Id The ID of the product
				Id *float32 `json:"id,omitempty"`

				// IsDeleted Whether this product will be made marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// IsLinkable Whether this product can be added to a deal or not
				IsLinkable *bool `json:"is_linkable,omitempty"`

				// Name The name of the product
				Name *string `json:"name,omitempty"`

				// OwnerId Information about the Pipedrive user who owns the product
				OwnerId *int `json:"owner_id,omitempty"`

				// Prices Array of objects, each containing: product_id (number), currency (string), price (number), cost (number), direct_cost (number | null), notes (string)
				Prices *[]map[string]interface{} `json:"prices,omitempty"`

				// Tax The tax percentage
				Tax *float32 `json:"tax,omitempty"`

				// Unit The unit in which this product is sold
				Unit *string `json:"unit,omitempty"`

				// VisibleTo Visibility of the product
				VisibleTo *UpdateProduct200DataVisibleTo `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDuplicateProductResponse parses an HTTP response from a DuplicateProductWithResponse call
func ParseDuplicateProductResponse(rsp *http.Response) (*DuplicateProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DuplicateProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// BillingFrequency Only available in Growth and above plans
				//
				// How often a customer is billed for access to a service or product
				BillingFrequency *DuplicateProduct201DataBillingFrequency `json:"billing_frequency,omitempty"`

				// BillingFrequencyCycles Only available in Growth and above plans
				//
				// The number of times the billing frequency repeats for a product in a deal
				//
				// When `billing_frequency` is set to `one-time`, this field must be `null`
				//
				// When `billing_frequency` is set to `weekly`, this field cannot be `null`
				//
				// For all the other values of `billing_frequency`, `null` represents a product billed indefinitely
				//
				// Must be a positive integer less or equal to 208
				BillingFrequencyCycles *int `json:"billing_frequency_cycles"`

				// Code The product code
				Code *string `json:"code,omitempty"`

				// CustomFields An object where each key represents a custom field. All custom fields are referenced as randomly generated 40-character hashes
				CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

				// Id The ID of the product
				Id *float32 `json:"id,omitempty"`

				// IsDeleted Whether this product will be made marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// IsLinkable Whether this product can be added to a deal or not
				IsLinkable *bool `json:"is_linkable,omitempty"`

				// Name The name of the product
				Name *string `json:"name,omitempty"`

				// OwnerId Information about the Pipedrive user who owns the product
				OwnerId *int `json:"owner_id,omitempty"`

				// Prices Array of objects, each containing: product_id (number), currency (string), price (number), cost (number), direct_cost (number | null), notes (string)
				Prices *[]map[string]interface{} `json:"prices,omitempty"`

				// Tax The tax percentage
				Tax *float32 `json:"tax,omitempty"`

				// Unit The unit in which this product is sold
				Unit *string `json:"unit,omitempty"`

				// VisibleTo Visibility of the product
				VisibleTo *DuplicateProduct201DataVisibleTo `json:"visible_to,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetProductFollowersResponse parses an HTTP response from a GetProductFollowersWithResponse call
func ParseGetProductFollowersResponse(rsp *http.Response) (*GetProductFollowersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductFollowersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Followers array
			Data *[]struct {
				// AddTime The add time of the following
				AddTime *string `json:"add_time,omitempty"`

				// UserId The ID of the user following the entity
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddProductFollowerResponse parses an HTTP response from a AddProductFollowerWithResponse call
func ParseAddProductFollowerResponse(rsp *http.Response) (*AddProductFollowerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddProductFollowerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data The follower object
			Data *struct {
				// AddTime The add time of the following
				AddTime *string `json:"add_time,omitempty"`

				// UserId The ID of the user following the entity
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetProductFollowersChangelogResponse parses an HTTP response from a GetProductFollowersChangelogWithResponse call
func ParseGetProductFollowersChangelogResponse(rsp *http.Response) (*GetProductFollowersChangelogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductFollowersChangelogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Follower changelogs array
			Data *[]struct {
				// Action The type of change
				Action *string `json:"action,omitempty"`

				// ActorUserId The ID of the user who did the change
				ActorUserId *int `json:"actor_user_id,omitempty"`

				// FollowerUserId The ID of the user who was following the entity
				FollowerUserId *int `json:"follower_user_id,omitempty"`

				// Time The time at which the change happened
				Time *string `json:"time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProductFollowerResponse parses an HTTP response from a DeleteProductFollowerWithResponse call
func ParseDeleteProductFollowerResponse(rsp *http.Response) (*DeleteProductFollowerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductFollowerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UserId Deleted follower user ID
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProductImageResponse parses an HTTP response from a DeleteProductImageWithResponse call
func ParseDeleteProductImageResponse(rsp *http.Response) (*DeleteProductImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of the image that was deleted from the product.
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProductImageResponse parses an HTTP response from a GetProductImageWithResponse call
func ParseGetProductImageResponse(rsp *http.Response) (*GetProductImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The product image data and the respective public URL
			Data *struct {
				// AddTime The date of image upload.
				AddTime *string `json:"add_time,omitempty"`

				// CompanyId The ID of the company
				CompanyId *string `json:"company_id,omitempty"`

				// Id The ID of the product image
				Id *int `json:"id,omitempty"`

				// MimeType The MIME type of the product image
				MimeType *string `json:"mime_type,omitempty"`

				// Name The name of the product image file
				Name *string `json:"name,omitempty"`

				// ProductId The ID of the product associated
				ProductId *int `json:"product_id,omitempty"`

				// PublicUrl The public URL of the product image
				PublicUrl *string `json:"public_url,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadProductImageResponse parses an HTTP response from a UploadProductImageWithResponse call
func ParseUploadProductImageResponse(rsp *http.Response) (*UploadProductImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadProductImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// AddTime The date of image upload.
				AddTime *string `json:"add_time,omitempty"`

				// CompanyId The ID of the company
				CompanyId *string `json:"company_id,omitempty"`

				// Id The ID of the product image
				Id *int `json:"id,omitempty"`

				// ProductId The ID of the product associated
				ProductId *float32 `json:"product_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUpdateProductImageResponse parses an HTTP response from a UpdateProductImageWithResponse call
func ParseUpdateProductImageResponse(rsp *http.Response) (*UpdateProductImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProductImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// AddTime The date of image upload.
				AddTime *string `json:"add_time,omitempty"`

				// CompanyId The ID of the company
				CompanyId *string `json:"company_id,omitempty"`

				// Id The ID of the product image
				Id *int `json:"id,omitempty"`

				// ProductId The ID of the product associated
				ProductId *float32 `json:"product_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProductVariationsResponse parses an HTTP response from a GetProductVariationsWithResponse call
func ParseGetProductVariationsResponse(rsp *http.Response) (*GetProductVariationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductVariationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData Pagination related data
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Array containing data for all products
			Data *[]struct {
				// Id The ID of the product variation
				Id *float32 `json:"id,omitempty"`

				// Name The name of the product variation
				Name *string `json:"name,omitempty"`

				// Prices Array of objects, each containing: product_variation_id (number), currency (string), price (number), cost (number), direct_cost (number) , notes (string)
				Prices *[]map[string]interface{} `json:"prices,omitempty"`

				// ProductId The ID of the product
				ProductId *int `json:"product_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddProductVariationResponse parses an HTTP response from a AddProductVariationWithResponse call
func ParseAddProductVariationResponse(rsp *http.Response) (*AddProductVariationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddProductVariationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// Id The ID of the product variation
				Id *float32 `json:"id,omitempty"`

				// Name The name of the product variation
				Name *string `json:"name,omitempty"`

				// Prices Array of objects, each containing: product_variation_id (number), currency (string), price (number), cost (number), direct_cost (number) , notes (string)
				Prices *[]map[string]interface{} `json:"prices,omitempty"`

				// ProductId The ID of the product
				ProductId *int `json:"product_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteProductVariationResponse parses an HTTP response from a DeleteProductVariationWithResponse call
func ParseDeleteProductVariationResponse(rsp *http.Response) (*DeleteProductVariationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductVariationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of a deleted product variant
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProductVariationResponse parses an HTTP response from a UpdateProductVariationWithResponse call
func ParseUpdateProductVariationResponse(rsp *http.Response) (*UpdateProductVariationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProductVariationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id The ID of the product variation
				Id *float32 `json:"id,omitempty"`

				// Name The name of the product variation
				Name *string `json:"name,omitempty"`

				// Prices Array of objects, each containing: product_variation_id (number), currency (string), price (number), cost (number), direct_cost (number) , notes (string)
				Prices *[]map[string]interface{} `json:"prices,omitempty"`

				// ProductId The ID of the product
				ProductId *int `json:"product_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStagesResponse parses an HTTP response from a GetStagesWithResponse call
func ParseGetStagesResponse(rsp *http.Response) (*GetStagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data The array of stages
			Data *[]struct {
				// AddTime The stage creation time
				AddTime *string `json:"add_time,omitempty"`

				// DaysToRotten The number of days the deals not updated in this stage would become rotten. Applies only if the `is_deal_rot_enabled` is set.
				DaysToRotten *int `json:"days_to_rotten"`

				// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
				DealProbability *int `json:"deal_probability,omitempty"`

				// Id The ID of the stage
				Id *int `json:"id,omitempty"`

				// IsDealRotEnabled Whether deals in this stage can become rotten
				IsDealRotEnabled *bool `json:"is_deal_rot_enabled,omitempty"`

				// IsDeleted Whether the stage is marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// Name The name of the stage
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of the stage
				OrderNr *int `json:"order_nr,omitempty"`

				// PipelineId The ID of the pipeline to add the stage to
				PipelineId *int `json:"pipeline_id,omitempty"`

				// UpdateTime The stage update time
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddStageResponse parses an HTTP response from a AddStageWithResponse call
func ParseAddStageResponse(rsp *http.Response) (*AddStageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddStageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The stage object
			Data *struct {
				// AddTime The stage creation time
				AddTime *string `json:"add_time,omitempty"`

				// DaysToRotten The number of days the deals not updated in this stage would become rotten. Applies only if the `is_deal_rot_enabled` is set.
				DaysToRotten *int `json:"days_to_rotten"`

				// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
				DealProbability *int `json:"deal_probability,omitempty"`

				// Id The ID of the stage
				Id *int `json:"id,omitempty"`

				// IsDealRotEnabled Whether deals in this stage can become rotten
				IsDealRotEnabled *bool `json:"is_deal_rot_enabled,omitempty"`

				// IsDeleted Whether the stage is marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// Name The name of the stage
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of the stage
				OrderNr *int `json:"order_nr,omitempty"`

				// PipelineId The ID of the pipeline to add the stage to
				PipelineId *int `json:"pipeline_id,omitempty"`

				// UpdateTime The stage update time
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStageResponse parses an HTTP response from a DeleteStageWithResponse call
func ParseDeleteStageResponse(rsp *http.Response) (*DeleteStageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Id Deleted stage ID
				Id *int `json:"id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStageResponse parses an HTTP response from a GetStageWithResponse call
func ParseGetStageResponse(rsp *http.Response) (*GetStageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The stage object
			Data *struct {
				// AddTime The stage creation time
				AddTime *string `json:"add_time,omitempty"`

				// DaysToRotten The number of days the deals not updated in this stage would become rotten. Applies only if the `is_deal_rot_enabled` is set.
				DaysToRotten *int `json:"days_to_rotten"`

				// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
				DealProbability *int `json:"deal_probability,omitempty"`

				// Id The ID of the stage
				Id *int `json:"id,omitempty"`

				// IsDealRotEnabled Whether deals in this stage can become rotten
				IsDealRotEnabled *bool `json:"is_deal_rot_enabled,omitempty"`

				// IsDeleted Whether the stage is marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// Name The name of the stage
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of the stage
				OrderNr *int `json:"order_nr,omitempty"`

				// PipelineId The ID of the pipeline to add the stage to
				PipelineId *int `json:"pipeline_id,omitempty"`

				// UpdateTime The stage update time
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateStageResponse parses an HTTP response from a UpdateStageWithResponse call
func ParseUpdateStageResponse(rsp *http.Response) (*UpdateStageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateStageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The stage object
			Data *struct {
				// AddTime The stage creation time
				AddTime *string `json:"add_time,omitempty"`

				// DaysToRotten The number of days the deals not updated in this stage would become rotten. Applies only if the `is_deal_rot_enabled` is set.
				DaysToRotten *int `json:"days_to_rotten"`

				// DealProbability The success probability percentage of the deal. Used/shown when the deal weighted values are used.
				DealProbability *int `json:"deal_probability,omitempty"`

				// Id The ID of the stage
				Id *int `json:"id,omitempty"`

				// IsDealRotEnabled Whether deals in this stage can become rotten
				IsDealRotEnabled *bool `json:"is_deal_rot_enabled,omitempty"`

				// IsDeleted Whether the stage is marked as deleted or not
				IsDeleted *bool `json:"is_deleted,omitempty"`

				// Name The name of the stage
				Name *string `json:"name,omitempty"`

				// OrderNr Defines the order of the stage
				OrderNr *int `json:"order_nr,omitempty"`

				// PipelineId The ID of the pipeline to add the stage to
				PipelineId *int `json:"pipeline_id,omitempty"`

				// UpdateTime The stage update time
				UpdateTime *string `json:"update_time,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserFollowersResponse parses an HTTP response from a GetUserFollowersWithResponse call
func ParseGetUserFollowersResponse(rsp *http.Response) (*GetUserFollowersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFollowersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AdditionalData The additional data of the list
			AdditionalData *struct {
				// NextCursor The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and theres no more pages to be returned.
				NextCursor *string `json:"next_cursor,omitempty"`
			} `json:"additional_data,omitempty"`

			// Data Followers array
			Data *[]struct {
				// AddTime The add time of the following
				AddTime *string `json:"add_time,omitempty"`

				// UserId The ID of the user following the entity
				UserId *int `json:"user_id,omitempty"`
			} `json:"data,omitempty"`

			// Success If the response is successful or not
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
